[
  {
    "role": "user",
    "content": "- circt.llvm.org/\n  - index.md\n  - talks/\n    - index.md\n  - getting_started/\n    - index.md\n  - docs/\n    - index.md\n    - Tools/\n      - index.md\n      - circt-synth/\n        - index.md\n      - circt-verilog/\n        - index.md\n      - handshake-runner/\n        - index.md\n    - EmitPasses/\n      - index.md\n    - Charter/\n      - index.md\n    - Dialects/\n      - index.md\n      - ESIAppID/\n        - index.md\n      - Arc/\n        - index.md\n      - Calyx/\n        - index.md\n      - CHIRRTL/\n        - index.md\n      - Comb/\n        - index.md\n        - RationaleComb/\n          - index.md\n      - Datapath/\n        - index.md\n        - RationaleDatapath/\n          - index.md\n      - DC/\n        - index.md\n        - RationaleDC/\n          - index.md\n      - Emit/\n        - index.md\n        - RationaleEmit/\n          - index.md\n      - ESI/\n        - index.md\n        - types/\n          - index.md\n        - services/\n          - index.md\n        - software_api/\n          - index.md\n        - notes/\n          - index.md\n        - RationaleESI/\n          - index.md\n      - FIRRTL/\n        - index.md\n        - FIRRTLAnnotations/\n          - index.md\n        - RationaleFIRRTL/\n          - index.md\n        - FIRRTLIntrinsics/\n          - index.md\n      - FSM/\n        - index.md\n        - RationaleFSM/\n          - index.md\n      - Handshake/\n        - index.md\n        - RationaleHandshake/\n          - index.md\n      - HW/\n        - index.md\n        - RationaleHW/\n          - index.md\n      - HWArith/\n        - index.md\n        - RationaleHWArith/\n          - index.md\n      - Kanagawa/\n        - index.md\n        - RationaleKanagawa/\n          - index.md\n      - LoopSchedule/\n        - index.md\n        - LoopSchedule/\n          - index.md\n      - MSFT/\n        - index.md\n      - OM/\n        - index.md\n        - RationaleOM/\n          - index.md\n      - Pipeline/\n        - index.md\n        - RationalePipeline/\n          - index.md\n      - RTGTest/\n        - index.md\n      - Seq/\n        - index.md\n        - RationaleSeq/\n          - index.md\n      - SSP/\n        - index.md\n        - RationaleSSP/\n          - index.md\n      - SV/\n        - index.md\n        - RationaleSV/\n          - index.md\n      - Synth/\n        - index.md\n        - RationaleSynth/\n          - index.md\n        - LongestPathAnalysis/\n          - index.md\n      - SystemC/\n        - index.md\n        - RationaleSystemC/\n          - index.md\n      - Debug/\n        - index.md\n      - Interop/\n        - index.md\n        - RationaleInterop/\n          - index.md\n      - LLHD/\n        - index.md\n      - LTL/\n        - index.md\n      - Moore/\n        - index.md\n      - RTG/\n        - index.md\n      - Sim/\n        - index.md\n      - SMT/\n        - index.md\n      - Verif/\n        - index.md\n    - ToolsWorkarounds/\n      - index.md\n    - FormalVerification/\n      - index.md\n    - GettingStarted/\n      - index.md\n    - HLS/\n      - index.md\n    - Passes/\n      - index.md\n    - PyCDE/\n      - index.md\n      - compiling/\n        - index.md\n      - basics/\n        - index.md\n    - Scheduling/\n      - index.md\n    - RationaleSymbols/\n      - index.md\n    - PythonBindings/\n      - index.md"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/index.md"
  },
  {
    "role": "user",
    "content": "CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n![](includes/img/circt-logo.svg)\n\n\u26a1\ufe0f \u201cCIRCT\u201d / Circuit IR Compilers and Tools\n===========================================\n\n\u201cCIRCT\u201d stands for \u201cCircuit IR Compilers and Tools\u201d. One might also interpret\nit as the recursively as \u201cCIRCT IR Compiler and Tools\u201d. The T can be\nselectively expanded as Tool, Translator, Team, Technology, Target, Tree, Type,\n\u2026 we\u2019re ok with the ambiguity.\n\nThe CIRCT community is an open and welcoming community. If you\u2019d like to\nparticipate, you can do so in a number of different ways:\n\n1. Join our\n   [Discourse Forum](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/) on the LLVM Discourse server. To get a \u201cmailing list\u201d like experience click the bell icon in the upper right and switch to \u201cWatching\u201d. It is also helpful to go to your Discourse profile, then the \u201cemails\u201d tab, and check \u201cEnable mailing list mode\u201d.\n2. For real-time discussion join the\n   [CIRCT channel](https://discord.com/channels/636084430946959380/742572728787402763) of the LLVM discord server.\n3. Join our weekly video chat. Please see the\n   [meeting notes document](https://docs.google.com/document/d/1fOSRdyZR2w75D87yU2Ma9h2-_lEPL4NxvhJGJd-s5pk/edit#)\n   for more information.\n4. Contribute code. CIRCT follows all of the LLVM Policies: you can create pull\n   requests for the CIRCT repository, and gain commit access using the\n   [standard\n   LLVM policies](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/).\n\nAlso take a look at the following diagram, which gives a brief overview of the current\n[dialects and how they interact](includes/img/dialects.svg):\n\n![](includes/img/dialectlegend.svg)\n\n![](includes/img/dialects.svg)\n\nMotivation\n----------\n\nThe EDA industry has well-known and widely used proprietary and open source\ntools. However, these tools are inconsistent, have usability concerns, and were\nnot designed together into a common platform. Furthermore\nthese tools are generally built with\n[Verilog](https://en.wikipedia.org/wiki/Verilog) (also\n[VHDL](https://en.wikipedia.org/wiki/VHDL)) as the IRs that they\ninterchange. Verilog has well known design issues, and limitations, e.g.\nsuffering from poor location tracking support.\n\nThe\n[CIRCT project](https://github.com/llvm/circt) is an (experimental!) effort\nlooking to apply MLIR and the LLVM development methodology to the domain of\nhardware design tools. Many of us dream of having reusable infrastructure that\nis modular, uses library-based design techniques, is more consistent, and builds\non the best practices in compiler infrastructure and compiler design techniques.\n\nBy working together, we hope that we can build a new center of gravity to draw\ncontributions from the small (but enthusiastic!) community of people who work\non open hardware tooling. In turn we hope this will propel open tools forward,\nenables new higher-level abstractions for hardware design, and\nperhaps some pieces may even be adopted by proprietary tools in time.\n\nFor more information, please see our longer\n[charter document](/docs/Charter/).\n\nNightly performance plots:\n<https://circt.org/perf/>\n\n[Next - Talks and Related Publications](https://circt.llvm.org/talks/ \"Talks and Related Publications\") \n\n[Edit on GitHub](https://github.com/llvm/circt-www//edit/main/website/content/_index.md)\n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation+](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/talks/index.md"
  },
  {
    "role": "user",
    "content": "Talks and Related Publications - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nTalks and Related Publications\n==============================\n\n[Open design meeting](https://docs.google.com/document/d/1fOSRdyZR2w75D87yU2Ma9h2-_lEPL4NxvhJGJd-s5pk/edit#heading=h.rcuxyx55hyqp) presentations\n------------------------------------------------------------------------------------------------------------------------------------------------\n\n* Nov 17, 2021: \u201cCharting CIRCT: the present and near future landscape\u201d by John Demme, Fabian Schuiki, Mike Urbach, and Andrew Young at LLVM Developer Meeting 2021;\n  [slides](https://llvm.org/devmtg/2021-11/slides/2021-ChartingCIRC-TThePresentAndFutureLandscape.pdf)\n  [recording](https://www.youtube.com/watch?v=K-Aqyce5ra0)\n* Nov 17, 2021: \u201cCIRCT: Lifting hardware development out of the 20th century\u201d by Andrew Lenharth, and Chris Lattner at LLVM Developer Meeting 2021;\n  [slides](https://llvm.org/devmtg/2021-11/slides/2021-CIRCT-LiftingHardwareDevOutOfThe20thCentury.pdf)\n  [recording](https://www.youtube.com/watch?v=ee01_yHjs9k)\n* Apr 19, 2021: \u201cThe Golden Age of Compiler Design in an Era of HW/SW Co-design\u201d by Chris Lattner at ASPLOS 2021 ;\n  [recording](https://www.youtube.com/watch?v=4HgShra-KnY)\n* Jan 27, 2021: Jie Wang talked about AutoSA ;\n  [recording](https://sifive.zoom.us/rec/play/ds7NksD03x8_hJ9oiwg4pk-c7JaChrU6py1QAC7Or9lm-giOZ-ZOS-XQNK5glYa6OJm9-MT9mRwMSKE5.CMopCniDF4nhfGXw?continueMode=true)\n  [github project](https://github.com/UCLA-VAST/AutoSA)\n* Jan 13, 2021: Rachit Nigam talked about Calyx Intermediate language ;\n  [slides](https://rachitnigam.com/files/slides/calyx.pdf)\n  [recording](https://sifive.zoom.us/rec/share/NvoM4qs6f0r8b1Rzt_jpRiOC9fWxba1j1zuDx8idWye4O6KgZBojxKXc48tKrCCp.tUFXyNHI3eoR1V8r)\n* Jan 6, 2021: Mike Urbach presented slides on NPComp to Static Hardware ;\n  [slides](https://docs.google.com/presentation/d/1MyQWWFsksfMO5DVdJkpSnL1POQLibVb0RbGwCQm9JcY/edit?usp=sharing)\n  [recording](https://sifive.zoom.us/rec/share/J6uVkQsxLvqNy1iMXoxuCaDfNrsI3O7Gue1magWykcjhV1EdUBdFk9R8Mr3MGjPs.UQrjhAN9u8gJ0La0)\n* Dec 16, 2020: Richard Townsend talked about his Haskell to hardware work ;\n  [slides](http://www.cs.columbia.edu/~sedwards/papers/townsend2017functional.pdf)\n  [recording](https://sifive.zoom.us/rec/share/5a_ICg-LBbv6IzUjwmO4POUdo3gr8qH5rcC3T1Mi563OlD4aWlD-8RU3aH88FWr3.z9cXYF4pyVJfYVkc)\n* Dec 9, 2020: David Durst gave a talk about Aetherling ;\n  [paper](https://aetherling.org/aetherling.pdf)\n  [project website](https://aetherling.org/)\n* Dec 2, 2020: Thomas Bourgeat and Cl\u00e9ment Pit-Claudel gave a talk about Koika ;\n  [paper](https://dl.acm.org/doi/10.1145/3385412.3385965)\n* Nov 4, 2020: Chris Torng gave a talk on mflowgen - a modular approach to reusable physical design flows ;\n  [project website](https://mflowgen.readthedocs.io/en/latest/)\n* Oct 28, 2020: Cheng Tan talked about OpenCGRA work happening at PNNL ;\n  [github project](https://github.com/pnnl/OpenCGRA)\n* Oct 21, 2020: Sitao Huang talked about PyLog work happening at UIUC ;\n  [slides](https://drive.google.com/file/d/1k-fLrgfo3Mh4Kv4uCOS8VDLX5ngG5znj/view?usp=sharing)\n* Sep 30, 2020: Wilson Snyder presented an overview of Verilator and its infrastructure ;\n  [github project](https://github.com/verilator/verilator)\n* Sep 23, 2020: Rachit Nigam, Adrian Sampson talked about Dahlia language ;\n  [web demo](https://capra.cs.cornell.edu/dahlia/)\n  [youtube talk](https://www.youtube.com/watch?v=hp_RwcnrFJg)\n* Sep 16, 2020: Adam Izraelevitz presented about FIRRTL design and lessons learned ;\n  [presentation](https://docs.google.com/presentation/d/1fkwgbBe_AfNYkNxUJEdZCAo-Ys_6u_fdxd3K5d59eXU/edit?usp=sharing)\n* Sep 9, 2020: Fabrizio Ferrandi presented about Bambu ;\n  [presentation](https://drive.google.com/file/d/1Q3VCv4i7S4Ys2zR7cn4N9HhCYyFzeMj6/view?usp=sharing)\n* Aug 19, 2020: Hanchen Ye talked about Handshake-based HLS work did at Xilinx ;\n  [presentation](https://drive.google.com/file/d/1_YYKpd60ltPb0Kg5agqib2FAOvBLHlJO/view?usp=sharing)\n* July 22, 2020: Aliaksei led a discussion about Verilog type systems;\n  [slides](https://docs.google.com/presentation/d/1m5to8jIGCwOhZfAHA6UOAc7BBThHSRxUkc2Niu48bqI/edit?usp=sharing)\n* July 8, 2020: Stephen talked about RTL dialect, how things connect and compose ;\n  [slides](https://drive.google.com/file/d/1kjeYi4X_WC5B45z3nvw9W7UfyREahJhz/view?usp=sharing)\n* June 24, 2020: Stephen shared his work on Handshake dialect ;\n  [presentation](https://drive.google.com/file/d/1UYQAfHrzcsdXUZ93bHPTPNwrscwx89M-/view?usp=sharing)\n* June 10, 2020: John Demme talked about Elastic-Silicon-Interconnect project ;\n  [github project](https://github.com/microsoft/Elastic-Silicon-Interconnect)\n\n[Edit on GitHub](https://github.com/llvm/circt-www//edit/main/website/content/talks/_index.md)\n\n [Prev -](https://circt.llvm.org/)\n[Next - Getting Started](https://circt.llvm.org/getting_started/ \"Getting Started\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation+](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/getting_started/index.md"
  },
  {
    "role": "user",
    "content": "Getting Started - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nGetting Started\n===============\n\nSee\n<https://circt.llvm.org/docs/GettingStarted/>.\n\n[Edit on GitHub](https://github.com/llvm/circt-www//edit/main/website/content/getting_started/_index.md)\n\n [Prev - Talks and Related Publications](https://circt.llvm.org/talks/ \"Talks and Related Publications\")\n[Next - Code Documentation](https://circt.llvm.org/docs/ \"Code Documentation\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation+](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/index.md"
  },
  {
    "role": "user",
    "content": "Code Documentation - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nCode Documentation\n==================\n\nCode Documentation Docs\n-----------------------\n\n* [Tools](https://circt.llvm.org/docs/Tools/)\n* [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n* [Dialects](https://circt.llvm.org/docs/Dialects/)\n* [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n* [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n* [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n* [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n* [Passes](https://circt.llvm.org/docs/Passes/)\n* [Python CIRCT Design Entry (PyCDE)](https://circt.llvm.org/docs/PyCDE/)\n* [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n* [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n* [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n* [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)\n\n [Prev - Getting Started](https://circt.llvm.org/getting_started/ \"Getting Started\")\n[Next - Tools](https://circt.llvm.org/docs/Tools/ \"Tools\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation+](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Tools/index.md"
  },
  {
    "role": "user",
    "content": "Tools - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nTools\n=====\n\nTools Docs\n----------\n\n* [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n* [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n* [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n\n [Prev - Code Documentation](https://circt.llvm.org/docs/ \"Code Documentation\")\n[Next - circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/ \"circt-synth\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Tools/circt-synth/index.md"
  },
  {
    "role": "user",
    "content": "circt-synth - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\ncirct-synth\n===========\n\n**circt-synth** [*options*] [*filename*]\n\nA logic synthesis tool converting designs expressed in the\n[comb](/docs/Dialects/Comb/) and\n[HW](/docs/Dialects/HW/) dialects.\nThere are no additional build requirements and can build directly\n`ninja circt-synth`. The tool currently only supports combinatorial logic but we\nare actively working to extend support to sequential designs (get involved).\n\nBy default the design is lowered to an and-inverter graph (AIG) represented\nusing the\n[synth](/docs/Dialects/Synth/) dialect using optimisations that\ntarget general cell libraries. A `--synthesis-strategy` option can configure\narea vs delay optimisation. The tool uses a longest path analysis to guide\ndesign decisions and can output the critical path to a file via the\n`--output-longest-path=<filename>` option.\n\n### Example\u00a0[\u00b6](#example)\n\n```\n// sum.mlir\nmodule {\n  hw.module @sum(in %a : i4, in %b : i4, out sum : i4) {\n    %0 = comb.add %a, %b : i4\n    hw.output %0 : i4\n  }\n}\n```\n\nWriting `circt-synth sum.mlir` the addition is lowered to the\n[synth](/docs/Dialects/Synth/) dialect that expresses the design using\nonly and-inverter operations and `concat`/`extract` operations:\n\n```\nmodule {\n  hw.module private @sum(in %a : i4, in %b : i4, out sum : i4) {\n    %0 = comb.extract %a from 0 : (i4) -> i1\n    %1 = comb.extract %a from 1 : (i4) -> i1\n    %2 = comb.extract %a from 2 : (i4) -> i1\n    %3 = comb.extract %a from 3 : (i4) -> i1\n    %4 = comb.extract %b from 0 : (i4) -> i1\n    %5 = comb.extract %b from 1 : (i4) -> i1\n    %6 = comb.extract %b from 2 : (i4) -> i1\n    %7 = comb.extract %b from 3 : (i4) -> i1\n    %8 = synth.aig.and_inv not %0, not %4 : i1\n    %9 = synth.aig.and_inv %0, %4 : i1\n    %10 = synth.aig.and_inv not %8, not %9 : i1\n    %11 = synth.aig.and_inv not %1, not %5 : i1\n    ...\n    %31 = comb.concat %30, %23, %16, %10 : i1, i1, i1, i1\n    hw.output %31 : i4\n  }\n}\n```\n\n [Prev - Tools](https://circt.llvm.org/docs/Tools/ \"Tools\")\n[Next - circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/ \"circt-verilog\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools-](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Tools/circt-verilog/index.md"
  },
  {
    "role": "user",
    "content": "circt-verilog - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\ncirct-verilog\n=============\n\n**circt-verilog** [*options*] [*filename*]\n\nA (System) Verilog parser that generates CIRCT code using the core dialects.\nThe `circ-verilog` tool depends on the\n[slang](https://github.com/MikePopoloski/slang) parser and as such requires a specific build configuration. The supported subset of System Verilog is actively growing and can be tracked via the\n[SV Tests dashboard](https://chipsalliance.github.io/sv-tests-results/).\n\n### Build\u00a0[\u00b6](#build)\n\nAdd to your circt cmake command:`-DCIRCT_SLANG_FRONTEND_ENABLED=ON`.\n\n```\n$ cd circt\n$ mkdir build\n$ cd build\n$ cmake -G Ninja .. \\\n    -DMLIR_DIR=$PWD/../llvm/build/lib/cmake/mlir \\\n    -DLLVM_DIR=$PWD/../llvm/build/lib/cmake/llvm \\\n    -DLLVM_ENABLE_ASSERTIONS=ON \\\n    -DCMAKE_BUILD_TYPE=DEBUG \\\n    -DLLVM_USE_SPLIT_DWARF=ON \\\n    -DLLVM_ENABLE_LLD=ON  \\\n    -DCIRCT_SLANG_FRONTEND_ENABLED=ON\n$ ninja circt-verilog\n```\n\n### Example\u00a0[\u00b6](#example)\n\nA simple counter module that uses a register with a synchronous reset is written\nin System Verilog (`counter.sv`).\n\n```\nmodule counter (\n    input  logic       clk,\n    input  logic       reset,\n    output logic [7:0] count\n);\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'b0;\n        else\n            count <= count + 9'd1;\n    end\nendmodule\n```\n\nWriting `circt-verilog counter.sv` generates the following:\n\n```\nmodule {\n  hw.module @counter(in %clk : i1, in %reset : i1, out count : i8) {\n    %c1_i8 = hw.constant 1 : i8\n    %c0_i8 = hw.constant 0 : i8\n    %0 = comb.add %count, %c1_i8 : i8\n    %1 = seq.to_clock %clk\n    %count = seq.firreg %0 clock %1 reset async %reset, %c0_i8 : i8\n    hw.output %count : i8\n  }\n}\n```\n\n [Prev - circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/ \"circt-synth\")\n[Next - handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/ \"handshake-runner\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools-](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Tools/handshake-runner/index.md"
  },
  {
    "role": "user",
    "content": "handshake-runner - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nhandshake-runner\n================\n\nSYNOPSIS\u00a0[\u00b6](#synopsis)\n-----------------------\n\n| **handshake-runner** [*options*] [*filename*] [*arguments*]\n\nDESCRIPTION\u00a0[\u00b6](#description)\n-----------------------------\n\nThis application executes a function in the given MLIR module. Arguments to the\nfunction are passed on the command line and results are returned on stdout.\nMemref types are specified as a comma-separated list of values. This particular\ntool is use to check the validity of Standard-to-Handshake conversion in CIRCT.\n\n### Example\u00a0[\u00b6](#example)\n\nThe following MLIR module first convert to Handshake IR with the circt-opt tool\nas `circt-opt -create-dataflow <file-name>`. And then the converted handshake IR\ncan be run by the handshake-runner with a command line argument \u201c2\u201d as\n`handshake-runner <file-name> 2` and produces the expected result \u201c1\u201d.\n\n```\nmodule {\n  func @main(%arg0: index) -> (i8) {\n    %0 = alloc() : memref<10xi8>\n    %c1 = constant 1 : i8\n         store %c1, %0[%arg0] : memref<10xi8>\n         %1 = load %0[%arg0] : memref<10xi8>\n         return %1 : i8\n  }\n}\n```\n\n### Options\u00a0[\u00b6](#options)\n\n-h, \u2013help\n:   Prints brief usage information.\n\n\u2013runStats\n:   Print Execution Statistics\n\n\u2013toplevelFunction=`<string>`\n:   The toplevel function to execute\n\n-v, \u2013version\n:   Prints the current version number.\n\nEXIT STATUS\u00a0[\u00b6](#exit-status)\n-----------------------------\n\nIf handshake-runner succeeds, it will exit with 0. Otherwise, if an error\noccurs, it will exit with a non-zero value.\n\nBUGS\u00a0[\u00b6](#bugs)\n---------------\n\nSee GitHub Issues:\n<https://github.com/llvm/circt/issues>\n\nAUTHOR\u00a0[\u00b6](#author)\n-------------------\n\nMaintained by the CIRCT Team (\n[https://circt.org/)](https://circt.org/%29).\n\nSEE ALSO\u00a0[\u00b6](#see-also)\n-----------------------\n\n[circt-opt](circt-opt.md)\n\n [Prev - circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/ \"circt-verilog\")\n[Next -](https://circt.llvm.org/docs/EmitPasses/) \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools-](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/EmitPasses/index.md"
  },
  {
    "role": "user",
    "content": "CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n### `-strip-emit`\u00a0[\u00b6](#-strip-emit)\n\n*Remove Emit dialect ops*\n\nRemoves all Emit dialect operations from the IR. Useful as a prepass in\npipelines that have to discard Emit operations.\n\n [Prev - handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/ \"handshake-runner\")\n[Next - CIRCT Charter](https://circt.llvm.org/docs/Charter/ \"CIRCT Charter\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Charter/index.md"
  },
  {
    "role": "user",
    "content": "CIRCT Charter - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nCIRCT Charter\n=============\n\nAbstract\u00a0[\u00b6](#abstract)\n-----------------------\n\nRecent trends in computer architecture have resulted in two core problems.\nFirstly, how do we design complex, heterogeneous systems-on-chip mixing\ngeneral purpose and specialized components? Secondly, how do we\nprogram them? We believe that design tools that represent and\nmanipulate a wide variety of abstractions are central to solving these\nproblems. This projects is focused on using LLVM/MLIR to express\nthese abstractions and to build useable open-source flows based on\nthose abstractions to solve the design problems of the next decade.\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\nWith the slowing rate of scaling in semiconductor process technology,\nthere has become a widespread shift to develop more specialized\narchitectures. Circuits implementing these specialized architectures are\ngenerally called *accelerators*, although they are developed as a\ntradeoff between performance, power usage, design cost and manufacturing\ncost. Accelerators typically implement compute structures, interconnect,\nand memory hierarchies optimized for particular workloads. Optimizing\nmemory and communication is often more important for overall design\ngoals than optimizing the computing structures.\nAccelerators are almost always programmable to some extent, in order to\nallow them to operate on a set of similar workloads, although they are\ntypically much less programmable than general purpose architectures.\n\nAccelerators are often so valuable because of their specialization that\nthey may be included in devices even when they are not constantly\nused.\n\nThe need for specialization has led to a wide variety of accelerators in\nsome areas, such as machine learning. Programming a wide\nvariety of accelerators from a wide scope of design languages is a\nsignificant challenge. MLIR addresses this by using many abstractions\ncalled *dialects*. Individual design languages are typically associated\nwith their own dialects, which are generally lowered into common\ndialects and optimized. Implementing optimizations on common dialects\nallows the effort of developing and maintaining optimizations to be\nshared between design languages and target architectures. Eventually,\ndialects are lowered (perhaps in a target-specific fashion) to low-level\ndialects and eventually to target-specific dialects, facilitating code\ngeneration for particular accelerator targets.\n\nAt the same time, developing accelerators themselves is becoming more\nchallenging. Accelerators are often complex and may\nhave multiple design constraints which are difficult to meet. Even\nbuilding one accelerator can have a significant cost. At the same time,\naccelerators are also numerous, implying that there is less design\neffort available for each accelerator and yet the cost of building an\naccelerator must be incurred over and over again. We argue that the\nfundamental concepts of MLIR can address this hardware design complexity\nare as applicable to the process of *building* accelerators as they are\nto the process of *programming* them. Furthermore, unifying the\nabstractions for accelerator design and accelerator programming is a key\nstep towards enabling programming for arbitrary accelerators.\n\nDialects for Hardware Design\u00a0[\u00b6](#dialects-for-hardware-design)\n---------------------------------------------------------------\n\nIn existing systems, we see the use of a wide variety of abstractions\ncommonly in use. These abstractions tend to exist in a hierarchy of\nabstractions used at different parts of the design process, where\nhigher-level abstractions are used to generate lower-level abstractions.\nOften this hierarchy is not explicit in tools, but is only apparent in\nthe informal processes applied by human engineers. For instance,\nengineers might discuss the flow of data through a sequence of\naccelerators using a block diagram on a whiteboard, capture that\narchitecture in informal documentation and then proceed with\nimplementing and integrating these components in a hardware design\nlanguage. We believe that using MLIR to define hardware design\nabstractions using dialects will make these specifications more precise\nand enable more automation of transformations between these\nabstractions.\n\nNote that these abstractions may be used in different ways at different\npoints in the design process. These differences in usage often come down\nto a difference in component granularity. For instance early in the\ndesign process an abstraction may be used with large, coarse-grained\ncomponents. After lowering, perhaps through other abstractions, the same\nabstraction may again appear with smaller, fine-grained\ncomponents.\n\nBelow, we summarize the most important abstractions used in existing\nprocesses. This list is unlikely to be comprehensive and it is likely\nthat the process of capturing these abstractions as MLIR dialects will\nidentify additional abstractions or constraints that help facilitate the\nlowering between dialects. Many existing systems span multiple\nabstractions, but we\u2019ve tried here to focus on the most significant\ninternal representations used in each tool.\n\n### Structural Circuit Netlists\u00a0[\u00b6](#structural-circuit-netlists)\n\nNetlists are a longstanding abstraction used for circuit design,\nexpressing the instantiation and interconnection of primitive\ncomponents. Components are typically fine-grained, representing logic\ngates in a standard-cell integrated circuit, or architectural primitives\nin programmable logic. The EDIF format has been almost ubiquitous\nsince the early days of Electronic Design Automation, although the\nVerilog language is also commonly used to store netlists in\nmodern tools.\n\nNetlist descriptions often blur the distinctions between the inputs and\noutputs of components. Connections between components may represent\nphysical connections where multiple components may (hopefully at\ndifferent times!) drive a signal onto the same wire. Alternatively, a\nsingle component may sometimes use a wire as an input and at other times\nuse the same wire for output.\n\n### Register-transfer level (RTL)\u00a0[\u00b6](#register-transfer-level-rtl)\n\nThe Register-transfer level is has been commonly used to describe logic\ncircuits. The process of logic synthesis is commonly used to lower RTL\ndesigns into structural netlists. Verilog, SystemVerilog, and VHDL are\ncommonly used in the industry. The LLHD framework\nexplicitly takes a multi-level approach to capturing RTL designs and\nlowering them into more fundamental constructs which can be efficiently\nsimulated or synthesized. A key aspect of this systems is the\nobservation that useful input languages (such as SystemVerilog) provide\na much wider set of constructs than can be easily synthesized, and\nmanaging this complexity in a structured way is key to building real\nsystems. Another recent system focused on improving RTL-level design is\nChisel, along with associated\nFIRRTL intermediate\nrepresentation.\n\nAt the register-transfer level, the distinction between components which\nare clocked (i.e. registers) and those which are not clocked (i.e.\ncombinational logic) is explicit. Many circuit synthesis techniques have\nhistorically leveraged this distinction to focus only on the\ncombinational aspects. Modern circuit analysis techniques often consider\nthe behavior across synchronous boundaries. Retiming is a common\ntransformation performed on RTL descriptions.\n\n### Finite-State Machine + Datapath (FSMD)\u00a0[\u00b6](#finite-state-machine--datapath-fsmd)\n\nHigh-Level synthesis (HLS) of RTL designs from C code has become a common\nparadigm for accelerator design.\nTypically generating a high-performance implementation requires analysis\nand scheduling of the FSMD model in order to understand the performance\nimplications of particular choices.\n\nA common intermediate abstraction in HLS is a combination of\nfinite-state machines and datapath abstractions. Conceptually, in each\nstate of the state machine, certain operations in a datapath are\nenabled. This abstraction facilitates reasoning about resource sharing\nand pipelined behavior, while leaving the specifics of how those\nmechanisms are implemented implicit. Lowering into an RTL-level\ndescription typically requires explicitly representing these mechanisms,\nconverting both the control finite-state machine and the datapath into\nregisters and combinational logic. This lowering also requires\nexplicitly representing clocks and clock enables in the circuit in an\nefficient way. Note that finite-state machines may also be represented\nin other ways (for instance, using microcode) rather than being lowered\nthrough logic synthesis into fixed logic.\n\nSeveral projects have described the internal representation of HLS\ncompilers. LegUp leverages the Clang/LLVM framework for\nrepresenting designs, while Bambu builds an independent\ninternal representation.\n\n[Calyx](https://capra.cs.cornell.edu/calyx) is a new intermediate language\nthat combines a software-like control language with a hardware-like structural\nlanguage. This intermediate level of representation allows Calyx to optimize\nstructural programs using control flow information.\nCalyx currently serves as the compilation target for\n[Dahlia](https://capra.cs.cornell.edu/dahlia)\nand several other domain-specific architectures (systolic array, number\ntheoretic transform unit).\n\n### [Dataflow/handshake](/docs/Dialects/Handshake/RationaleHandshake/)\n\nDataflow models have long been used to represent parallel computation.\nTypically these models include components representing independent\nprocesses communicating through streams of data. These models provide a\nnotion of concurrency which is intrinsically decoupled, unlike\nsynchronous models like RTL. This makes it easy to describe distributed\nsystems with *elastic* or *latency-insensitive* properties, where the\nlatency to communicate data from one process to another is guaranteed to\nnot change the streams of data being computed.\n\nIt is possible to extract dataflow models from fine-grained CDFG\nrepresentations of sequential code and the resulting\ndataflow models can be implemented directly in a circuit, although the\ncircuits used to implement fine-grained handshake logic are often more\ncomplex than an equivalent FSMD model (for designs which can be\nstatically scheduled). More commonly, dataflow models are used with\ncoarse-grained synchronous components to implement a globally\nasynchronous-locally synchronous(GALS) architecture. This architecture\nis often appropriate for large accelerator designs where clock\ndistribution and global timing closure can be challenging when\nimplementing large componentized RTL designs.\n\nAnother common use of dataflow models is as a simulation tool, as in\nFireSim. FireSim starts with a cycle-accurate RTL model, and extracts\na dataflow model where time is represented explicitly in the model.\nThis allows distributed simulation or for models of parts of a\nhardware design to be inserted where RTL does not yet exist. By\nmapping the dataflow model back to hardware in a non-cycle accurate\nway, very fast emulation can be built quickly.\n\n### IP composition\u00a0[\u00b6](#ip-composition)\n\nIP composition has become a key methodology for most FPGA and ASIC\ndesigns, enabling large designs to be constructed out of small\ncomponents. The key to making IP composition robust has been to focus on\ninterface-based composition using protocols like ARM AXI, rather than\nsignal-level composition which is commonly done in RTL design. Standard\ninterface protocols have enabled designers to independently solve the\nproblems of how components behave internally with how they are\nintegrated. At the lowest levels of the design flow, this has allowed\nlarger designs to meet timing during place and route, by enabling\nhierarchical floorplanning and late-stage interconnect synthesis. It can\nalso enable the impact of late-stage changes, called Engineering Change\nOrders (ECOs), to be encapsulated, avoiding unnecessary redundant\nverification. IP composition also enables portable operating system\nsoftware and runtimes based on declarative descriptions of device\narchitectures, for instance using Device Trees.\n\nIPXact is an industry standard file format, although a lack of\nindustry-standard IP definitions and heavy reliance in practice on\nvendor extensions has meant that tools using IPXact are largely not\ninter-operable. In addition, being based on XML, IPXact is somewhat\nverbose and difficult for humans to interact with. DUH is a recent\nopen-source effort based on JSON formats also focusing on IP\ncomposition.\n\nTool Flows\u00a0[\u00b6](#tool-flows)\n---------------------------\n\nAlthough it is important to have appropriate abstractions to build with,\nthose abstractions are simply a means to support transformations of\ndesigns. Although many flows are potentially interested, we highlight\nsome of the most interesting flows.\n\n### High-Level Synthesis (HLS)\u00a0[\u00b6](#high-level-synthesis-hls)\n\nA common toolflow is to synthesize circuits from sequential algorithmic\ncode. Many tools have implemented this type of tool flow, usually with a\nfocus on signal processing applications. In such a flow, building deeply\npipelined and parallelized implementations of loops is a key capability.\nA typical high-level synthesis flow starts from an optimized\ncontrol-dataflow graph (CDFG). Additional hardware-oriented\noptimizations, such as bitwidth minimization, ROM inference,\nshift-register identification, and algebraic optimizations with hardware\ncost models taken into account are typically performed to reduce\nimplementation cost. Memory analysis and optimization is also critical\nfor most code. Arrays are often implemented in local memories wherever\npossible, and memory accesses optimized to eliminate cache hierarchy\nwherever possible. Memories are often restructured through memory\npartitioning to increase bandwidth. Accurate points-to analysis and\naffine index analysis are necessary to statically identify limits on\npipelining. Operation scheduling is performed to identify initial\nclock-cycle boundaries.\n\nA scheduled design can be expressed as an FSMD model. In this form, it\nbecomes possible to identify micro-architectural optimizations.\nOperations can be shared on the same hardware and the multiplexing cost\nfrom this sharing can be accurately estimated. Control logic cost can\nalso be estimated and minimized. Verification is also important in this\nstage: simulation can be used to verify a design with the original\nsequential testbench and partial formal analysis, e.g. reachability\nanalysis on generated control logic, are possible. Interface synthesis\nis also applicable at this level of abstraction, converting algorithmic\ninterfaces (like sequential accesses to memory) with implementation\ninterfaces (like FIFO interfaces).\n\nAfter optimization, the FSMD model can be realized as a\nRegister-Transfer Level (RTL) design. This transformation makes the\ncontrol FSM explicit and blurs the distinction between the control logic\nand data path. Logic optimization is possible between the control logic\nand the data path and these optimizations can leverage Clock Enable\ninputs on registers. RTL models are typically realized as Verilog or\nVHDL, enabling implementation using vendor tools. Alternatively, these\nmodels could be further lowered to more hardware-specific dialects in\nMLIR.\n\n### Dataflow-based Multicore Programming\u00a0[\u00b6](#dataflow-based-multicore-programming)\n\nMulticore programming is commonly done using Single-Program\nMultiple-Data (SPMD) programming, such as CUDA for GPUs. Typically, each\nprocessor reads a portion of a large data set from external memory into\nlocal memory, processing it locally before writing results back to\nexternal memory. As a result, communication between processors largely\nhappens through external memory, resulting in significant power\nconsumption and a communication bottleneck. While communication between\ncores using on-chip memory is also possible, this must be managed\nexplicitly and separately from global memory. Explicit dataflow-based\nprogramming represents inter-process communication explicitly as streams\nof data, allowing communication intent to be explicitly separated from\nstateful storage. Additionally, since dataflow processes do not share\nstate, dataflow-based programming describes memory locality explicitly\nin a program.\n\nMany optimizations are possible on dataflow models. Most critically,\nfusion optimizations manipulate the dataflow graph to generate toplevel\ndataflow components where each component represents execution on a\nsingle processor. In order to generate a balanced\nsystem, this is typically done with several goals. Primarily, this needs\nto be done considering locality of access, often merging dataflow\ncomponents which share inputs or process data in a pipeline.\nSecondarily, it is also important to balance the amount of processing\ndone on each physical processor. This minimizes the amount of time where\none processor is stalled waiting for data from another processor. In\nmore complicated systems with feedback, unbalanced workloads may be\npreferable to ensure that feedback paths complete quickly. \\*Fission\ntransformations may also be important, where large granularity\ncomponents exist in a dataflow program. Obviously data-parallel\ncomputations can be partitioned using Split/Join pairs, while more\ncomplex components consisting of nested loops with recurrences require\nmore complex analysis.\n\nStream computation can be implemented using different mechanisms\ndepending on the architecture. Some architectures provide stream\noperations in the ISA, enabling data to be communicated on physical\nstreams. However, in most cases, stream accesses are turned into memory\noperations. For instance, streams on general purpose CPUs are typically\nimplemented through memory allocation, pointer manipulation and\nsynchronization between threads or perhaps using OS-level pipes between\nprocesses. Stream communication may also occur between general purpose\nCPUs and an accelerator with stream communication being implemented by a\ncombination of DMA hardware, shared memory access, and runtime API\ncalls. In distributed systems, stream communication can also be\nimplemented over a network, for instance using TCP/IP. In such cases,\nunderstanding the bottleneck of a shared medium can be critical. In each\nof these cases, there are lowerings from dataflow concepts to more\ngeneric process/thread/fibre concepts, where there are significant\narchitecture-specific tradeoffs which must be managed. We argue that\nmodeling this lowering explicitly is almost always more convenient for a\nprogrammer than exposing low-level concepts (e.g. threads and locks) to\nthe programmer.\n\n [Prev -](https://circt.llvm.org/docs/EmitPasses/)\n[Next - Dialects](https://circt.llvm.org/docs/Dialects/ \"Dialects\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/index.md"
  },
  {
    "role": "user",
    "content": "Dialects - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nDialects\n========\n\nThis section contains documentation for core and contributed dialects available\nfrom the CIRCT repository. The description for each dialect includes content\nautomatically generated from the dialect\u2019s\n[Operation Definition Specification (ODS)](../OpDefinitions.md).\n\nDialects Docs\n-------------\n\n* ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n* ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n* ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n* ['comb' Dialect](https://circt.llvm.org/docs/Dialects/Comb/)\n* ['datapath' Dialect](https://circt.llvm.org/docs/Dialects/Datapath/)\n* ['dc' Dialect](https://circt.llvm.org/docs/Dialects/DC/)\n* ['emit' Dialect](https://circt.llvm.org/docs/Dialects/Emit/)\n* ['esi' Dialect](https://circt.llvm.org/docs/Dialects/ESI/)\n* ['firrtl' Dialect](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n* ['fsm' Dialect](https://circt.llvm.org/docs/Dialects/FSM/)\n* ['handshake' Dialect](https://circt.llvm.org/docs/Dialects/Handshake/)\n* ['hw' Dialect](https://circt.llvm.org/docs/Dialects/HW/)\n* ['hwarith' Dialect](https://circt.llvm.org/docs/Dialects/HWArith/)\n* ['kanagawa' Dialect](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n* ['loopschedule' Dialect](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n* ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n* ['om' Dialect](https://circt.llvm.org/docs/Dialects/OM/)\n* ['pipeline' Dialect](https://circt.llvm.org/docs/Dialects/Pipeline/)\n* ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n* ['seq' Dialect](https://circt.llvm.org/docs/Dialects/Seq/)\n* ['ssp' Dialect](https://circt.llvm.org/docs/Dialects/SSP/)\n* ['sv' Dialect](https://circt.llvm.org/docs/Dialects/SV/)\n* ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/)\n* ['systemc' Dialect](https://circt.llvm.org/docs/Dialects/SystemC/)\n* [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n* [Interop Dialect](https://circt.llvm.org/docs/Dialects/Interop/)\n* [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n* [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n* [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n* [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n* [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n* [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n* [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n\n [Prev - CIRCT Charter](https://circt.llvm.org/docs/Charter/ \"CIRCT Charter\")\n[Next -](https://circt.llvm.org/docs/Dialects/ESIAppID/) \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/ESIAppID/index.md"
  },
  {
    "role": "user",
    "content": "CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n### InnerSymAttr\u00a0[\u00b6](#innersymattr)\n\n*Inner symbol definition*\n\nDefines the properties of an inner\\_sym attribute. It specifies the symbol\nname and symbol visibility for each field ID. For any ground types,\nthere are no subfields and the field ID is 0. For aggregate types, a\nunique field ID is assigned to each field by visiting them in a\ndepth-first pre-order. The custom assembly format ensures that for ground\ntypes, only `@<sym_name>` is printed.\n\n#### Parameters:\u00a0[\u00b6](#parameters)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| props | `::llvm::ArrayRef<InnerSymPropertiesAttr>` |  |\n\n### InnerSymPropertiesAttr\u00a0[\u00b6](#innersympropertiesattr)\n\n#### Parameters:\u00a0[\u00b6](#parameters-1)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| name | `::mlir::StringAttr` |  |\n| fieldID | `uint64_t` |  |\n| sym\\_visibility | `::mlir::StringAttr` |  |\n\n### NullChannelAttr\u00a0[\u00b6](#nullchannelattr)\n\n*An attribute which indicates a channel is unconnected.*\n\nSyntax:\n\n```\n#esi.null<\n  TypeAttr   # type\n>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-2)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| type | `TypeAttr` |  |\n\n [Prev - Dialects](https://circt.llvm.org/docs/Dialects/ \"Dialects\")\n[Next - 'arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/ \"'arc' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Arc/index.md"
  },
  {
    "role": "user",
    "content": "'arc' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'arc' Dialect\n=============\n\n*Canonical representation of state transfer in a circuit*\n\nThis is the `arc` dialect, useful for representing state transfer functions\nin a circuit.\n\n* [Operations](#operations)\n  + [`arc.alloc_memory` (circt::arc::AllocMemoryOp)](#arcalloc_memory-circtarcallocmemoryop)\n  + [`arc.alloc_state` (circt::arc::AllocStateOp)](#arcalloc_state-circtarcallocstateop)\n  + [`arc.alloc_storage` (circt::arc::AllocStorageOp)](#arcalloc_storage-circtarcallocstorageop)\n  + [`arc.call` (circt::arc::CallOp)](#arccall-circtarccallop)\n  + [`arc.clock_domain` (circt::arc::ClockDomainOp)](#arcclock_domain-circtarcclockdomainop)\n  + [`arc.define` (circt::arc::DefineOp)](#arcdefine-circtarcdefineop)\n  + [`arc.execute` (circt::arc::ExecuteOp)](#arcexecute-circtarcexecuteop)\n  + [`arc.final` (circt::arc::FinalOp)](#arcfinal-circtarcfinalop)\n  + [`arc.initial` (circt::arc::InitialOp)](#arcinitial-circtarcinitialop)\n  + [`arc.lut` (circt::arc::LutOp)](#arclut-circtarclutop)\n  + [`arc.memory` (circt::arc::MemoryOp)](#arcmemory-circtarcmemoryop)\n  + [`arc.memory_read` (circt::arc::MemoryReadOp)](#arcmemory_read-circtarcmemoryreadop)\n  + [`arc.memory_read_port` (circt::arc::MemoryReadPortOp)](#arcmemory_read_port-circtarcmemoryreadportop)\n  + [`arc.memory_write` (circt::arc::MemoryWriteOp)](#arcmemory_write-circtarcmemorywriteop)\n  + [`arc.memory_write_port` (circt::arc::MemoryWritePortOp)](#arcmemory_write_port-circtarcmemorywriteportop)\n  + [`arc.model` (circt::arc::ModelOp)](#arcmodel-circtarcmodelop)\n  + [`arc.output` (circt::arc::OutputOp)](#arcoutput-circtarcoutputop)\n  + [`arc.root_input` (circt::arc::RootInputOp)](#arcroot_input-circtarcrootinputop)\n  + [`arc.root_output` (circt::arc::RootOutputOp)](#arcroot_output-circtarcrootoutputop)\n  + [`arc.runtime.model` (circt::arc::RuntimeModelOp)](#arcruntimemodel-circtarcruntimemodelop)\n  + [`arc.sim.emit` (circt::arc::SimEmitValueOp)](#arcsimemit-circtarcsimemitvalueop)\n  + [`arc.sim.get_port` (circt::arc::SimGetPortOp)](#arcsimget_port-circtarcsimgetportop)\n  + [`arc.sim.instantiate` (circt::arc::SimInstantiateOp)](#arcsiminstantiate-circtarcsiminstantiateop)\n  + [`arc.sim.set_input` (circt::arc::SimSetInputOp)](#arcsimset_input-circtarcsimsetinputop)\n  + [`arc.sim.step` (circt::arc::SimStepOp)](#arcsimstep-circtarcsimstepop)\n  + [`arc.state` (circt::arc::StateOp)](#arcstate-circtarcstateop)\n  + [`arc.state_read` (circt::arc::StateReadOp)](#arcstate_read-circtarcstatereadop)\n  + [`arc.state_write` (circt::arc::StateWriteOp)](#arcstate_write-circtarcstatewriteop)\n  + [`arc.storage.get` (circt::arc::StorageGetOp)](#arcstorageget-circtarcstoragegetop)\n  + [`arc.tap` (circt::arc::TapOp)](#arctap-circtarctapop)\n  + [`arc.vectorize` (circt::arc::VectorizeOp)](#arcvectorize-circtarcvectorizeop)\n  + [`arc.vectorize.return` (circt::arc::VectorizeReturnOp)](#arcvectorizereturn-circtarcvectorizereturnop)\n  + [`arc.zero_count` (circt::arc::ZeroCountOp)](#arczero_count-circtarczerocountop)\n* [Attributes](#attributes-19)\n  + [TraceTapAttr](#tracetapattr)\n* [Types](#types)\n  + [MemoryType](#memorytype)\n  + [SimModelInstanceType](#simmodelinstancetype)\n  + [StateType](#statetype)\n  + [StorageType](#storagetype)\n* [Enums](#enums)\n  + [ZeroCountPredicate](#zerocountpredicate)\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `arc.alloc_memory` (circt::arc::AllocMemoryOp)\u00a0[\u00b6](#arcalloc_memory-circtarcallocmemoryop)\n\n*Allocate a memory*\n\nSyntax:\n\n```\noperation ::= `arc.alloc_memory` $storage attr-dict `:` functional-type($storage, $memory)\n```\n\nInterfaces: `MemoryEffectOpInterface (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}`\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `storage` |  |\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| `memory` |  |\n\n### `arc.alloc_state` (circt::arc::AllocStateOp)\u00a0[\u00b6](#arcalloc_state-circtarcallocstateop)\n\n*Allocate internal state*\n\nSyntax:\n\n```\noperation ::= `arc.alloc_state` $storage (`tap` $tap^)? attr-dict `:` functional-type($storage, $state)\n```\n\nInterfaces: `MemoryEffectOpInterface (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}`\n\n#### Attributes:\u00a0[\u00b6](#attributes)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `tap` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `storage` |  |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `state` |  |\n\n### `arc.alloc_storage` (circt::arc::AllocStorageOp)\u00a0[\u00b6](#arcalloc_storage-circtarcallocstorageop)\n\n*Allocate contiguous storage space from a larger storage space*\n\nSyntax:\n\n```\noperation ::= `arc.alloc_storage` $input (`[` $offset^ `]`)? attr-dict `:` functional-type($input, $output)\n```\n\nInterfaces: `MemoryEffectOpInterface (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `offset` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `input` |  |\n\n#### Results:\u00a0[\u00b6](#results-2)\n\n| Result | Description |\n| --- | --- |\n| `output` |  |\n\n### `arc.call` (circt::arc::CallOp)\u00a0[\u00b6](#arccall-circtarccallop)\n\n*Calls an arc*\n\nSyntax:\n\n```\noperation ::= `arc.call` $arc `(` $inputs `)` attr-dict `:` functional-type(operands, results)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `MemRefsNormalizable`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`, `ClockedOpInterface`, `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-2)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `arc` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-3)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-3)\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `arc.clock_domain` (circt::arc::ClockDomainOp)\u00a0[\u00b6](#arcclock_domain-circtarcclockdomainop)\n\n*A clock domain*\n\nSyntax:\n\n```\noperation ::= `arc.clock_domain` ` ` `(` $inputs `)` `clock` $clock attr-dict `:`\n              functional-type($inputs, results) $body\n```\n\nTraits: `IsolatedFromAbove`, `RecursiveMemoryEffects`, `SingleBlockImplicitTerminator<arc::OutputOp>`, `SingleBlock`\n\nInterfaces: `RegionKindInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-4)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n| `clock` | A type for clock-carrying wires |\n\n#### Results:\u00a0[\u00b6](#results-4)\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `arc.define` (circt::arc::DefineOp)\u00a0[\u00b6](#arcdefine-circtarcdefineop)\n\n*State transfer arc definition*\n\nTraits: `HasParent<mlir::ModuleOp>`, `IsolatedFromAbove`, `SingleBlockImplicitTerminator<arc::OutputOp>`, `SingleBlock`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallableOpInterface`, `FunctionOpInterface`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-3)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `function_type` | ::mlir::TypeAttr | type attribute of function type |\n| `arg_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `res_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n\n### `arc.execute` (circt::arc::ExecuteOp)\u00a0[\u00b6](#arcexecute-circtarcexecuteop)\n\n*Execute an SSACFG region*\n\nSyntax:\n\n```\noperation ::= `arc.execute` (` ` `(` $inputs^ `:` type($inputs) `)`)?\n              (`->` `(` type($results)^ `)`)?\n              attr-dict-with-keyword $body\n```\n\nThe `arc.execute` op allows an SSACFG region to be embedded in a parent\ngraph region, or another SSACFG region. Whenever execution reaches this op,\nits body region is executed and the results yielded from the body are\nproduced as the `arc.execute` op\u2019s results. The op is isolated from above.\nAny SSA values defined outside the op that are used inside the body have to\nbe captured as operands and then referred to as entry block arguments in the\nbody.\n\nTraits: `IsolatedFromAbove`, `RecursiveMemoryEffects`\n\n#### Operands:\u00a0[\u00b6](#operands-5)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-5)\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `arc.final` (circt::arc::FinalOp)\u00a0[\u00b6](#arcfinal-circtarcfinalop)\n\n*Region to be executed at the end of simulation*\n\nSyntax:\n\n```\noperation ::= `arc.final` attr-dict-with-keyword $body\n```\n\nTraits: `HasParent<ModelOp>`, `NoRegionArguments`, `NoTerminator`, `RecursiveMemoryEffects`, `SingleBlock`\n\n### `arc.initial` (circt::arc::InitialOp)\u00a0[\u00b6](#arcinitial-circtarcinitialop)\n\n*Region to be executed at the start of simulation*\n\nSyntax:\n\n```\noperation ::= `arc.initial` attr-dict-with-keyword $body\n```\n\nTraits: `HasParent<ModelOp>`, `NoRegionArguments`, `NoTerminator`, `RecursiveMemoryEffects`, `SingleBlock`\n\n### `arc.lut` (circt::arc::LutOp)\u00a0[\u00b6](#arclut-circtarclutop)\n\n*A lookup-table.*\n\nSyntax:\n\n```\noperation ::= `arc.lut` `(` $inputs `)` `:` functional-type($inputs, $output)\n              attr-dict-with-keyword $body\n```\n\nRepresents a lookup-table as one operation. The operations that map the\nlookup/input values to the corresponding table-entry are collected inside\nthe body of this operation.\nNote that the operation is marked to be isolated from above to guarantee\nthat all input values have to be passed as an operand. This allows for\nsimpler analyses and canonicalizations of the LUT as well as lowering.\nOnly combinational operations are allowed inside the LUT, i.e., no\nside-effects, state, time delays, etc.\n\nTraits: `AlwaysSpeculatableImplTrait`, `IsolatedFromAbove`, `SingleBlockImplicitTerminator<arc::OutputOp>`, `SingleBlock`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-6)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of signless integer |\n\n#### Results:\u00a0[\u00b6](#results-6)\n\n| Result | Description |\n| --- | --- |\n| `output` | signless integer |\n\n### `arc.memory` (circt::arc::MemoryOp)\u00a0[\u00b6](#arcmemory-circtarcmemoryop)\n\n*Memory*\n\nSyntax:\n\n```\noperation ::= `arc.memory` type($memory) attr-dict\n```\n\nInterfaces: `MemoryEffectOpInterface (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}`\n\n#### Results:\u00a0[\u00b6](#results-7)\n\n| Result | Description |\n| --- | --- |\n| `memory` |  |\n\n### `arc.memory_read` (circt::arc::MemoryReadOp)\u00a0[\u00b6](#arcmemory_read-circtarcmemoryreadop)\n\n*Read a word from a memory*\n\nSyntax:\n\n```\noperation ::= `arc.memory_read` $memory `[` $address `]` attr-dict `:` type($memory)\n```\n\nInterfaces: `InferTypeOpInterface`, `MemoryEffectOpInterface (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}`\n\n#### Operands:\u00a0[\u00b6](#operands-7)\n\n| Operand | Description |\n| --- | --- |\n| `memory` |  |\n| `address` | integer |\n\n#### Results:\u00a0[\u00b6](#results-8)\n\n| Result | Description |\n| --- | --- |\n| `data` | integer |\n\n### `arc.memory_read_port` (circt::arc::MemoryReadPortOp)\u00a0[\u00b6](#arcmemory_read_port-circtarcmemoryreadportop)\n\n*Read port from a memory*\n\nSyntax:\n\n```\noperation ::= `arc.memory_read_port` $memory `[` $address `]` attr-dict `:` type($memory)\n```\n\nRepresents a combinatorial memory read port. No memory read side-effect\ntrait is necessary because at the stage of the Arc lowering where this\noperation is legal to be present, it is guaranteed that all reads from the\nsame address produce the same output. This is because all writes are\nreordered to happen at the end of the cycle in LegalizeStateUpdates (or\nalternatively produce the necessary temporaries).\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-8)\n\n| Operand | Description |\n| --- | --- |\n| `memory` |  |\n| `address` | integer |\n\n#### Results:\u00a0[\u00b6](#results-9)\n\n| Result | Description |\n| --- | --- |\n| `data` | integer |\n\n### `arc.memory_write` (circt::arc::MemoryWriteOp)\u00a0[\u00b6](#arcmemory_write-circtarcmemorywriteop)\n\n*Write a word to a memory*\n\nSyntax:\n\n```\noperation ::= `arc.memory_write` $memory `[` $address `]` `,` $data (`if` $enable^)?\n              attr-dict `:` type($memory)\n```\n\nInterfaces: `MemoryEffectOpInterface (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}`\n\n#### Operands:\u00a0[\u00b6](#operands-9)\n\n| Operand | Description |\n| --- | --- |\n| `memory` |  |\n| `address` | integer |\n| `enable` | 1-bit signless integer |\n| `data` | integer |\n\n### `arc.memory_write_port` (circt::arc::MemoryWritePortOp)\u00a0[\u00b6](#arcmemory_write_port-circtarcmemorywriteportop)\n\n*Write port to a memory*\n\nSyntax:\n\n```\noperation ::= `arc.memory_write_port` $memory `,` $arc  `(` $inputs `)` (`clock` $clock^)?  (`enable` $enable^)?\n              (`mask` $mask^)? `latency` $latency attr-dict `:`\n              type($memory) `,` type($inputs)\n```\n\nTraits: `AttrSizedOperandSegments`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`, `ClockedOpInterface`, `MemoryEffectOpInterface (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-4)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `arc` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `enable` | ::mlir::UnitAttr | unit attribute |\n| `mask` | ::mlir::UnitAttr | unit attribute |\n| `latency` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-10)\n\n| Operand | Description |\n| --- | --- |\n| `memory` |  |\n| `inputs` | variadic of any type |\n| `clock` | A type for clock-carrying wires |\n\n### `arc.model` (circt::arc::ModelOp)\u00a0[\u00b6](#arcmodel-circtarcmodelop)\n\n*A model with stratified clocks*\n\nSyntax:\n\n```\noperation ::= `arc.model` $sym_name `io` $io\n              (`initializer` $initialFn^)?\n              (`finalizer` $finalFn^)?\n              (`traceTaps` $traceTaps^)?\n              attr-dict-with-keyword $body\n```\n\nA model with stratified clocks. The `io` optional attribute\nspecifies the I/O of the module associated to this model.\n\nTraits: `IsolatedFromAbove`, `NoTerminator`\n\nInterfaces: `SymbolUserOpInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-5)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `io` | ::mlir::TypeAttr | type attribute of a module |\n| `initialFn` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `finalFn` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `traceTaps` | ::mlir::ArrayAttr | Array of trace metadata |\n\n### `arc.output` (circt::arc::OutputOp)\u00a0[\u00b6](#arcoutput-circtarcoutputop)\n\n*Arc terminator*\n\nSyntax:\n\n```\noperation ::= `arc.output` attr-dict ($outputs^ `:` qualified(type($outputs)))?\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<DefineOp, LutOp, ClockDomainOp, ExecuteOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-11)\n\n| Operand | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `arc.root_input` (circt::arc::RootInputOp)\u00a0[\u00b6](#arcroot_input-circtarcrootinputop)\n\n*A root input*\n\nSyntax:\n\n```\noperation ::= `arc.root_input` $name `,` $storage attr-dict `:` functional-type($storage, $state)\n```\n\nInterfaces: `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-6)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-12)\n\n| Operand | Description |\n| --- | --- |\n| `storage` |  |\n\n#### Results:\u00a0[\u00b6](#results-10)\n\n| Result | Description |\n| --- | --- |\n| `state` |  |\n\n### `arc.root_output` (circt::arc::RootOutputOp)\u00a0[\u00b6](#arcroot_output-circtarcrootoutputop)\n\n*A root output*\n\nSyntax:\n\n```\noperation ::= `arc.root_output` $name `,` $storage attr-dict `:` functional-type($storage, $state)\n```\n\nInterfaces: `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-7)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-13)\n\n| Operand | Description |\n| --- | --- |\n| `storage` |  |\n\n#### Results:\u00a0[\u00b6](#results-11)\n\n| Result | Description |\n| --- | --- |\n| `state` |  |\n\n### `arc.runtime.model` (circt::arc::RuntimeModelOp)\u00a0[\u00b6](#arcruntimemodel-circtarcruntimemodelop)\n\n*Provides static metadata of an Arc model used by the runtime*\n\nSyntax:\n\n```\noperation ::= `arc.runtime.model` $sym_name $name `numStateBytes` $numStateBytes\n              (`traceTaps` $traceTaps^)? attr-dict\n```\n\nCollection of static metadata for a specific Arc model accessed by the\narcilator runtime library:\n\n* name: Name of the model\n* numStateBytes: Number of bytes required to store the model\u2019s internal\n  state\n* traceTaps: Traced signal metadata\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<::mlir::ModuleOp>`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `Symbol`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-8)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n| `numStateBytes` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n| `traceTaps` | ::mlir::ArrayAttr | Array of trace metadata |\n\n### `arc.sim.emit` (circt::arc::SimEmitValueOp)\u00a0[\u00b6](#arcsimemit-circtarcsimemitvalueop)\n\n*Sends a value to the simulation driver*\n\nSyntax:\n\n```\noperation ::= `arc.sim.emit` $valueName `,` $value attr-dict `:` type($value)\n```\n\nSends a named value to the simulation driver. This is notably useful\nfor printing values during simulation.\n\n#### Attributes:\u00a0[\u00b6](#attributes-9)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `valueName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-14)\n\n| Operand | Description |\n| --- | --- |\n| `value` | any type |\n\n### `arc.sim.get_port` (circt::arc::SimGetPortOp)\u00a0[\u00b6](#arcsimget_port-circtarcsimgetportop)\n\n*Gets the value of a port of the model instance*\n\nSyntax:\n\n```\noperation ::= `arc.sim.get_port` $instance `,` $port attr-dict\n              `:` type($value) `,` qualified(type($instance))\n```\n\nGets the value of the given port in a specific instance of a model. The\nprovided port must be of the type of the expected value.\n\nInterfaces: `MemoryEffectOpInterface (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-10)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `port` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-15)\n\n| Operand | Description |\n| --- | --- |\n| `instance` |  |\n\n#### Results:\u00a0[\u00b6](#results-12)\n\n| Result | Description |\n| --- | --- |\n| `value` | any type |\n\n### `arc.sim.instantiate` (circt::arc::SimInstantiateOp)\u00a0[\u00b6](#arcsiminstantiate-circtarcsiminstantiateop)\n\n*Instantiates an Arc model for simulation*\n\nCreates an instance of an Arc model in scope, in order to simulate it.\nThe model can be used from within the associated region, modelling its\nlifetime.\n\nTraits: `NoTerminator`\n\nInterfaces: `MemoryEffectOpInterface (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-11)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `runtimeModel` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `runtimeArgs` | ::mlir::StringAttr | string attribute |\n\n### `arc.sim.set_input` (circt::arc::SimSetInputOp)\u00a0[\u00b6](#arcsimset_input-circtarcsimsetinputop)\n\n*Sets the value of an input of the model instance*\n\nSyntax:\n\n```\noperation ::= `arc.sim.set_input` $instance `,` $input `=` $value attr-dict\n              `:` type($value) `,` qualified(type($instance))\n```\n\nSets the value of an input port in a specific instance of a model. The\nprovided input port must be of input type on the model and its type must\nmatch the type of the value operand.\n\nInterfaces: `MemoryEffectOpInterface (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-12)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `input` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-16)\n\n| Operand | Description |\n| --- | --- |\n| `instance` |  |\n| `value` | any type |\n\n### `arc.sim.step` (circt::arc::SimStepOp)\u00a0[\u00b6](#arcsimstep-circtarcsimstepop)\n\n*Evaluates one step of the simulation for the provided model instance*\n\nSyntax:\n\n```\noperation ::= `arc.sim.step` $instance attr-dict `:` qualified(type($instance))\n```\n\nEvaluates one step of the simulation for the provided model instance,\nupdating ports accordingly.\n\nInterfaces: `MemoryEffectOpInterface (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource, MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}`\n\n#### Operands:\u00a0[\u00b6](#operands-17)\n\n| Operand | Description |\n| --- | --- |\n| `instance` |  |\n\n### `arc.state` (circt::arc::StateOp)\u00a0[\u00b6](#arcstate-circtarcstateop)\n\n*Instantiates a state element with input from a transfer arc*\n\nSyntax:\n\n```\noperation ::= `arc.state` $arc `(` $inputs `)` (`clock` $clock^)? (`enable` $enable^)?\n              (`reset` $reset^)?\n              ( `initial` ` ` `(` $initials^ `:` type($initials) `)`)?\n              `latency` $latency attr-dict `:` functional-type($inputs, results)\n```\n\nTraits: `AttrSizedOperandSegments`, `MemRefsNormalizable`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`, `ClockedOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-13)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `arc` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `latency` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-18)\n\n| Operand | Description |\n| --- | --- |\n| `clock` | A type for clock-carrying wires |\n| `enable` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `inputs` | variadic of any type |\n| `initials` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-13)\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `arc.state_read` (circt::arc::StateReadOp)\u00a0[\u00b6](#arcstate_read-circtarcstatereadop)\n\n*Read a state\u2019s value*\n\nSyntax:\n\n```\noperation ::= `arc.state_read` $state attr-dict `:` type($state)\n```\n\nInterfaces: `InferTypeOpInterface`, `MemoryEffectOpInterface (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}`\n\n#### Operands:\u00a0[\u00b6](#operands-19)\n\n| Operand | Description |\n| --- | --- |\n| `state` |  |\n\n#### Results:\u00a0[\u00b6](#results-14)\n\n| Result | Description |\n| --- | --- |\n| `value` | any type |\n\n### `arc.state_write` (circt::arc::StateWriteOp)\u00a0[\u00b6](#arcstate_write-circtarcstatewriteop)\n\n*Update a state\u2019s value*\n\nSyntax:\n\n```\noperation ::= `arc.state_write` $state `=` $value (`if` $condition^)?\n              (`tap` $traceTapModel`[`$traceTapIndex^`]` )? attr-dict `:` type($state)\n```\n\nInterfaces: `MemoryEffectOpInterface (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-14)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `traceTapModel` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `traceTapIndex` | ::mlir::IntegerAttr | 64-bit unsigned integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-20)\n\n| Operand | Description |\n| --- | --- |\n| `state` |  |\n| `value` | any type |\n| `condition` | 1-bit signless integer |\n\n### `arc.storage.get` (circt::arc::StorageGetOp)\u00a0[\u00b6](#arcstorageget-circtarcstoragegetop)\n\n*Access an allocated state, memory, or storage slice*\n\nSyntax:\n\n```\noperation ::= `arc.storage.get` $storage `[` $offset `]` attr-dict\n              `:` qualified(type($storage)) `->` type($result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-15)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `offset` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-21)\n\n| Operand | Description |\n| --- | --- |\n| `storage` |  |\n\n#### Results:\u00a0[\u00b6](#results-15)\n\n| Result | Description |\n| --- | --- |\n| `result` | or or |\n\n### `arc.tap` (circt::arc::TapOp)\u00a0[\u00b6](#arctap-circtarctapop)\n\n*A tracker op to observe a value under one or more given names*\n\nSyntax:\n\n```\noperation ::= `arc.tap` $value attr-dict `:` type($value)\n```\n\n#### Attributes:\u00a0[\u00b6](#attributes-16)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `names` | ::mlir::ArrayAttr | string array attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-22)\n\n| Operand | Description |\n| --- | --- |\n| `value` | any type |\n\n### `arc.vectorize` (circt::arc::VectorizeOp)\u00a0[\u00b6](#arcvectorize-circtarcvectorizeop)\n\n*Isolated subgraph of operations to be vectorized*\n\nSyntax:\n\n```\noperation ::= `arc.vectorize` $inputs attr-dict `:` functional-type($inputs, $results) $body\n```\n\nThis operation represents a vectorized computation DAG. It places a\nconvenient boundary between the subgraph to be vectorized and the\nsurrounding non-vectorizable parts of the original graph.\n\nThis allows us to split the vectorization transformations into multiple\nparts/passes:\n\n* Finding an initial set of operations to be vectorized\n* Optimizing this set by pulling in more operations into the nested block,\n  splitting it such that the vector width does not exceed a given limit,\n  applying a cost model and potentially reverting the decision to\n  vectorize this subgraph (e.g., because not enough ops could be pulled\n  in)\n* Performing the actual vectorization by lowering this operation. This\n  operation allows to perform the lowering of the boundary and the body\n  separately and either via 1D `vector` types for SIMD vectorization or\n  plain integers for manual vectorization within a scalar register.\n\nFor each block argument of the nested block, there is a list of operands\nthat represent the elements of the vector. If the boundary is already\nvectorized each list will only contain a single SSA value of either vector\ntype or an integer representing the concatenation of all original operands\nof that vector.\n\nExample:\n\nGiven the following two AND operations in the IR\n\n```\n%0 = arith.and %in0, %in1 : i1\n%1 = arith.and %in2, %in2 : i1\n```\n\nthey could be vectorized by putting one such AND operation in the body block\nof the `arc.vectorize` operation and forwarding the operands accordingly.\n\n```\n%0:2 = arc.vectorize (%in0, %in1), (%in2, %in2) :\n  (i1, i1, i1, i1) -> (i1, i1) {\n^bb0(%arg0: i1, %arg1: i1):\n  %1 = arith.and %arg0, %arg1 : i1\n  arc.output %1 : i1\n}\n```\n\nIn a next step, the boundary could be lowered/vectorized. This can happen\nin terms of integers for vectorization within scalar registers:\n\n```\n%0 = comb.concat %in0, %in1 : i1, i1\n%1 = comb.replicate %in2 : (i1) -> i2\n%2 = arc.vectorize (%0), (%1) : (i2, i2) -> (i2) {\n^bb0(%arg0: i1, %arg1: i1):\n  %1 = arith.and %arg0, %arg1 : i1\n  arc.output %1 : i1\n}\n%3 = comb.extract %2 from 1 : (i2) -> i1\n%4 = comb.extract %2 from 0 : (i2) -> i1\n```\n\nOr via `vector` types for SIMD vectorization:\n\n```\n%cst = arith.constant dense<0> : vector<2xi1>\n%0 = vector.insert %in0, %cst[0] : i1 into vector<2xi1>\n%1 = vector.insert %in1, %0[1] : i1 into vector<2xi1>\n%2 = vector.broadcast %in2 : i1 to vector<2xi1>\n%3 = arc.vectorize (%1), (%2) :\n  (vector<2xi1>, vector<2xi1>) -> (vector<2xi1>) {\n^bb0(%arg0: i1, %arg1: i1):\n  %1 = arith.and %arg0, %arg1 : i1\n  arc.output %1 : i1\n}\n%4 = vector.extract %2[0] : vector<2xi1>\n%5 = vector.extract %2[1] : vector<2xi1>\n```\n\nAlternatively, the body could be vectorized first. Again, as integers\n\n```\n%0:2 = arc.vectorize (%in0, %in1), (%in2, %in2) :\n  (i1, i1, i1, i1) -> (i1, i1) {\n^bb0(%arg0: i2, %arg1: i2):\n  %1 = arith.and %arg0, %arg1 : i2\n  arc.output %1 : i2\n}\n```\n\nor SIMD vectors.\n\n```\n%0:2 = arc.vectorize (%in0, %in1), (%in2, %in3) :\n  (i1, i1, i1, i1) -> (i1, i1) {\n^bb0(%arg0: vector<2xi1>, %arg1: vector<2xi1>):\n  %1 = arith.and %arg0, %arg1 : vector<2xi1>\n  arc.output %1 : vector<2xi1>\n}\n```\n\nOnce both sides are lowered, the `arc.vectorize` op simply becomes a\npassthrough for the operands and can be removed by inlining the nested\nblock. The integer based vectorization would then look like the following:\n\n```\n%0 = comb.concat %in0, %in1 : i1, i1\n%1 = comb.replicate %in2 : (i1) -> i2\n%2 = arith.and %0, %1 : i2\n%3 = comb.extract %2 from 1 : (i2) -> i1\n%4 = comb.extract %2 from 0 : (i2) -> i1\n```\n\nThe SIMD vector based lowering would result in the following IR:\n\n```\n%cst = arith.constant dense<0> : vector<2xi1>\n%0 = vector.insert %in0, %cst[0] : i1 into vector<2xi1>\n%1 = vector.insert %in1, %0[1] : i1 into vector<2xi1>\n%2 = vector.broadcast %in2 : i1 to vector<2xi1>\n%3 = arith.and %1, %2 : vector<2xi1>\n%4 = vector.extract %3[0] : vector<2xi1>\n%5 = vector.extract %3[1] : vector<2xi1>\n```\n\nTraits: `IsolatedFromAbove`, `RecursiveMemoryEffects`\n\n#### Attributes:\u00a0[\u00b6](#attributes-17)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inputOperandSegments` | ::mlir::DenseI32ArrayAttr | i32 dense array attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-23)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-16)\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `arc.vectorize.return` (circt::arc::VectorizeReturnOp)\u00a0[\u00b6](#arcvectorizereturn-circtarcvectorizereturnop)\n\n*Arc.vectorized terminator*\n\nSyntax:\n\n```\noperation ::= `arc.vectorize.return` operands attr-dict `:` qualified(type(operands))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<VectorizeOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-24)\n\n| Operand | Description |\n| --- | --- |\n| `value` | any type |\n\n### `arc.zero_count` (circt::arc::ZeroCountOp)\u00a0[\u00b6](#arczero_count-circtarczerocountop)\n\n*Leading/trailing zero count operation*\n\nSyntax:\n\n```\noperation ::= `arc.zero_count` $predicate $input attr-dict `:` type($input)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-18)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `predicate` | circt::arc::ZeroCountPredicateAttr | arc.zero\\_count predicate |\n\n#### Operands:\u00a0[\u00b6](#operands-25)\n\n| Operand | Description |\n| --- | --- |\n| `input` | signless integer |\n\n#### Results:\u00a0[\u00b6](#results-17)\n\n| Result | Description |\n| --- | --- |\n| `output` | signless integer |\n\nAttributes\u00a0[\u00b6](#attributes-19)\n------------------------------\n\n### TraceTapAttr\u00a0[\u00b6](#tracetapattr)\n\n*Metadata of a signal with trace instrumentation*\n\nSyntax:\n\n```\n#arc.trace_tap<\n  mlir::TypeAttr,   # sigType\n  uint64_t,   # stateOffset\n  mlir::ArrayAttr   # names\n>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| sigType | `mlir::TypeAttr` |  |\n| stateOffset | `uint64_t` |  |\n| names | `mlir::ArrayAttr` |  |\n\nTypes\u00a0[\u00b6](#types)\n-----------------\n\n### MemoryType\u00a0[\u00b6](#memorytype)\n\nSyntax:\n\n```\n!arc.memory<\n  unsigned,   # numWords\n  ::mlir::IntegerType,   # wordType\n  ::mlir::IntegerType   # addressType\n>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-1)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| numWords | `unsigned` |  |\n| wordType | `::mlir::IntegerType` |  |\n| addressType | `::mlir::IntegerType` |  |\n\n### SimModelInstanceType\u00a0[\u00b6](#simmodelinstancetype)\n\nSyntax:\n\n```\n!arc.sim.instance<\n  mlir::FlatSymbolRefAttr   # model\n>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-2)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| model | `mlir::FlatSymbolRefAttr` |  |\n\n### StateType\u00a0[\u00b6](#statetype)\n\nSyntax:\n\n```\n!arc.state<\n  ::mlir::Type   # type\n>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-3)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| type | `::mlir::Type` |  |\n\n### StorageType\u00a0[\u00b6](#storagetype)\n\nSyntax:\n\n```\n!arc.storage<\n  unsigned   # size\n>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-4)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| size | `unsigned` |  |\n\nEnums\u00a0[\u00b6](#enums)\n-----------------\n\n### ZeroCountPredicate\u00a0[\u00b6](#zerocountpredicate)\n\n*Arc.zero\\_count predicate*\n\n#### Cases:\u00a0[\u00b6](#cases)\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| leading | `0` | leading |\n| trailing | `1` | trailing |\n\n [Prev -](https://circt.llvm.org/docs/Dialects/ESIAppID/)\n[Next - 'calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/ \"'calyx' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Calyx/index.md"
  },
  {
    "role": "user",
    "content": "'calyx' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'calyx' Dialect\n===============\n\n*Types and operations for the Calyx dialect*\n\nCalyx is an intermediate language and infrastructure for building\ncompilers that generate custom hardware accelerators. For more\ninformation, visit the\n[documentation](https://capra.cs.cornell.edu/calyx/).\n\n* [Operations](#operations)\n  + [`calyx.assign` (::circt::calyx::AssignOp)](#calyxassign-circtcalyxassignop)\n  + [`calyx.comb_component` (::circt::calyx::CombComponentOp)](#calyxcomb_component-circtcalyxcombcomponentop)\n  + [`calyx.comb_group` (::circt::calyx::CombGroupOp)](#calyxcomb_group-circtcalyxcombgroupop)\n  + [`calyx.component` (::circt::calyx::ComponentOp)](#calyxcomponent-circtcalyxcomponentop)\n  + [`calyx.constant` (::circt::calyx::ConstantOp)](#calyxconstant-circtcalyxconstantop)\n  + [`calyx.control` (::circt::calyx::ControlOp)](#calyxcontrol-circtcalyxcontrolop)\n  + [`calyx.cycle` (::circt::calyx::CycleOp)](#calyxcycle-circtcalyxcycleop)\n  + [`calyx.enable` (::circt::calyx::EnableOp)](#calyxenable-circtcalyxenableop)\n  + [`calyx.group` (::circt::calyx::GroupOp)](#calyxgroup-circtcalyxgroupop)\n  + [`calyx.group_done` (::circt::calyx::GroupDoneOp)](#calyxgroup_done-circtcalyxgroupdoneop)\n  + [`calyx.group_go` (::circt::calyx::GroupGoOp)](#calyxgroup_go-circtcalyxgroupgoop)\n  + [`calyx.ieee754.add` (::circt::calyx::AddFOpIEEE754)](#calyxieee754add-circtcalyxaddfopieee754)\n  + [`calyx.ieee754.compare` (::circt::calyx::CompareFOpIEEE754)](#calyxieee754compare-circtcalyxcomparefopieee754)\n  + [`calyx.ieee754.divSqrt` (::circt::calyx::DivSqrtOpIEEE754)](#calyxieee754divsqrt-circtcalyxdivsqrtopieee754)\n  + [`calyx.ieee754.fpToInt` (::circt::calyx::FpToIntOpIEEE754)](#calyxieee754fptoint-circtcalyxfptointopieee754)\n  + [`calyx.ieee754.intToFp` (::circt::calyx::IntToFpOpIEEE754)](#calyxieee754inttofp-circtcalyxinttofpopieee754)\n  + [`calyx.ieee754.mul` (::circt::calyx::MulFOpIEEE754)](#calyxieee754mul-circtcalyxmulfopieee754)\n  + [`calyx.if` (::circt::calyx::IfOp)](#calyxif-circtcalyxifop)\n  + [`calyx.instance` (::circt::calyx::InstanceOp)](#calyxinstance-circtcalyxinstanceop)\n  + [`calyx.invoke` (::circt::calyx::InvokeOp)](#calyxinvoke-circtcalyxinvokeop)\n  + [`calyx.memory` (::circt::calyx::MemoryOp)](#calyxmemory-circtcalyxmemoryop)\n  + [`calyx.par` (::circt::calyx::ParOp)](#calyxpar-circtcalyxparop)\n  + [`calyx.primitive` (::circt::calyx::PrimitiveOp)](#calyxprimitive-circtcalyxprimitiveop)\n  + [`calyx.register` (::circt::calyx::RegisterOp)](#calyxregister-circtcalyxregisterop)\n  + [`calyx.repeat` (::circt::calyx::RepeatOp)](#calyxrepeat-circtcalyxrepeatop)\n  + [`calyx.seq` (::circt::calyx::SeqOp)](#calyxseq-circtcalyxseqop)\n  + [`calyx.seq_mem` (::circt::calyx::SeqMemoryOp)](#calyxseq_mem-circtcalyxseqmemoryop)\n  + [`calyx.static_group` (::circt::calyx::StaticGroupOp)](#calyxstatic_group-circtcalyxstaticgroupop)\n  + [`calyx.static_if` (::circt::calyx::StaticIfOp)](#calyxstatic_if-circtcalyxstaticifop)\n  + [`calyx.static_par` (::circt::calyx::StaticParOp)](#calyxstatic_par-circtcalyxstaticparop)\n  + [`calyx.static_repeat` (::circt::calyx::StaticRepeatOp)](#calyxstatic_repeat-circtcalyxstaticrepeatop)\n  + [`calyx.static_seq` (::circt::calyx::StaticSeqOp)](#calyxstatic_seq-circtcalyxstaticseqop)\n  + [`calyx.std_add` (::circt::calyx::AddLibOp)](#calyxstd_add-circtcalyxaddlibop)\n  + [`calyx.std_and` (::circt::calyx::AndLibOp)](#calyxstd_and-circtcalyxandlibop)\n  + [`calyx.std_divs_pipe` (::circt::calyx::DivSPipeLibOp)](#calyxstd_divs_pipe-circtcalyxdivspipelibop)\n  + [`calyx.std_divu_pipe` (::circt::calyx::DivUPipeLibOp)](#calyxstd_divu_pipe-circtcalyxdivupipelibop)\n  + [`calyx.std_eq` (::circt::calyx::EqLibOp)](#calyxstd_eq-circtcalyxeqlibop)\n  + [`calyx.std_ge` (::circt::calyx::GeLibOp)](#calyxstd_ge-circtcalyxgelibop)\n  + [`calyx.std_gt` (::circt::calyx::GtLibOp)](#calyxstd_gt-circtcalyxgtlibop)\n  + [`calyx.std_le` (::circt::calyx::LeLibOp)](#calyxstd_le-circtcalyxlelibop)\n  + [`calyx.std_lsh` (::circt::calyx::LshLibOp)](#calyxstd_lsh-circtcalyxlshlibop)\n  + [`calyx.std_lt` (::circt::calyx::LtLibOp)](#calyxstd_lt-circtcalyxltlibop)\n  + [`calyx.std_mult_pipe` (::circt::calyx::MultPipeLibOp)](#calyxstd_mult_pipe-circtcalyxmultpipelibop)\n  + [`calyx.std_mux` (::circt::calyx::MuxLibOp)](#calyxstd_mux-circtcalyxmuxlibop)\n  + [`calyx.std_neq` (::circt::calyx::NeqLibOp)](#calyxstd_neq-circtcalyxneqlibop)\n  + [`calyx.std_not` (::circt::calyx::NotLibOp)](#calyxstd_not-circtcalyxnotlibop)\n  + [`calyx.std_or` (::circt::calyx::OrLibOp)](#calyxstd_or-circtcalyxorlibop)\n  + [`calyx.std_pad` (::circt::calyx::PadLibOp)](#calyxstd_pad-circtcalyxpadlibop)\n  + [`calyx.std_rems_pipe` (::circt::calyx::RemSPipeLibOp)](#calyxstd_rems_pipe-circtcalyxremspipelibop)\n  + [`calyx.std_remu_pipe` (::circt::calyx::RemUPipeLibOp)](#calyxstd_remu_pipe-circtcalyxremupipelibop)\n  + [`calyx.std_rsh` (::circt::calyx::RshLibOp)](#calyxstd_rsh-circtcalyxrshlibop)\n  + [`calyx.std_seq` (::circt::calyx::SeqLibOp)](#calyxstd_seq-circtcalyxseqlibop)\n  + [`calyx.std_sge` (::circt::calyx::SgeLibOp)](#calyxstd_sge-circtcalyxsgelibop)\n  + [`calyx.std_sgt` (::circt::calyx::SgtLibOp)](#calyxstd_sgt-circtcalyxsgtlibop)\n  + [`calyx.std_shru` (::circt::calyx::ShruLibOp)](#calyxstd_shru-circtcalyxshrulibop)\n  + [`calyx.std_signext` (::circt::calyx::ExtSILibOp)](#calyxstd_signext-circtcalyxextsilibop)\n  + [`calyx.std_sle` (::circt::calyx::SleLibOp)](#calyxstd_sle-circtcalyxslelibop)\n  + [`calyx.std_slice` (::circt::calyx::SliceLibOp)](#calyxstd_slice-circtcalyxslicelibop)\n  + [`calyx.std_slt` (::circt::calyx::SltLibOp)](#calyxstd_slt-circtcalyxsltlibop)\n  + [`calyx.std_sneq` (::circt::calyx::SneqLibOp)](#calyxstd_sneq-circtcalyxsneqlibop)\n  + [`calyx.std_srsh` (::circt::calyx::SrshLibOp)](#calyxstd_srsh-circtcalyxsrshlibop)\n  + [`calyx.std_sub` (::circt::calyx::SubLibOp)](#calyxstd_sub-circtcalyxsublibop)\n  + [`calyx.std_wire` (::circt::calyx::WireLibOp)](#calyxstd_wire-circtcalyxwirelibop)\n  + [`calyx.std_xor` (::circt::calyx::XorLibOp)](#calyxstd_xor-circtcalyxxorlibop)\n  + [`calyx.undef` (::circt::calyx::UndefinedOp)](#calyxundef-circtcalyxundefinedop)\n  + [`calyx.undefined` (::circt::calyx::UndefLibOp)](#calyxundefined-circtcalyxundeflibop)\n  + [`calyx.while` (::circt::calyx::WhileOp)](#calyxwhile-circtcalyxwhileop)\n  + [`calyx.wires` (::circt::calyx::WiresOp)](#calyxwires-circtcalyxwiresop)\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `calyx.assign` (::circt::calyx::AssignOp)\u00a0[\u00b6](#calyxassign-circtcalyxassignop)\n\n*Calyx Assignment*\n\nThe \u201ccalyx.assign\u201d operation represents a non-blocking\nassignment. An assignment may optionally be guarded,\nwhich controls when the assignment should be active.\nThis operation should only be instantiated in the\n\u201ccalyx.wires\u201d section or a \u201ccalyx.group\u201d.\n\n```\n  calyx.assign %dest = %src : i16\n  calyx.assign %dest = %guard ? %src : i16\n```\n\nTraits: `HasParent<GroupOp, CombGroupOp, StaticGroupOp, WiresOp>`\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `dest` | any type |\n| `src` | any type |\n| `guard` | 1-bit signless integer |\n\n### `calyx.comb_component` (::circt::calyx::CombComponentOp)\u00a0[\u00b6](#calyxcomb_component-circtcalyxcombcomponentop)\n\n*Calyx Combinational Component*\n\nThe \u201ccalyx.comb\\_component\u201d operation represents a Calyx combinational component containing:\n(1) In- and output port definitions that define the interface.\n(2) Combinational cells and wires.\n\n```\n  calyx.comb_component @C(%in: i32) -> (%out: i16) {\n    ...\n    calyx.wires { ... }\n  }\n```\n\nTraits: `HasParent<mlir::ModuleOp>`, `IsolatedFromAbove`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallableOpInterface`, `ComponentInterface`, `FunctionOpInterface`, `OpAsmOpInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `function_type` | ::mlir::TypeAttr | type attribute of function type |\n| `arg_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `res_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `portNames` | ::mlir::ArrayAttr | array attribute |\n| `portAttributes` | ::mlir::ArrayAttr | array attribute |\n| `portDirections` | ::mlir::IntegerAttr | arbitrary integer attribute |\n\n### `calyx.comb_group` (::circt::calyx::CombGroupOp)\u00a0[\u00b6](#calyxcomb_group-circtcalyxcombgroupop)\n\n*Calyx Combinational Group*\n\nSyntax:\n\n```\noperation ::= `calyx.comb_group` $sym_name $body attr-dict\n```\n\nRepresents a Calyx combinational group, which is a collection\nof combinational assignments that are only active when the group\nis run from the control execution schedule.\nA combinational group does not have group\\_go or group\\_done operators.\n\n```\n  calyx.comb_group @MyCombGroup {\n    calyx.assign %1 = %2 : i32\n  }\n```\n\nTraits: `HasParent<WiresOp>`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `GroupInterface`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `calyx.component` (::circt::calyx::ComponentOp)\u00a0[\u00b6](#calyxcomponent-circtcalyxcomponentop)\n\n*Calyx Component*\n\nThe \u201ccalyx.component\u201d operation represents an overall Calyx component containing:\n(1) In- and output port definitions that define the interface.\n(2) The cells, wires, and control schedule.\n\nA Calyx component requires attributes `clk`, `go`, and `reset` on separate input ports,\nand `done` on an output port.\n\n```\n  calyx.component @C(%in: i32, %go: i1 {go}, %clk: i1 {clk}, %reset: i1 {reset}) -> (%out: i16, %done: i1 {done}) {\n    ...\n    calyx.wires { ... }\n    calyx.control { ... }\n  }\n```\n\nTraits: `HasParent<mlir::ModuleOp>`, `IsolatedFromAbove`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallableOpInterface`, `ComponentInterface`, `FunctionOpInterface`, `OpAsmOpInterface`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-2)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `function_type` | ::mlir::TypeAttr | type attribute of function type |\n| `arg_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `res_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `portNames` | ::mlir::ArrayAttr | array attribute |\n| `portAttributes` | ::mlir::ArrayAttr | array attribute |\n| `portDirections` | ::mlir::IntegerAttr | arbitrary integer attribute |\n\n### `calyx.constant` (::circt::calyx::ConstantOp)\u00a0[\u00b6](#calyxconstant-circtcalyxconstantop)\n\n*Constant capable of representing an integer or floating point value*\n\nSyntax:\n\n```\noperation ::= `calyx.constant` $sym_name ` ` `<` $value `>` attr-dict `:` qualified(type($out))\n```\n\nThe `constant` operation is a wrapper around bit vectors with fixed-size number of bits.\nSpecific value and intended type should be specified via attribute only.\n\nExample:\n\n```\n// Integer constant\n%1 = calyx.constant <42 : i32> : i32\n\n// Floating point constant\n%1 = calyx.constant <4.2 : f32> : i32\n```\n\nTraits: `ConstantLike`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-3)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `value` | ::mlir::TypedAttr | TypedAttr instance |\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| `out` | signless integer |\n\n### `calyx.control` (::circt::calyx::ControlOp)\u00a0[\u00b6](#calyxcontrol-circtcalyxcontrolop)\n\n*Calyx Control*\n\nSyntax:\n\n```\noperation ::= `calyx.control` $body attr-dict\n```\n\nThe \u201ccalyx.control\u201d operation represents the\nexecution schedule defined for the given\ncomponent, i.e. when each group executes.\n\n```\n  calyx.control {\n    calyx.seq {\n      calyx.enable @GroupA\n    }\n  }\n```\n\nTraits: `HasParent<ComponentOp>`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\n### `calyx.cycle` (::circt::calyx::CycleOp)\u00a0[\u00b6](#calyxcycle-circtcalyxcycleop)\n\n*Calyx Static Cycle Op*\n\nReturns an I1 signal that is active `start` cycles after the static\ngroup starts, and inactive all other times. Optional `end`\nattribute allows the signal to be active from until `end` cycles\nafter the static group starts. Must be used within a static group.\n\n```\n  calyx.static_group latency<2> @MyStaticGroup {\n    %1 = calyx.cycle 1 : i1\n  }\n```\n\nTraits: `HasParent<StaticGroupOp>`\n\n#### Attributes:\u00a0[\u00b6](#attributes-4)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `start` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `end` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `active` | 1-bit signless integer |\n\n### `calyx.enable` (::circt::calyx::EnableOp)\u00a0[\u00b6](#calyxenable-circtcalyxenableop)\n\n*Calyx Enable*\n\nSyntax:\n\n```\noperation ::= `calyx.enable` $groupName attr-dict\n```\n\nThe \u201ccalyx.enable\u201d operation represents the execution of\na group defined explicitly in the \u201ccalyx.wires\u201d section.\n\nThe \u2018compiledGroups\u2019 attribute is used in the Compile\nControl pass to track which groups are compiled within\nthe new compilation group.\n\n```\n  calyx.enable @SomeGroup\n```\n\nTraits: `ControlLike`\n\n#### Attributes:\u00a0[\u00b6](#attributes-5)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `groupName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `compiledGroups` | ::mlir::ArrayAttr | array attribute |\n\n### `calyx.group` (::circt::calyx::GroupOp)\u00a0[\u00b6](#calyxgroup-circtcalyxgroupop)\n\n*Calyx Group*\n\nSyntax:\n\n```\noperation ::= `calyx.group` $sym_name $body attr-dict\n```\n\nRepresents a Calyx group, which is a collection\nof assignments that are only active when the group\nis run from the control execution schedule. A group\nsignifies its termination with a special port named\na \u201cdone\u201d port.\n\n```\n  calyx.group @MyGroup {\n    calyx.assign %1 = %2 : i32\n    calyx.group_done %3 : i1\n  }\n```\n\nTraits: `HasParent<WiresOp>`, `NoRegionArguments`, `SingleBlock`\n\nInterfaces: `GroupInterface`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-6)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `calyx.group_done` (::circt::calyx::GroupDoneOp)\u00a0[\u00b6](#calyxgroup_done-circtcalyxgroupdoneop)\n\n*Calyx Group Done Port*\n\nThe \u201ccalyx.group\\_done\u201d operation represents a port on a\nCalyx group that signifies when the group is finished.\nA done operation may optionally be guarded, which controls\nwhen the group\u2019s done operation should be active.\n\n```\n  calyx.group_done %src : i1\n  calyx.group_done %guard ? %src : i1\n```\n\nTraits: `HasParent<GroupOp>`, `Terminator`\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `src` | 1-bit signless integer |\n| `guard` | 1-bit signless integer |\n\n### `calyx.group_go` (::circt::calyx::GroupGoOp)\u00a0[\u00b6](#calyxgroup_go-circtcalyxgroupgoop)\n\n*Calyx Group Go Port*\n\nThe \u201ccalyx.group\\_go\u201d operation represents a port on a\nCalyx group that signifies when the group begins.\nA go operation may optionally be guarded, which\ncontrols when the group\u2019s go operation should be\nactive. The go operation should only be inserted\nduring the Go Insertion pass. It does not\nreceive a source until the Compile Control pass.\n\n```\n  %group_name1.go = calyx.group_go %src : i1\n  %group_name2.go = calyx.group_go %guard ? %src : i1\n```\n\nTraits: `HasParent<GroupOp>`\n\nInterfaces: `OpAsmOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `src` | 1-bit signless integer |\n| `guard` | 1-bit signless integer |\n\n#### Results:\u00a0[\u00b6](#results-2)\n\n| Result | Description |\n| --- | --- |\n| \u00abunnamed\u00bb | 1-bit signless integer |\n\n### `calyx.ieee754.add` (::circt::calyx::AddFOpIEEE754)\u00a0[\u00b6](#calyxieee754add-circtcalyxaddfopieee754)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.ieee754.add` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nInterfaces: `CellInterface`, `FloatingPointOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-7)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-3)\n\n| Result | Description |\n| --- | --- |\n| `clk` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n| `control` | 1-bit signless integer |\n| `subOp` | 1-bit signless integer |\n| `left` | signless integer |\n| `right` | signless integer |\n| `roundingMode` | 3-bit signless integer |\n| `out` | signless integer |\n| `exceptionalFlags` | 5-bit signless integer |\n| `done` | 1-bit signless integer |\n\n### `calyx.ieee754.compare` (::circt::calyx::CompareFOpIEEE754)\u00a0[\u00b6](#calyxieee754compare-circtcalyxcomparefopieee754)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.ieee754.compare` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nInterfaces: `CellInterface`, `FloatingPointOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-8)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-4)\n\n| Result | Description |\n| --- | --- |\n| `clk` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n| `left` | signless integer |\n| `right` | signless integer |\n| `signaling` | 1-bit signless integer |\n| `lt` | 1-bit signless integer |\n| `eq` | 1-bit signless integer |\n| `gt` | 1-bit signless integer |\n| `unordered` | 1-bit signless integer |\n| `exceptionalFlags` | 5-bit signless integer |\n| `done` | 1-bit signless integer |\n\n### `calyx.ieee754.divSqrt` (::circt::calyx::DivSqrtOpIEEE754)\u00a0[\u00b6](#calyxieee754divsqrt-circtcalyxdivsqrtopieee754)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.ieee754.divSqrt` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nInterfaces: `CellInterface`, `FloatingPointOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-9)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-5)\n\n| Result | Description |\n| --- | --- |\n| `clk` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n| `control` | 1-bit signless integer |\n| `sqrtOp` | 1-bit signless integer |\n| `left` | signless integer |\n| `right` | signless integer |\n| `roundingMode` | 3-bit signless integer |\n| `out` | signless integer |\n| `exceptionalFlags` | 5-bit signless integer |\n| `done` | 1-bit signless integer |\n\n### `calyx.ieee754.fpToInt` (::circt::calyx::FpToIntOpIEEE754)\u00a0[\u00b6](#calyxieee754fptoint-circtcalyxfptointopieee754)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.ieee754.fpToInt` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `FloatingPointOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-10)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-6)\n\n| Result | Description |\n| --- | --- |\n| `clk` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n| `in` | signless integer |\n| `signedOut` | 1-bit signless integer |\n| `out` | signless integer |\n| `done` | 1-bit signless integer |\n\n### `calyx.ieee754.intToFp` (::circt::calyx::IntToFpOpIEEE754)\u00a0[\u00b6](#calyxieee754inttofp-circtcalyxinttofpopieee754)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.ieee754.intToFp` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `FloatingPointOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-11)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-7)\n\n| Result | Description |\n| --- | --- |\n| `clk` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n| `in` | signless integer |\n| `signedIn` | 1-bit signless integer |\n| `out` | signless integer |\n| `done` | 1-bit signless integer |\n\n### `calyx.ieee754.mul` (::circt::calyx::MulFOpIEEE754)\u00a0[\u00b6](#calyxieee754mul-circtcalyxmulfopieee754)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.ieee754.mul` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nInterfaces: `CellInterface`, `FloatingPointOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-12)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-8)\n\n| Result | Description |\n| --- | --- |\n| `clk` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n| `control` | 1-bit signless integer |\n| `left` | signless integer |\n| `right` | signless integer |\n| `roundingMode` | 3-bit signless integer |\n| `out` | signless integer |\n| `exceptionalFlags` | 5-bit signless integer |\n| `done` | 1-bit signless integer |\n\n### `calyx.if` (::circt::calyx::IfOp)\u00a0[\u00b6](#calyxif-circtcalyxifop)\n\n*Calyx If*\n\nSyntax:\n\n```\noperation ::= `calyx.if` $cond (`with` $groupName^)? $thenRegion (`else` $elseRegion^)? attr-dict\n```\n\nThe \u201ccalyx.if\u201d operation represents and if-then-else construct for\nconditionally executing two Calyx groups. The operands to an if operation is\na 1-bit port and an optional combinational group under which this port is driven.\n\nNote: The native and CIRCT Calyx IRs may diverge wrt. \u2018with\u2019 execution, see:\n<https://github.com/cucapra/calyx/discussions/588>\n\n```\n  calyx.if %1 with @G1 {\n    calyx.enable @G2\n    ...\n  } else {\n    calyx.enable @G3\n    ...\n  }\n  calyx.if %1 {\n    calyx.enable @G2\n    ...\n  }\n```\n\nTraits: `ControlLike`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `IfInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-13)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `groupName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-3)\n\n| Operand | Description |\n| --- | --- |\n| `cond` | 1-bit signless integer |\n\n### `calyx.instance` (::circt::calyx::InstanceOp)\u00a0[\u00b6](#calyxinstance-circtcalyxinstanceop)\n\n*Calyx Component Instance*\n\nSyntax:\n\n```\noperation ::= `calyx.instance` $sym_name `of` $componentName attr-dict (`:` qualified(type($results))^)?\n```\n\nRepresents an instance of a Calyx component, which may include state.\n\n```\n  %c.in, %c.out = calyx.instance @c of @MyComponent : i64, i16\n```\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-14)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `componentName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Results:\u00a0[\u00b6](#results-9)\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `calyx.invoke` (::circt::calyx::InvokeOp)\u00a0[\u00b6](#calyxinvoke-circtcalyxinvokeop)\n\n*Calyx Invoke*\n\ncalyx.invoke is similar to the behavior of a function\ncall, which invokes a given component.\n\nThe \u2018callee\u2019 attribute is the name of the component,\nthe \u2018ports\u2019 attribute specifies the input port of the component when it is invoked,\nthe \u2018inputs\u2019 attribute specifies the assignment on the corresponding port,\nand the \u2018refCellsMap\u2019 attribute maps the reference cells in the `callee` with\nthe original cells in the caller.\n\n```\n  calyx.component @identity {\n    %mem.addr0, %mem.clk, ... = calyx.seq_mem @mem <[1] x 32> [1] {external = false}\n  }\n  %id.in, %id.out, ... = calyx.instance @id of @identity : i32, i32, ...\n  %r.in, ... = calyx.register @r : i32, ...\n  %mem_1.addr0, %mem_1.clk, ... = calyx.seq_mem @mem_1 <[1] x 32> [1] {external = true}\n  ...\n  calyx.control {\n    calyx.seq {\n      calyx.invoke @id[mem = mem_1](%id.in = %c1_10, %r.in = %id.out) -> (i32, i32)\n    }\n  }\n```\n\nTraits: `ControlLike`, `SameVariadicOperandSize`\n\n#### Attributes:\u00a0[\u00b6](#attributes-15)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `callee` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `refCellsMap` | ::mlir::ArrayAttr | array attribute |\n| `portNames` | ::mlir::ArrayAttr | array attribute |\n| `inputNames` | ::mlir::ArrayAttr | array attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-4)\n\n| Operand | Description |\n| --- | --- |\n| `ports` | variadic of any type |\n| `inputs` | variadic of any type |\n\n### `calyx.memory` (::circt::calyx::MemoryOp)\u00a0[\u00b6](#calyxmemory-circtcalyxmemoryop)\n\n*Defines a memory*\n\nSyntax:\n\n```\noperation ::= `calyx.memory` $sym_name ` ` `<` $sizes `x` $width `>` $addrSizes attr-dict `:` qualified(type($results))\n```\n\nThe \u201ccalyx.memory\u201d op defines a memory. Memories can have any number of\ndimensions, as specified by the length of the `$sizes` and `$addrSizes`\narrays. The `$addrSizes` specify the bitwidth of each dimension\u2019s address,\nand should be wide enough to address the range of the corresponding\ndimension in `$sizes`. The `$width` attribute dictates the width of a single\nelement.\n\nSee\n<https://docs.calyxir.org/libraries/core.html#memories> for\nmore information.\n\n```\n  // A 1-dimensional, 32-bit memory with size dimension 1. Equivalent representation in the native compiler:\n  // `m1 = std_mem_d1(32, 1, 1)`\n  %m1.addr0, %m1.write_data, %m1.write_en, %m1.clk, %m1.read_data, %m1.done = calyx.memory @m1 <[1] x 32> [1] : i1, i32, i1, i1, i32, i1\n\n  // A 2-dimensional, 8-bit memory with size dimensions 64 x 64. Equivalent representation in the native compiler:\n  // `m2 = std_mem_d2(8, 64, 64, 6, 6)`\n  %m2.addr0, %m2.addr1, %m2.write_data, %m2.write_en, %m2.clk, %m2.read_data, %m2.done = calyx.memory @m2 <[64, 64] x 8> [6, 6] : i6, i6, i8, i1, i1, i8, i1\n```\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-16)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `width` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n| `sizes` | ::mlir::ArrayAttr | array attribute |\n| `addrSizes` | ::mlir::ArrayAttr | array attribute |\n\n#### Results:\u00a0[\u00b6](#results-10)\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of signless integer |\n\n### `calyx.par` (::circt::calyx::ParOp)\u00a0[\u00b6](#calyxpar-circtcalyxparop)\n\n*Calyx Parallel*\n\nSyntax:\n\n```\noperation ::= `calyx.par` $body attr-dict\n```\n\nThe \u201ccalyx.par\u201d operation executes the\ncontrol within its region in parallel.\n\n```\n  calyx.par {\n    // G1 and G2 will execute in parallel.\n    // The region is complete when both\n    // G1 and G2 are done.\n    calyx.enable @G1\n    calyx.enable @G2\n  }\n```\n\nTraits: `ControlLike`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\n### `calyx.primitive` (::circt::calyx::PrimitiveOp)\u00a0[\u00b6](#calyxprimitive-circtcalyxprimitiveop)\n\n*Calyx Primitive Instance*\n\nSyntax:\n\n```\noperation ::= `calyx.primitive` $sym_name `of` $primitiveName `` custom<ParameterList>($parameters) attr-dict (`:` qualified(type($results))^)?\n```\n\nRepresents an instance of a Calyx primitive.\n\n```\n  %c.in, %c.out = calyx.primitive @c of @MyExternalPrimitive : i64, i16\n```\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-17)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `parameters` | ::mlir::ArrayAttr | parameter array |\n| `primitiveName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Results:\u00a0[\u00b6](#results-11)\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `calyx.register` (::circt::calyx::RegisterOp)\u00a0[\u00b6](#calyxregister-circtcalyxregisterop)\n\n*Defines a register*\n\nSyntax:\n\n```\noperation ::= `calyx.register` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThe \u201ccalyx.register\u201d op defines a register.\n\n```\n  // A 32-bit register.\n  %r.in, %r.write_en, %r.clk, %r.reset, %r.out, %r.done = calyx.register @r : i32, i1, i1, i1, i32, i1\n```\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-18)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-12)\n\n| Result | Description |\n| --- | --- |\n| `in` | any type |\n| `write_en` | 1-bit signless integer |\n| `clk` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `out` | any type |\n| `done` | 1-bit signless integer |\n\n### `calyx.repeat` (::circt::calyx::RepeatOp)\u00a0[\u00b6](#calyxrepeat-circtcalyxrepeatop)\n\n*Calyx Dynamic Repeat*\n\nSyntax:\n\n```\noperation ::= `calyx.repeat` $count $body attr-dict\n```\n\nThe \u201ccalyx.repeat\u201d operation represents the repeated execution of\nthe control within its region.\nThe key difference with static repeat is that the body (unlike with static\nrepeat) can be dynamically timed.\n\n```\n  calyx.repeat 10 {\n    calyx.enable @G1\n    ...\n  }\n```\n\nTraits: `ControlLike`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\n#### Attributes:\u00a0[\u00b6](#attributes-19)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `count` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n### `calyx.seq` (::circt::calyx::SeqOp)\u00a0[\u00b6](#calyxseq-circtcalyxseqop)\n\n*Calyx Sequential*\n\nSyntax:\n\n```\noperation ::= `calyx.seq` $body attr-dict\n```\n\nThe \u201ccalyx.seq\u201d operation executes the\ncontrol within its region sequentially.\n\n```\n  calyx.seq {\n    // G2 will not begin execution until G1 is done.\n    calyx.enable @G1\n    calyx.enable @G2\n  }\n```\n\nTraits: `ControlLike`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\n### `calyx.seq_mem` (::circt::calyx::SeqMemoryOp)\u00a0[\u00b6](#calyxseq_mem-circtcalyxseqmemoryop)\n\n*Defines a memory with sequential read*\n\nSyntax:\n\n```\noperation ::= `calyx.seq_mem` $sym_name ` ` `<` $sizes `x` $width `>` $addrSizes attr-dict `:` qualified(type($results))\n```\n\nThe \u201ccalyx.seq\\_mem\u201d op defines a memory with sequential reads. Memories can\nhave any number of dimensions, as specified by the length of the `$sizes` and\n`$addrSizes` arrays. The `$addrSizes` specify the bitwidth of each dimension\u2019s\naddress, and should be wide enough to address the range of the corresponding\ndimension in `$sizes`. The `$width` attribute dictates the width of a single\nelement.\n\nSee\n<https://docs.calyxir.org/libraries/core.html#memories> for\nmore information.\n\n```\n  // A 1-dimensional, 32-bit memory with size dimension 1. Equivalent representation in the native compiler:\n  // `m1 = seq_mem_d1(32, 1, 1)`\n  %m1.addr0, %m1.write_data, %m1.write_en, %m1.clk, %m1.read_data, %m1.read_en, %m1.done = calyx.memory @m1 <[1] x 32> [1] : i1, i32, i1, i1, i32, i1\n\n  // A 2-dimensional, 8-bit memory with size dimensions 64 x 64. Equivalent representation in the native compiler:\n  // `m2 = seq_mem_d2(8, 64, 64, 6, 6)`\n  %m2.addr0, %m2.addr1, %m2.write_data, %m2.write_en, %m2.write_done, %m2.clk, %m2.read_data, %m2.read_en, %m2.read_done = calyx.memory @m2 <[64, 64] x 8> [6, 6] : i6, i6, i8, i1, i1, i8, i1\n```\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-20)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `width` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n| `sizes` | ::mlir::ArrayAttr | array attribute |\n| `addrSizes` | ::mlir::ArrayAttr | array attribute |\n\n#### Results:\u00a0[\u00b6](#results-13)\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of signless integer |\n\n### `calyx.static_group` (::circt::calyx::StaticGroupOp)\u00a0[\u00b6](#calyxstatic_group-circtcalyxstaticgroupop)\n\n*Calyx Static Group*\n\nSyntax:\n\n```\noperation ::= `calyx.static_group` `latency` `<` $latency `>` $sym_name $body attr-dict\n```\n\nRepresents a Calyx static group, which is a collection\nof assignments that are only active when the group\nis run from the control execution schedule. A group\nsignifies its termination with a special port named\na \u201cdone\u201d port.\n\n```\n  calyx.static_group latency<1> @MyStaticGroup {\n    calyx.assign %1 = %2 : i32\n  }\n```\n\nTraits: `HasParent<WiresOp>`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `GroupInterface`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-21)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `latency` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n### `calyx.static_if` (::circt::calyx::StaticIfOp)\u00a0[\u00b6](#calyxstatic_if-circtcalyxstaticifop)\n\n*Calyx Static If*\n\nSyntax:\n\n```\noperation ::= `calyx.static_if` $cond $thenRegion (`else` $elseRegion^)? attr-dict\n```\n\nThe \u201ccalyx.static\\_if\u201d operation represents an if-then-else construct for\nconditionally executing two Calyx groups. The operands to an if operation is\na 1-bit port.\n\n```\n  calyx.static_if %1 {\n    calyx.enable @G2\n    ...\n  } else {\n    calyx.enable @G3\n    ...\n  }\n  calyx.if %1 {\n    calyx.enable @G2\n    ...\n  }\n```\n\nTraits: `ControlLike`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `IfInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-5)\n\n| Operand | Description |\n| --- | --- |\n| `cond` | 1-bit signless integer |\n\n### `calyx.static_par` (::circt::calyx::StaticParOp)\u00a0[\u00b6](#calyxstatic_par-circtcalyxstaticparop)\n\n*Calyx Static Parallel*\n\nSyntax:\n\n```\noperation ::= `calyx.static_par` $body attr-dict\n```\n\nThe \u201ccalyx.static\\_par\u201d operation executes the\ncontrol within its region in parallel.\n\n```\n  calyx.static_par {\n    // G1 and G2 will execute in parallel.\n    // The region is complete when both\n    // G1 and G2 are done.\n    calyx.enable @G1\n    calyx.enable @G2\n  }\n```\n\nTraits: `ControlLike`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\n### `calyx.static_repeat` (::circt::calyx::StaticRepeatOp)\u00a0[\u00b6](#calyxstatic_repeat-circtcalyxstaticrepeatop)\n\n*Calyx Static Repeat*\n\nSyntax:\n\n```\noperation ::= `calyx.static_repeat` $count $body attr-dict\n```\n\nThe \u201ccalyx.static\\_repeat\u201d operation represents the repeated execution of\nthe control within its region. All control within the region must be static.\n\n```\n  calyx.static_repeat 10 {\n    calyx.enable @G1\n    ...\n  }\n```\n\nTraits: `ControlLike`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\n#### Attributes:\u00a0[\u00b6](#attributes-22)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `count` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n### `calyx.static_seq` (::circt::calyx::StaticSeqOp)\u00a0[\u00b6](#calyxstatic_seq-circtcalyxstaticseqop)\n\n*Calyx Static Seq*\n\nSyntax:\n\n```\noperation ::= `calyx.static_seq` $body attr-dict\n```\n\nThe \u201ccalyx.static\\_seq\u201d operation executes the\ncontrol within its region sequentially.\n\n```\n  calyx.static_seq {\n    // G2 will not begin execution until G1 is done.\n    calyx.enable @G1\n    calyx.enable @G2\n  }\n```\n\nTraits: `ControlLike`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\n### `calyx.std_add` (::circt::calyx::AddLibOp)\u00a0[\u00b6](#calyxstd_add-circtcalyxaddlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_add` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-23)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-14)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n\n### `calyx.std_and` (::circt::calyx::AndLibOp)\u00a0[\u00b6](#calyxstd_and-circtcalyxandlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_and` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-24)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-15)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n\n### `calyx.std_divs_pipe` (::circt::calyx::DivSPipeLibOp)\u00a0[\u00b6](#calyxstd_divs_pipe-circtcalyxdivspipelibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_divs_pipe` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-25)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-16)\n\n| Result | Description |\n| --- | --- |\n| `clk` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n| `done` | 1-bit signless integer |\n\n### `calyx.std_divu_pipe` (::circt::calyx::DivUPipeLibOp)\u00a0[\u00b6](#calyxstd_divu_pipe-circtcalyxdivupipelibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_divu_pipe` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-26)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-17)\n\n| Result | Description |\n| --- | --- |\n| `clk` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n| `done` | 1-bit signless integer |\n\n### `calyx.std_eq` (::circt::calyx::EqLibOp)\u00a0[\u00b6](#calyxstd_eq-circtcalyxeqlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_eq` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-27)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-18)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | 1-bit signless integer |\n\n### `calyx.std_ge` (::circt::calyx::GeLibOp)\u00a0[\u00b6](#calyxstd_ge-circtcalyxgelibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_ge` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-28)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-19)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | 1-bit signless integer |\n\n### `calyx.std_gt` (::circt::calyx::GtLibOp)\u00a0[\u00b6](#calyxstd_gt-circtcalyxgtlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_gt` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-29)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-20)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | 1-bit signless integer |\n\n### `calyx.std_le` (::circt::calyx::LeLibOp)\u00a0[\u00b6](#calyxstd_le-circtcalyxlelibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_le` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-30)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-21)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | 1-bit signless integer |\n\n### `calyx.std_lsh` (::circt::calyx::LshLibOp)\u00a0[\u00b6](#calyxstd_lsh-circtcalyxlshlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_lsh` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-31)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-22)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n\n### `calyx.std_lt` (::circt::calyx::LtLibOp)\u00a0[\u00b6](#calyxstd_lt-circtcalyxltlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_lt` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-32)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-23)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | 1-bit signless integer |\n\n### `calyx.std_mult_pipe` (::circt::calyx::MultPipeLibOp)\u00a0[\u00b6](#calyxstd_mult_pipe-circtcalyxmultpipelibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_mult_pipe` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-33)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-24)\n\n| Result | Description |\n| --- | --- |\n| `clk` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n| `done` | 1-bit signless integer |\n\n### `calyx.std_mux` (::circt::calyx::MuxLibOp)\u00a0[\u00b6](#calyxstd_mux-circtcalyxmuxlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_mux` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-34)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-25)\n\n| Result | Description |\n| --- | --- |\n| `cond` | 1-bit signless integer |\n| `tru` | any type |\n| `fal` | any type |\n| `out` | any type |\n\n### `calyx.std_neq` (::circt::calyx::NeqLibOp)\u00a0[\u00b6](#calyxstd_neq-circtcalyxneqlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_neq` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-35)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-26)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | 1-bit signless integer |\n\n### `calyx.std_not` (::circt::calyx::NotLibOp)\u00a0[\u00b6](#calyxstd_not-circtcalyxnotlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_not` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-36)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-27)\n\n| Result | Description |\n| --- | --- |\n| `in` | integer |\n| `out` | integer |\n\n### `calyx.std_or` (::circt::calyx::OrLibOp)\u00a0[\u00b6](#calyxstd_or-circtcalyxorlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_or` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-37)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-28)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n\n### `calyx.std_pad` (::circt::calyx::PadLibOp)\u00a0[\u00b6](#calyxstd_pad-circtcalyxpadlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_pad` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-38)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-29)\n\n| Result | Description |\n| --- | --- |\n| `in` | integer |\n| `out` | integer |\n\n### `calyx.std_rems_pipe` (::circt::calyx::RemSPipeLibOp)\u00a0[\u00b6](#calyxstd_rems_pipe-circtcalyxremspipelibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_rems_pipe` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-39)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-30)\n\n| Result | Description |\n| --- | --- |\n| `clk` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n| `done` | 1-bit signless integer |\n\n### `calyx.std_remu_pipe` (::circt::calyx::RemUPipeLibOp)\u00a0[\u00b6](#calyxstd_remu_pipe-circtcalyxremupipelibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_remu_pipe` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-40)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-31)\n\n| Result | Description |\n| --- | --- |\n| `clk` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n| `done` | 1-bit signless integer |\n\n### `calyx.std_rsh` (::circt::calyx::RshLibOp)\u00a0[\u00b6](#calyxstd_rsh-circtcalyxrshlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_rsh` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-41)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-32)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n\n### `calyx.std_seq` (::circt::calyx::SeqLibOp)\u00a0[\u00b6](#calyxstd_seq-circtcalyxseqlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_seq` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-42)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-33)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | 1-bit signless integer |\n\n### `calyx.std_sge` (::circt::calyx::SgeLibOp)\u00a0[\u00b6](#calyxstd_sge-circtcalyxsgelibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_sge` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-43)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-34)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | 1-bit signless integer |\n\n### `calyx.std_sgt` (::circt::calyx::SgtLibOp)\u00a0[\u00b6](#calyxstd_sgt-circtcalyxsgtlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_sgt` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-44)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-35)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | 1-bit signless integer |\n\n### `calyx.std_shru` (::circt::calyx::ShruLibOp)\u00a0[\u00b6](#calyxstd_shru-circtcalyxshrulibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_shru` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-45)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-36)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n\n### `calyx.std_signext` (::circt::calyx::ExtSILibOp)\u00a0[\u00b6](#calyxstd_signext-circtcalyxextsilibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_signext` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-46)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-37)\n\n| Result | Description |\n| --- | --- |\n| `in` | integer |\n| `out` | integer |\n\n### `calyx.std_sle` (::circt::calyx::SleLibOp)\u00a0[\u00b6](#calyxstd_sle-circtcalyxslelibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_sle` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-47)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-38)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | 1-bit signless integer |\n\n### `calyx.std_slice` (::circt::calyx::SliceLibOp)\u00a0[\u00b6](#calyxstd_slice-circtcalyxslicelibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_slice` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-48)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-39)\n\n| Result | Description |\n| --- | --- |\n| `in` | integer |\n| `out` | integer |\n\n### `calyx.std_slt` (::circt::calyx::SltLibOp)\u00a0[\u00b6](#calyxstd_slt-circtcalyxsltlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_slt` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-49)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-40)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | 1-bit signless integer |\n\n### `calyx.std_sneq` (::circt::calyx::SneqLibOp)\u00a0[\u00b6](#calyxstd_sneq-circtcalyxsneqlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_sneq` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-50)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-41)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | 1-bit signless integer |\n\n### `calyx.std_srsh` (::circt::calyx::SrshLibOp)\u00a0[\u00b6](#calyxstd_srsh-circtcalyxsrshlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_srsh` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-51)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-42)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n\n### `calyx.std_sub` (::circt::calyx::SubLibOp)\u00a0[\u00b6](#calyxstd_sub-circtcalyxsublibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_sub` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-52)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-43)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n\n### `calyx.std_wire` (::circt::calyx::WireLibOp)\u00a0[\u00b6](#calyxstd_wire-circtcalyxwirelibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_wire` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-53)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-44)\n\n| Result | Description |\n| --- | --- |\n| `in` | integer |\n| `out` | integer |\n\n### `calyx.std_xor` (::circt::calyx::XorLibOp)\u00a0[\u00b6](#calyxstd_xor-circtcalyxxorlibop)\n\n*Defines an operation which maps to a Calyx library primitive*\n\nSyntax:\n\n```\noperation ::= `calyx.std_xor` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThis operation represents an instance of a Calyx library primitive.\nA library primitive maps to some hardware-implemented component within the\nnative Calyx compiler.\n\n```\n  // A 32-bit adder. This falls under the binary library operations.\n  %add.left, %add.right, %add.out = calyx.std_add @add : i32, i32, i32\n\n  // An 8-bit comparison operator (with a 1-bit output). This falls under\n  // the boolean binary library operations.\n  %gt.left, %gt.right, %gt.out = calyx.std_gt @gt : i8, i8, i1\n\n  // An 8-bit to 16-bit pad operator. This falls under the unary\n  // library operations.\n  %pad.in, %pad.out = calyx.std_pad @pad : i8, i16\n```\n\nTraits: `Combinational`\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-54)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-45)\n\n| Result | Description |\n| --- | --- |\n| `left` | any type |\n| `right` | any type |\n| `out` | any type |\n\n### `calyx.undef` (::circt::calyx::UndefinedOp)\u00a0[\u00b6](#calyxundef-circtcalyxundefinedop)\n\n*Calyx Undefined Value*\n\nSyntax:\n\n```\noperation ::= `calyx.undef` attr-dict `:` qualified(type($res))\n```\n\nThe \u201cundef\u201d operation represents an undefined value\nthat may be used when a specific source or destination\ndoes not have an assignment yet. This is used to avoid\npulling in the entire LLVMIR dialect for a single\noperation.\n\n```\n  %0 = calyx.undef : i1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\u00a0[\u00b6](#results-46)\n\n| Result | Description |\n| --- | --- |\n| `res` | any type |\n\n### `calyx.undefined` (::circt::calyx::UndefLibOp)\u00a0[\u00b6](#calyxundefined-circtcalyxundeflibop)\n\n*An undefined signal*\n\nSyntax:\n\n```\noperation ::= `calyx.undefined` $sym_name attr-dict `:` qualified(type(results))\n```\n\nThe \u201ccalyx.undef\u201d op defines an undefined signal. An undefined signal can be\nreplaced with any value representable in n-bits.\n\n```\n  // A 32-bit undefined value\n  %undef.out = calyx.undef @undef : i32\n```\n\nInterfaces: `CellInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-55)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-47)\n\n| Result | Description |\n| --- | --- |\n| `out` | any type |\n\n### `calyx.while` (::circt::calyx::WhileOp)\u00a0[\u00b6](#calyxwhile-circtcalyxwhileop)\n\n*Calyx While*\n\nSyntax:\n\n```\noperation ::= `calyx.while` $cond (`with` $groupName^)? $body attr-dict\n```\n\nThe \u201ccalyx.while\u201d operation represents a construct for continuously\nexecuting the inner groups of the \u2018while\u2019 operation while the condition port\nevaluates to true. The operands to a while operation is a 1-bit port and an\noptional combinational group under which this port is driven.\n\nNote: The native and CIRCT Calyx IRs may diverge wrt. \u2018with\u2019 execution, see:\n<https://github.com/cucapra/calyx/discussions/588>\n\n```\n  calyx.while %1 with @G1 {\n    calyx.enable @G2\n    ...\n  }\n  calyx.while %1 {\n    calyx.enable @G2\n    ...\n  }\n```\n\nTraits: `ControlLike`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\n#### Attributes:\u00a0[\u00b6](#attributes-56)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `groupName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-6)\n\n| Operand | Description |\n| --- | --- |\n| `cond` | 1-bit signless integer |\n\n### `calyx.wires` (::circt::calyx::WiresOp)\u00a0[\u00b6](#calyxwires-circtcalyxwiresop)\n\n*Calyx Wires*\n\nSyntax:\n\n```\noperation ::= `calyx.wires` $body attr-dict\n```\n\nThe \u201ccalyx.wires\u201d operation represents a set of\nguarded connections between component instances,\nwhich may be placed within groups.\n\n```\n  calyx.wires {\n    calyx.group @A { ... }\n    calyx.assign %1 = %2 : i16\n  }\n```\n\nTraits: `HasParent<ComponentOp, CombComponentOp>`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\nInterfaces: `RegionKindInterface`\n\n [Prev - 'arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/ \"'arc' Dialect\")\n[Next - 'chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/ \"'chirrtl' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/CHIRRTL/index.md"
  },
  {
    "role": "user",
    "content": "'chirrtl' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'chirrtl' Dialect\n=================\n\n*Types and operations for the chirrtl dialect*\n\nThis dialect defines the `chirrtl` dialect, which contains high-level\nmemory defintions which can be lowered to FIRRTL.\n\n* [Operations](#operations)\n  + [`chirrtl.combmem` (::circt::chirrtl::CombMemOp)](#chirrtlcombmem-circtchirrtlcombmemop)\n  + [`chirrtl.debugport` (::circt::chirrtl::MemoryDebugPortOp)](#chirrtldebugport-circtchirrtlmemorydebugportop)\n  + [`chirrtl.memoryport` (::circt::chirrtl::MemoryPortOp)](#chirrtlmemoryport-circtchirrtlmemoryportop)\n  + [`chirrtl.memoryport.access` (::circt::chirrtl::MemoryPortAccessOp)](#chirrtlmemoryportaccess-circtchirrtlmemoryportaccessop)\n  + [`chirrtl.seqmem` (::circt::chirrtl::SeqMemOp)](#chirrtlseqmem-circtchirrtlseqmemop)\n* [Types](#types)\n  + [CMemoryPortType](#cmemoryporttype)\n  + [CMemoryType](#cmemorytype)\n* [Enums](#enums)\n  + [Convention](#convention)\n  + [EventControl](#eventcontrol)\n  + [LayerConvention](#layerconvention)\n  + [LayerSpecialization](#layerspecialization)\n  + [MemDirAttr](#memdirattr)\n  + [NameKindEnum](#namekindenum)\n  + [RUWBehavior](#ruwbehavior)\n  + [TargetKind](#targetkind)\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `chirrtl.combmem` (::circt::chirrtl::CombMemOp)\u00a0[\u00b6](#chirrtlcombmem-circtchirrtlcombmemop)\n\n*Define a new combinational memory*\n\nSyntax:\n\n```\noperation ::= `chirrtl.combmem` (`sym` $inner_sym^)? `` custom<NameKind>($nameKind)\n              `` custom<CombMemOp>(attr-dict) `:` qualified(type($result))\n```\n\nDefine a new behavioral combinational memory. Combinational memories have a\nwrite latency of 1 and a read latency of 0.\n\nInterfaces: `FNamableOp`, `HasCustomSSAName`, `InnerSymbolOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `nameKind` | ::circt::firrtl::NameKindEnumAttr | name kind |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `init` | ::circt::firrtl::MemoryInitAttr | Information about the initial state of a memory |\n| `prefix` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| `result` | a behavioral memory |\n\n### `chirrtl.debugport` (::circt::chirrtl::MemoryDebugPortOp)\u00a0[\u00b6](#chirrtldebugport-circtchirrtlmemorydebugportop)\n\n*Defines a debug memory port on CHIRRTL memory*\n\nSyntax:\n\n```\noperation ::= `chirrtl.debugport` $memory custom<MemoryDebugPortOp>(attr-dict) `:`\n              functional-type(operands, results)\n```\n\nThis operation defines a new debug memory port on a `combmem`CHISEL.\n`data` is the data returned from the memory port.\n\nInterfaces: `HasCustomSSAName`, `InferTypeOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `memory` | a behavioral memory |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `data` | reference type |\n\n### `chirrtl.memoryport` (::circt::chirrtl::MemoryPortOp)\u00a0[\u00b6](#chirrtlmemoryport-circtchirrtlmemoryportop)\n\n*Defines a memory port on CHIRRTL memory*\n\nSyntax:\n\n```\noperation ::= `chirrtl.memoryport` $direction $memory `` custom<MemoryPortOp>(attr-dict) `:`\n              functional-type(operands, results)\n```\n\nThis operation defines a new memory port on a `seqmem` or `combmem`CHISEL.\n`data` is the data returned from the memory port.\n\nThe memory port requires an access point, which sets the enable condition\nof the port, the clock, and the address. This is done by passing the the\n`port` argument to a `chirrtl.memoryport.access operation`.\n\nInterfaces: `HasCustomSSAName`, `InferTypeOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-2)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `direction` | ::circt::firrtl::MemDirAttrAttr | Memory Direction Enum |\n| `name` | ::mlir::StringAttr | string attribute |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `memory` | a behavioral memory |\n\n#### Results:\u00a0[\u00b6](#results-2)\n\n| Result | Description |\n| --- | --- |\n| `data` | a base type |\n| `port` | a behavioral memory port |\n\n### `chirrtl.memoryport.access` (::circt::chirrtl::MemoryPortAccessOp)\u00a0[\u00b6](#chirrtlmemoryportaccess-circtchirrtlmemoryportaccessop)\n\n*Enables a memory port*\n\nSyntax:\n\n```\noperation ::= `chirrtl.memoryport.access` $port `[` $index `]` `,` $clock attr-dict `:` qualified(type(operands))\n```\n\nThis operation is used to conditionally enable a memory port, and associate\nit with a `clock` and `index`. The memory port will be actuve on the\npositive edge of the clock. The index is the address of the memory\naccessed. See the FIRRTL rational for more information about why this\noperation exists.\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `port` | a behavioral memory port |\n| `index` | sint or uint type |\n| `clock` | clock |\n\n### `chirrtl.seqmem` (::circt::chirrtl::SeqMemOp)\u00a0[\u00b6](#chirrtlseqmem-circtchirrtlseqmemop)\n\n*Define a new sequential memory*\n\nSyntax:\n\n```\noperation ::= `chirrtl.seqmem` (`sym` $inner_sym^)? `` custom<NameKind>($nameKind) $ruw\n              custom<SeqMemOp>(attr-dict) `:` qualified(type($result))\n```\n\nDefine a new behavioral sequential memory. Sequential memories have a\nwrite latency and a read latency of 1.\n\nInterfaces: `FNamableOp`, `HasCustomSSAName`, `InnerSymbolOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-3)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `ruw` | ::circt::firrtl::RUWBehaviorAttr | read under write behavior |\n| `name` | ::mlir::StringAttr | string attribute |\n| `nameKind` | ::circt::firrtl::NameKindEnumAttr | name kind |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `init` | ::circt::firrtl::MemoryInitAttr | Information about the initial state of a memory |\n| `prefix` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-3)\n\n| Result | Description |\n| --- | --- |\n| `result` | a behavioral memory |\n\nTypes\u00a0[\u00b6](#types)\n-----------------\n\n### CMemoryPortType\u00a0[\u00b6](#cmemoryporttype)\n\n*A behavioral memory port*\n\nSyntax: `!chirrtl.cmemoryport`\n\nSyntax:\n\n```\ncmemoryport-type ::= `cmemoryport`\n```\n\nThe value of a `cmemoryport` type represents a port which has been\ndeclared on a `cmemory`. This value is used to set the memory port access\nconditions.\n\n### CMemoryType\u00a0[\u00b6](#cmemorytype)\n\n*A behavioral memory*\n\nSyntax:\n\n```\ncmemory-type ::= `cmemory` `<` element-type, element-count `>`\n```\n\nThe value of a `cmemory` type represents a behavioral memory with unknown\nports. This is produced by `combmem` and `seqmem` declarations and used by\n`memoryport` declarations to define memories and their ports. A CMemory is\nsimilar to a vector of passive element types.\n\nExamples:\n\n```\n!chirrtl.cmemory<uint<32>, 16>\n!chirrtl.cmemory<bundle<a : uint<1>>, 16>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `firrtl::FIRRTLBaseType` |  |\n| numElements | `uint64_t` |  |\n\nEnums\u00a0[\u00b6](#enums)\n-----------------\n\n### Convention\u00a0[\u00b6](#convention)\n\n*Lowering convention*\n\n#### Cases:\u00a0[\u00b6](#cases)\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Internal | `0` | internal |\n| Scalarized | `1` | scalarized |\n\n### EventControl\u00a0[\u00b6](#eventcontrol)\n\n*Edge control trigger*\n\n#### Cases:\u00a0[\u00b6](#cases-1)\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| AtPosEdge | `0` | posedge |\n| AtNegEdge | `1` | negedge |\n| AtEdge | `2` | edge |\n\n### LayerConvention\u00a0[\u00b6](#layerconvention)\n\n*Layer convention*\n\n#### Cases:\u00a0[\u00b6](#cases-2)\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Bind | `0` | bind |\n| Inline | `1` | inline |\n\n### LayerSpecialization\u00a0[\u00b6](#layerspecialization)\n\n*Layer specialization*\n\n#### Cases:\u00a0[\u00b6](#cases-3)\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Enable | `0` | enable |\n| Disable | `1` | disable |\n\n### MemDirAttr\u00a0[\u00b6](#memdirattr)\n\n*Memory Direction Enum*\n\n#### Cases:\u00a0[\u00b6](#cases-4)\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Infer | `0` | Infer |\n| Read | `1` | Read |\n| Write | `2` | Write |\n| ReadWrite | `3` | ReadWrite |\n\n### NameKindEnum\u00a0[\u00b6](#namekindenum)\n\n*Name kind*\n\n#### Cases:\u00a0[\u00b6](#cases-5)\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| DroppableName | `0` | droppable\\_name |\n| InterestingName | `1` | interesting\\_name |\n\n### RUWBehavior\u00a0[\u00b6](#ruwbehavior)\n\n*Read under write behavior*\n\n#### Cases:\u00a0[\u00b6](#cases-6)\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Undefined | `0` | Undefined |\n| Old | `1` | Old |\n| New | `2` | New |\n\n### TargetKind\u00a0[\u00b6](#targetkind)\n\n*Object model target kind*\n\n#### Cases:\u00a0[\u00b6](#cases-7)\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| DontTouch | `0` | dont\\_touch |\n| Instance | `1` | instance |\n| MemberInstance | `2` | member\\_instance |\n| MemberReference | `3` | member\\_reference |\n| Reference | `4` | reference |\n\n [Prev - 'calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/ \"'calyx' Dialect\")\n[Next - 'comb' Dialect](https://circt.llvm.org/docs/Dialects/Comb/ \"'comb' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Comb/index.md"
  },
  {
    "role": "user",
    "content": "'comb' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'comb' Dialect\n==============\n\n*Types and operations for comb dialect*\n\nThis dialect defines the `comb` dialect, which is intended to be a generic\nrepresentation of combinational logic outside of a particular use-case.\n\n* [Operations](#operations)\n  + [`comb.add` (::circt::comb::AddOp)](#combadd-circtcombaddop)\n  + [`comb.and` (::circt::comb::AndOp)](#comband-circtcombandop)\n  + [`comb.concat` (::circt::comb::ConcatOp)](#combconcat-circtcombconcatop)\n  + [`comb.divs` (::circt::comb::DivSOp)](#combdivs-circtcombdivsop)\n  + [`comb.divu` (::circt::comb::DivUOp)](#combdivu-circtcombdivuop)\n  + [`comb.extract` (::circt::comb::ExtractOp)](#combextract-circtcombextractop)\n  + [`comb.icmp` (::circt::comb::ICmpOp)](#combicmp-circtcombicmpop)\n  + [`comb.mods` (::circt::comb::ModSOp)](#combmods-circtcombmodsop)\n  + [`comb.modu` (::circt::comb::ModUOp)](#combmodu-circtcombmoduop)\n  + [`comb.mul` (::circt::comb::MulOp)](#combmul-circtcombmulop)\n  + [`comb.mux` (::circt::comb::MuxOp)](#combmux-circtcombmuxop)\n  + [`comb.or` (::circt::comb::OrOp)](#combor-circtcomborop)\n  + [`comb.parity` (::circt::comb::ParityOp)](#combparity-circtcombparityop)\n  + [`comb.replicate` (::circt::comb::ReplicateOp)](#combreplicate-circtcombreplicateop)\n  + [`comb.reverse` (::circt::comb::ReverseOp)](#combreverse-circtcombreverseop)\n  + [`comb.shl` (::circt::comb::ShlOp)](#combshl-circtcombshlop)\n  + [`comb.shrs` (::circt::comb::ShrSOp)](#combshrs-circtcombshrsop)\n  + [`comb.shru` (::circt::comb::ShrUOp)](#combshru-circtcombshruop)\n  + [`comb.sub` (::circt::comb::SubOp)](#combsub-circtcombsubop)\n  + [`comb.truth_table` (::circt::comb::TruthTableOp)](#combtruth_table-circtcombtruthtableop)\n  + [`comb.xor` (::circt::comb::XorOp)](#combxor-circtcombxorop)\n* [Enums](#enums)\n  + [ICmpPredicate](#icmppredicate)\n\nOperations\n----------\n\n### `comb.add` (::circt::comb::AddOp)\n\nSyntax:\n\n```\noperation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.and` (::circt::comb::AndOp)\n\nSyntax:\n\n```\noperation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.concat` (::circt::comb::ConcatOp)\n\n*Concatenate a variadic list of operands together.*\n\nSee the comb rationale document for details on operand ordering.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.divs` (::circt::comb::DivSOp)\n\nSyntax:\n\n```\noperation ::= `comb.divs` (`bin` $twoState^)? $lhs `,` $rhs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a signless integer bitvector |\n| `rhs` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.divu` (::circt::comb::DivUOp)\n\nSyntax:\n\n```\noperation ::= `comb.divu` (`bin` $twoState^)? $lhs `,` $rhs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a signless integer bitvector |\n| `rhs` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.extract` (::circt::comb::ExtractOp)\n\n*Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.*\n\nSyntax:\n\n```\noperation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `lowBit` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.icmp` (::circt::comb::ICmpOp)\n\n*Compare two integer values*\n\nSyntax:\n\n```\noperation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))\n```\n\nThis operation compares two integers using a predicate. If the predicate is\ntrue, returns 1, otherwise returns 0. This operation always returns a one\nbit wide result.\n\n```\n    %r = comb.icmp eq %a, %b : i4\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `predicate` | circt::comb::ICmpPredicateAttr | hw.icmp comparison predicate |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a signless integer bitvector |\n| `rhs` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit signless integer |\n\n### `comb.mods` (::circt::comb::ModSOp)\n\nSyntax:\n\n```\noperation ::= `comb.mods` (`bin` $twoState^)? $lhs `,` $rhs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a signless integer bitvector |\n| `rhs` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.modu` (::circt::comb::ModUOp)\n\nSyntax:\n\n```\noperation ::= `comb.modu` (`bin` $twoState^)? $lhs `,` $rhs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a signless integer bitvector |\n| `rhs` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.mul` (::circt::comb::MulOp)\n\nSyntax:\n\n```\noperation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.mux` (::circt::comb::MuxOp)\n\n*Return one or the other operand depending on a selector bit*\n\nSyntax:\n\n```\noperation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue  attr-dict `:` qualified(type($result))\n```\n\n```\n  %0 = mux %pred, %tvalue, %fvalue : i4\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `cond` | 1-bit signless integer |\n| `trueValue` | any type |\n| `falseValue` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `comb.or` (::circt::comb::OrOp)\n\nSyntax:\n\n```\noperation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.parity` (::circt::comb::ParityOp)\n\nSyntax:\n\n```\noperation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit signless integer |\n\n### `comb.replicate` (::circt::comb::ReplicateOp)\n\n*Concatenate the operand a constant number of times*\n\nSyntax:\n\n```\noperation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.reverse` (::circt::comb::ReverseOp)\n\n*Reverses the bit order of an integer value*\n\nSyntax:\n\n```\noperation ::= `comb.reverse` $input attr-dict `:` type($input)\n```\n\nReverses the bit ordering of a value. The LSB becomes the MSB and vice versa.\n\nExample:\n\n```\n  %out = comb.reverse %in : i4\n```\n\nIf %in is 4\u2019b1101, then %out is 4\u2019b1011.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.shl` (::circt::comb::ShlOp)\n\nSyntax:\n\n```\noperation ::= `comb.shl` (`bin` $twoState^)? $lhs `,` $rhs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a signless integer bitvector |\n| `rhs` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.shrs` (::circt::comb::ShrSOp)\n\nSyntax:\n\n```\noperation ::= `comb.shrs` (`bin` $twoState^)? $lhs `,` $rhs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a signless integer bitvector |\n| `rhs` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.shru` (::circt::comb::ShrUOp)\n\nSyntax:\n\n```\noperation ::= `comb.shru` (`bin` $twoState^)? $lhs `,` $rhs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a signless integer bitvector |\n| `rhs` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.sub` (::circt::comb::SubOp)\n\nSyntax:\n\n```\noperation ::= `comb.sub` (`bin` $twoState^)? $lhs `,` $rhs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a signless integer bitvector |\n| `rhs` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `comb.truth_table` (::circt::comb::TruthTableOp)\n\n*Return a true/false based on a lookup table*\n\nSyntax:\n\n```\noperation ::= `comb.truth_table` $inputs `->` $lookupTable attr-dict\n```\n\n```\n  %a = ... : i1\n  %b = ... : i1\n  %0 = comb.truth_table %a, %b -> [false, true, true, false]\n```\n\nThis operation assumes a fully elaborated table \u2013 2^n entries. Inputs are\nsorted MSB -> LSB from left to right and the offset into `lookupTable` is\ncomputed from them. The table is sorted from 0 -> (2^n - 1) from left to\nright.\n\nNo difference from array\\_get into an array of constants except for xprop\nbehavior. If one of the inputs is unknown, but said input doesn\u2019t make a\ndifference in the output (based on the lookup table) the result should not\nbe \u2018x\u2019 \u2013 it should be the well-known result.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `lookupTable` | ::mlir::DenseBoolArrayAttr | i1 dense array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit signless integer |\n\n### `comb.xor` (::circt::comb::XorOp)\n\nSyntax:\n\n```\noperation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `twoState` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\nEnums\n-----\n\n### ICmpPredicate\n\n*Hw.icmp comparison predicate*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| eq | `0` | eq |\n| ne | `1` | ne |\n| slt | `2` | slt |\n| sle | `3` | sle |\n| sgt | `4` | sgt |\n| sge | `5` | sge |\n| ult | `6` | ult |\n| ule | `7` | ule |\n| ugt | `8` | ugt |\n| uge | `9` | uge |\n| ceq | `10` | ceq |\n| cne | `11` | cne |\n| weq | `12` | weq |\n| wne | `13` | wne |\n\n'comb' Dialect Docs\n-------------------\n\n* [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n\n [Prev - 'chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/ \"'chirrtl' Dialect\")\n[Next - `comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/ \"`comb` Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Comb/RationaleComb/index.md"
  },
  {
    "role": "user",
    "content": "`comb` Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n`comb` Dialect Rationale\n========================\n\nThis document describes various design points of the Comb dialect, a common\ndialect that is typically used in conjunction with the `hw` and `sv` dialects.\nPlease see the\n[`hw` Dialect Rationale](/docs/Dialects/HW/RationaleHW/) for high level insight\non how these work together. This follows in the spirit of\nother\n[MLIR Rationale docs](https://mlir.llvm.org/docs/Rationale/).\n\n* [`comb` Dialect Rationale](#comb-dialect-rationale)\n  + [Introduction to the `comb` Dialect](#introduction-to-the-comb-dialect)\n  + [Type System for `comb` Dialect](#type-system-for-comb-dialect)\n    - [Zero-bit integer width is not supported](#zero-bit-integer-width-is-not-supported)\n  + [Comb Operations](#comb-operations)\n    - [Fully associative operations are variadic](#fully-associative-operations-are-variadic)\n    - [Operators carry signs instead of types](#operators-carry-signs-instead-of-types)\n    - [No implicit extensions of operands](#no-implicit-extensions-of-operands)\n    - [No \u201cComplement\u201d, \u201cNegate\u201d, \u201cZExt\u201d, \u201cSExt\u201d, Operators](#no-complement-negate-zext-sext-operators)\n    - [No multibit mux operations](#no-multibit-mux-operations)\n  + [Endianness: operand ordering and internal representation](#endianness-operand-ordering-and-internal-representation)\n  + [Bitcasts](#bitcasts)\n  + [Cost Model](#cost-model)\n\nIntroduction to the `comb` Dialect\u00a0[\u00b6](#introduction-to-the-comb-dialect)\n-------------------------------------------------------------------------\n\nThe `comb` dialect provides a collection of operations that define a mid-level\ncompiler IR for combinational logic. It is *not* designed to model\nSystemVerilog or any other hardware design language directly. Instead, it is\ndesigned to be easy to analyze and transform, and be a flexible and extensible\nsubstrate that may be extended with higher level dialects mixed into it.\n\nType System for `comb` Dialect\u00a0[\u00b6](#type-system-for-comb-dialect)\n-----------------------------------------------------------------\n\nTODO: Simple integer types, eventually parametrically wide integer type\n`hw.int<width>`. Supports type aliases. See HW rationale for more info.\n\n### Zero-bit integer width is not supported\u00a0[\u00b6](#zero-bit-integer-width-is-not-supported)\n\nCombinational operations like add and multiply work on values of signless\nstandard integer types, e.g. `i42`, but they do not allow zero bit inputs. This\ndesign point is motivated by a couple of reasons:\n\n1. The semantics of some operations (e.g. `comb.sext`) do not have an obvious\n   definition with a zero bit input.\n2. Zero bit operations are useless for operations that are definable, and their\n   presence makes the compiler more complicated.\n\nOn the second point, consider an example like `comb.mux` which could allow zero\nbit inputs and therefore produce zero bit results. Allowing that as a design\npoint would require us to special case this in our cost models, and we would\nhave that optimizes it away.\n\nBy rejecting zero bit operations, we choose to put the complexity into the\nlowering passes that generate the HW dialect (e.g. LowerToHW from FIRRTL).\n\nNote that this decision only affects the core operations in the `comb` dialect\nitself - it is perfectly reasonable to define your operations and mix them into\nother `comb` constructs.\n\nComb Operations\u00a0[\u00b6](#comb-operations)\n-------------------------------------\n\nThis section contains notes about design decisions relating to\noperations in the `comb` dialect.\n\n### Fully associative operations are variadic\u00a0[\u00b6](#fully-associative-operations-are-variadic)\n\nTODO: describe why add/xor/or are variadic\n\n### Operators carry signs instead of types\u00a0[\u00b6](#operators-carry-signs-instead-of-types)\n\nOperators, in\n[LLVM-2.0 style](https://mlir.llvm.org/docs/Rationale/Rationale/#integer-signedness-semantics), which have consistent behavior in module\narithmetic with respect to signedness are not modeled with sign. `comb`\noperates on signless types with signless operations. This is in accordance\nwith LLVM\u2019s approach.\n\nSome operations, such as division, have different behaviors for signed v.s.\nunsigned types, thus they are modeled with different ops (`divu` and `divs`).\n\n### Selectable truth-table\u00a0[\u00b6](#selectable-truth-table)\n\nTo keep the interpretation of comb operators local to the dialect, each\noperation where it matters has an optional flag to indicate what semantics it needs\nto preserve. All operations are defined in the expected way for 2-state (binary) logic. However, comb is used for operations which have extended truth table for non-2-state logic for various target languages. To accommodate this, operations can opt into known extended truth tables so that any transformation will preserve semantics with respect to the extended truth table.\n\nInitially, operations support 2-state or the union of 4-state (verilog) and 9-state (VHDL) behavior. 2-state is specified with the \u201cbin\u201d flag on operations. In the future, explicit flags for \u201c4state\u201d and \u201c9state\u201d might be added.\n\nThis is done so as to not make the operations in comb type-dependent.\nThis is a tradeoff in that comb operations are either 2-state or the union of\ncommon backend language weirdness. This could be refined in the future.\n\n### No implicit extensions of operands\u00a0[\u00b6](#no-implicit-extensions-of-operands)\n\nVerilog and many other HDL\u2019s allow operators like `+` to work with\nmixed size operands, and some have complicated contextual rules about how wide\nthe result is (e.g. adding two 12 bit integers gives you a 13 bit result).\n\nWhile this is convenient for source programmers, this makes the job of compiler\nanalysis and optimization extremely challenging: peephole optimizations and\ndataflow transformations need to reason about these pervasively. Because the\n`comb` dialect is designed as a \u201cmid-level\u201d dialect focused on optimization,\nit doesn\u2019t allow implicit extensions: for example, `comb.add` takes the same\nwidth inputs and returns the same width result.\n\nThere is room in the future for other points in the design space: for example,\nit might be useful to add an `sv.add` operation that allows mixed operands to\nget better separation of concerns in the Verilog printer if we wanted really\nfancy extension elision. So far, very simple techniques have been enough to get\nreasonable output.\n\n### No \u201cComplement\u201d, \u201cNegate\u201d, \u201cZExt\u201d, \u201cSExt\u201d, Operators\u00a0[\u00b6](#no-complement-negate-zext-sext-operators)\n\nWe choose to omit several operators that you might expect, in order to make the\nIR more regular, easy to transform, and have fewer canonical forms.\n\n* No `~x` complement or `-x` negation operator: instead use `comb.xor(x, -1)`.\n  or `comb.sub(0, x)` respectively. These avoid having to duplicate many folds\n  between `xor` and `sub`.\n* No zero extension operator to add high zero bits. This is strictly redundant\n  with `concat(zero, value)`.\n* No sign extension operator to add high sign bits. `sext(x)` is strictly\n  redundant with `concat(replicate(extract(x, highbit)), x)`.\n\nThe absence of these operations doesn\u2019t affect the expressive ability of the IR,\nand ExportVerilog will notice these and generate the compact Verilog syntax\ne.g. a complement or negate when needed.\n\n### No multibit mux operations\u00a0[\u00b6](#no-multibit-mux-operations)\n\nThe comb dialect in CIRCT doesn\u2019t have a first-class multibit mux. Instead we\nprefer to use two array operations to represent this. For example, consider\na 3-bit condition:\n\n```\n hw.module @multibit_mux(%a: i32, %b: i32, %c: i32, %idx: i3) -> (%out: i32) {\n   %x_i32 = sv.constantX : i32\n   %tmpArray = hw.array_create %a, %b, %x_i32, %b, %c, %x_i32 : i32\n   %result   = hw.array_get %tmpArray[%idx] : !hw.array<6xi32>\n   hw.output %result: i32\n }\n```\n\nThis gets lowered into (something like) this Verilog:\n\n```\nmodule multibit_mux(\n  input  [31:0] a, b, c,\n  input  [2:0]  idx,\n  output [31:0] out);\n\n  wire [5:0][31:0] _T = {{a}, {b}, {32'bx}, {b}, {c}, {32'bx}};\n  assign out = _T[idx];\nendmodule\n```\n\nIn this example, the last X element could be dropped and generate\nequivalent code.\n\nWe believe that synthesis tools handle the correctly and generate efficient\nnetlists. For those that don\u2019t (e.g. Yosys), we have a `disallowPackedArrays`\nLoweringOption that legalizes away multi-dimensional arrays as part of lowering.\n\nWhile we could use the same approach for single-bit muxes, we choose to have a\nsingle bit `comb.mux` operation for a few reasons:\n\n* This is extremely common in hardware, and using 2x the memory to represent\n  the IR would be wasteful.\n* This are many peephole and other optimizations that apply to it.\n\nWe discussed these design points at length in an\n[August 11, 2021 design\nmeeting](https://docs.google.com/document/d/1fOSRdyZR2w75D87yU2Ma9h2-_lEPL4NxvhJGJd-s5pk/edit#heading=h.ygmlwiic5e1y), and\ndiscussed the tradeoffs of adding support for a single-operation mux. Such a\nmove has some advantages and disadvantages:\n\n1. It is another operation that many transformations would need to be aware of,\n   e.g. Verilog emission would have to handle it, and peephole optimizations\n   would have to be aware of `array_get` and `comb.mux`.\n2. We don\u2019t have any known analyses or optimizations that are difficult to\n   implement with the current representation.\n\nWe agreed that we\u2019d revisit in the future if there were a specific reason to\nadd it. Until then we represent the `array_create`/`array_get` pattern for\nfrontends that want to generate this.\n\n### Undefined value for division\u00a0[\u00b6](#undefined-value-for-division)\n\n`divu` and `divs` result in [Undefined Values][] when the\ndenominator is 0. It is expected that a frontend will use additional\noperations to implement the semantics required for that language. For\nexample, system verilog returns an `x` on divide by zero, thus its\nrepresentation may be\n`mux(denominator == 0, sv.constantx, divu(numerator,denominator))` whereas VHDL\nhas a runtime-trap in simulation, thus it may require\n`if(denominator==0) { assert() } else { divu(numerator,denominator)}` .\nSome vendor division blocks produce 0 in this case and\nthat could be modeled as `mux(denominator==0, 0, divu(numerator,denominator))`.\n\nSince division in general is very rare in real synthesizable HW, circt doesn\u2019t\nmake much effort to optimize divide by zero (nor even division in general, as\npreviously mentioned). Any guard to implement a specific semantic should by\nitself cause the actual divide by constant zero to be dead code.\n\nUndefined Values\u00a0[\u00b6](#undefined-values)\n---------------------------------------\n\nAn operation which produces an undefined value (as produced by `divu`, for example)\nunder some conditions is considered to have an instance-specific, static, pure function\nwhich takes as arguments the operands of the operation and produces a result. This\nfunction is potentially unique to each instance of the operation, may be different\nbetween compilations, is opaque, and return any value in the target\u2019s type system. It\nis guaranteed that repeated evaluation of the same operation with the same operands will\nreturn the same result.\n\nA division by zero, for example, could return any constant, either of its input,\n`x` or `z` (in SV or VHDL), the sum of its input, or the result of any other\ncombinatorial function.\n\nEndianness: operand ordering and internal representation\u00a0[\u00b6](#endianness-operand-ordering-and-internal-representation)\n----------------------------------------------------------------------------------------------------------------------\n\nCertain operations require ordering to be defined (i.e. `comb.concat`,\n`hw.array_concat`, and `hw.array_create`). There are two places where this\nis relevant: in the MLIR assembly and in the MLIR C++ model.\n\nIn MLIR assembly, operands are always listed MSB to LSB (big endian style):\n\n```\n%msb = comb.constant 0xEF : i8\n%mid = comb.constant 0x7 : i4\n%lsb = comb.constant 0xA018 : i16\n%result = comb.concat %msb, %mid, %lsb : i8, i4, i16\n// %result is 0xEF7A018\n```\n\n**Note**: Integers are always written in left-to-right lexical order. Operand\nordering for `concat.concat` was chosen to be consistent with simply abutting\nthem in lexical order.\n\n```\n%1 = comb.constant 0x1 : i4\n%2 = comb.constant 0x2 : i4\n%3 = comb.constant 0x3 : i4\n%arr123 = hw.array_create %1, %2, %3 : i4\n// %arr123[0] = 0x3\n// %arr123[1] = 0x2\n// %arr123[2] = 0x1\n\n%arr456 = ... // {0x4, 0x5, 0x6}\n%arr78  = ... // {0x7, 0x8}\n%arr = comb.array_concat %arr123, %arr456, %arr78 : !hw.array<3 x i4>, !hw.array<3 x i4>, !hw.array<2 x i4>\n// %arr[0] = 0x8\n// %arr[1] = 0x7\n// %arr[2] = 0x6\n// %arr[3] = 0x5\n// %arr[4] = 0x4\n// %arr[5] = 0x3\n// %arr[6] = 0x2\n// %arr[7] = 0x1\n```\n\n**Note**: This ordering scheme is unintuitive for anyone expecting C\narray-like ordering. In C, arrays are laid out with index 0 as the least\nsignificant value and the first element (lexically) in the array literal. In\nthe CIRCT *model* (assembly and C++ of the operation creating the array), it\nis the opposite \u2013 the most significant value is on the left (e.g. the first\noperand is the most significant). The indexing semantics at runtime, however,\ndiffer in that the element zero is the least significant (which is lexically\non the right).\n\nIn the CIRCT C++ model, lists of values are in lexical order. That is, index\nzero of a list is the leftmost operand in assembly, which is the most\nsignificant value.\n\n```\nConcatOp result = ConcatOp::create(builder, ..., {msb, lsb});\n// Is equivalent to the above integer concatenation example.\nArrayConcatOp arr = ArrayConcatOp::create(builder, ..., {arr123, arr456});\n// Is equivalent to the above array example.\n```\n\n**Array slicing and indexing** (`array_get`) operations both have indexes as\noperands. These indexes are the *runtime* index, **not** the index in the\noperand list which created the array upon which the op is running.\n\nBitcasts\u00a0[\u00b6](#bitcasts)\n-----------------------\n\nThe bitcast operation represents a bitwise reinterpretation (cast) of a value.\nThis always synthesizes away in hardware, though it may or may not be\nsyntactically represented in lowering or export language. Since bitcasting\nrequires information on the bitwise layout of the types on which it operates,\nwe discuss that here. All of the types are *packed*, meaning there is never\npadding or alignment.\n\n* **Integer bit vectors**: MLIR\u2019s `IntegerType` with `Signless` semantics are\n  used to represent bit vectors. They are never padded or aligned.\n* **Arrays**: The HW dialect defines a custom `ArrayType`. The in-hardware\n  layout matches C \u2013 the high index of array starts at the MSB. Array\u2019s 0th\n  element\u2019s LSB located at array LSB.\n* **Structs**: The HW dialect defines a custom `StructType`. The in-hardware\n  layout matches C \u2013 the first listed member\u2019s MSB corresponds to the struct\u2019s\n  MSB. The last member in the list shares its LSB with the struct.\n* **Unions**: The HW dialect\u2019s `UnionType` could contain the data of any of the\n  member types so its layout is defined to be equivalent to the union of members\n  type bitcast layout. In cases where the member types have different bit widths,\n  all members start at the 0th bit and are padded up to the width of the widest\n  member. The value with which they are padded is undefined.\n\n**Example figure**\n\n```\n15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 \n-------------------------------------------------\n| MSB                                       LSB | 16 bit integer vector\n-------------------------------------------------\n                         | MSB              LSB | 8 bit integer vector\n-------------------------------------------------\n| MSB      [1]       LSB | MSB     [0]      LSB | 2 element array of 8 bit integer vectors\n-------------------------------------------------\n\n      13 12 11 10  9  8  7  6  5  4  3  2  1  0 \n                            ---------------------\n                            | MSB           LSB | 7 bit integer vector\n      -------------------------------------------\n      | MSB     [1]     LSB | MSB    [0]    LSB | 2 element array of 7 bit integer vectors\n      -------------------------------------------\n      | MSB a LSB | MSB b[1] LSB | MSB b[0] LSB | struct\n      -------------------------------------------  a: 4 bit integral\n                                                   b: 2 element array of 5 bit integer vectors\n```\n\nCost Model\u00a0[\u00b6](#cost-model)\n---------------------------\n\nAs a very general mid-level IR, it is important to define the principles that\ncanonicalizations and other general purpose transformations should optimize for.\nThere are often many different ways to represent a piece of logic in the IR, and\nthings will work better together if we keep the compiler consistent.\n\nFirst, unlike something like LLVM IR, keep in mind that the HW dialect is a\nmodel of hardware \u2013 each operation generally corresponds to an instance of\nhardware, it is not an \u201cinstruction\u201d that is executed by an imperative CPU.\nAs such, the primary concerns are area and latency (and size of generated\nVerilog), not \u201cnumber of operations executed\u201d. As such, here are important\nconcerns that general purpose\ntransformations should consider, ordered from most important to least important.\n\n**Simple transformations are always profitable**\n\nMany simple transformations are always a good thing, this includes:\n\n1. Constant folding.\n2. Simple strength reduction (e.g. divide to shift).\n3. Common subexpression elimination.\n\nThese generally reduce the size of the IR in memory, can reduce the area of a\nsynthesized design, and often unblock secondary transformations.\n\n**Reducing widths of non-trivial operations is always profitable**\n\nIt is always a good idea to reduce the width of non-trivial operands like add,\nmultiply, shift, divide, `and`, `or` (etc) since it produces less hardware and\nenables other simplifications.\n\nThat said, it is a bad idea to *duplicate* operations to reduce widths: for\nexample, it is better to have one large multiply with many users than to clone\nit because one user only needs some of the output bits.\n\nIt is also beneficial to reduce widths, even if it adds truncations or\nextensions in the IR (because they are \u201cjust wires\u201d). However, there are limits:\nany and-by-constant could be lowered to a concat of each bit principle,\ne.g. it is legal to turn `and(x, 9)` into `concat(x[3], 00, x[0])`. Doing so is\nconsidered unprofitable though, because it bloats the IR (and generated\nVerilog).\n\n**Don\u2019t get overly tricky with divide and remainder**\n\nDivide operations (particularly those with non-constant divisors) generate a lot\nof hardware, and can have long latencies. As such, it is a generally bad idea\nto do anything to an individual instance of a divide that can increase its\nlatency (e.g. merging a narrow divide with a wider divide and using a subset of\nthe result bits).\n\n**Constants and moving bits around is free**\n\nThe following are considered \u201cfree\u201d for area and latency concerns:\n\n1. `hw.constant`\n2. concatenation (including zero/sign extension idioms) and truncation\n3. `comb.and` and `comb.or` with a constant.\n4. Other similar operations that do not synthesize into hardware.\n\nAll things being equal it is good to reduce the number of instances of these (to\nreduce IR size and increase canonical form) but it is ok to introduce more of\nthese to improve on other metrics above.\n\n**Ordering Concat and Extract**\n\nThe`concat(extract(..))` form is preferred over the `extract(concat(..))` form,\nbecause\n\n* `extract` gets \u201ccloser\u201d to underlying `add/sub/xor/op` operations, giving way\n  optimizations like narrowing.\n* the form gives a more accurate view of the values that are being depended on.\n* redundant extract operations can be removed from the concat argument lists,\n  e.g.:\n  `cat(extract(a), b, c, extract(d))`\n\nBoth forms perform similarly on hardware, since they are simply bit-copies.\n\n [Prev - 'comb' Dialect](https://circt.llvm.org/docs/Dialects/Comb/ \"'comb' Dialect\")\n[Next - 'datapath' Dialect](https://circt.llvm.org/docs/Dialects/Datapath/ \"'datapath' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect-](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Datapath/index.md"
  },
  {
    "role": "user",
    "content": "'datapath' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'datapath' Dialect\n==================\n\n*Datapath Optimization*\n\nThis dialect defines the `datapath` dialect, which is about the efficient\nconstruction of arithmetic circuits via low-level datapath optimizations.\n\n* [Operations](#operations)\n  + [`datapath.compress` (::circt::datapath::CompressOp)](#datapathcompress-circtdatapathcompressop)\n  + [`datapath.partial_product` (::circt::datapath::PartialProductOp)](#datapathpartial_product-circtdatapathpartialproductop)\n  + [`datapath.pos_partial_product` (::circt::datapath::PosPartialProductOp)](#datapathpos_partial_product-circtdatapathpospartialproductop)\n\nOperations\n----------\n\n### `datapath.compress` (::circt::datapath::CompressOp)\n\n*Reduce a set of bitvectors to a carry-save representation*\n\nSyntax:\n\n```\noperation ::= `datapath.compress` $inputs attr-dict `:` custom<CompressFormat>(type($inputs), type($results))\n```\n\nReduce an array of bitvectors to a smaller set of bitvectors (at least 2).\nA compressor tree sums multiple bitvectors (often partial products in\nmultipliers or adders). Instead of adding all bitvectors sequentially, a\ncompressor tree reduces the number of operands in parallel stages. The\nresult is stored in a redundant (carry-save) representation, deferring the\ncompressor tree implementation to a later stage.\n\nExample:\n\n```\n%0:2 = datapath.compress %a, %b, %c : i16 [3 -> 2]\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of a signless integer bitvector |\n\n### `datapath.partial_product` (::circt::datapath::PartialProductOp)\n\n*Generate partial products from multiplying the operands*\n\nSyntax:\n\n```\noperation ::= `datapath.partial_product` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n```\n\nThe first step in a multiplication is to generate partial products, which\nwhen summed, yield the product of the two operands. The partial\nproduct operator does not specify an implementation, only that summing the\nresults will yield the product of the two operands. The number of results\ncorresponds to the rows of a partial product array, which by default is\nequal to the width of the inputs.\n\nVerilog Example 4-bit multiplication:\n\n```\npartial_product[0][3:0] = {4{a[0]}} & b\n...\npartial_product[3][3:0] = {4{a[3]}} & b\nab[3:0] = partial_product[0] + ... + partial_product[3] // = a*b\n```\n\nExample using `datapath` dialect:\n\n```\n%0:4 = datapath.partial_product %a, %b : (i4, i4) -> (i4, i4, i4, i4)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a signless integer bitvector |\n| `rhs` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of a signless integer bitvector |\n\n### `datapath.pos_partial_product` (::circt::datapath::PosPartialProductOp)\n\n*Generate partial products for (a+b)\\*c*\n\nSyntax:\n\n```\noperation ::= `datapath.pos_partial_product` $addend0  `,` $addend1 `,` $multiplicand attr-dict `:` functional-type(operands, results)\n```\n\nA partial product array which when summed produces the result (a+b)\\*c.\nAn efficient circuit can be constructed that encodes a carry-save input\nwithout performing a full carry-propagation. The number of results\ncorresponds to the rows of a partial product array, which by default is\nequal to the width of the inputs.\n\nExample using `datapath` dialect:\n\n```\n%0:3 = datapath.pos_partial_product %a, %b, %c : (i3, i3, i3) \n                                              -> (i3, i3, i3)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `addend0` | a signless integer bitvector |\n| `addend1` | a signless integer bitvector |\n| `multiplicand` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of a signless integer bitvector |\n\n'datapath' Dialect Docs\n-----------------------\n\n* ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n\n [Prev - `comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/ \"`comb` Dialect Rationale\")\n[Next - 'datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/ \"'datapath' Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/index.md"
  },
  {
    "role": "user",
    "content": "'datapath' Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'datapath' Dialect Rationale\n============================\n\nThis document outlines the rationale of the datapath dialect, a dialect used for the efficient construction of arithmetic circuits.\n\n* [Introduction to the `datapath` dialect](#introduction-to-the-datapath-dialect)\n* [Intended Usage](#intended-usage)\n* [Example](#example)\n\nIntroduction to the `datapath` dialect\u00a0[\u00b6](#introduction-to-the-datapath-dialect)\n---------------------------------------------------------------------------------\n\nDatapath design refers to the process of lowering arithmetic circuits to gate-level designs. When lowering arithmetic operations such as `comb.add` and `comb.mul` to gate-level implementations there are many component-level implementations to choose from. At the core of efficient gate-level implementations are a collection of circuit constructs that are composed to perform an arithmetic\noperation on bitvectors. For example, in computer arithmetic a `comb.mul` would be comprised of three steps:\n\n1. Partial Product generation\n2. Compressor tree reduction to carry-save format\n3. Carry-propagate adder\n\nDecomposing arithmetic operators into their efficient sub-circuits creates opportunities to optimise and fuse arithmetic operations together.\n[Reto Zimmerman\u2019s work](https://iis-people.ee.ethz.ch/~zimmi/publications/sop_synthesis.pdf) provides a good overview of some of the optimisations\nthat the `datapath` dialect can expose. The core idea is to avoid inserting expensive carry-propagate adders and to leverage carry-save representations.\nThe `datapath` operations themselves should be thought of more as generators than concretelty specified mathematical operations.\n\nIntended Usage\u00a0[\u00b6](#intended-usage)\n-----------------------------------\n\nThe `datapath` dialect is designed to be used as part of a synthesis flow, lowering a subset of `comb` operations to `datapath` operations. Optimisation passes on the `datapath` dialect can merge operations to form larger datapath blocks, where carry-propagation is deferred. The `datapath` operations can then be lowered into a subset of `comb`, consisting of only gate-level operations.\n\nExample\u00a0[\u00b6](#example)\n---------------------\n\nIn a simple example, we can fold a\\*b+c using the datapath dialect to remove a carry-propagate adder:\n\n```\n%0 = comb.mul %a, %b : i4\n%1 = comb.add %0, %c : i4\n```\n\nWhich is equivalent to:\n\n```\n%0:4 = datapath.partial_product %a, %b : (i4, i4) -> (i4, i4, i4, i4)\n%1:2 = datapath.compress %0#0, %0#1, %0#2, %0#3, %c : i4 [5 -> 2]\n%2 = comb.add %1#0, %1#1 : i4\n```\n\n [Prev - 'datapath' Dialect](https://circt.llvm.org/docs/Dialects/Datapath/ \"'datapath' Dialect\")\n[Next - 'dc' Dialect](https://circt.llvm.org/docs/Dialects/DC/ \"'dc' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect-](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/DC/index.md"
  },
  {
    "role": "user",
    "content": "'dc' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'dc' Dialect\n============\n\n*Dynamic Control*\n\nThis is the `dc` dialect, used to represent dynamic control constructs with\nhandshaking semantics.\n\n* [Operations](#operations)\n  + [`dc.branch` (circt::dc::BranchOp)](#dcbranch-circtdcbranchop)\n  + [`dc.buffer` (circt::dc::BufferOp)](#dcbuffer-circtdcbufferop)\n  + [`dc.fork` (circt::dc::ForkOp)](#dcfork-circtdcforkop)\n  + [`dc.from_esi` (circt::dc::FromESIOp)](#dcfrom_esi-circtdcfromesiop)\n  + [`dc.join` (circt::dc::JoinOp)](#dcjoin-circtdcjoinop)\n  + [`dc.merge` (circt::dc::MergeOp)](#dcmerge-circtdcmergeop)\n  + [`dc.pack` (circt::dc::PackOp)](#dcpack-circtdcpackop)\n  + [`dc.select` (circt::dc::SelectOp)](#dcselect-circtdcselectop)\n  + [`dc.sink` (circt::dc::SinkOp)](#dcsink-circtdcsinkop)\n  + [`dc.source` (circt::dc::SourceOp)](#dcsource-circtdcsourceop)\n  + [`dc.to_esi` (circt::dc::ToESIOp)](#dcto_esi-circtdctoesiop)\n  + [`dc.unpack` (circt::dc::UnpackOp)](#dcunpack-circtdcunpackop)\n* [Types](#types)\n  + [TokenType](#tokentype)\n  + [ValueType](#valuetype)\n\nOperations\n----------\n\n### `dc.branch` (circt::dc::BranchOp)\n\n*Branch operation*\n\nSyntax:\n\n```\noperation ::= `dc.branch` $condition attr-dict\n```\n\nThe incoming select token is propagated to the selected output based on\nthe value of the condition.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `condition` | must be a !dc.value type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `trueToken` |  |\n| `falseToken` |  |\n\n### `dc.buffer` (circt::dc::BufferOp)\n\n*Buffer operation*\n\nSyntax:\n\n```\noperation ::= `dc.buffer` `[` $size `]` $input ($initValues^)? attr-dict `:` type($input)\n```\n\nThe buffer operation may buffer a `dc.value` or `dc.token` typed SSA value.\nIn practice, this provides a mechanism to buffer data-side values in a\ncontrol-sensitive manner.\n\nExample:\n\n```\n%value_out = dc.buffer [2] %value : !dc.value<i32, i1, i4>\n```\n\n**Hardware/CIRCT context note**: buffers have no dialect-side notion of\ncycles/stages/implementation. It is up to the generating pass to interpret\nbuffer semantics - some may want to add attributes to a single buffer, some\nmay want to stagger `dc.buffer`s sequentially.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `size` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n| `initValues` | ::mlir::ArrayAttr | array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | must be a !dc.value or !dc.token type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | must be a !dc.value or !dc.token type |\n\n### `dc.fork` (circt::dc::ForkOp)\n\n*Splits the incoming token into multiple outgoing tokens*\n\nThis operator splits the incoming token into multiple outgoing tokens.\n\nExample:\n\n```\n%0, %1 = dc.fork [2] %a : !dc.token, !dc.token\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `token` |  |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of |\n\n### `dc.from_esi` (circt::dc::FromESIOp)\n\n*Convert an ESI-typed value to a DC-typed value*\n\nSyntax:\n\n```\noperation ::= `dc.from_esi` $input attr-dict `:` type($input)\n```\n\nConvert an ESI channel to a `dc.token/dc.value`.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | must be a !dc.value or !dc.token type |\n\n### `dc.join` (circt::dc::JoinOp)\n\n*Synchronizes the incoming tokens with the outgoing token*\n\nSyntax:\n\n```\noperation ::= `dc.join` $tokens attr-dict\n```\n\nThis operator synchronizes all incoming tokens. Synchronization implies applying\njoin semantics in between all in- and output ports.\n\nExample:\n\n```\n%0 = dc.join %a, %b\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `tokens` | variadic of |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` |  |\n\n### `dc.merge` (circt::dc::MergeOp)\n\n*Merge operation*\n\nSyntax:\n\n```\noperation ::= `dc.merge` $first `,` $second attr-dict\n```\n\nSelect one of the incoming tokens and emits an output stating which token\nwas selected. If multiple tokens are ready to transact at the same time,\nthe tokens are selected with priority, from first to last (i.e. left to right\nin the IR). This property ensures deterministic behavior.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `first` |  |\n| `second` |  |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | must be a !dc.value type |\n\n### `dc.pack` (circt::dc::PackOp)\n\n*Pack operation*\n\nSyntax:\n\n```\noperation ::= `dc.pack` $token `,` $input attr-dict `:` type($input)\n```\n\nAn operation which packs together a !dc.token value with some other\nvalue.\n\nTypically, a `dc.pack` op will be used to facilitate data-dependent\ncontrol flow, wherein a `dc.value<i1>` is to be generated as a select\nsignal for either a `dc.branch` or `dc.select` operation.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `token` |  |\n| `input` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` |  |\n\n### `dc.select` (circt::dc::SelectOp)\n\n*Select operation*\n\nSyntax:\n\n```\noperation ::= `dc.select` $condition `,` $trueToken `,` $falseToken attr-dict\n```\n\nAn input token is selected based on the value of the incoming select\nsignal, and propagated to the single output. Only the condition value,\nthe selected input, and the output will be transacted.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `condition` | must be a !dc.value type |\n| `trueToken` |  |\n| `falseToken` |  |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` |  |\n\n### `dc.sink` (circt::dc::SinkOp)\n\n*Sink operation*\n\nSyntax:\n\n```\noperation ::= `dc.sink` $token attr-dict\n```\n\nThe sink operation will always accept any incoming tokens, and\ndiscard them.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `token` |  |\n\n### `dc.source` (circt::dc::SourceOp)\n\n*Source operation*\n\nSyntax:\n\n```\noperation ::= `dc.source` attr-dict\n```\n\nThe source operation will always produce a token.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` |  |\n\n### `dc.to_esi` (circt::dc::ToESIOp)\n\n*Convert a DC-typed value to an ESI-typed value*\n\nSyntax:\n\n```\noperation ::= `dc.to_esi` $input attr-dict `:` type($input)\n```\n\nConvert a `dc.token/dc.value` to an ESI channel.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | must be a !dc.value or !dc.token type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `dc.unpack` (circt::dc::UnpackOp)\n\n*Unpack operation*\n\nSyntax:\n\n```\noperation ::= `dc.unpack` $input attr-dict `:` qualified(type($input))\n```\n\nAn operation which unpacks a !dc.value value into a !dc.token value\nand its constituent values.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` |  |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `token` |  |\n| `output` | any type |\n\nTypes\n-----\n\n### TokenType\n\nSyntax: `!dc.token`\n\nA `!dc.token`-typed value represents a control value with handshake semantics.\n\n### ValueType\n\nSyntax:\n\n```\n!dc.value<\n  Type   # innerType\n>\n```\n\nA `!dc.value`-typed value represents a value which is wrapped with\n`!dc.token` semantics. This type is used to attach control semantics to\nvalues. The inner value may be of any type.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| innerType | `Type` |  |\n\n'dc' Dialect Docs\n-----------------\n\n* [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n\n [Prev - 'datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/ \"'datapath' Dialect Rationale\")\n[Next - DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/ \"DC Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/DC/RationaleDC/index.md"
  },
  {
    "role": "user",
    "content": "DC Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nDC Dialect Rationale\n====================\n\n* [Introduction](#introduction)\n* [Value (channel) semantics](#value-channel-semantics)\n* [Canonicalization](#canonicalization)\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\nDC (**D**ynamic **C**ontrol) IR describes independent, unsynchronized processes\ncommunicating data through First-in First-out (FIFO) communication channels.\nThis can be implemented in many ways, such as using synchronous logic, or with\nprocessors.\n\nThe intention of DC is to model all operations required to represent such a\ncontrol flow language. DC aims to be strictly a control\nflow dialect - as opposed to the Handshake dialect, which assigns control\nsemantics to *all* SSA values. As such, data values are\nonly present in DC where they are required to model control flow.\n\nBy having such a control language, the dialect aims to facilitate the\nconstruction of dataflow programs where control and data\nis explicitly separate. This enables optimization of the control and data side\nof the program independently, as well as mapping\nof the data side into functional units, pipelines, etc.. Furthermore, separating\ndata and control will make it easier to reason about possible critical paths of\neither circuit, which may inform buffer placement.\n\nThe DC dialect has been heavily influenced by the Handshake dialect, and can\neither be seen as a successor to it, or a lower level\nabstraction. As of writing, DC is *fully deterministic*. This means that\nnon-deterministic operators such as the ones found in Handshake -\n`handshake.merge, handshake.control_merge` - do **not** have a lowering to DC.\nHandshake programs must therefore be converted or by construction not contain\nany of these non-deterministic operators. Apart from that, **all** handshake\noperations can be lowered to a combination of DC\nand e.g. `arith` operations (to represent the data side semantics of any given\noperation).\n\nIn DC IR, all values have implicit fork and sink semantics. That is, a DC-typed\nvalue may be referenced multiple times, as well as it being legal that said\nvalue is not referenced at all. This has been chosen to facilitate\ncanonicalization, thus removing the need for all canonicalization patterns to\nview forks as opaque/a special case. If a given DC lowering requires explcit\nfork/sink semantics, forks and sinks can be *materialized* throuh use of the\n`--dc-materialize-forks-sinks` pass. Conversely, if one wishes to optimize DC\nIR which already contains fork and sink operations, one may use the\n`--dc-dematerialize-forks-sinks` pass, run canonicalization, and then re-apply\nthe `--dc-materialize-forks-sinks` pass.\n\nValue (channel) semantics\u00a0[\u00b6](#value-channel-semantics)\n-------------------------------------------------------\n\n1. **Latency insensitive**:\n   * Any DC-typed value (`dc.token/dc.value<T...>`) has latency insensitive\n     semantics.\n   * DC does **not** specify the implementation of this latency\n     insensitivity, given that it strictly pertains to the **control** of latency\n     insensitive values. This should reinforce the mental model that DC isn\u2019t\n     strictly a hardware construct - that is, DC values could be implemented in\n     hardware by e.g ready/valid semantics or by FIFO interfaces (read/write, full, empty, \u2026)\n     or in software by e.g. message queues, RPC, or other streaming protocols.\n   * In the current state of the world (CIRCT), DC uses ESI to implement its\n     latency insensitive hardware protocol. By doing so, we let DC do what DC does\n     best (control language) and likewise with ESI (silicon interconnect).\n2. **Values are channels**:\n   * Given the above latency insensitivity, it is useful to think of DC values\n     as channels, wherein a channel can be arbitrarily buffered without changing the\n     semantics of the program.\n3. **FIFO semantics**:\n   * DC-typed values have FIFO semantics, meaning that the order of values in\n     the \u2018channel\u2019 is preserved (i.e. the order of values written to the channel is\n     the same as the order of values read from the channel).\n\nCanonicalization\u00a0[\u00b6](#canonicalization)\n---------------------------------------\n\nBy explicitly separating data and control parts of a program, we allow for\ncontrol-only canonicalization to take place.\nHere are some examples of non-trivial canonicalization patterns:\n\n* **Transitive join closure**:\n  + Taking e.g. the Handshake dialect as the source abstraction, all\n    operations - unless some specific Handshake operations - will be considered as\n    *unit rate actors* and have join semantics. When lowering Handshake to DC, and\n    by separating the data and control paths, we can easily identify `join`\n    operations which are staggered, and can be merged through a transitive closure\n    of the control graph.\n* **Branch to select**: Canonicalizes away a select where its inputs originate\n  from a branch, and both have the same select signal.\n* **Identical join**: Canonicalizes away joins where all inputs are the same\n  (i.e. a single join can be used).\n\n [Prev - 'dc' Dialect](https://circt.llvm.org/docs/Dialects/DC/ \"'dc' Dialect\")\n[Next - 'emit' Dialect](https://circt.llvm.org/docs/Dialects/Emit/ \"'emit' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect-](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Emit/index.md"
  },
  {
    "role": "user",
    "content": "'emit' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'emit' Dialect\n==============\n\n*Types and operations for the `emit` dialect*\n\nThe `emit` dialect is intended to model the structure of the emitted RTL.\n\nIt organizes the files, file lists, directories and collateral.\n\n* [Operations](#operations)\n  + [`emit.file` (::circt::emit::FileOp)](#emitfile-circtemitfileop)\n  + [`emit.file_list` (::circt::emit::FileListOp)](#emitfile_list-circtemitfilelistop)\n  + [`emit.fragment` (::circt::emit::FragmentOp)](#emitfragment-circtemitfragmentop)\n  + [`emit.ref` (::circt::emit::RefOp)](#emitref-circtemitrefop)\n  + [`emit.verbatim` (::circt::emit::VerbatimOp)](#emitverbatim-circtemitverbatimop)\n\nOperations\n----------\n\n### `emit.file` (::circt::emit::FileOp)\n\n*Represents the contents of an emitted file*\n\nSyntax:\n\n```\noperation ::= `emit.file` $file_name (`sym` $sym_name^)? $bodyRegion attr-dict\n```\n\nThis operation groups a set of nested operations to be emitted to a file.\n\nOther operations (such as file lists)can reference a file to access its\nfilename through an optional symbol.\n\nTraits: `IsolatedFromAbove`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `file_name` | ::mlir::StringAttr | string attribute |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `emit.file_list` (::circt::emit::FileListOp)\n\n*Represents a file list*\n\nSyntax:\n\n```\noperation ::= `emit.file_list` $file_name `,` $files (`sym` $sym_name^)? attr-dict\n```\n\nThis operation emits a file list referencing a set of files.\n\nFile lists can be references from other ops (including other file lists)\nthrough an optional symbol.\n\nInterfaces: `SymbolUserOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `file_name` | ::mlir::StringAttr | string attribute |\n| `files` | ::mlir::ArrayAttr | flat symbol ref array attribute |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `emit.fragment` (::circt::emit::FragmentOp)\n\n*Emittable fragment which can be replicated before modules*\n\nSyntax:\n\n```\noperation ::= `emit.fragment` $sym_name $bodyRegion attr-dict\n```\n\nThe fragment operation is a container for other operations that can\nbe emitted before other operations. It carries a symbol that can be\nreferenced by an `emit.fragments` attribute placed on operations before\nwhich the fragments should be inserted.\n\nIn single-file mode, each fragment is emitted once. In split file emission\nmode, fragments precede all operations that reference them, but are still\nemitted at most once per file.\n\nTraits: `HasParent<mlir::ModuleOp>`, `IsolatedFromAbove`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `emit.ref` (::circt::emit::RefOp)\n\n*Print a referenced SV operation inline into the file*\n\nSyntax:\n\n```\noperation ::= `emit.ref` $target attr-dict\n```\n\nThe `emit.ref` operation targets an op via a symbol, emitting its\ncontents into the file it is part of. The set of targetable\noperations and the emission rules are defined in ExportVerilog.\n\nTraits: `HasParent<circt::emit::FileOp>`\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `target` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n### `emit.verbatim` (::circt::emit::VerbatimOp)\n\n*Verbatim opaque text emitted inline.*\n\nSyntax:\n\n```\noperation ::= `emit.verbatim` $text attr-dict\n```\n\nThis operation produces opaque text inline in the file.\n\n`emit.verbatim` allows symbol reference substitutions with {{0}} syntax.\n\nTraits: `HasParent<circt::emit::FileOp>`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `text` | ::mlir::StringAttr | string attribute |\n\n'emit' Dialect Docs\n-------------------\n\n* [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n\n [Prev - DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/ \"DC Dialect Rationale\")\n[Next - Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/ \"Emission (Emit) Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Emit/RationaleEmit/index.md"
  },
  {
    "role": "user",
    "content": "Emission (Emit) Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nEmission (Emit) Dialect Rationale\n=================================\n\nThis document describes various design points of the `emit` dialect, why it is\nthe way it is, and current status. This follows in the spirit of other\n[MLIR\nRationale docs](https://mlir.llvm.org/docs/Rationale/).\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\nThe `emit` dialects controls the structure and formatting of the files emitted\nfrom CIRCT. It captures information about both SystemVerilog output files and\ngeneric collateral files. The ops are translated to output files in\n`ExportVerilog`. Presently, the dialect is intertwined with SystemVerilog -\nit can reference items in a design through symbols to emit references to\nthem through SystemVerilog names in the output.\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\nThe dialect is centred around the `emit.file` operation which groups a list\nof statements in its body, responsible for producing the contents of the file.\nThe `emit.file_list` operation pins down a list of references to emitted files\nand outputs a file list file enumerating the paths to them.\nTogether, these operations represent the SV and collateral output of CIRCT.\n\n [Prev - 'emit' Dialect](https://circt.llvm.org/docs/Dialects/Emit/ \"'emit' Dialect\")\n[Next - 'esi' Dialect](https://circt.llvm.org/docs/Dialects/ESI/ \"'esi' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect-](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/ESI/index.md"
  },
  {
    "role": "user",
    "content": "'esi' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'esi' Dialect\n=============\n\nThe Elastic Silicon Interconnect dialect aims to aid in accelerator system construction.\n\n**WARNING**: The ESI dialect has evolved significantly since its inception while\nthese documents have not. As such, large parts are significantly out-of-date.\n\n* [Application channels](#application-channels)\n  + [ChannelBundleType](#channelbundletype)\n  + [ChannelType](#channeltype)\n  + [ClockType](#clocktype)\n  + [ListType](#listtype)\n  + [WindowType](#windowtype)\n  + [FirMemType](#firmemtype)\n  + [HLMemType](#hlmemtype)\n  + [ImmutableType](#immutabletype)\n  + [WindowFieldType](#windowfieldtype)\n  + [WindowFrameType](#windowframetype)\n  + [ListType](#listtype-1)\n  + [`esi.buffer` (::circt::esi::ChannelBufferOp)](#esibuffer-circtesichannelbufferop)\n  + [`esi.cosim.from_host` (::circt::esi::CosimFromHostEndpointOp)](#esicosimfrom_host-circtesicosimfromhostendpointop)\n  + [`esi.cosim.to_host` (::circt::esi::CosimToHostEndpointOp)](#esicosimto_host-circtesicosimtohostendpointop)\n  + [`esi.fifo` (::circt::esi::FIFOOp)](#esififo-circtesififoop)\n  + [`esi.null` (::circt::esi::NullSourceOp)](#esinull-circtesinullsourceop)\n  + [`esi.bundle.pack` (::circt::esi::PackBundleOp)](#esibundlepack-circtesipackbundleop)\n  + [`esi.stage` (::circt::esi::PipelineStageOp)](#esistage-circtesipipelinestageop)\n  + [`esi.snoop.xact` (::circt::esi::SnoopTransactionOp)](#esisnoopxact-circtesisnooptransactionop)\n  + [`esi.snoop.vr` (::circt::esi::SnoopValidReadyOp)](#esisnoopvr-circtesisnoopvalidreadyop)\n  + [`esi.bundle.unpack` (::circt::esi::UnpackBundleOp)](#esibundleunpack-circtesiunpackbundleop)\n  + [`esi.unwrap.fifo` (::circt::esi::UnwrapFIFOOp)](#esiunwrapfifo-circtesiunwrapfifoop)\n  + [`esi.unwrap.iface` (::circt::esi::UnwrapSVInterfaceOp)](#esiunwrapiface-circtesiunwrapsvinterfaceop)\n  + [`esi.unwrap.vr` (::circt::esi::UnwrapValidReadyOp)](#esiunwrapvr-circtesiunwrapvalidreadyop)\n  + [`esi.window.unwrap` (::circt::esi::UnwrapWindow)](#esiwindowunwrap-circtesiunwrapwindow)\n  + [`esi.wrap.fifo` (::circt::esi::WrapFIFOOp)](#esiwrapfifo-circtesiwrapfifoop)\n  + [`esi.wrap.iface` (::circt::esi::WrapSVInterfaceOp)](#esiwrapiface-circtesiwrapsvinterfaceop)\n  + [`esi.wrap.vr` (::circt::esi::WrapValidReadyOp)](#esiwrapvr-circtesiwrapvalidreadyop)\n  + [`esi.window.wrap` (::circt::esi::WrapWindow)](#esiwindowwrap-circtesiwrapwindow)\n* [Services](#services)\n  + [`esi.manifest.hier_node` (::circt::esi::AppIDHierNodeOp)](#esimanifesthier_node-circtesiappidhiernodeop)\n  + [`esi.manifest.hier_root` (::circt::esi::AppIDHierRootOp)](#esimanifesthier_root-circtesiappidhierrootop)\n  + [`esi.buffer` (::circt::esi::ChannelBufferOp)](#esibuffer-circtesichannelbufferop-1)\n  + [`esi.manifest.compressed` (::circt::esi::CompressedManifestOp)](#esimanifestcompressed-circtesicompressedmanifestop)\n  + [`esi.cosim.from_host` (::circt::esi::CosimFromHostEndpointOp)](#esicosimfrom_host-circtesicosimfromhostendpointop-1)\n  + [`esi.cosim.to_host` (::circt::esi::CosimToHostEndpointOp)](#esicosimto_host-circtesicosimtohostendpointop-1)\n  + [`esi.service.decl` (::circt::esi::CustomServiceDeclOp)](#esiservicedecl-circtesicustomservicedeclop)\n  + [`esi.fifo` (::circt::esi::FIFOOp)](#esififo-circtesififoop-1)\n  + [`esi.null` (::circt::esi::NullSourceOp)](#esinull-circtesinullsourceop-1)\n  + [`esi.bundle.pack` (::circt::esi::PackBundleOp)](#esibundlepack-circtesipackbundleop-1)\n  + [`esi.stage` (::circt::esi::PipelineStageOp)](#esistage-circtesipipelinestageop-1)\n  + [`esi.service.req` (::circt::esi::RequestConnectionOp)](#esiservicereq-circtesirequestconnectionop)\n  + [`esi.service.port` (::circt::esi::ServiceDeclPortOp)](#esiserviceport-circtesiservicedeclportop)\n  + [`esi.manifest.impl_conn` (::circt::esi::ServiceImplClientRecordOp)](#esimanifestimpl_conn-circtesiserviceimplclientrecordop)\n  + [`esi.manifest.service_impl` (::circt::esi::ServiceImplRecordOp)](#esimanifestservice_impl-circtesiserviceimplrecordop)\n  + [`esi.service.impl_req.req` (::circt::esi::ServiceImplementConnReqOp)](#esiserviceimpl_reqreq-circtesiserviceimplementconnreqop)\n  + [`esi.service.impl_req` (::circt::esi::ServiceImplementReqOp)](#esiserviceimpl_req-circtesiserviceimplementreqop)\n  + [`esi.service.instance` (::circt::esi::ServiceInstanceOp)](#esiserviceinstance-circtesiserviceinstanceop)\n  + [`esi.manifest.req` (::circt::esi::ServiceRequestRecordOp)](#esimanifestreq-circtesiservicerequestrecordop)\n  + [`esi.snoop.xact` (::circt::esi::SnoopTransactionOp)](#esisnoopxact-circtesisnooptransactionop-1)\n  + [`esi.snoop.vr` (::circt::esi::SnoopValidReadyOp)](#esisnoopvr-circtesisnoopvalidreadyop-1)\n  + [`esi.manifest.constants` (::circt::esi::SymbolConstantsOp)](#esimanifestconstants-circtesisymbolconstantsop)\n  + [`esi.manifest.sym` (::circt::esi::SymbolMetadataOp)](#esimanifestsym-circtesisymbolmetadataop)\n  + [`esi.bundle.unpack` (::circt::esi::UnpackBundleOp)](#esibundleunpack-circtesiunpackbundleop-1)\n  + [`esi.unwrap.fifo` (::circt::esi::UnwrapFIFOOp)](#esiunwrapfifo-circtesiunwrapfifoop-1)\n  + [`esi.unwrap.iface` (::circt::esi::UnwrapSVInterfaceOp)](#esiunwrapiface-circtesiunwrapsvinterfaceop-1)\n  + [`esi.unwrap.vr` (::circt::esi::UnwrapValidReadyOp)](#esiunwrapvr-circtesiunwrapvalidreadyop-1)\n  + [`esi.window.unwrap` (::circt::esi::UnwrapWindow)](#esiwindowunwrap-circtesiunwrapwindow-1)\n  + [`esi.wrap.fifo` (::circt::esi::WrapFIFOOp)](#esiwrapfifo-circtesiwrapfifoop-1)\n  + [`esi.wrap.iface` (::circt::esi::WrapSVInterfaceOp)](#esiwrapiface-circtesiwrapsvinterfaceop-1)\n  + [`esi.wrap.vr` (::circt::esi::WrapValidReadyOp)](#esiwrapvr-circtesiwrapvalidreadyop-1)\n  + [`esi.window.wrap` (::circt::esi::WrapWindow)](#esiwindowwrap-circtesiwrapwindow-1)\n  + [`esi.manifest.hier_node` (::circt::esi::AppIDHierNodeOp)](#esimanifesthier_node-circtesiappidhiernodeop-1)\n  + [`esi.manifest.hier_root` (::circt::esi::AppIDHierRootOp)](#esimanifesthier_root-circtesiappidhierrootop-1)\n  + [`esi.service.std.call` (::circt::esi::CallServiceDeclOp)](#esiservicestdcall-circtesicallservicedeclop)\n  + [`esi.buffer` (::circt::esi::ChannelBufferOp)](#esibuffer-circtesichannelbufferop-2)\n  + [`esi.manifest.compressed` (::circt::esi::CompressedManifestOp)](#esimanifestcompressed-circtesicompressedmanifestop-1)\n  + [`esi.cosim.from_host` (::circt::esi::CosimFromHostEndpointOp)](#esicosimfrom_host-circtesicosimfromhostendpointop-2)\n  + [`esi.cosim.to_host` (::circt::esi::CosimToHostEndpointOp)](#esicosimto_host-circtesicosimtohostendpointop-2)\n  + [`esi.service.decl` (::circt::esi::CustomServiceDeclOp)](#esiservicedecl-circtesicustomservicedeclop-1)\n  + [`esi.fifo` (::circt::esi::FIFOOp)](#esififo-circtesififoop-2)\n  + [`esi.service.std.func` (::circt::esi::FuncServiceDeclOp)](#esiservicestdfunc-circtesifuncservicedeclop)\n  + [`esi.service.std.hostmem` (::circt::esi::HostMemServiceDeclOp)](#esiservicestdhostmem-circtesihostmemservicedeclop)\n  + [`esi.service.std.mmio` (::circt::esi::MMIOServiceDeclOp)](#esiservicestdmmio-circtesimmioservicedeclop)\n  + [`esi.null` (::circt::esi::NullSourceOp)](#esinull-circtesinullsourceop-2)\n  + [`esi.bundle.pack` (::circt::esi::PackBundleOp)](#esibundlepack-circtesipackbundleop-2)\n  + [`esi.stage` (::circt::esi::PipelineStageOp)](#esistage-circtesipipelinestageop-2)\n  + [`esi.mem.ram` (::circt::esi::RandomAccessMemoryDeclOp)](#esimemram-circtesirandomaccessmemorydeclop)\n  + [`esi.service.req` (::circt::esi::RequestConnectionOp)](#esiservicereq-circtesirequestconnectionop-1)\n  + [`esi.service.port` (::circt::esi::ServiceDeclPortOp)](#esiserviceport-circtesiservicedeclportop-1)\n  + [`esi.manifest.impl_conn` (::circt::esi::ServiceImplClientRecordOp)](#esimanifestimpl_conn-circtesiserviceimplclientrecordop-1)\n  + [`esi.manifest.service_impl` (::circt::esi::ServiceImplRecordOp)](#esimanifestservice_impl-circtesiserviceimplrecordop-1)\n  + [`esi.service.impl_req.req` (::circt::esi::ServiceImplementConnReqOp)](#esiserviceimpl_reqreq-circtesiserviceimplementconnreqop-1)\n  + [`esi.service.impl_req` (::circt::esi::ServiceImplementReqOp)](#esiserviceimpl_req-circtesiserviceimplementreqop-1)\n  + [`esi.service.instance` (::circt::esi::ServiceInstanceOp)](#esiserviceinstance-circtesiserviceinstanceop-1)\n  + [`esi.manifest.req` (::circt::esi::ServiceRequestRecordOp)](#esimanifestreq-circtesiservicerequestrecordop-1)\n  + [`esi.snoop.xact` (::circt::esi::SnoopTransactionOp)](#esisnoopxact-circtesisnooptransactionop-2)\n  + [`esi.snoop.vr` (::circt::esi::SnoopValidReadyOp)](#esisnoopvr-circtesisnoopvalidreadyop-2)\n  + [`esi.manifest.constants` (::circt::esi::SymbolConstantsOp)](#esimanifestconstants-circtesisymbolconstantsop-1)\n  + [`esi.manifest.sym` (::circt::esi::SymbolMetadataOp)](#esimanifestsym-circtesisymbolmetadataop-1)\n  + [`esi.service.std.telemetry` (::circt::esi::TelemetryServiceDeclOp)](#esiservicestdtelemetry-circtesitelemetryservicedeclop)\n  + [`esi.bundle.unpack` (::circt::esi::UnpackBundleOp)](#esibundleunpack-circtesiunpackbundleop-2)\n  + [`esi.unwrap.fifo` (::circt::esi::UnwrapFIFOOp)](#esiunwrapfifo-circtesiunwrapfifoop-2)\n  + [`esi.unwrap.iface` (::circt::esi::UnwrapSVInterfaceOp)](#esiunwrapiface-circtesiunwrapsvinterfaceop-2)\n  + [`esi.unwrap.vr` (::circt::esi::UnwrapValidReadyOp)](#esiunwrapvr-circtesiunwrapvalidreadyop-2)\n  + [`esi.window.unwrap` (::circt::esi::UnwrapWindow)](#esiwindowunwrap-circtesiunwrapwindow-2)\n  + [`esi.wrap.fifo` (::circt::esi::WrapFIFOOp)](#esiwrapfifo-circtesiwrapfifoop-2)\n  + [`esi.wrap.iface` (::circt::esi::WrapSVInterfaceOp)](#esiwrapiface-circtesiwrapsvinterfaceop-2)\n  + [`esi.wrap.vr` (::circt::esi::WrapValidReadyOp)](#esiwrapvr-circtesiwrapvalidreadyop-2)\n  + [`esi.window.wrap` (::circt::esi::WrapWindow)](#esiwindowwrap-circtesiwrapwindow-2)\n* [Structural](#structural)\n  + [`esi.pure_module.input` (::circt::esi::ESIPureModuleInputOp)](#esipure_moduleinput-circtesiesipuremoduleinputop)\n  + [`esi.pure_module` (::circt::esi::ESIPureModuleOp)](#esipure_module-circtesiesipuremoduleop)\n  + [`esi.pure_module.output` (::circt::esi::ESIPureModuleOutputOp)](#esipure_moduleoutput-circtesiesipuremoduleoutputop)\n  + [`esi.pure_module.param` (::circt::esi::ESIPureModuleParamOp)](#esipure_moduleparam-circtesiesipuremoduleparamop)\n* [Interfaces](#interfaces)\n* [ChannelOpInterface (`ChannelOpInterface`)](#channelopinterface-channelopinterface)\n  + [Methods:](#methods)\n* [HasAppID (`HasAppIDOpInterface`)](#hasappid-hasappidopinterface)\n  + [Methods:](#methods-1)\n* [IsManifestData (`IsManifestData`)](#ismanifestdata-ismanifestdata)\n  + [Methods:](#methods-2)\n* [ServiceDeclOpInterface (`ServiceDeclOpInterface`)](#servicedeclopinterface-servicedeclopinterface)\n  + [Methods:](#methods-3)\n\nApplication channels\n--------------------\n\nThe main component of ESI are point-to-point, typed channels that allow\ndesigners to connect modules to each other and software, then communicate by\nsending messages. Channels largely abstract away the details of message\ncommunication from the designer, though the designer can declaratively specify\nhow to implement the channel.\n\nMessages have types: ints, structs, arrays, unions, and variable-length lists.\nThe width of a channel is not necessarily the same width as the message. ESI\n\u201cwindows\u201d can be used to break up a message into a series of \u201cframes\u201d. IP blocks\ncan emit / absorb \u201cwindowed\u201d messages or full-sized messages, which can be\nautomatically broken up to save wire area at the cost of bandwidth.\n\nAny channel which is exposed to the host will have a platform-agnostic software\nAPI constructed for it based on the type of the channel. The software\napplication merely has to connect to the accelerator then invoke a method to\nsend or receive messages from the accelerator system.\n\n### ChannelBundleType\n\n*A bundle of channels*\n\nSyntax:\n\n```\n!esi.bundle<\n  ::llvm::ArrayRef<BundledChannel>,   # channels\n  ::mlir::UnitAttr   # resettable\n>\n```\n\nA channel bundle (sometimes referred to as just \u201cbundle\u201d) is a set of\nchannels of associated signals, along with per-channel names and directions.\nThe prototypical example for a bundle is a request-response channel pair.\n\nThe direction terminology is a bit confusing. Let us designate the module\nwhich is outputting the bundle as the \u201csender\u201d module and a module which has\na bundle as an input as the \u201creceiver\u201d. The directions \u201cfrom\u201d and \u201cto\u201d are\nfrom the senders perspective. So, the \u201cto\u201d direction means that channel is\ntransmitting messages from the sender to the receiver. Then, \u201cfrom\u201d means\nthat the sender is getting messages from the receiver (typically responses).\n\nWhen requesting a bundle from a service, the service is always considered\nthe sender; so, \u201cto\u201d means the service is sending messages to the client and\n\u201cfrom\u201d means the service is receiving messages from the client.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| channels | `::llvm::ArrayRef<BundledChannel>` |  |\n| resettable | `::mlir::UnitAttr` | boolean flag |\n\n### ChannelType\n\n*An ESI-compatible channel port*\n\nSyntax:\n\n```\n!esi.channel<\n  Type,   # inner\n  ::circt::esi::ChannelSignaling,   # signaling\n  uint64_t   # dataDelay\n>\n```\n\nAn ESI port kind which models a latency-insensitive, unidirectional,\npoint-to-point data stream. Channels are typed (like all of ESI). Said\ntype can be any MLIR type, but must be lowered to something a backend\nknows how to output (i.e. something emitVerilog knows about).\n\nParameters:\nsignaling: the style of the control signals (valid/ready vs FIFO).\ndataDelay: the number of cycles data takes to arrive after the control\nindicates a transaction has occured. For instance, on a FIFO without read\nahead, this would be 1. Defaults to 0.\n\nExample:\n\n```\nhw.module.extern @Sender() -> (%x: !esi.channel<i1>)\nhw.module @Reciever(%a: !esi.channel<hw.array<5xi16>>) { }\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| inner | `Type` |  |\n| signaling | `::circt::esi::ChannelSignaling` |  |\n| dataDelay | `uint64_t` |  |\n\n### ClockType\n\n*A type for clock-carrying wires*\n\nSyntax: `!seq.clock`\n\nThe `!seq.clock` type represents signals which can be used to drive the\nclock input of sequential operations.\n\n### ListType\n\n*A runtime-variably sized list*\n\nSyntax:\n\n```\n!esi.list<\n  Type   # elementType\n>\n```\n\nIn software, a chunk of memory with runtime-specified length. In hardware, a\nstream of runtime-specified amount of data transmitted over many cycles in\ncompile-time specified specified windows (chunks).\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `Type` |  |\n\n### WindowType\n\n*A data window*\n\nSyntax:\n\n```\n!esi.window<\n  StringAttr,   # name\n  mlir::Type,   # into\n  ::llvm::ArrayRef<WindowFrameType>   # frames\n>\n```\n\nA \u2018data window\u2019 allows designers to break up large messages into multiple\nframes (aka flits) spread across multiple cycles. Windows are specified in\nterms of a mapping of struct fields to frames. The width of a window is the\nmaximum frame size + the union tag (log2(#frames)).\n\nA data window does NOT imply an ESI channel.\n\nCurrent restrictions:\n\n* A field may only appear once.\n* Fields may only be re-ordered (wrt the original message) within a frame.\n* Array fields whose array length is not evenly divisible by \u2019numItems\u2019 will\n  have an implicit frame inserted directly after containing the leftover array\n  items.\n* A frame which contains an array with a \u2019numItems\u2019 specification CANNOT\n  contain another array with \u2019numItems\u2019 specified or a list field.\n* Likewise, a frame which contains a list field CANNOT contain another list\n  field or an array with \u2019numItems\u2019 specified.\n\nWhen either a list or an array with \u2019numItems\u2019 is specified in a frame, all\nthe other fields in the frame are assumed to be constant over the length of\nthe list/array transmission. This allows for efficient hardware\nimplementations where the constant fields can be held in registers while the\nlist/array segments stream through. In general, when a struct field appears\nin multiple frames, it must be constant throughout the message transmission.\n\nTypically lowered to a union of structs. There is a special case of one\nframe with no name. In this case, it is lowered to just the struct itself.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| name | `StringAttr` |  |\n| into | `mlir::Type` |  |\n| frames | `::llvm::ArrayRef<WindowFrameType>` |  |\n\n### FirMemType\n\n*A FIRRTL-flavored memory*\n\nSyntax:\n\n```\n!seq.firmem<\n  uint64_t,   # depth\n  uint32_t,   # width\n  std::optional<uint32_t>   # maskWidth\n>\n```\n\nThe `!seq.firmem` type represents a FIRRTL-flavored memory declared by a\n`seq.firmem` operation. It captures the parameters of the memory that are\nrelevant to the read, write, and read-write ports, such as width and depth.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| depth | `uint64_t` |  |\n| width | `uint32_t` |  |\n| maskWidth | `std::optional<uint32_t>` |  |\n\n### HLMemType\n\n*Multi-dimensional memory type*\n\nSyntax:\n\n```\nhlmem-type ::== `hlmem` `<` dim-list element-type `>`\n```\n\nThe HLMemType represents the type of an addressable memory structure. The\ntype is inherently multidimensional. Dimensions must be known integer values.\n\nNote: unidimensional memories are represented as <1x{element type}> -\n<{element type}> is illegal.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| shape | `::llvm::ArrayRef<int64_t>` |  |\n| elementType | `Type` |  |\n\n### ImmutableType\n\n*Value type that is immutable after initialization*\n\nSyntax:\n\n```\n!seq.immutable<\n  ::mlir::Type   # innerType\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| innerType | `::mlir::Type` |  |\n\n### WindowFieldType\n\n*A field-in-frame specifier*\n\nSyntax:\n\n```\n!esi.window.field<\n  StringAttr,   # fieldName\n  uint64_t,   # numItems\n  uint64_t   # bulkCountWidth\n>\n```\n\nSpecify that a field should appear within the enclosing frame.\n\n\u2019numItems\u2019 indicates how many items of the field should appear in the frame.\nOnly applicable to array or list fields. If not specified:\n\n* For arrays, the entire array will appear in the frame.\n* For lists, it is assumed to be 1.\n\nFor lists, there are two possible encodings:\n\n* Parallel (default): a \u2019last\u2019 field to the struct to indicate that the\n  end of the list is this frame. If \u2019numItems\u2019 is specified for a list, a\n  \u2018\\_size\u2019 (representing the number of valid items in the array)\n  field will be added to the struct. When `<fieldName>_size` is less than\n  \u2019numItems\u2019, `last` MUST be true meaning that all frames must be full\n  except for the last one. This format matches typical on-chip hardware\n  streaming interfaces but is terribly inefficient for serial links.\n* Serial (bulk transfer): in this encoding, there must be a \u2018header\u2019 frame\n  immediately preceding the frame which contains the list field. That frame\n  must include a special \u2018count\u2019 field which indicates how many items of the\n  list will be transmitted next. Once the number of items are transmitted\n  (transmitted frames == ceil(count/numItems)), the header is re-transmitted\n  to set up the next bulk transfer *for the same list*. If the transfer was\n  the last transfer, the header should set the count to zero. This method\n  allows for efficient transfers over serial links (no \u2019last\u2019 or \u2018\\_size\u2019\n  fields) without requiring knowledge of the total list size up front.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| fieldName | `StringAttr` |  |\n| numItems | `uint64_t` | # of items in arrays or lists |\n| bulkCountWidth | `uint64_t` | bitwidth of the \u2018count\u2019 field in bulk mode |\n\n### WindowFrameType\n\n*Declare a data window frame*\n\nSyntax:\n\n```\n!esi.window.frame<\n  StringAttr,   # name\n  ::llvm::ArrayRef<WindowFieldType>   # members\n>\n```\n\nA named list of fields which should appear in a given frame.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| name | `StringAttr` |  |\n| members | `::llvm::ArrayRef<WindowFieldType>` |  |\n\n### ListType\n\n*A runtime-variably sized list*\n\nSyntax:\n\n```\n!esi.list<\n  Type   # elementType\n>\n```\n\nIn software, a chunk of memory with runtime-specified length. In hardware, a\nstream of runtime-specified amount of data transmitted over many cycles in\ncompile-time specified specified windows (chunks).\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `Type` |  |\n\n### `esi.buffer` (::circt::esi::ChannelBufferOp)\n\n*Control options for an ESI channel.*\n\nSyntax:\n\n```\noperation ::= `esi.buffer` $clk `,` $rst `,` $input attr-dict\n              `:` qualified(type($input)) `->` qualified(type($output))\n```\n\nA channel buffer (`buffer`) is essentially a set of options on a channel.\nIt always adds at least one cycle of latency (pipeline stage) to the\nchannel, but this is configurable.\n\nThis operation is inserted on an ESI dataflow edge. It must exist\nprevious to SystemVerilog emission but can be added in a lowering pass.\n\nA `stages` attribute may be provided to specify a specific number of cycles\n(pipeline stages) to use on this channel. Must be greater than 0.\n\nA `name` attribute may be provided to assigned a name to a buffered\nconnection.\n\nExample:\n\n```\n%esiChan = hw.instance \"sender\" @Sender () : () -> (!esi.channel<i1>)\n// Allow automatic selection of options.\n%bufferedChan = esi.buffer %esiChan : i1\nhw.instance \"recv\" @Reciever (%bufferedChan) : (!esi.channel<i1>) -> ()\n\n// Alternatively, specify the number of stages.\n%fourStageBufferedChan = esi.buffer %esiChan { stages = 4 } : i1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ChannelOpInterface`, `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `stages` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `esi.cosim.from_host` (::circt::esi::CosimFromHostEndpointOp)\n\n*Co-simulation endpoint receiving data from the host*\n\nSyntax:\n\n```\noperation ::= `esi.cosim.from_host` $clk `,` $rst `,` $id attr-dict `:` qualified(type($fromHost))\n```\n\nA co-simulation endpoint is a connection from the simulation to some\noutside process, usually a software application responsible for driving\nthe simulation (driver).\n\nIt is uni-directional, in this case receiving data from the host for the\nsimulation.\n\nNOTE: $id MUST be unique across all endpoints at simulation runtime.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `id` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `fromHost` | an ESI channel |\n\n### `esi.cosim.to_host` (::circt::esi::CosimToHostEndpointOp)\n\n*Co-simulation endpoint sending data to the host.*\n\nSyntax:\n\n```\noperation ::= `esi.cosim.to_host` $clk `,` $rst `,` $toHost`,` $id attr-dict `:` qualified(type($toHost))\n```\n\nA co-simulation endpoint is a connection from the simulation to some\noutside process, usually a software application responsible for driving\nthe simulation (driver).\n\nIt is uni-directional, in this case sending data from the simulation to the\nhost.\n\nNOTE: $id MUST be unique across all endpoints at simulation runtime.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `id` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `toHost` | an ESI channel |\n\n### `esi.fifo` (::circt::esi::FIFOOp)\n\n*A FIFO with ESI channel connections*\n\nSyntax:\n\n```\noperation ::= `esi.fifo` `in` $input `clk` $clk `rst` $rst `depth` $depth attr-dict\n              `:` type($input) `->` type($output)\n```\n\nA FIFO is a first-in-first-out buffer. This operation is a simple FIFO\nwhich can be used to connect two ESI channels. The ESI channels MUST have\nFIFO signaling semantics.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `depth` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `esi.null` (::circt::esi::NullSourceOp)\n\n*An op which never produces messages.*\n\nSyntax:\n\n```\noperation ::= `esi.null` attr-dict `:` qualified(type($out))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `out` | an ESI channel |\n\n### `esi.bundle.pack` (::circt::esi::PackBundleOp)\n\n*Pack channels into a bundle*\n\nSyntax:\n\n```\noperation ::= `esi.bundle.pack` $toChannels attr-dict `:` custom<UnPackBundleType>(\n              type($toChannels), type($fromChannels), type($bundle))\n```\n\nInterfaces: `OpAsmOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `toChannels` | variadic of an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `bundle` | a bundle of channels |\n| `fromChannels` | variadic of an ESI channel |\n\n### `esi.stage` (::circt::esi::PipelineStageOp)\n\n*An elastic buffer stage.*\n\nSyntax:\n\n```\noperation ::= `esi.stage` $clk `,` $rst `,` $input attr-dict\n              `:` qualified(type($input))\n```\n\nAn individual elastic pipeline register. Generally lowered to from a\nChannelBuffer (\u2018buffer\u2019), though can be inserted anywhere to add an\nadditional pipeline stage. Adding individually could be useful for\nlate-pass latency balancing.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ChannelOpInterface`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `esi.snoop.xact` (::circt::esi::SnoopTransactionOp)\n\n*Get the data and transaction signal from a channel*\n\nSyntax:\n\n```\noperation ::= `esi.snoop.xact` $input attr-dict `:` qualified(type($input))\n```\n\nA snoop that observes when a transaction occurs on a channel and provides\nthe data being transmitted. The transaction signal indicates when data is\nactually being transferred on the channel, regardless of the underlying\nsignaling protocol (ValidReady or FIFO). Like other snoop operations, this\ndoes not count as another user of the channel. Useful for monitoring data\nflow and debugging.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `transaction` | 1-bit signless integer |\n| `data` | any type |\n\n### `esi.snoop.vr` (::circt::esi::SnoopValidReadyOp)\n\n*Get the valid, ready, and data signals from a channel*\n\nSyntax:\n\n```\noperation ::= `esi.snoop.vr` $input attr-dict `:` qualified(type($input))\n```\n\nA snoop allows one to combinationally observe a channel\u2019s internal signals.\nIt does not count as another user of the channel. Useful for constructing\ncontrol logic which can be combinationally driven. Also potentially useful\nfor debugging.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `valid` | 1-bit signless integer |\n| `ready` | 1-bit signless integer |\n| `data` | any type |\n\n### `esi.bundle.unpack` (::circt::esi::UnpackBundleOp)\n\n*Unpack channels from a bundle*\n\nSyntax:\n\n```\noperation ::= `esi.bundle.unpack` $fromChannels `from` $bundle attr-dict `:` custom<UnPackBundleType>(\n              type($toChannels), type($fromChannels), type($bundle))\n```\n\nInterfaces: `OpAsmOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `bundle` | a bundle of channels |\n| `fromChannels` | variadic of an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `toChannels` | variadic of an ESI channel |\n\n### `esi.unwrap.fifo` (::circt::esi::UnwrapFIFOOp)\n\n*Unwrap a value from an ESI port into a FIFO interface*\n\nSyntax:\n\n```\noperation ::= `esi.unwrap.fifo` $chanInput `,` $rden attr-dict `:` qualified(type($chanInput))\n```\n\nInterfaces: `ChannelOpInterface`, `InferTypeOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `chanInput` | an ESI channel |\n| `rden` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `data` | any type |\n| `empty` | 1-bit signless integer |\n\n### `esi.unwrap.iface` (::circt::esi::UnwrapSVInterfaceOp)\n\n*Unwrap an SV interface from an ESI port*\n\nSyntax:\n\n```\noperation ::= `esi.unwrap.iface` $chanInput `into` $interfaceSource attr-dict `:` `(` qualified(type($chanInput)) `,` qualified(type($interfaceSource)) `)`\n```\n\nUnwrap an ESI channel into a SystemVerilog interface containing valid,\nready, and data signals.\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `chanInput` | an ESI channel |\n| `interfaceSource` | sv.interface |\n\n### `esi.unwrap.vr` (::circt::esi::UnwrapValidReadyOp)\n\n*Unwrap a value from an ESI port*\n\nUnwrapping a value allows operations on the contained value. Unwrap the\nchannel along with a ready signal that you generate. Result is the data\nalong with a valid signal.\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `chanInput` | an ESI channel |\n| `ready` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `rawOutput` | any type |\n| `valid` | 1-bit signless integer |\n\n### `esi.window.unwrap` (::circt::esi::UnwrapWindow)\n\n*Unwrap a data window into a union*\n\nSyntax:\n\n```\noperation ::= `esi.window.unwrap` $window attr-dict `:` qualified(type($window))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `window` | a data window |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `frame` | any type |\n\n### `esi.wrap.fifo` (::circt::esi::WrapFIFOOp)\n\n*Wrap a value into an ESI port with FIFO signaling*\n\nSyntax:\n\n```\noperation ::= `esi.wrap.fifo` $data `,` $empty attr-dict `:`\n              custom<WrapFIFOType>(type($data), type($chanOutput))\n```\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `data` | any type |\n| `empty` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `chanOutput` | an ESI channel |\n| `rden` | 1-bit signless integer |\n\n### `esi.wrap.iface` (::circt::esi::WrapSVInterfaceOp)\n\n*Wrap an SV interface into an ESI port*\n\nSyntax:\n\n```\noperation ::= `esi.wrap.iface` $interfaceSink attr-dict `:` qualified(type($interfaceSink)) `->` qualified(type($output))\n```\n\nWrap a SystemVerilog interface into an ESI channel. Interface MUST look\nlike an interface produced by ESI meaning it MUST contain valid, ready,\nand data signals. Any other signals will be discarded.\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `interfaceSink` | sv.interface |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `esi.wrap.vr` (::circt::esi::WrapValidReadyOp)\n\n*Wrap a value into an ESI port*\n\nWrapping a value into an ESI port type allows modules to send values down\nan ESI port. Wrap data with valid bit, result is the ESI channel and the\nready signal from the other end of the channel.\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `rawInput` | any type |\n| `valid` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `chanOutput` | an ESI channel |\n| `ready` | 1-bit signless integer |\n\n### `esi.window.wrap` (::circt::esi::WrapWindow)\n\n*Wrap a union into a data window*\n\nSyntax:\n\n```\noperation ::= `esi.window.wrap` $frame attr-dict `:` custom<InferWindowRet>(type($frame), type($window))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `frame` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `window` | a data window |\n\nServices\n--------\n\nESI \u201cservices\u201d provide device-wide connectivity and arbitration for shared\nresources, which can be requested from any IP block (service \u201cclient\u201d). Standard\nservices will include DRAM, clock/reset, statistical counter reporting, and\ndebug.\n\n### `esi.manifest.hier_node` (::circt::esi::AppIDHierNodeOp)\n\n*A node in the AppID hierarchy*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.hier_node` qualified($appID) `mod` $moduleRef attr-dict-with-keyword $children\n```\n\nTraits: `HasParent<circt::esi::AppIDHierRootOp, circt::esi::AppIDHierNodeOp>`, `NoTerminator`, `SingleBlock`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `appID` | ::circt::esi::AppIDAttr | An application relevant instance identifier |\n| `moduleRef` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n### `esi.manifest.hier_root` (::circt::esi::AppIDHierRootOp)\n\n*The root of an appid instance hierarchy*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.hier_root` $topModuleRef attr-dict-with-keyword $children\n```\n\nTraits: `HasParent<mlir::ModuleOp>`, `NoTerminator`, `SingleBlock`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `topModuleRef` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n### `esi.buffer` (::circt::esi::ChannelBufferOp)\n\n*Control options for an ESI channel.*\n\nSyntax:\n\n```\noperation ::= `esi.buffer` $clk `,` $rst `,` $input attr-dict\n              `:` qualified(type($input)) `->` qualified(type($output))\n```\n\nA channel buffer (`buffer`) is essentially a set of options on a channel.\nIt always adds at least one cycle of latency (pipeline stage) to the\nchannel, but this is configurable.\n\nThis operation is inserted on an ESI dataflow edge. It must exist\nprevious to SystemVerilog emission but can be added in a lowering pass.\n\nA `stages` attribute may be provided to specify a specific number of cycles\n(pipeline stages) to use on this channel. Must be greater than 0.\n\nA `name` attribute may be provided to assigned a name to a buffered\nconnection.\n\nExample:\n\n```\n%esiChan = hw.instance \"sender\" @Sender () : () -> (!esi.channel<i1>)\n// Allow automatic selection of options.\n%bufferedChan = esi.buffer %esiChan : i1\nhw.instance \"recv\" @Reciever (%bufferedChan) : (!esi.channel<i1>) -> ()\n\n// Alternatively, specify the number of stages.\n%fourStageBufferedChan = esi.buffer %esiChan { stages = 4 } : i1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ChannelOpInterface`, `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `stages` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `esi.manifest.compressed` (::circt::esi::CompressedManifestOp)\n\n*A zlib-compressed JSON manifest*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.compressed` $compressedManifest attr-dict\n```\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `compressedManifest` | ::circt::esi::BlobAttr | A binary blob |\n\n### `esi.cosim.from_host` (::circt::esi::CosimFromHostEndpointOp)\n\n*Co-simulation endpoint receiving data from the host*\n\nSyntax:\n\n```\noperation ::= `esi.cosim.from_host` $clk `,` $rst `,` $id attr-dict `:` qualified(type($fromHost))\n```\n\nA co-simulation endpoint is a connection from the simulation to some\noutside process, usually a software application responsible for driving\nthe simulation (driver).\n\nIt is uni-directional, in this case receiving data from the host for the\nsimulation.\n\nNOTE: $id MUST be unique across all endpoints at simulation runtime.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `id` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `fromHost` | an ESI channel |\n\n### `esi.cosim.to_host` (::circt::esi::CosimToHostEndpointOp)\n\n*Co-simulation endpoint sending data to the host.*\n\nSyntax:\n\n```\noperation ::= `esi.cosim.to_host` $clk `,` $rst `,` $toHost`,` $id attr-dict `:` qualified(type($toHost))\n```\n\nA co-simulation endpoint is a connection from the simulation to some\noutside process, usually a software application responsible for driving\nthe simulation (driver).\n\nIt is uni-directional, in this case sending data from the simulation to the\nhost.\n\nNOTE: $id MUST be unique across all endpoints at simulation runtime.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `id` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `toHost` | an ESI channel |\n\n### `esi.service.decl` (::circt::esi::CustomServiceDeclOp)\n\n*An ESI service interface declaration*\n\nSyntax:\n\n```\noperation ::= `esi.service.decl` $sym_name $ports attr-dict\n```\n\nA declaration of an ESI service interface. Defines a contract between a\nservice provider and its clients.\n\nExample:\n\n```\nesi.service.decl @HostComms {\n  esi.service.port send : !esi.bundle<[!esi.any from \"send\"]>\n  esi.service.port recieve : !esi.channel<[i8 to \"recv\"]>\n}\n```\n\nTraits: `HasParent<::mlir::ModuleOp>`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `ServiceDeclOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `esi.fifo` (::circt::esi::FIFOOp)\n\n*A FIFO with ESI channel connections*\n\nSyntax:\n\n```\noperation ::= `esi.fifo` `in` $input `clk` $clk `rst` $rst `depth` $depth attr-dict\n              `:` type($input) `->` type($output)\n```\n\nA FIFO is a first-in-first-out buffer. This operation is a simple FIFO\nwhich can be used to connect two ESI channels. The ESI channels MUST have\nFIFO signaling semantics.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `depth` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `esi.null` (::circt::esi::NullSourceOp)\n\n*An op which never produces messages.*\n\nSyntax:\n\n```\noperation ::= `esi.null` attr-dict `:` qualified(type($out))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `out` | an ESI channel |\n\n### `esi.bundle.pack` (::circt::esi::PackBundleOp)\n\n*Pack channels into a bundle*\n\nSyntax:\n\n```\noperation ::= `esi.bundle.pack` $toChannels attr-dict `:` custom<UnPackBundleType>(\n              type($toChannels), type($fromChannels), type($bundle))\n```\n\nInterfaces: `OpAsmOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `toChannels` | variadic of an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `bundle` | a bundle of channels |\n| `fromChannels` | variadic of an ESI channel |\n\n### `esi.stage` (::circt::esi::PipelineStageOp)\n\n*An elastic buffer stage.*\n\nSyntax:\n\n```\noperation ::= `esi.stage` $clk `,` $rst `,` $input attr-dict\n              `:` qualified(type($input))\n```\n\nAn individual elastic pipeline register. Generally lowered to from a\nChannelBuffer (\u2018buffer\u2019), though can be inserted anywhere to add an\nadditional pipeline stage. Adding individually could be useful for\nlate-pass latency balancing.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ChannelOpInterface`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `esi.service.req` (::circt::esi::RequestConnectionOp)\n\n*Request a connection to receive data*\n\nSyntax:\n\n```\noperation ::= `esi.service.req` $servicePort `(` qualified($appID) `)`\n              attr-dict `:` qualified(type($toClient))\n```\n\nInterfaces: `HasAppID`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `servicePort` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n| `appID` | ::circt::esi::AppIDAttr | An application relevant instance identifier |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `toClient` | a bundle of channels |\n\n### `esi.service.port` (::circt::esi::ServiceDeclPortOp)\n\n*An ESI service bundle being received by the client*\n\nSyntax:\n\n```\noperation ::= `esi.service.port` $inner_sym  attr-dict `:` $toClientType\n```\n\nTraits: `HasParent<::circt::esi::CustomServiceDeclOp>`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::mlir::StringAttr | string attribute |\n| `toClientType` | ::mlir::TypeAttr | type attribute of a bundle of channels |\n\n### `esi.manifest.impl_conn` (::circt::esi::ServiceImplClientRecordOp)\n\n*Details of a service implementation client connection*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.impl_conn` $relAppIDPath `req` $servicePort `(` $typeID `)`\n              (`channels` $channelAssignments^)? (`with` $implDetails^)? attr-dict\n```\n\nA record containing all the necessary details of how to connect to a client\nwhich the parent service record is servicing. Emitted on a per-client bundle\nbasis. There shall be at most on of these records in the entire manifest for\na particular client.\n\nTraits: `HasParent<ServiceImplRecordOp>`\n\nInterfaces: `IsManifestData`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `relAppIDPath` | ::mlir::ArrayAttr | Array of AppIDs |\n| `servicePort` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n| `typeID` | ::mlir::TypeAttr | type attribute of a bundle of channels |\n| `channelAssignments` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n| `implDetails` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n### `esi.manifest.service_impl` (::circt::esi::ServiceImplRecordOp)\n\n*Record of a service implementation*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.service_impl` qualified($appID) (`svc` $service^)? (`std` $stdService^)?\n              `by` $serviceImplName (`engine` $isEngine^)? `with` $implDetails\n              attr-dict-with-keyword custom<ServiceImplRecordReqDetails>($reqDetails)\n```\n\nA record of a service implementation. Optionally emitted by the service\nimplementation. Contains information necessary to connect to the service and\nservice clients.\n\nTraits: `NoTerminator`\n\nInterfaces: `HasAppID`, `IsManifestData`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `appID` | ::circt::esi::AppIDAttr | An application relevant instance identifier |\n| `isEngine` | ::mlir::UnitAttr | unit attribute |\n| `service` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `stdService` | ::mlir::StringAttr | string attribute |\n| `serviceImplName` | ::mlir::StringAttr | string attribute |\n| `implDetails` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n### `esi.service.impl_req.req` (::circt::esi::ServiceImplementConnReqOp)\n\n*The canonical form of a connection request*\n\nSyntax:\n\n```\noperation ::= `esi.service.impl_req.req` $servicePort `(` $relativeAppIDPath `)`\n              attr-dict `:` qualified(type($toClient))\n```\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `servicePort` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n| `relativeAppIDPath` | ::mlir::ArrayAttr | Array of AppIDs |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `toClient` | a bundle of channels |\n\n### `esi.service.impl_req` (::circt::esi::ServiceImplementReqOp)\n\n*Request for a service to be implemented*\n\nSyntax:\n\n```\noperation ::= `esi.service.impl_req` qualified($appID) (`svc` $service_symbol^)? `impl` `as` $impl_type\n              (`std` $stdService^)? (`opts` $impl_opts^)? `(` $inputs `)`\n              attr-dict `:` functional-type($inputs, results)\n              $portReqs\n```\n\nThe connect services pass replaces `service.instance`s with this op. The\n`portReqs` region is the set of connection requests which need to be\nimplemented for this service instance. Channels to/from the requests have\nbeen added to the operands/results of this op and consumers/producers have\nbeen redirected.\n\nSome other pass or frontend is expected to replace this op with an actual\nimplementation.\n\nTraits: `NoTerminator`\n\nInterfaces: `HasAppID`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `appID` | ::circt::esi::AppIDAttr | An application relevant instance identifier |\n| `service_symbol` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `impl_type` | ::mlir::StringAttr | string attribute |\n| `stdService` | ::mlir::StringAttr | string attribute |\n| `impl_opts` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `esi.service.instance` (::circt::esi::ServiceInstanceOp)\n\n*Instantiate a server module*\n\nSyntax:\n\n```\noperation ::= `esi.service.instance` qualified($appID) (`svc` $service_symbol^)? `impl` `as` $impl_type\n              (`opts` $impl_opts^)? `(` $inputs `)`\n              attr-dict `:` functional-type($inputs, results)\n```\n\nInstantiate a service adhering to a service declaration interface.\n\nA pass collects all of the connection requests to the service this op\nimplements from the containing modules\u2019 descendants (in the instance\nhierarchy). It bubbles them all up to the module containing this op,\ncreating the necessary ESI channel ports, groups them appropriately, then\nreplaces this op with a `service.impl_req`.\n\nIf \u2018service\\_symbol\u2019 isn\u2019t specified, this instance will be used to implement\nall of the service requests which get surfaced to here. This option is\ngenerally used at the top level to specify host connectivity.\n\nSince implementing the server will usually need \u201cnormal\u201d I/O, `inputs` and\n`results` act like normal `hw.instance` ports.\n\n$identifier is used by frontends to specify or remember the type of\nimplementation to use for this service.\n\nInterfaces: `HasAppID`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `appID` | ::circt::esi::AppIDAttr | An application relevant instance identifier |\n| `service_symbol` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `impl_type` | ::mlir::StringAttr | string attribute |\n| `impl_opts` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| \u00abunnamed\u00bb | variadic of any type |\n\n### `esi.manifest.req` (::circt::esi::ServiceRequestRecordOp)\n\n*Record of a service request*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.req` qualified($requestor) `,` $servicePort (`std` $stdService^)?\n              `,` $typeID attr-dict\n```\n\nA record of a service request, including the requestor, the service\nrequested, and the parameters of the request. Emitted before connecting the\nservice to preserve metadata about the original request.\n\nInterfaces: `HasAppID`, `IsManifestData`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `requestor` | ::circt::esi::AppIDAttr | An application relevant instance identifier |\n| `servicePort` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n| `stdService` | ::mlir::StringAttr | string attribute |\n| `typeID` | ::mlir::TypeAttr | type attribute of a bundle of channels |\n\n### `esi.snoop.xact` (::circt::esi::SnoopTransactionOp)\n\n*Get the data and transaction signal from a channel*\n\nSyntax:\n\n```\noperation ::= `esi.snoop.xact` $input attr-dict `:` qualified(type($input))\n```\n\nA snoop that observes when a transaction occurs on a channel and provides\nthe data being transmitted. The transaction signal indicates when data is\nactually being transferred on the channel, regardless of the underlying\nsignaling protocol (ValidReady or FIFO). Like other snoop operations, this\ndoes not count as another user of the channel. Useful for monitoring data\nflow and debugging.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `transaction` | 1-bit signless integer |\n| `data` | any type |\n\n### `esi.snoop.vr` (::circt::esi::SnoopValidReadyOp)\n\n*Get the valid, ready, and data signals from a channel*\n\nSyntax:\n\n```\noperation ::= `esi.snoop.vr` $input attr-dict `:` qualified(type($input))\n```\n\nA snoop allows one to combinationally observe a channel\u2019s internal signals.\nIt does not count as another user of the channel. Useful for constructing\ncontrol logic which can be combinationally driven. Also potentially useful\nfor debugging.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `valid` | 1-bit signless integer |\n| `ready` | 1-bit signless integer |\n| `data` | any type |\n\n### `esi.manifest.constants` (::circt::esi::SymbolConstantsOp)\n\n*Constant values associated with a symbol*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.constants` $symbolRef $constants attr-dict\n```\n\nInterfaces: `IsManifestData`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `symbolRef` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `constants` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n### `esi.manifest.sym` (::circt::esi::SymbolMetadataOp)\n\n*Metadata about a symbol*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.sym` $symbolRef\n              (`name` $name^)?\n              (`repo` $repo^)?\n              (`commit` $commitHash^)?\n              (`version` $version^)?\n              (`summary` $summary^)?\n              attr-dict\n```\n\nMetadata about a symbol, including its name, repository, commit hash,\nversion, and summary. All are optional, but strongly encouraged. Any\nadditional metadata which users wish to attach should go as discardable\nattributes.\n\nInterfaces: `IsManifestData`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `symbolRef` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n| `repo` | ::mlir::StringAttr | string attribute |\n| `commitHash` | ::mlir::StringAttr | string attribute |\n| `version` | ::mlir::StringAttr | string attribute |\n| `summary` | ::mlir::StringAttr | string attribute |\n\n### `esi.bundle.unpack` (::circt::esi::UnpackBundleOp)\n\n*Unpack channels from a bundle*\n\nSyntax:\n\n```\noperation ::= `esi.bundle.unpack` $fromChannels `from` $bundle attr-dict `:` custom<UnPackBundleType>(\n              type($toChannels), type($fromChannels), type($bundle))\n```\n\nInterfaces: `OpAsmOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `bundle` | a bundle of channels |\n| `fromChannels` | variadic of an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `toChannels` | variadic of an ESI channel |\n\n### `esi.unwrap.fifo` (::circt::esi::UnwrapFIFOOp)\n\n*Unwrap a value from an ESI port into a FIFO interface*\n\nSyntax:\n\n```\noperation ::= `esi.unwrap.fifo` $chanInput `,` $rden attr-dict `:` qualified(type($chanInput))\n```\n\nInterfaces: `ChannelOpInterface`, `InferTypeOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `chanInput` | an ESI channel |\n| `rden` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `data` | any type |\n| `empty` | 1-bit signless integer |\n\n### `esi.unwrap.iface` (::circt::esi::UnwrapSVInterfaceOp)\n\n*Unwrap an SV interface from an ESI port*\n\nSyntax:\n\n```\noperation ::= `esi.unwrap.iface` $chanInput `into` $interfaceSource attr-dict `:` `(` qualified(type($chanInput)) `,` qualified(type($interfaceSource)) `)`\n```\n\nUnwrap an ESI channel into a SystemVerilog interface containing valid,\nready, and data signals.\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `chanInput` | an ESI channel |\n| `interfaceSource` | sv.interface |\n\n### `esi.unwrap.vr` (::circt::esi::UnwrapValidReadyOp)\n\n*Unwrap a value from an ESI port*\n\nUnwrapping a value allows operations on the contained value. Unwrap the\nchannel along with a ready signal that you generate. Result is the data\nalong with a valid signal.\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `chanInput` | an ESI channel |\n| `ready` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `rawOutput` | any type |\n| `valid` | 1-bit signless integer |\n\n### `esi.window.unwrap` (::circt::esi::UnwrapWindow)\n\n*Unwrap a data window into a union*\n\nSyntax:\n\n```\noperation ::= `esi.window.unwrap` $window attr-dict `:` qualified(type($window))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `window` | a data window |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `frame` | any type |\n\n### `esi.wrap.fifo` (::circt::esi::WrapFIFOOp)\n\n*Wrap a value into an ESI port with FIFO signaling*\n\nSyntax:\n\n```\noperation ::= `esi.wrap.fifo` $data `,` $empty attr-dict `:`\n              custom<WrapFIFOType>(type($data), type($chanOutput))\n```\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `data` | any type |\n| `empty` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `chanOutput` | an ESI channel |\n| `rden` | 1-bit signless integer |\n\n### `esi.wrap.iface` (::circt::esi::WrapSVInterfaceOp)\n\n*Wrap an SV interface into an ESI port*\n\nSyntax:\n\n```\noperation ::= `esi.wrap.iface` $interfaceSink attr-dict `:` qualified(type($interfaceSink)) `->` qualified(type($output))\n```\n\nWrap a SystemVerilog interface into an ESI channel. Interface MUST look\nlike an interface produced by ESI meaning it MUST contain valid, ready,\nand data signals. Any other signals will be discarded.\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `interfaceSink` | sv.interface |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `esi.wrap.vr` (::circt::esi::WrapValidReadyOp)\n\n*Wrap a value into an ESI port*\n\nWrapping a value into an ESI port type allows modules to send values down\nan ESI port. Wrap data with valid bit, result is the ESI channel and the\nready signal from the other end of the channel.\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `rawInput` | any type |\n| `valid` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `chanOutput` | an ESI channel |\n| `ready` | 1-bit signless integer |\n\n### `esi.window.wrap` (::circt::esi::WrapWindow)\n\n*Wrap a union into a data window*\n\nSyntax:\n\n```\noperation ::= `esi.window.wrap` $frame attr-dict `:` custom<InferWindowRet>(type($frame), type($window))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `frame` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `window` | a data window |\n\n### `esi.manifest.hier_node` (::circt::esi::AppIDHierNodeOp)\n\n*A node in the AppID hierarchy*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.hier_node` qualified($appID) `mod` $moduleRef attr-dict-with-keyword $children\n```\n\nTraits: `HasParent<circt::esi::AppIDHierRootOp, circt::esi::AppIDHierNodeOp>`, `NoTerminator`, `SingleBlock`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `appID` | ::circt::esi::AppIDAttr | An application relevant instance identifier |\n| `moduleRef` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n### `esi.manifest.hier_root` (::circt::esi::AppIDHierRootOp)\n\n*The root of an appid instance hierarchy*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.hier_root` $topModuleRef attr-dict-with-keyword $children\n```\n\nTraits: `HasParent<mlir::ModuleOp>`, `NoTerminator`, `SingleBlock`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `topModuleRef` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n### `esi.service.std.call` (::circt::esi::CallServiceDeclOp)\n\n*Service against which hardware can call into software*\n\nSyntax:\n\n```\noperation ::= `esi.service.std.call` $sym_name attr-dict\n```\n\nTraits: `HasParent<::mlir::ModuleOp>`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `ServiceDeclOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `esi.buffer` (::circt::esi::ChannelBufferOp)\n\n*Control options for an ESI channel.*\n\nSyntax:\n\n```\noperation ::= `esi.buffer` $clk `,` $rst `,` $input attr-dict\n              `:` qualified(type($input)) `->` qualified(type($output))\n```\n\nA channel buffer (`buffer`) is essentially a set of options on a channel.\nIt always adds at least one cycle of latency (pipeline stage) to the\nchannel, but this is configurable.\n\nThis operation is inserted on an ESI dataflow edge. It must exist\nprevious to SystemVerilog emission but can be added in a lowering pass.\n\nA `stages` attribute may be provided to specify a specific number of cycles\n(pipeline stages) to use on this channel. Must be greater than 0.\n\nA `name` attribute may be provided to assigned a name to a buffered\nconnection.\n\nExample:\n\n```\n%esiChan = hw.instance \"sender\" @Sender () : () -> (!esi.channel<i1>)\n// Allow automatic selection of options.\n%bufferedChan = esi.buffer %esiChan : i1\nhw.instance \"recv\" @Reciever (%bufferedChan) : (!esi.channel<i1>) -> ()\n\n// Alternatively, specify the number of stages.\n%fourStageBufferedChan = esi.buffer %esiChan { stages = 4 } : i1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ChannelOpInterface`, `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `stages` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `esi.manifest.compressed` (::circt::esi::CompressedManifestOp)\n\n*A zlib-compressed JSON manifest*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.compressed` $compressedManifest attr-dict\n```\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `compressedManifest` | ::circt::esi::BlobAttr | A binary blob |\n\n### `esi.cosim.from_host` (::circt::esi::CosimFromHostEndpointOp)\n\n*Co-simulation endpoint receiving data from the host*\n\nSyntax:\n\n```\noperation ::= `esi.cosim.from_host` $clk `,` $rst `,` $id attr-dict `:` qualified(type($fromHost))\n```\n\nA co-simulation endpoint is a connection from the simulation to some\noutside process, usually a software application responsible for driving\nthe simulation (driver).\n\nIt is uni-directional, in this case receiving data from the host for the\nsimulation.\n\nNOTE: $id MUST be unique across all endpoints at simulation runtime.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `id` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `fromHost` | an ESI channel |\n\n### `esi.cosim.to_host` (::circt::esi::CosimToHostEndpointOp)\n\n*Co-simulation endpoint sending data to the host.*\n\nSyntax:\n\n```\noperation ::= `esi.cosim.to_host` $clk `,` $rst `,` $toHost`,` $id attr-dict `:` qualified(type($toHost))\n```\n\nA co-simulation endpoint is a connection from the simulation to some\noutside process, usually a software application responsible for driving\nthe simulation (driver).\n\nIt is uni-directional, in this case sending data from the simulation to the\nhost.\n\nNOTE: $id MUST be unique across all endpoints at simulation runtime.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `id` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `toHost` | an ESI channel |\n\n### `esi.service.decl` (::circt::esi::CustomServiceDeclOp)\n\n*An ESI service interface declaration*\n\nSyntax:\n\n```\noperation ::= `esi.service.decl` $sym_name $ports attr-dict\n```\n\nA declaration of an ESI service interface. Defines a contract between a\nservice provider and its clients.\n\nExample:\n\n```\nesi.service.decl @HostComms {\n  esi.service.port send : !esi.bundle<[!esi.any from \"send\"]>\n  esi.service.port recieve : !esi.channel<[i8 to \"recv\"]>\n}\n```\n\nTraits: `HasParent<::mlir::ModuleOp>`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `ServiceDeclOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `esi.fifo` (::circt::esi::FIFOOp)\n\n*A FIFO with ESI channel connections*\n\nSyntax:\n\n```\noperation ::= `esi.fifo` `in` $input `clk` $clk `rst` $rst `depth` $depth attr-dict\n              `:` type($input) `->` type($output)\n```\n\nA FIFO is a first-in-first-out buffer. This operation is a simple FIFO\nwhich can be used to connect two ESI channels. The ESI channels MUST have\nFIFO signaling semantics.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `depth` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `esi.service.std.func` (::circt::esi::FuncServiceDeclOp)\n\n*Function service*\n\nSyntax:\n\n```\noperation ::= `esi.service.std.func` $sym_name attr-dict\n```\n\nDeclares a service which provides a function call interface to a client.\n\nPorts:\nto\\_client call(args: any) -> result: any\nClient exposes a function call interface to the user and does not allow\nout-of-order returns.\n\nTODO: ports for out-of-order returns\n\nTraits: `HasParent<::mlir::ModuleOp>`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `ServiceDeclOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `esi.service.std.hostmem` (::circt::esi::HostMemServiceDeclOp)\n\n*Host memory service*\n\nSyntax:\n\n```\noperation ::= `esi.service.std.hostmem` $sym_name attr-dict\n```\n\nDeclares a service to read/write host memory. Used for DMA services. Must be\nimplemented by a BSP.\n\nTraits: `HasParent<::mlir::ModuleOp>`\n\nInterfaces: `ServiceDeclOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `esi.service.std.mmio` (::circt::esi::MMIOServiceDeclOp)\n\n*MMIO service*\n\nSyntax:\n\n```\noperation ::= `esi.service.std.mmio` $sym_name attr-dict\n```\n\nDeclares a service to be backed by a MMIO interface, which is platform\ndependent. Must be implemented by a BSP.\n\nTraits: `HasParent<::mlir::ModuleOp>`\n\nInterfaces: `ServiceDeclOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `esi.null` (::circt::esi::NullSourceOp)\n\n*An op which never produces messages.*\n\nSyntax:\n\n```\noperation ::= `esi.null` attr-dict `:` qualified(type($out))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `out` | an ESI channel |\n\n### `esi.bundle.pack` (::circt::esi::PackBundleOp)\n\n*Pack channels into a bundle*\n\nSyntax:\n\n```\noperation ::= `esi.bundle.pack` $toChannels attr-dict `:` custom<UnPackBundleType>(\n              type($toChannels), type($fromChannels), type($bundle))\n```\n\nInterfaces: `OpAsmOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `toChannels` | variadic of an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `bundle` | a bundle of channels |\n| `fromChannels` | variadic of an ESI channel |\n\n### `esi.stage` (::circt::esi::PipelineStageOp)\n\n*An elastic buffer stage.*\n\nSyntax:\n\n```\noperation ::= `esi.stage` $clk `,` $rst `,` $input attr-dict\n              `:` qualified(type($input))\n```\n\nAn individual elastic pipeline register. Generally lowered to from a\nChannelBuffer (\u2018buffer\u2019), though can be inserted anywhere to add an\nadditional pipeline stage. Adding individually could be useful for\nlate-pass latency balancing.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ChannelOpInterface`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `esi.mem.ram` (::circt::esi::RandomAccessMemoryDeclOp)\n\n*Random access memory service*\n\nSyntax:\n\n```\noperation ::= `esi.mem.ram` $sym_name $innerType `x` $depth attr-dict\n```\n\nDeclares a service which is backed by a memory of some sort. Allows random\naccess of the inner elements.\n\nPorts:\nread(address: clog2(depth)) -> data: innerType\nwrite({address: clog2(depth), data: innerType}) -> done: i0\n\nUsers can ensure R/W ordering by waiting for the write \u201cdone\u201d message before\nissuing a potentially dependant read. Ordering of R/W messages in flight is\nundefined.\n\nTraits: `HasParent<::mlir::ModuleOp>`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `ServiceDeclOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `innerType` | ::mlir::TypeAttr | any type attribute |\n| `depth` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n### `esi.service.req` (::circt::esi::RequestConnectionOp)\n\n*Request a connection to receive data*\n\nSyntax:\n\n```\noperation ::= `esi.service.req` $servicePort `(` qualified($appID) `)`\n              attr-dict `:` qualified(type($toClient))\n```\n\nInterfaces: `HasAppID`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `servicePort` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n| `appID` | ::circt::esi::AppIDAttr | An application relevant instance identifier |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `toClient` | a bundle of channels |\n\n### `esi.service.port` (::circt::esi::ServiceDeclPortOp)\n\n*An ESI service bundle being received by the client*\n\nSyntax:\n\n```\noperation ::= `esi.service.port` $inner_sym  attr-dict `:` $toClientType\n```\n\nTraits: `HasParent<::circt::esi::CustomServiceDeclOp>`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::mlir::StringAttr | string attribute |\n| `toClientType` | ::mlir::TypeAttr | type attribute of a bundle of channels |\n\n### `esi.manifest.impl_conn` (::circt::esi::ServiceImplClientRecordOp)\n\n*Details of a service implementation client connection*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.impl_conn` $relAppIDPath `req` $servicePort `(` $typeID `)`\n              (`channels` $channelAssignments^)? (`with` $implDetails^)? attr-dict\n```\n\nA record containing all the necessary details of how to connect to a client\nwhich the parent service record is servicing. Emitted on a per-client bundle\nbasis. There shall be at most on of these records in the entire manifest for\na particular client.\n\nTraits: `HasParent<ServiceImplRecordOp>`\n\nInterfaces: `IsManifestData`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `relAppIDPath` | ::mlir::ArrayAttr | Array of AppIDs |\n| `servicePort` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n| `typeID` | ::mlir::TypeAttr | type attribute of a bundle of channels |\n| `channelAssignments` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n| `implDetails` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n### `esi.manifest.service_impl` (::circt::esi::ServiceImplRecordOp)\n\n*Record of a service implementation*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.service_impl` qualified($appID) (`svc` $service^)? (`std` $stdService^)?\n              `by` $serviceImplName (`engine` $isEngine^)? `with` $implDetails\n              attr-dict-with-keyword custom<ServiceImplRecordReqDetails>($reqDetails)\n```\n\nA record of a service implementation. Optionally emitted by the service\nimplementation. Contains information necessary to connect to the service and\nservice clients.\n\nTraits: `NoTerminator`\n\nInterfaces: `HasAppID`, `IsManifestData`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `appID` | ::circt::esi::AppIDAttr | An application relevant instance identifier |\n| `isEngine` | ::mlir::UnitAttr | unit attribute |\n| `service` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `stdService` | ::mlir::StringAttr | string attribute |\n| `serviceImplName` | ::mlir::StringAttr | string attribute |\n| `implDetails` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n### `esi.service.impl_req.req` (::circt::esi::ServiceImplementConnReqOp)\n\n*The canonical form of a connection request*\n\nSyntax:\n\n```\noperation ::= `esi.service.impl_req.req` $servicePort `(` $relativeAppIDPath `)`\n              attr-dict `:` qualified(type($toClient))\n```\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `servicePort` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n| `relativeAppIDPath` | ::mlir::ArrayAttr | Array of AppIDs |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `toClient` | a bundle of channels |\n\n### `esi.service.impl_req` (::circt::esi::ServiceImplementReqOp)\n\n*Request for a service to be implemented*\n\nSyntax:\n\n```\noperation ::= `esi.service.impl_req` qualified($appID) (`svc` $service_symbol^)? `impl` `as` $impl_type\n              (`std` $stdService^)? (`opts` $impl_opts^)? `(` $inputs `)`\n              attr-dict `:` functional-type($inputs, results)\n              $portReqs\n```\n\nThe connect services pass replaces `service.instance`s with this op. The\n`portReqs` region is the set of connection requests which need to be\nimplemented for this service instance. Channels to/from the requests have\nbeen added to the operands/results of this op and consumers/producers have\nbeen redirected.\n\nSome other pass or frontend is expected to replace this op with an actual\nimplementation.\n\nTraits: `NoTerminator`\n\nInterfaces: `HasAppID`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `appID` | ::circt::esi::AppIDAttr | An application relevant instance identifier |\n| `service_symbol` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `impl_type` | ::mlir::StringAttr | string attribute |\n| `stdService` | ::mlir::StringAttr | string attribute |\n| `impl_opts` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `esi.service.instance` (::circt::esi::ServiceInstanceOp)\n\n*Instantiate a server module*\n\nSyntax:\n\n```\noperation ::= `esi.service.instance` qualified($appID) (`svc` $service_symbol^)? `impl` `as` $impl_type\n              (`opts` $impl_opts^)? `(` $inputs `)`\n              attr-dict `:` functional-type($inputs, results)\n```\n\nInstantiate a service adhering to a service declaration interface.\n\nA pass collects all of the connection requests to the service this op\nimplements from the containing modules\u2019 descendants (in the instance\nhierarchy). It bubbles them all up to the module containing this op,\ncreating the necessary ESI channel ports, groups them appropriately, then\nreplaces this op with a `service.impl_req`.\n\nIf \u2018service\\_symbol\u2019 isn\u2019t specified, this instance will be used to implement\nall of the service requests which get surfaced to here. This option is\ngenerally used at the top level to specify host connectivity.\n\nSince implementing the server will usually need \u201cnormal\u201d I/O, `inputs` and\n`results` act like normal `hw.instance` ports.\n\n$identifier is used by frontends to specify or remember the type of\nimplementation to use for this service.\n\nInterfaces: `HasAppID`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `appID` | ::circt::esi::AppIDAttr | An application relevant instance identifier |\n| `service_symbol` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `impl_type` | ::mlir::StringAttr | string attribute |\n| `impl_opts` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| \u00abunnamed\u00bb | variadic of any type |\n\n### `esi.manifest.req` (::circt::esi::ServiceRequestRecordOp)\n\n*Record of a service request*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.req` qualified($requestor) `,` $servicePort (`std` $stdService^)?\n              `,` $typeID attr-dict\n```\n\nA record of a service request, including the requestor, the service\nrequested, and the parameters of the request. Emitted before connecting the\nservice to preserve metadata about the original request.\n\nInterfaces: `HasAppID`, `IsManifestData`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `requestor` | ::circt::esi::AppIDAttr | An application relevant instance identifier |\n| `servicePort` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n| `stdService` | ::mlir::StringAttr | string attribute |\n| `typeID` | ::mlir::TypeAttr | type attribute of a bundle of channels |\n\n### `esi.snoop.xact` (::circt::esi::SnoopTransactionOp)\n\n*Get the data and transaction signal from a channel*\n\nSyntax:\n\n```\noperation ::= `esi.snoop.xact` $input attr-dict `:` qualified(type($input))\n```\n\nA snoop that observes when a transaction occurs on a channel and provides\nthe data being transmitted. The transaction signal indicates when data is\nactually being transferred on the channel, regardless of the underlying\nsignaling protocol (ValidReady or FIFO). Like other snoop operations, this\ndoes not count as another user of the channel. Useful for monitoring data\nflow and debugging.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `transaction` | 1-bit signless integer |\n| `data` | any type |\n\n### `esi.snoop.vr` (::circt::esi::SnoopValidReadyOp)\n\n*Get the valid, ready, and data signals from a channel*\n\nSyntax:\n\n```\noperation ::= `esi.snoop.vr` $input attr-dict `:` qualified(type($input))\n```\n\nA snoop allows one to combinationally observe a channel\u2019s internal signals.\nIt does not count as another user of the channel. Useful for constructing\ncontrol logic which can be combinationally driven. Also potentially useful\nfor debugging.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `valid` | 1-bit signless integer |\n| `ready` | 1-bit signless integer |\n| `data` | any type |\n\n### `esi.manifest.constants` (::circt::esi::SymbolConstantsOp)\n\n*Constant values associated with a symbol*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.constants` $symbolRef $constants attr-dict\n```\n\nInterfaces: `IsManifestData`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `symbolRef` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `constants` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n### `esi.manifest.sym` (::circt::esi::SymbolMetadataOp)\n\n*Metadata about a symbol*\n\nSyntax:\n\n```\noperation ::= `esi.manifest.sym` $symbolRef\n              (`name` $name^)?\n              (`repo` $repo^)?\n              (`commit` $commitHash^)?\n              (`version` $version^)?\n              (`summary` $summary^)?\n              attr-dict\n```\n\nMetadata about a symbol, including its name, repository, commit hash,\nversion, and summary. All are optional, but strongly encouraged. Any\nadditional metadata which users wish to attach should go as discardable\nattributes.\n\nInterfaces: `IsManifestData`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `symbolRef` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n| `repo` | ::mlir::StringAttr | string attribute |\n| `commitHash` | ::mlir::StringAttr | string attribute |\n| `version` | ::mlir::StringAttr | string attribute |\n| `summary` | ::mlir::StringAttr | string attribute |\n\n### `esi.service.std.telemetry` (::circt::esi::TelemetryServiceDeclOp)\n\n*Telemetry service*\n\nSyntax:\n\n```\noperation ::= `esi.service.std.telemetry` $sym_name attr-dict\n```\n\nDeclares a service to send telemetry data. Has one port \u2018report\u2019 for\nsomething to request telemetry data (via a \u2018get\u2019 channel to the client and a\n\u2018data\u2019 channel for the return value).\n\nTraits: `HasParent<::mlir::ModuleOp>`\n\nInterfaces: `ServiceDeclOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `esi.bundle.unpack` (::circt::esi::UnpackBundleOp)\n\n*Unpack channels from a bundle*\n\nSyntax:\n\n```\noperation ::= `esi.bundle.unpack` $fromChannels `from` $bundle attr-dict `:` custom<UnPackBundleType>(\n              type($toChannels), type($fromChannels), type($bundle))\n```\n\nInterfaces: `OpAsmOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `bundle` | a bundle of channels |\n| `fromChannels` | variadic of an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `toChannels` | variadic of an ESI channel |\n\n### `esi.unwrap.fifo` (::circt::esi::UnwrapFIFOOp)\n\n*Unwrap a value from an ESI port into a FIFO interface*\n\nSyntax:\n\n```\noperation ::= `esi.unwrap.fifo` $chanInput `,` $rden attr-dict `:` qualified(type($chanInput))\n```\n\nInterfaces: `ChannelOpInterface`, `InferTypeOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `chanInput` | an ESI channel |\n| `rden` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `data` | any type |\n| `empty` | 1-bit signless integer |\n\n### `esi.unwrap.iface` (::circt::esi::UnwrapSVInterfaceOp)\n\n*Unwrap an SV interface from an ESI port*\n\nSyntax:\n\n```\noperation ::= `esi.unwrap.iface` $chanInput `into` $interfaceSource attr-dict `:` `(` qualified(type($chanInput)) `,` qualified(type($interfaceSource)) `)`\n```\n\nUnwrap an ESI channel into a SystemVerilog interface containing valid,\nready, and data signals.\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `chanInput` | an ESI channel |\n| `interfaceSource` | sv.interface |\n\n### `esi.unwrap.vr` (::circt::esi::UnwrapValidReadyOp)\n\n*Unwrap a value from an ESI port*\n\nUnwrapping a value allows operations on the contained value. Unwrap the\nchannel along with a ready signal that you generate. Result is the data\nalong with a valid signal.\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `chanInput` | an ESI channel |\n| `ready` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `rawOutput` | any type |\n| `valid` | 1-bit signless integer |\n\n### `esi.window.unwrap` (::circt::esi::UnwrapWindow)\n\n*Unwrap a data window into a union*\n\nSyntax:\n\n```\noperation ::= `esi.window.unwrap` $window attr-dict `:` qualified(type($window))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `window` | a data window |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `frame` | any type |\n\n### `esi.wrap.fifo` (::circt::esi::WrapFIFOOp)\n\n*Wrap a value into an ESI port with FIFO signaling*\n\nSyntax:\n\n```\noperation ::= `esi.wrap.fifo` $data `,` $empty attr-dict `:`\n              custom<WrapFIFOType>(type($data), type($chanOutput))\n```\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `data` | any type |\n| `empty` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `chanOutput` | an ESI channel |\n| `rden` | 1-bit signless integer |\n\n### `esi.wrap.iface` (::circt::esi::WrapSVInterfaceOp)\n\n*Wrap an SV interface into an ESI port*\n\nSyntax:\n\n```\noperation ::= `esi.wrap.iface` $interfaceSink attr-dict `:` qualified(type($interfaceSink)) `->` qualified(type($output))\n```\n\nWrap a SystemVerilog interface into an ESI channel. Interface MUST look\nlike an interface produced by ESI meaning it MUST contain valid, ready,\nand data signals. Any other signals will be discarded.\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `interfaceSink` | sv.interface |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | an ESI channel |\n\n### `esi.wrap.vr` (::circt::esi::WrapValidReadyOp)\n\n*Wrap a value into an ESI port*\n\nWrapping a value into an ESI port type allows modules to send values down\nan ESI port. Wrap data with valid bit, result is the ESI channel and the\nready signal from the other end of the channel.\n\nInterfaces: `ChannelOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `rawInput` | any type |\n| `valid` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `chanOutput` | an ESI channel |\n| `ready` | 1-bit signless integer |\n\n### `esi.window.wrap` (::circt::esi::WrapWindow)\n\n*Wrap a union into a data window*\n\nSyntax:\n\n```\noperation ::= `esi.window.wrap` $frame attr-dict `:` custom<InferWindowRet>(type($frame), type($window))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `frame` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `window` | a data window |\n\nStructural\n----------\n\nESI has a special module which doesn\u2019t expose ports. All external interactions\nare expected to be done through services.\n\n### `esi.pure_module.input` (::circt::esi::ESIPureModuleInputOp)\n\n*Inputs become input ports when the module is lowered*\n\nSyntax:\n\n```\noperation ::= `esi.pure_module.input` $name attr-dict `:` type($value)\n```\n\nTo create input ports when lowering a pure module op into an HWModuleOp, use\nthis op. This op is typically created by a service implementation generator.\n\nIf two \u2018input\u2019 ops exist in the same block, the names match, and the type\nmatches they\u2019ll become one port during lowering. Two or more may not exist\nwith the same name and different types. Useful for \u2018clk\u2019 and \u2018rst\u2019.\n\nTraits: `HasParent<ESIPureModuleOp>`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `value` | any type |\n\n### `esi.pure_module` (::circt::esi::ESIPureModuleOp)\n\n*ESI pure module*\n\nSyntax:\n\n```\noperation ::= `esi.pure_module` $sym_name attr-dict-with-keyword $body\n```\n\nA module containing only ESI channels and modules with only ESI ports. All\nnon-local connectivity is done through ESI services. If this module is the\ntop level in the design, then the design\u2019s actual top level ports are\ndefined by a BSP.\n\nUseful on its own for simulation and BSPs which don\u2019t define a top-level.\n\nTraits: `HasParent<mlir::ModuleOp>`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `HWModuleLike`, `InstanceGraphModuleOpInterface`, `PortList`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `esi.pure_module.output` (::circt::esi::ESIPureModuleOutputOp)\n\n*Outputs become output ports when the module is lowered*\n\nSyntax:\n\n```\noperation ::= `esi.pure_module.output` $name `,` $value attr-dict `:` type($value)\n```\n\nTo create output ports when lowering a pure module op into an HWModuleOp, use\nthis op. This op is typically created by a service implementation generator.\n\nTwo \u2018output\u2019 ops with the same name cannot exist in the same block.\n\nTraits: `HasParent<ESIPureModuleOp>`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `value` | any type |\n\n### `esi.pure_module.param` (::circt::esi::ESIPureModuleParamOp)\n\n*Params become module parameters when the module is lowered*\n\nSyntax:\n\n```\noperation ::= `esi.pure_module.param` $name `:` $type attr-dict\n```\n\nAllows attaching parameters to modules which become HW module parameters\nwhen lowering. Currently, they are ignored. Some low-level BSPs instantiate\nmodules with parameters. This allows the modules produced to accept\nparameters so those BSPs can instantiate them.\n\nTraits: `HasParent<ESIPureModuleOp>`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `type` | ::mlir::TypeAttr | any type attribute |\n\nInterfaces\n----------\n\nMisc CIRCT interfaces.\n\nChannelOpInterface (`ChannelOpInterface`)\n-----------------------------------------\n\n\u201cAn interface for operations which carries channel semantics.\u201d\n\n### Methods:\n\n#### `channelType`\n\n```\ncirct::esi::ChannelType channelType();\n```\n\n\u201cReturns the channel type of this operation.\u201d\n\nNOTE: This method *must* be implemented by the user.\n\n#### `innerType`\n\n```\nmlir::Type innerType();\n```\n\n\u201cReturns the inner type of this channel. This will be the type of the\ndata value of the channel, if the channel carries data semantics. Else,\nreturn NoneType.\u201d\n\nNOTE: This method *must* be implemented by the user.\n\nHasAppID (`HasAppIDOpInterface`)\n--------------------------------\n\nOp can be identified by an AppID.\n\n### Methods:\n\n#### `getAppID`\n\n```\n::circt::esi::AppIDAttr getAppID();\n```\n\nReturns the AppID of this operation.\n\nNOTE: This method *must* be implemented by the user.\n\nIsManifestData (`IsManifestData`)\n---------------------------------\n\nOp\u2019s attributes should be represented in the manifest.\n\n### Methods:\n\n#### `getManifestClass`\n\n```\nStringRef getManifestClass();\n```\n\nGet the class name for this op.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getSymbolRefAttr`\n\n```\nFlatSymbolRefAttr getSymbolRefAttr();\n```\n\nGet the symbol to which this manifest data is referring, if any.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getDetails`\n\n```\nvoid getDetails(SmallVectorImpl<NamedAttribute>&results);\n```\n\nPopulate results with the manifest data.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getDetailsAsDict`\n\n```\nDictionaryAttr getDetailsAsDict();\n```\n\nGet the manifest data from this op as an attribute.\n\nNOTE: This method *must* be implemented by the user.\n\nServiceDeclOpInterface (`ServiceDeclOpInterface`)\n-------------------------------------------------\n\nAny op which represents a service declaration should implement this\ninterface.\n\n### Methods:\n\n#### `getPortList`\n\n```\nvoid getPortList(llvm::SmallVectorImpl<ServicePortInfo>&ports);\n```\n\nReturns the list of interface ports for this service interface.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getTypeName`\n\n```\nstd::optional<StringRef> getTypeName();\n```\n\nReturn a well-known name for this service type.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortInfo`\n\n```\nFailureOr<ServicePortInfo> getPortInfo(StringAttr portName);\n```\n\nGet info on a particular port.\n\nNOTE: This method *must* be implemented by the user.\n\n'esi' Dialect Docs\n------------------\n\n* [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n* [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n* [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n* [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n* [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n\n [Prev - Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/ \"Emission (Emit) Dialect Rationale\")\n[Next - ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/ \"ESI data types and communication types\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/ESI/types/index.md"
  },
  {
    "role": "user",
    "content": "ESI data types and communication types - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nESI data types and communication types\n======================================\n\nESI has two different classes of MLIR types: ones which represent data on the\nwires (data types) and ones which specify the type of communication. From a user\nperspective, communication types aren\u2019t really types \u2013 this is just how the\ncommunication style is modeled in MLIR and thus an implementation detail.\n\nData types\u00a0[\u00b6](#data-types)\n---------------------------\n\nIn addition to the types in the `hw` dialect, ESI will add few:\n\n### Void\u00a0[\u00b6](#void)\n\n`void` translates to \u201cno data\u201d, meaning just a control signal.\n\nStatus: **planned**\n\n### Lists\u00a0[\u00b6](#lists)\n\nLists are used to reason about variably-sized data. There are two types of\nlists: those for which the size is known before transmission begins (a fixed\nsize list, or **fixed\\_list**), and those for which it isn\u2019t (a variably sized\nlist, or just **list**). `fixed_lists` are **very** roughly similar to a C\npointer/size pair (in that they contain a size upfront) whereas `lists` are\nroughly similar to a simply singlely linked list wherein the size is not known\nuntil one iterates through it.\n\nSince it isn\u2019t yet clear what (if any) benefit `fixed_list` will provide, it is\nnot plan-of-record to implement it. `list` will be implemented in the future.\n\nStatus: **planned**\n\nCommunication types\u00a0[\u00b6](#communication-types)\n---------------------------------------------\n\nAs stated above, communication \u201ctypes\u201d do not represent data on the wire;\nrather, they speak to the signaling.\n\nChannels\u00a0[\u00b6](#channels)\n-----------------------\n\nESI \u201cchannels\u201d are streaming connections upon which *messages* can be sent and\nreceived. They are expressed by wrapping the type (e.g. `!esi.channel<i5>`) and\nusing it like any other value type.\n\n```\nhw.module @add11(%clk: i1, %ints: !esi.channel<i32>) -> (%outs: !esi.channel<i32> ) {\n  hw.output %ints\n}\n```\n\nThe value which the channel is carrying must be (un)wrapped to access it:\n\n```\nhw.module @add11(%clk: i1, %ints: !esi.channel<i32>) -> (mutatedInts: !esi.channel<i32>) {\n  %i, %i_valid = esi.unwrap.vr %ints, %rdy\n  %c11 = hw.constant 11\n  %m = comb.add %c11, %i\n  %mutInts, %rdy = esi.wrap.vr %m, %i_valid\n  hw.output %mutInts\n}\n```\n\n[insert diagram of wrap/unwrap]\n\nStatus: **complete and stable** (for supported data types)\n\nMemory-mapped IO\u00a0[\u00b6](#memory-mapped-io)\n---------------------------------------\n\n*This section is not fully thought out or written about. It is certainly not\nimplemented. The text in this section should be considered initial thoughts.*\n\nStatus: **Planning**\n\n### MMIO Regions\u00a0[\u00b6](#mmio-regions)\n\nThe basic idea is to present ESI memory mapped **regions** exposed by\nmodules. There could be any number of these regions exposed and they\nwould work somewhat like input (request) / output (response) port pairs,\nbut with implicit request-response signaling and structure. The MMIO\nspace itself would be defined by a statically sized struct (so lists\nwould be disallowed), with address offsets implicitly or explicitly\ndefined. The method for base address assignment is yet to be decided.\nThese regions can support atomic reads or writes of arbitrary size or\nlimited size.\n\n### MMIO Requests (read/write)\u00a0[\u00b6](#mmio-requests-readwrite)\n\nOther modules connected to the same MMIO bus could specify read/write\nrequests in several ways:\n\n* As a data window with blinds (or similar construct) specifying the\n  struct fields to read/write\n* As a list of address offsets and sizes or data to read/write\n\nAlong with the request content, atomicity of the request would have to\nbe specified. The response on a read would correspond to the read\nrequest \u2013 either a list of bytes read or a data window with the\nrequested data filled in. For a write, a simple acknowledgement or error\nwould suffice for the response.\n\n### Automatic self-description\u00a0[\u00b6](#automatic-self-description)\n\nAn MMIO region\u2019s data type can be used to automatically generate a\nself-describing software data type and an access API. Additionally, a per\nMMIO bus table could be generated with the base addresses for each connected\nregion and a descriptor for each.\n\n### Software access\u00a0[\u00b6](#software-access)\n\nThe MMIO struct would become a software struct which software could map\nto the base address as a typed pointer. This way, software access would\nbe simpler (just a normal struct pointer dereference \u2013 e.g. p->field1)\nand safer as it knows the correct address implicitly and the type of\nthat field. Additionally, if the MMIO region knows the processor\u2019s\nendianness, it could respond in the correct endianness. How to initiate\nan atomic read/write of multiple fields from software is undecided yet,\nthough there may be some merit to exposing data windows to software.\n\n### Additional Type: any\u00a0[\u00b6](#additional-type-any)\n\nAn MMIO space can be have type **any** to allow access to memory spaces which\nare fundamentally untyped (e.g. memory-mapped host RAM). In this case, the\nrequestor can specify the type. For instance, to access 64-bit values the\nrequestor would send a request with a given address and specify a uint<64> type\nresponse or write. Alternatively, it could request a response or write type of\ntype struct ConfigSpace to specify it wants to read or write a configuration.\n\n### Implementation\u00a0[\u00b6](#implementation)\n\nThe MMIO system *could* be implemented on top of the streaming portion.\n\nData windows\n============\n\nBy default, an entire message is guaranteed to be presented to the receiving\nmodule in one clock cycle (excepting `lists`). For particularly large messages,\nthis is not ideal as it requires a data path equal to the size of the message.\nData windows specify which parts of a message a module accepts on each clock\ncycle. For structs, they specify which members are accepted on which cycles. For\narrays and lists, they specify how many items can be accepted each clock cycle.\n\nData windows do not affect port compatibility. In other words, a designer can\nconnect ports using two different windows into the same data type. This can be\nused to connect different modules with different bandwidths. A data window\nmerely specifies the logical \u201cgasket\u201d used to connect two differently sized\nports.\n\nThe MLIR representation of data windows has yet to be determined.\n\nStatus: **planning**\n\n [Prev - 'esi' Dialect](https://circt.llvm.org/docs/Dialects/ESI/ \"'esi' Dialect\")\n[Next - ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/ \"ESI Global Services\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect-](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/ESI/services/index.md"
  },
  {
    "role": "user",
    "content": "ESI Global Services - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nESI Global Services\n===================\n\n*This section not fully fleshed out and suffers from poor writing.*\n\nESI will provide access to global resource via **ESI Services**. These\n\u201cbuses\u201d define a typed interface and instances are instantiated globally\n\u2013 they should be accessible at all levels of the design hierarchy. ESI\nservices are intended to provide access to truly global resources like\nPCIe, shared DMA engines, DRAM, network interfaces, etc. They are\ngeneric enough to be extended to non-physical interfaces like telemetry\n\u2013 if you have a centralized telemetry reporting engine, you probably\nwant any module or submodule in the design to be able to access and\nreport to it.\n\nStatus: **planning**\n\nService/Client & Directions\u00a0[\u00b6](#serviceclient--directions)\n-----------------------------------------------------------\n\nESI services have servers and clients which are roughly analogous to\nmasters and slaves in traditional buses, but with slightly different\nmeanings. Whereas master/slave denote who can initiate a transaction,\nservers/clients denote the many-to-many or one-to-many relationship.\nSpecifically, servers are expected to have many clients. Any service or\nclient can initiate a transaction, depending on the direction specified.\n\nWhether a module implements a server or client must be explicitly declared in\nthe module declaration. Directions (out/in) of data channels/MMIO are\ndetermined by that explicit declaration and the direction specified in the\nservice definition. Four different directions are allowed in the service\ndefinition: `ToServer`, `ToServers`, `ToClient`, `ToClients`. The plurals\nindicate the messages sent should be broadcast to all servers or client. The\nsingular form indicates that a specific server or client must be addressed\nwhen sending a message unless the server is single server and the sender is a\nclient.\n\nService Definitions\u00a0[\u00b6](#service-definitions)\n---------------------------------------------\n\nAn ESI service is essentially an interface which modules are required to\nimplement to connect to a given service. The first attribute which must be\nspecified is whether multiple servers are allowed via the `single` or\n`multi` keywords. The second is a list of MMIO and/or channels and\nassociated directions.\n\nMessage Sizes\u00a0[\u00b6](#message-sizes)\n---------------------------------\n\nA `ToServer` data channel is free to block (backpressure) other clients\nwhile one is sending a message. As such, in most cases it is best to\nkeep messages short. While the **list** type is allowed, it is easy to\nabuse.\n\nWire Level Signaling\u00a0[\u00b6](#wire-level-signaling)\n-----------------------------------------------\n\nThe ESI compiler is free to choose any communication substrate which implements\nthe required functionality. A traditional interconnect is not guaranteed, though\nthe ESI compiler will may select a traditional signaling protocol like Avalon-MM\nor AXI AMBA in many cases.\n\nExamples\u00a0[\u00b6](#examples)\n-----------------------\n\n(Pseudocode in C++-ish/Verilog-ish style since MLIR asm syntax TDB.)\n\n```\n// DMA_Request, Response are structs.\n\nservice HostMemory single { // Specify a service with one server\n    ToServer MMIO<any> Memory; // An untyped MMIO wherein the server\n                                 // is the 'slave'\n    ToServer DMA_Request DmaReq; // DMA access\n    ToClient DMA_Response DmaResp;\n}\n\nmodule NiosProcessor { // A NIOS core allowing memory access\n    server HostMemory Mem; // A single master server can be implicitly\n                           // instantiated and referred to be the\n                           // module's instance name\n}\n```\n\n```\nservice Telemetry multi { // Specify a service with multiple servers\n    ToClients void RequestStatus; // Any server can request a status update\n                                  // from every client\n    ToServers Event<AllStatusesUnion> Events; // Clients can respond to all\n                                              // the servers\n}\n\nTelemetry GlobalBroadcastTelemetry;\n```\n\n```\nservice RoutedNetwork multi { // A service with multiple servers\n    ToServer NetworkPacket Send; // Clients must select a server\n    ToClient NetworkPacket Recv; // Servers must select a particular client\n    ToServer MMIO<RoutingConfig> Config; // A per-server configuration interface\n}\n\nRoutedNetwork Net;\n\nmodule NetTelemetryProcessor { // A module which collects telemetry\n                               // and sends it over the network\n    server Telemetry TelemetryInput;\n    client RoutedNetwork TelemetryOutput;\n}\n\nNetTelemetryProcessor netTelemProc (\n    .TelemetryInput(GlobalBroadcastTelemetry),\n    .TelemetryOutput(Net)\n)\n```\n\n [Prev - ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/ \"ESI data types and communication types\")\n[Next - ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/ \"ESI Software APIs\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect-](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/ESI/software_api/index.md"
  },
  {
    "role": "user",
    "content": "ESI Software APIs - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nESI Software APIs\n=================\n\n*More on this to be written.*\n\nStatus: **unimplemented**\n\nThanks to ESI\u2019s strong static typing, typed, design-dependent software APIs can\nbe automatically generated. Said APIs would be mostly independent of the\ntransport mechanism (PCIe, network, etc.) used to communicate with the silicon.\nThe same API could even drive a simulation of the ESI system.\n\nSaid APIs would need to ensure that the software is talking to the correct\nhardware. There are several possible approaches:\n\n* Generate a hash which is contained in the API and the hardware then compare\n  at runtime. This has the downside of software not being able to communicate\n  with logically compatible hardware. (E.g. mismatched interfaces which aren\u2019t\n  used.)\n* Communicate via some self-describing message format (e.g. protobuf or\n  bond). This has the downside of encoding/decoding overhead.\n* Auto-generate self-describing hardware for dynamic discovery of\n  functionality. This would allow software to be built without a static API\n  (e.g. a generic poke/prod script). The downside is larger hardware area, though\n  maybe not by much.\n\n [Prev - ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/ \"ESI Global Services\")\n[Next - Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/ \"Miscellaneous Notes\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect-](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/ESI/notes/index.md"
  },
  {
    "role": "user",
    "content": "Miscellaneous Notes - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nMiscellaneous Notes\n===================\n\nABI\u00a0[\u00b6](#abi)\n-------------\n\nThe ABI specifies how an ESI \u201cAPI\u201d is translated to hardware,\nspecifically RTL. This involves both the wire-level signaling between\nmodules and how data is arranged on those wires.\n\nThis section is purposely underspecified in this proposal as it should be an\nimplementation detail which only advanced users need know. The main issues\ndiscussed here are how lists and data windows are lowered and presented to\nRTL modules. Lowering of fixed-size, default-presentation semantics ports is\nmostly straight forward, so is not discussed here.\n\n### Wire-level signaling\u00a0[\u00b6](#wire-level-signaling)\n\nSince ESI connections are elastic (latency-insensitive), the signaling\nscheme must include some notion of validity and some notion of\nbackpressure. This rules out interfaces which inherently cannot be\nback-pressured, though future ESI specs may support non-backpressure\n(feed-forward) interfaces. For now, a buffering gasket which\nconverts between ESI and the non-backpressure-able interface is\nnecessary, perhaps implementing backpressure in a higher-level protocol\n(e.g. not initiating DMA transfers until space exists to buffer them).\nThese typically exist somewhere in many if not most designs.\n\nIt is up to the compiler to determine the appropriate wire signaling\nscheme to use for message transfer between ESI interfaces. (The designer\ncan optionally specify it manually.) If buffering is required, the\nmodule should state that it is required and then the compiler should\nbuild it automatically. The interface to an RTL module, however, is up\nto that particular module.\n\nThere are several existing standards which we should consider\nimplementing:\n\n* AXI Stream/AMBA\n* Avalon-MM/Avalon-ST\n* Simple valid/ready-ack semantics (this should be the default) for\n  streaming\n* Simple RW RAM-style interface (this should be the default) for MMIO\n\n### Lists and Data Windows\u00a0[\u00b6](#lists-and-data-windows)\n\nThe basic idea behind presenting lists and data windows to modules (at\nleast with simple valid/ready-ack semantics) is that ESI can\nautomatically construct the proper state machines automatically and to\nessentially present a discriminated union which informs the RTL which\npart of the message is currently being presented \u2013 the particular data\nwindow part and/or position in a list.\n\nA note on language implementation\u00a0[\u00b6](#a-note-on-language-implementation)\n-------------------------------------------------------------------------\n\nIt is not always clear how a particular hardware design language (HDL)\nwould be made to support all of the ESI constructs. That\u2019s fine \u2013 not\nall HDLs are suited to all the ESI constructs. For instance, some\nlanguages are only designed for data stream processing so only the data\nchannel (streaming) parts of ESI make sense. Maybe a compiler for said\nlanguage would also generate some MMIO regions/clients (to access DRAM, PCIe,\nnetwork, et cetera).\n\nAn HDL compiler which supports ESI is not required to implement the\nentire ESI spec. Rather, it is encouraged to only implement the parts of\nESI that make sense; however, it is also encouraged that the compiler\nauthors think long and hard about which constructs make sense. For\nexample, for an RTL compiler it may not be immediately obvious how to\nsupport **`lists`**, the variable length data type. After further\nconsideration, however, one may realize that RTL can accept variable\nlength data over multiple cycles. In fact, this is the intention as\nvariable length data in hardware is generally reasoned about and\nimplemented in the temporal dimension rather than the spatial one.\n\u201cGeneral purpose\u201d HDLs (i.e. SystemVerilog) compilers are encouraged to\nsupport all of the ESI specification.\n\n [Prev - ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/ \"ESI Software APIs\")\n[Next - The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/ \"The Elastic Silicon Interconnect dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect-](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/ESI/RationaleESI/index.md"
  },
  {
    "role": "user",
    "content": "The Elastic Silicon Interconnect dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nThe Elastic Silicon Interconnect dialect\n========================================\n\nLong ago, software function calling conventions were ad-hoc. This led to\nissues, particularly with register clobbering and stack corruption. This is \u2013\nin large part \u2013 the state of FPGA/ASIC design today: wire signaling protocols\nare often ad-hoc, which also leads to major issues. Though there are efforts\nto standardize the signaling protocols there are many minor and major\nvariants, both of which lead to confusion which can cause real problems when\none is listening to and twiddling the wires manually. ESI solves this by\nproviding a simple, intuitive, common, and standardized interface to developers\nand then figures out the signaling details and conversions between them.\n\nWhile the ABI/signaling problem is slowly being partially solved, it does not\nspeak to the types of data on the wires \u2013 the software analogy being memory\nand registers. In the software world, data types were added. More and more\ncomplex type systems began to evolve \u2013 to great successes in some cases as\nstrong typing can help developers avoid bugs and assist in debugging. In the\nFPGA/ASIC world, RTL-level languages are starting to get basic types but\nacross interconnects it is still common for the data types to be informally\nspecified in a data sheet. This indicates a total failure of the basic type\nsystem which RTL supports.\n\nThe Elastic Silicon Interconnect (ESI) project raises the bar on both fronts. On\nthe data type front, it (will) define a rich, hardware-centric type system to\nallow more formal data type definitions and strong static type safety. On the\nABI/signaling front, it can build simple, latency-insensitive interfaces and\nabstract away the signaling protocol. Essentially, the intent is to cleanly\nseparate/abstract the physical signaling layer from the message layer. This\nenables many tasks to be automated including \u2013 but not limited to \u2013 the\nfollowing:\n\n1. Inter-language communication\n2. Type checking to reduce bugs at interface boundaries\n3. Correct-by-construction building of communication fabric (including clock\n   domain crossings)\n4. Decision making about the physical signaling between modules\n5. Software API generation which bridges over PCIe, network, or simulation\n6. Pipelining based on floor planning between modules to reduce timing closure\n   pressure\n7. Compatibility between modules with different bandwidths (automatic\n   gearboxing)\n8. Type and signal aware debuggers/monitors in communication fabric\n9. Common interface for board support packages\n10. Extensible services to support global resources (e.g. telemetry)\n\nStatus\u00a0[\u00b6](#status)\n-------------------\n\nThe ESI project is in its infancy \u2013 it is not complete by any means. We are\nalways looking for people to experiment with it and contribute!\n\nPublications\u00a0[\u00b6](#publications)\n-------------------------------\n\n\u201cElastic Silicon Interconnects: Abstracting Communication in Accelerator\nDesign\u201d, John Demme (Microsoft).\n[paper](https://capra.cs.cornell.edu/latte21/paper/8.pdf),\n[talk](https://www.youtube.com/watch?v=gjOkGX2E7EY).\n\n [Prev - Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/ \"Miscellaneous Notes\")\n[Next - 'firrtl' Dialect](https://circt.llvm.org/docs/Dialects/FIRRTL/ \"'firrtl' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect-](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/FIRRTL/index.md"
  },
  {
    "role": "user",
    "content": "'firrtl' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'firrtl' Dialect\n================\n\nThis dialect defines the `firrtl` dialect, which is used to lower from Chisel\ncode to Verilog. For more information, see the\n[FIRRTL GitHub\npage](https://github.com/freechipsproject/firrtl).\n\n* [Operation Definitions \u2013 Structure](#operation-definitions----structure)\n  + [`firrtl.circuit` (::circt::firrtl::CircuitOp)](#firrtlcircuit-circtfirrtlcircuitop)\n  + [`firrtl.class` (::circt::firrtl::ClassOp)](#firrtlclass-circtfirrtlclassop)\n  + [`firrtl.domain` (::circt::firrtl::DomainOp)](#firrtldomain-circtfirrtldomainop)\n  + [`firrtl.extclass` (::circt::firrtl::ExtClassOp)](#firrtlextclass-circtfirrtlextclassop)\n  + [`firrtl.extmodule` (::circt::firrtl::FExtModuleOp)](#firrtlextmodule-circtfirrtlfextmoduleop)\n  + [`firrtl.intmodule` (::circt::firrtl::FIntModuleOp)](#firrtlintmodule-circtfirrtlfintmoduleop)\n  + [`firrtl.memmodule` (::circt::firrtl::FMemModuleOp)](#firrtlmemmodule-circtfirrtlfmemmoduleop)\n  + [`firrtl.module` (::circt::firrtl::FModuleOp)](#firrtlmodule-circtfirrtlfmoduleop)\n  + [`firrtl.formal` (::circt::firrtl::FormalOp)](#firrtlformal-circtfirrtlformalop)\n  + [`firrtl.layer` (::circt::firrtl::LayerOp)](#firrtllayer-circtfirrtllayerop)\n  + [`firrtl.option_case` (::circt::firrtl::OptionCaseOp)](#firrtloption_case-circtfirrtloptioncaseop)\n  + [`firrtl.option` (::circt::firrtl::OptionOp)](#firrtloption-circtfirrtloptionop)\n  + [`firrtl.simulation` (::circt::firrtl::SimulationOp)](#firrtlsimulation-circtfirrtlsimulationop)\n* [Operation Definitions \u2013 Declarations](#operation-definitions----declarations)\n  + [`firrtl.contract` (::circt::firrtl::ContractOp)](#firrtlcontract-circtfirrtlcontractop)\n  + [`firrtl.domain.anon` (::circt::firrtl::DomainCreateAnonOp)](#firrtldomainanon-circtfirrtldomaincreateanonop)\n  + [`firrtl.instance_choice` (::circt::firrtl::InstanceChoiceOp)](#firrtlinstance_choice-circtfirrtlinstancechoiceop)\n  + [`firrtl.instance` (::circt::firrtl::InstanceOp)](#firrtlinstance-circtfirrtlinstanceop)\n  + [`firrtl.mem` (::circt::firrtl::MemOp)](#firrtlmem-circtfirrtlmemop)\n  + [`firrtl.node` (::circt::firrtl::NodeOp)](#firrtlnode-circtfirrtlnodeop)\n  + [`firrtl.object` (::circt::firrtl::ObjectOp)](#firrtlobject-circtfirrtlobjectop)\n  + [`firrtl.reg` (::circt::firrtl::RegOp)](#firrtlreg-circtfirrtlregop)\n  + [`firrtl.regreset` (::circt::firrtl::RegResetOp)](#firrtlregreset-circtfirrtlregresetop)\n  + [`firrtl.wire` (::circt::firrtl::WireOp)](#firrtlwire-circtfirrtlwireop)\n* [Statement Operation \u2013 Statements](#statement-operation----statements)\n  + [`firrtl.assert` (::circt::firrtl::AssertOp)](#firrtlassert-circtfirrtlassertop)\n  + [`firrtl.assume` (::circt::firrtl::AssumeOp)](#firrtlassume-circtfirrtlassumeop)\n  + [`firrtl.attach` (::circt::firrtl::AttachOp)](#firrtlattach-circtfirrtlattachop)\n  + [`firrtl.bind` (::circt::firrtl::BindOp)](#firrtlbind-circtfirrtlbindop)\n  + [`firrtl.connect` (::circt::firrtl::ConnectOp)](#firrtlconnect-circtfirrtlconnectop)\n  + [`firrtl.cover` (::circt::firrtl::CoverOp)](#firrtlcover-circtfirrtlcoverop)\n  + [`firrtl.domain.define` (::circt::firrtl::DomainDefineOp)](#firrtldomaindefine-circtfirrtldomaindefineop)\n  + [`firrtl.fflush` (::circt::firrtl::FFlushOp)](#firrtlfflush-circtfirrtlfflushop)\n  + [`firrtl.fprintf` (::circt::firrtl::FPrintFOp)](#firrtlfprintf-circtfirrtlfprintfop)\n  + [`firrtl.force` (::circt::firrtl::ForceOp)](#firrtlforce-circtfirrtlforceop)\n  + [`firrtl.layerblock` (::circt::firrtl::LayerBlockOp)](#firrtllayerblock-circtfirrtllayerblockop)\n  + [`firrtl.match` (::circt::firrtl::MatchOp)](#firrtlmatch-circtfirrtlmatchop)\n  + [`firrtl.matchingconnect` (::circt::firrtl::MatchingConnectOp)](#firrtlmatchingconnect-circtfirrtlmatchingconnectop)\n  + [`firrtl.printf` (::circt::firrtl::PrintFOp)](#firrtlprintf-circtfirrtlprintfop)\n  + [`firrtl.propassign` (::circt::firrtl::PropAssignOp)](#firrtlpropassign-circtfirrtlpropassignop)\n  + [`firrtl.ref.define` (::circt::firrtl::RefDefineOp)](#firrtlrefdefine-circtfirrtlrefdefineop)\n  + [`firrtl.ref.force_initial` (::circt::firrtl::RefForceInitialOp)](#firrtlrefforce_initial-circtfirrtlrefforceinitialop)\n  + [`firrtl.ref.force` (::circt::firrtl::RefForceOp)](#firrtlrefforce-circtfirrtlrefforceop)\n  + [`firrtl.ref.release_initial` (::circt::firrtl::RefReleaseInitialOp)](#firrtlrefrelease_initial-circtfirrtlrefreleaseinitialop)\n  + [`firrtl.ref.release` (::circt::firrtl::RefReleaseOp)](#firrtlrefrelease-circtfirrtlrefreleaseop)\n  + [`firrtl.skip` (::circt::firrtl::SkipOp)](#firrtlskip-circtfirrtlskipop)\n  + [`firrtl.stop` (::circt::firrtl::StopOp)](#firrtlstop-circtfirrtlstopop)\n  + [`firrtl.int.verif.assert` (::circt::firrtl::VerifAssertIntrinsicOp)](#firrtlintverifassert-circtfirrtlverifassertintrinsicop)\n  + [`firrtl.int.verif.assume` (::circt::firrtl::VerifAssumeIntrinsicOp)](#firrtlintverifassume-circtfirrtlverifassumeintrinsicop)\n  + [`firrtl.int.verif.cover` (::circt::firrtl::VerifCoverIntrinsicOp)](#firrtlintverifcover-circtfirrtlverifcoverintrinsicop)\n  + [`firrtl.int.verif.ensure` (::circt::firrtl::VerifEnsureIntrinsicOp)](#firrtlintverifensure-circtfirrtlverifensureintrinsicop)\n  + [`firrtl.int.verif.require` (::circt::firrtl::VerifRequireIntrinsicOp)](#firrtlintverifrequire-circtfirrtlverifrequireintrinsicop)\n  + [`firrtl.when` (::circt::firrtl::WhenOp)](#firrtlwhen-circtfirrtlwhenop)\n* [Operation Definitions \u2013 Expressions](#operation-definitions----expressions)\n  + [`firrtl.add` (::circt::firrtl::AddPrimOp)](#firrtladd-circtfirrtladdprimop)\n  + [`firrtl.aggregateconstant` (::circt::firrtl::AggregateConstantOp)](#firrtlaggregateconstant-circtfirrtlaggregateconstantop)\n  + [`firrtl.and` (::circt::firrtl::AndPrimOp)](#firrtland-circtfirrtlandprimop)\n  + [`firrtl.andr` (::circt::firrtl::AndRPrimOp)](#firrtlandr-circtfirrtlandrprimop)\n  + [`firrtl.asAsyncReset` (::circt::firrtl::AsAsyncResetPrimOp)](#firrtlasasyncreset-circtfirrtlasasyncresetprimop)\n  + [`firrtl.asClock` (::circt::firrtl::AsClockPrimOp)](#firrtlasclock-circtfirrtlasclockprimop)\n  + [`firrtl.asSInt` (::circt::firrtl::AsSIntPrimOp)](#firrtlassint-circtfirrtlassintprimop)\n  + [`firrtl.asUInt` (::circt::firrtl::AsUIntPrimOp)](#firrtlasuint-circtfirrtlasuintprimop)\n  + [`firrtl.bitcast` (::circt::firrtl::BitCastOp)](#firrtlbitcast-circtfirrtlbitcastop)\n  + [`firrtl.bits` (::circt::firrtl::BitsPrimOp)](#firrtlbits-circtfirrtlbitsprimop)\n  + [`firrtl.bool` (::circt::firrtl::BoolConstantOp)](#firrtlbool-circtfirrtlboolconstantop)\n  + [`firrtl.bundlecreate` (::circt::firrtl::BundleCreateOp)](#firrtlbundlecreate-circtfirrtlbundlecreateop)\n  + [`firrtl.cat` (::circt::firrtl::CatPrimOp)](#firrtlcat-circtfirrtlcatprimop)\n  + [`firrtl.constCast` (::circt::firrtl::ConstCastOp)](#firrtlconstcast-circtfirrtlconstcastop)\n  + [`firrtl.constant` (::circt::firrtl::ConstantOp)](#firrtlconstant-circtfirrtlconstantop)\n  + [`firrtl.cvt` (::circt::firrtl::CvtPrimOp)](#firrtlcvt-circtfirrtlcvtprimop)\n  + [`firrtl.dshl` (::circt::firrtl::DShlPrimOp)](#firrtldshl-circtfirrtldshlprimop)\n  + [`firrtl.dshlw` (::circt::firrtl::DShlwPrimOp)](#firrtldshlw-circtfirrtldshlwprimop)\n  + [`firrtl.dshr` (::circt::firrtl::DShrPrimOp)](#firrtldshr-circtfirrtldshrprimop)\n  + [`firrtl.div` (::circt::firrtl::DivPrimOp)](#firrtldiv-circtfirrtldivprimop)\n  + [`firrtl.double` (::circt::firrtl::DoubleConstantOp)](#firrtldouble-circtfirrtldoubleconstantop)\n  + [`firrtl.eq` (::circt::firrtl::EQPrimOp)](#firrtleq-circtfirrtleqprimop)\n  + [`firrtl.elementwise_and` (::circt::firrtl::ElementwiseAndPrimOp)](#firrtlelementwise_and-circtfirrtlelementwiseandprimop)\n  + [`firrtl.elementwise_or` (::circt::firrtl::ElementwiseOrPrimOp)](#firrtlelementwise_or-circtfirrtlelementwiseorprimop)\n  + [`firrtl.elementwise_xor` (::circt::firrtl::ElementwiseXorPrimOp)](#firrtlelementwise_xor-circtfirrtlelementwisexorprimop)\n  + [`firrtl.enumcreate` (::circt::firrtl::FEnumCreateOp)](#firrtlenumcreate-circtfirrtlfenumcreateop)\n  + [`firrtl.integer` (::circt::firrtl::FIntegerConstantOp)](#firrtlinteger-circtfirrtlfintegerconstantop)\n  + [`firrtl.geq` (::circt::firrtl::GEQPrimOp)](#firrtlgeq-circtfirrtlgeqprimop)\n  + [`firrtl.gt` (::circt::firrtl::GTPrimOp)](#firrtlgt-circtfirrtlgtprimop)\n  + [`firrtl.hwStructCast` (::circt::firrtl::HWStructCastOp)](#firrtlhwstructcast-circtfirrtlhwstructcastop)\n  + [`firrtl.head` (::circt::firrtl::HeadPrimOp)](#firrtlhead-circtfirrtlheadprimop)\n  + [`firrtl.fstring.hierarchicalmodulename` (::circt::firrtl::HierarchicalModuleNameOp)](#firrtlfstringhierarchicalmodulename-circtfirrtlhierarchicalmodulenameop)\n  + [`firrtl.integer.add` (::circt::firrtl::IntegerAddOp)](#firrtlintegeradd-circtfirrtlintegeraddop)\n  + [`firrtl.integer.mul` (::circt::firrtl::IntegerMulOp)](#firrtlintegermul-circtfirrtlintegermulop)\n  + [`firrtl.integer.shl` (::circt::firrtl::IntegerShlOp)](#firrtlintegershl-circtfirrtlintegershlop)\n  + [`firrtl.integer.shr` (::circt::firrtl::IntegerShrOp)](#firrtlintegershr-circtfirrtlintegershrop)\n  + [`firrtl.invalidvalue` (::circt::firrtl::InvalidValueOp)](#firrtlinvalidvalue-circtfirrtlinvalidvalueop)\n  + [`firrtl.istag` (::circt::firrtl::IsTagOp)](#firrtlistag-circtfirrtlistagop)\n  + [`firrtl.leq` (::circt::firrtl::LEQPrimOp)](#firrtlleq-circtfirrtlleqprimop)\n  + [`firrtl.int.ltl.and` (::circt::firrtl::LTLAndIntrinsicOp)](#firrtlintltland-circtfirrtlltlandintrinsicop)\n  + [`firrtl.int.ltl.clock` (::circt::firrtl::LTLClockIntrinsicOp)](#firrtlintltlclock-circtfirrtlltlclockintrinsicop)\n  + [`firrtl.int.ltl.concat` (::circt::firrtl::LTLConcatIntrinsicOp)](#firrtlintltlconcat-circtfirrtlltlconcatintrinsicop)\n  + [`firrtl.int.ltl.delay` (::circt::firrtl::LTLDelayIntrinsicOp)](#firrtlintltldelay-circtfirrtlltldelayintrinsicop)\n  + [`firrtl.int.ltl.eventually` (::circt::firrtl::LTLEventuallyIntrinsicOp)](#firrtlintltleventually-circtfirrtlltleventuallyintrinsicop)\n  + [`firrtl.int.ltl.goto_repeat` (::circt::firrtl::LTLGoToRepeatIntrinsicOp)](#firrtlintltlgoto_repeat-circtfirrtlltlgotorepeatintrinsicop)\n  + [`firrtl.int.ltl.implication` (::circt::firrtl::LTLImplicationIntrinsicOp)](#firrtlintltlimplication-circtfirrtlltlimplicationintrinsicop)\n  + [`firrtl.int.ltl.intersect` (::circt::firrtl::LTLIntersectIntrinsicOp)](#firrtlintltlintersect-circtfirrtlltlintersectintrinsicop)\n  + [`firrtl.int.ltl.non_consecutive_repeat` (::circt::firrtl::LTLNonConsecutiveRepeatIntrinsicOp)](#firrtlintltlnon_consecutive_repeat-circtfirrtlltlnonconsecutiverepeatintrinsicop)\n  + [`firrtl.int.ltl.not` (::circt::firrtl::LTLNotIntrinsicOp)](#firrtlintltlnot-circtfirrtlltlnotintrinsicop)\n  + [`firrtl.int.ltl.or` (::circt::firrtl::LTLOrIntrinsicOp)](#firrtlintltlor-circtfirrtlltlorintrinsicop)\n  + [`firrtl.int.ltl.repeat` (::circt::firrtl::LTLRepeatIntrinsicOp)](#firrtlintltlrepeat-circtfirrtlltlrepeatintrinsicop)\n  + [`firrtl.int.ltl.until` (::circt::firrtl::LTLUntilIntrinsicOp)](#firrtlintltluntil-circtfirrtlltluntilintrinsicop)\n  + [`firrtl.lt` (::circt::firrtl::LTPrimOp)](#firrtllt-circtfirrtlltprimop)\n  + [`firrtl.list.concat` (::circt::firrtl::ListConcatOp)](#firrtllistconcat-circtfirrtllistconcatop)\n  + [`firrtl.list.create` (::circt::firrtl::ListCreateOp)](#firrtllistcreate-circtfirrtllistcreateop)\n  + [`firrtl.mul` (::circt::firrtl::MulPrimOp)](#firrtlmul-circtfirrtlmulprimop)\n  + [`firrtl.multibit_mux` (::circt::firrtl::MultibitMuxOp)](#firrtlmultibit_mux-circtfirrtlmultibitmuxop)\n  + [`firrtl.int.mux2cell` (::circt::firrtl::Mux2CellIntrinsicOp)](#firrtlintmux2cell-circtfirrtlmux2cellintrinsicop)\n  + [`firrtl.int.mux4cell` (::circt::firrtl::Mux4CellIntrinsicOp)](#firrtlintmux4cell-circtfirrtlmux4cellintrinsicop)\n  + [`firrtl.mux` (::circt::firrtl::MuxPrimOp)](#firrtlmux-circtfirrtlmuxprimop)\n  + [`firrtl.neq` (::circt::firrtl::NEQPrimOp)](#firrtlneq-circtfirrtlneqprimop)\n  + [`firrtl.neg` (::circt::firrtl::NegPrimOp)](#firrtlneg-circtfirrtlnegprimop)\n  + [`firrtl.not` (::circt::firrtl::NotPrimOp)](#firrtlnot-circtfirrtlnotprimop)\n  + [`firrtl.object.anyref_cast` (::circt::firrtl::ObjectAnyRefCastOp)](#firrtlobjectanyref_cast-circtfirrtlobjectanyrefcastop)\n  + [`firrtl.object.subfield` (::circt::firrtl::ObjectSubfieldOp)](#firrtlobjectsubfield-circtfirrtlobjectsubfieldop)\n  + [`firrtl.opensubfield` (::circt::firrtl::OpenSubfieldOp)](#firrtlopensubfield-circtfirrtlopensubfieldop)\n  + [`firrtl.opensubindex` (::circt::firrtl::OpenSubindexOp)](#firrtlopensubindex-circtfirrtlopensubindexop)\n  + [`firrtl.or` (::circt::firrtl::OrPrimOp)](#firrtlor-circtfirrtlorprimop)\n  + [`firrtl.orr` (::circt::firrtl::OrRPrimOp)](#firrtlorr-circtfirrtlorrprimop)\n  + [`firrtl.pad` (::circt::firrtl::PadPrimOp)](#firrtlpad-circtfirrtlpadprimop)\n  + [`firrtl.path` (::circt::firrtl::PathOp)](#firrtlpath-circtfirrtlpathop)\n  + [`firrtl.ref.rwprobe` (::circt::firrtl::RWProbeOp)](#firrtlrefrwprobe-circtfirrtlrwprobeop)\n  + [`firrtl.ref.cast` (::circt::firrtl::RefCastOp)](#firrtlrefcast-circtfirrtlrefcastop)\n  + [`firrtl.ref.resolve` (::circt::firrtl::RefResolveOp)](#firrtlrefresolve-circtfirrtlrefresolveop)\n  + [`firrtl.ref.send` (::circt::firrtl::RefSendOp)](#firrtlrefsend-circtfirrtlrefsendop)\n  + [`firrtl.ref.sub` (::circt::firrtl::RefSubOp)](#firrtlrefsub-circtfirrtlrefsubop)\n  + [`firrtl.rem` (::circt::firrtl::RemPrimOp)](#firrtlrem-circtfirrtlremprimop)\n  + [`firrtl.shl` (::circt::firrtl::ShlPrimOp)](#firrtlshl-circtfirrtlshlprimop)\n  + [`firrtl.shr` (::circt::firrtl::ShrPrimOp)](#firrtlshr-circtfirrtlshrprimop)\n  + [`firrtl.int.sizeof` (::circt::firrtl::SizeOfIntrinsicOp)](#firrtlintsizeof-circtfirrtlsizeofintrinsicop)\n  + [`firrtl.specialconstant` (::circt::firrtl::SpecialConstantOp)](#firrtlspecialconstant-circtfirrtlspecialconstantop)\n  + [`firrtl.string` (::circt::firrtl::StringConstantOp)](#firrtlstring-circtfirrtlstringconstantop)\n  + [`firrtl.sub` (::circt::firrtl::SubPrimOp)](#firrtlsub-circtfirrtlsubprimop)\n  + [`firrtl.subaccess` (::circt::firrtl::SubaccessOp)](#firrtlsubaccess-circtfirrtlsubaccessop)\n  + [`firrtl.subfield` (::circt::firrtl::SubfieldOp)](#firrtlsubfield-circtfirrtlsubfieldop)\n  + [`firrtl.subindex` (::circt::firrtl::SubindexOp)](#firrtlsubindex-circtfirrtlsubindexop)\n  + [`firrtl.subtag` (::circt::firrtl::SubtagOp)](#firrtlsubtag-circtfirrtlsubtagop)\n  + [`firrtl.tagextract` (::circt::firrtl::TagExtractOp)](#firrtltagextract-circtfirrtltagextractop)\n  + [`firrtl.tail` (::circt::firrtl::TailPrimOp)](#firrtltail-circtfirrtltailprimop)\n  + [`firrtl.fstring.time` (::circt::firrtl::TimeOp)](#firrtlfstringtime-circtfirrtltimeop)\n  + [`firrtl.resetCast` (::circt::firrtl::UninferredResetCastOp)](#firrtlresetcast-circtfirrtluninferredresetcastop)\n  + [`firrtl.unknown` (::circt::firrtl::UnknownValueOp)](#firrtlunknown-circtfirrtlunknownvalueop)\n  + [`firrtl.unresolved_path` (::circt::firrtl::UnresolvedPathOp)](#firrtlunresolved_path-circtfirrtlunresolvedpathop)\n  + [`firrtl.unsafe_domain_cast` (::circt::firrtl::UnsafeDomainCastOp)](#firrtlunsafe_domain_cast-circtfirrtlunsafedomaincastop)\n  + [`firrtl.vectorcreate` (::circt::firrtl::VectorCreateOp)](#firrtlvectorcreate-circtfirrtlvectorcreateop)\n  + [`firrtl.verbatim.expr` (::circt::firrtl::VerbatimExprOp)](#firrtlverbatimexpr-circtfirrtlverbatimexprop)\n  + [`firrtl.verbatim.wire` (::circt::firrtl::VerbatimWireOp)](#firrtlverbatimwire-circtfirrtlverbatimwireop)\n  + [`firrtl.xmr.deref` (::circt::firrtl::XMRDerefOp)](#firrtlxmrderef-circtfirrtlxmrderefop)\n  + [`firrtl.xmr.ref` (::circt::firrtl::XMRRefOp)](#firrtlxmrref-circtfirrtlxmrrefop)\n  + [`firrtl.xor` (::circt::firrtl::XorPrimOp)](#firrtlxor-circtfirrtlxorprimop)\n  + [`firrtl.xorr` (::circt::firrtl::XorRPrimOp)](#firrtlxorr-circtfirrtlxorrprimop)\n* [Operation Definitions \u2013 Intrinsics](#operation-definitions----intrinsics)\n  + [`firrtl.int.clock_div` (::circt::firrtl::ClockDividerIntrinsicOp)](#firrtlintclock_div-circtfirrtlclockdividerintrinsicop)\n  + [`firrtl.int.clock_gate` (::circt::firrtl::ClockGateIntrinsicOp)](#firrtlintclock_gate-circtfirrtlclockgateintrinsicop)\n  + [`firrtl.int.clock_inv` (::circt::firrtl::ClockInverterIntrinsicOp)](#firrtlintclock_inv-circtfirrtlclockinverterintrinsicop)\n  + [`firrtl.int.dpi.call` (::circt::firrtl::DPICallIntrinsicOp)](#firrtlintdpicall-circtfirrtldpicallintrinsicop)\n  + [`firrtl.int.fpga_probe` (::circt::firrtl::FPGAProbeIntrinsicOp)](#firrtlintfpga_probe-circtfirrtlfpgaprobeintrinsicop)\n  + [`firrtl.int.generic` (::circt::firrtl::GenericIntrinsicOp)](#firrtlintgeneric-circtfirrtlgenericintrinsicop)\n  + [`firrtl.int.has_been_reset` (::circt::firrtl::HasBeenResetIntrinsicOp)](#firrtlinthas_been_reset-circtfirrtlhasbeenresetintrinsicop)\n  + [`firrtl.int.isX` (::circt::firrtl::IsXIntrinsicOp)](#firrtlintisx-circtfirrtlisxintrinsicop)\n  + [`firrtl.int.plusargs.test` (::circt::firrtl::PlusArgsTestIntrinsicOp)](#firrtlintplusargstest-circtfirrtlplusargstestintrinsicop)\n  + [`firrtl.int.plusargs.value` (::circt::firrtl::PlusArgsValueIntrinsicOp)](#firrtlintplusargsvalue-circtfirrtlplusargsvalueintrinsicop)\n  + [`firrtl.int.unclocked_assume` (::circt::firrtl::UnclockedAssumeIntrinsicOp)](#firrtlintunclocked_assume-circtfirrtlunclockedassumeintrinsicop)\n  + [`firrtl.view` (::circt::firrtl::ViewIntrinsicOp)](#firrtlview-circtfirrtlviewintrinsicop)\n* [Type Definitions](#type-definitions)\n  + [AnalogType](#analogtype)\n  + [AnyRefType](#anyreftype)\n  + [AsyncResetType](#asyncresettype)\n  + [BaseTypeAliasType](#basetypealiastype)\n  + [BoolType](#booltype)\n  + [BundleType](#bundletype)\n  + [ClassType](#classtype)\n  + [ClockType](#clocktype)\n  + [DomainType](#domaintype)\n  + [DoubleType](#doubletype)\n  + [FEnumType](#fenumtype)\n  + [FStringType](#fstringtype)\n  + [FVectorType](#fvectortype)\n  + [FIntegerType](#fintegertype)\n  + [LHSType](#lhstype)\n  + [ListType](#listtype)\n  + [OpenBundleType](#openbundletype)\n  + [OpenVectorType](#openvectortype)\n  + [PathType](#pathtype)\n  + [RefType](#reftype)\n  + [ResetType](#resettype)\n  + [SIntType](#sinttype)\n  + [StringType](#stringtype)\n  + [UIntType](#uinttype)\n* [Attribute Definitions](#attribute-definitions)\n  + [AugmentedBundleTypeAttr](#augmentedbundletypeattr)\n  + [AugmentedGroundTypeAttr](#augmentedgroundtypeattr)\n  + [AugmentedVectorTypeAttr](#augmentedvectortypeattr)\n  + [DomainFieldAttr](#domainfieldattr)\n  + [MemoryInitAttr](#memoryinitattr)\n  + [ParamDeclAttr](#paramdeclattr)\n* [ClassLike (`ClassLike`)](#classlike-classlike)\n  + [Methods:](#methods)\n* [FConnectLike (`FConnectLike`)](#fconnectlike-fconnectlike)\n  + [Methods:](#methods-1)\n* [FInstanceLike (`FInstanceLike`)](#finstancelike-finstancelike)\n  + [Methods:](#methods-2)\n* [FModuleLike (`FModuleLike`)](#fmodulelike-fmodulelike)\n  + [Methods:](#methods-3)\n* [FNamableOp (`FNamableOp`)](#fnamableop-fnamableop)\n  + [Methods:](#methods-4)\n* [Forceable (`Forceable`)](#forceable-forceable)\n  + [Methods:](#methods-5)\n\nOperation Definitions \u2013 Structure\n---------------------------------\n\n### `firrtl.circuit` (::circt::firrtl::CircuitOp)\n\n*FIRRTL Circuit*\n\nSyntax:\n\n```\noperation ::= `firrtl.circuit` $name `` custom<CircuitOpAttrs>(attr-dict) $body\n```\n\nThe \u201cfirrtl.circuit\u201d operation represents an overall Verilog circuit,\ncontaining a list of modules.\n\nTraits: `InnerRefNamespace`, `IsolatedFromAbove`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `enable_layers` | ::mlir::ArrayAttr | symbol ref array attribute |\n| `disable_layers` | ::mlir::ArrayAttr | symbol ref array attribute |\n| `default_layer_specialization` | ::circt::firrtl::LayerSpecializationAttr | layer specialization |\n| `select_inst_choice` | ::mlir::ArrayAttr | array attribute |\n\n### `firrtl.class` (::circt::firrtl::ClassOp)\n\n*FIRRTL Class*\n\nThe \u201cfirrtl.class\u201d operation defines a class of property-only objects,\nincluding a given name, a list of ports, and a body that represents the\nconnections within the class.\n\nA class may only have property ports, and its body may only be ops that act\non properties, such as propassign ops.\n\nTraits: `HasParent<CircuitOp>`, `InnerSymbolTable`, `IsolatedFromAbove`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `ClassLike`, `FModuleLike`, `InstanceGraphModuleOpInterface`, `ModuleOpInterface`, `OpAsmOpInterface`, `PortList`, `SymbolOpInterface`, `SymbolUserOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `portDirections` | ::mlir::DenseBoolArrayAttr | i1 dense array attribute |\n| `portNames` | ::mlir::ArrayAttr | array attribute |\n| `portTypes` | ::mlir::ArrayAttr | array attribute |\n| `portSymbols` | ::mlir::ArrayAttr | array attribute |\n| `portLocations` | ::mlir::ArrayAttr | array attribute |\n| `domainInfo` | ::mlir::ArrayAttr | array attribute |\n\n### `firrtl.domain` (::circt::firrtl::DomainOp)\n\n*Define a domain type*\n\nSyntax:\n\n```\noperation ::= `firrtl.domain` $sym_name ( $fields^ )? attr-dict-with-keyword\n```\n\nA `firrtl.domain` operation defines a type of domain that exists in this\ncircuit. E.g., this can be used to declare a `ClockDomain` type when\nmodeling clocks in FIRRTL Dialect.\n\nTraits: `HasParent<firrtl::CircuitOp>`\n\nInterfaces: `SymbolOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `fields` | ::mlir::ArrayAttr | an array of domain fields |\n\n### `firrtl.extclass` (::circt::firrtl::ExtClassOp)\n\n*FIRRTL external class*\n\nThe \u201cfirrtl.extclass\u201d operation represents a reference to an external\nfirrtl class, and includes a given name, as well as a list of ports.\nJust as usual firrtl.class definitions, An ext.class may only have property\nports.\n\nexample:\n\n```\nfirrtl.extclass @MyImportedClass(in in_str: !firrtl.string, out out_str: !firrtl.string)\n```\n\nTraits: `HasParent<CircuitOp>`, `InnerSymbolTable`, `IsolatedFromAbove`\n\nInterfaces: `ClassLike`, `FModuleLike`, `InstanceGraphModuleOpInterface`, `ModuleOpInterface`, `OpAsmOpInterface`, `PortList`, `SymbolOpInterface`, `SymbolUserOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `portDirections` | ::mlir::DenseBoolArrayAttr | i1 dense array attribute |\n| `portNames` | ::mlir::ArrayAttr | array attribute |\n| `portTypes` | ::mlir::ArrayAttr | array attribute |\n| `portSymbols` | ::mlir::ArrayAttr | array attribute |\n| `portLocations` | ::mlir::ArrayAttr | array attribute |\n| `domainInfo` | ::mlir::ArrayAttr | array attribute |\n\n### `firrtl.extmodule` (::circt::firrtl::FExtModuleOp)\n\n*FIRRTL external module*\n\nThe \u201cfirrtl.extmodule\u201d operation represents an external reference to a\nVerilog module, including a given name and a list of ports.\n\nTraits: `HasParent<CircuitOp>`, `InnerSymbolTable`, `IsolatedFromAbove`\n\nInterfaces: `FModuleLike`, `InstanceGraphModuleOpInterface`, `ModuleOpInterface`, `OpAsmOpInterface`, `PortList`, `SymbolUserOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `defname` | ::mlir::StringAttr | string attribute |\n| `parameters` | ::mlir::ArrayAttr | parameter array attribute |\n| `convention` | ::circt::firrtl::ConventionAttr | lowering convention |\n| `portDirections` | ::mlir::DenseBoolArrayAttr | i1 dense array attribute |\n| `portLocations` | ::mlir::ArrayAttr | array attribute |\n| `portAnnotations` | ::mlir::ArrayAttr | array attribute |\n| `portSymbols` | ::mlir::ArrayAttr | array attribute |\n| `portNames` | ::mlir::ArrayAttr | array attribute |\n| `portTypes` | ::mlir::ArrayAttr | array attribute |\n| `knownLayers` | ::mlir::ArrayAttr | an array of layers |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `layers` | ::mlir::ArrayAttr | an array of layers |\n| `domainInfo` | ::mlir::ArrayAttr | array attribute |\n| `externalRequirements` | ::mlir::ArrayAttr | array attribute |\n\n### `firrtl.intmodule` (::circt::firrtl::FIntModuleOp)\n\n*FIRRTL intrinsic module*\n\nThe \u201cfirrtl.intmodule\u201d operation represents a compiler intrinsic.\n\nTraits: `HasParent<CircuitOp>`, `InnerSymbolTable`, `IsolatedFromAbove`\n\nInterfaces: `FModuleLike`, `InstanceGraphModuleOpInterface`, `ModuleOpInterface`, `OpAsmOpInterface`, `PortList`, `SymbolUserOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `intrinsic` | ::mlir::StringAttr | string attribute |\n| `parameters` | ::mlir::ArrayAttr | parameter array attribute |\n| `portDirections` | ::mlir::DenseBoolArrayAttr | i1 dense array attribute |\n| `portLocations` | ::mlir::ArrayAttr | array attribute |\n| `portAnnotations` | ::mlir::ArrayAttr | array attribute |\n| `portSymbols` | ::mlir::ArrayAttr | array attribute |\n| `portNames` | ::mlir::ArrayAttr | array attribute |\n| `portTypes` | ::mlir::ArrayAttr | array attribute |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `layers` | ::mlir::ArrayAttr | an array of layers |\n| `domainInfo` | ::mlir::ArrayAttr | array attribute |\n\n### `firrtl.memmodule` (::circt::firrtl::FMemModuleOp)\n\n*FIRRTL Generated Memory Module*\n\nThe \u201cfirrtl.memmodule\u201d operation represents an external reference to a\nmemory module. See the \u201cfirrtl.mem\u201d op for a deeper explantation of the\nparameters.\n\nA \u201cfirrtl.mem\u201d operation is typically lowered to this operation when they\nare not directly lowered to registers by the compiler.\n\nTraits: `HasParent<CircuitOp>`, `InnerSymbolTable`, `IsolatedFromAbove`\n\nInterfaces: `FModuleLike`, `InstanceGraphModuleOpInterface`, `ModuleOpInterface`, `OpAsmOpInterface`, `PortList`, `SymbolUserOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `numReadPorts` | ::mlir::IntegerAttr | 32-bit unsigned integer attribute |\n| `numWritePorts` | ::mlir::IntegerAttr | 32-bit unsigned integer attribute |\n| `numReadWritePorts` | ::mlir::IntegerAttr | 32-bit unsigned integer attribute |\n| `dataWidth` | ::mlir::IntegerAttr | 32-bit unsigned integer attribute |\n| `maskBits` | ::mlir::IntegerAttr | 32-bit unsigned integer attribute |\n| `readLatency` | ::mlir::IntegerAttr | 32-bit unsigned integer attribute |\n| `writeLatency` | ::mlir::IntegerAttr | 32-bit unsigned integer attribute |\n| `depth` | ::mlir::IntegerAttr | 64-bit unsigned integer attribute |\n| `extraPorts` | ::mlir::ArrayAttr | array attribute |\n| `portDirections` | ::mlir::DenseBoolArrayAttr | i1 dense array attribute |\n| `portLocations` | ::mlir::ArrayAttr | array attribute |\n| `portAnnotations` | ::mlir::ArrayAttr | array attribute |\n| `portSymbols` | ::mlir::ArrayAttr | array attribute |\n| `portNames` | ::mlir::ArrayAttr | array attribute |\n| `portTypes` | ::mlir::ArrayAttr | array attribute |\n| `ruw` | ::circt::firrtl::RUWBehaviorAttr | read under write behavior |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `layers` | ::mlir::ArrayAttr | an array of layers |\n| `domainInfo` | ::mlir::ArrayAttr | array attribute |\n\n### `firrtl.module` (::circt::firrtl::FModuleOp)\n\n*FIRRTL Module*\n\nThe \u201cfirrtl.module\u201d operation represents a Verilog module, including a given\nname, a list of ports, and a body that represents the connections within\nthe module.\n\nTraits: `HasParent<CircuitOp>`, `InnerSymbolTable`, `IsolatedFromAbove`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `FModuleLike`, `InstanceGraphModuleOpInterface`, `ModuleOpInterface`, `OpAsmOpInterface`, `PortList`, `SymbolUserOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `convention` | ::circt::firrtl::ConventionAttr | lowering convention |\n| `portDirections` | ::mlir::DenseBoolArrayAttr | i1 dense array attribute |\n| `portLocations` | ::mlir::ArrayAttr | array attribute |\n| `portAnnotations` | ::mlir::ArrayAttr | array attribute |\n| `portSymbols` | ::mlir::ArrayAttr | array attribute |\n| `portNames` | ::mlir::ArrayAttr | array attribute |\n| `portTypes` | ::mlir::ArrayAttr | array attribute |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `layers` | ::mlir::ArrayAttr | an array of layers |\n| `domainInfo` | ::mlir::ArrayAttr | array attribute |\n\n### `firrtl.formal` (::circt::firrtl::FormalOp)\n\n*Define a formal unit test*\n\nSyntax:\n\n```\noperation ::= `firrtl.formal` $sym_name `,` $moduleName $parameters attr-dict-with-keyword\n```\n\nThe `firrtl.formal` operation defines a formal verification unit test. The\nop defines a unique symbol name that can be used to refer to it. The design\nto be tested and any necessary test harness is defined by the separate\n`firrtl.module` op referenced by `moduleName`. Additional parameters may be\nspecified for the unit test. Input ports of the target module are considered\nto be symbolic values during the test; output ports are ignored.\n\nThis operation may be used to mark unit tests in a FIRRTL design, which\nother tools may later pick up and run automatically. It is intended to lower\nto the `verif.formal` operation. See `verif.formal` for more details.\n\nExample:\n\n```\nfirrtl.module @MyTest(in %a: !firrtl.uint<42>) {}\nfirrtl.formal @myTestA, @MyTest {bound = 42}\nfirrtl.formal @myTestB, @MyTest {mode = \"induction\", userAttr = 9001}\n```\n\nTraits: `HasParent<firrtl::CircuitOp>`\n\nInterfaces: `SymbolOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `moduleName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `parameters` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n### `firrtl.layer` (::circt::firrtl::LayerOp)\n\n*A layer definition*\n\nSyntax:\n\n```\noperation ::= `firrtl.layer` $sym_name `` $convention attr-dict-with-keyword $body\n```\n\nThe `firrtl.layer` operation defines a layer and a lowering convention for\nthat layer. Layers are a feature of FIRRTL that add verification or\ndebugging code to an existing module at runtime.\n\nA `firrtl.layer` operation only defines the layer and any layers nested\nunder it. Functionality is added to modules using the `firrtl.group`\noperation.\n\nTraits: `HasParent<firrtl::CircuitOp, firrtl::LayerOp>`, `IsolatedFromAbove`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `convention` | ::circt::firrtl::LayerConventionAttr | layer convention |\n\n### `firrtl.option_case` (::circt::firrtl::OptionCaseOp)\n\n*A configuration option value definition*\n\nSyntax:\n\n```\noperation ::= `firrtl.option_case` $sym_name attr-dict\n```\n\n`firrtl.option_case` defines an acceptable value to be provided for an\noption. Ops reference it to define their behavior when this case is active.\n\nTraits: `HasParent<firrtl::OptionOp>`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `firrtl.option` (::circt::firrtl::OptionOp)\n\n*An option group definition*\n\nSyntax:\n\n```\noperation ::= `firrtl.option` $sym_name attr-dict-with-keyword $body\n```\n\nThe `firrtl.option` operation defines a specializable parameter with a\nknown set of values, represented by the `firrtl.option_case` operations\nnested underneath.\n\nOperations which support specialization reference the option and its\ncases to define the specializations they support.\n\nExample:\n\n```\nfirrtl.circuit {\n  firrtl.option @Target {\n    firrtl.option_case @FPGA\n    firrtl.option_case @ASIC\n  }\n}\n```\n\nTraits: `HasParent<firrtl::CircuitOp>`, `IsolatedFromAbove`, `NoTerminator`, `SymbolTable`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `firrtl.simulation` (::circt::firrtl::SimulationOp)\n\n*Define a simulation unit test*\n\nSyntax:\n\n```\noperation ::= `firrtl.simulation` $sym_name `,` $moduleName $parameters attr-dict-with-keyword\n```\n\nThe `firrtl.simulation` operation defines a simulation unit test. The op\ndefines a unique symbol name that can be used to refer to it. The design to\nbe tested and any necessary test harness is defined by the separate\n`firrtl.module` op referenced by `moduleName`. Additional parameters may be\nspecified for the unit test. The target module\u2019s first four ports must be:\n\n```\n(\n  in %clock: !firrtl.clock,\n  in %init: !firrtl.uint<1>,\n  out %done: !firrtl.uint<1>,\n  out %success: !firrtl.uint<1>\n)\n```\n\nAny additional ports (index 4 and beyond) may only be property types and\nare ignored.\n\nThis operation may be used to mark unit tests in a FIRRTL design, which\nother tools may later pick up and run automatically. It is intended to lower\nto the `verif.simulation` operation. See `verif.simulation` for more\ndetails.\n\nExample:\n\n```\nfirrtl.extmodule @MyTest(\n  in clock: !firrtl.clock,\n  in init: !firrtl.uint<1>,\n  out done: !firrtl.uint<1>,\n  out success: !firrtl.uint<1>\n)\nfirrtl.simulation @myTestA, @MyTest {bound = 1000}\nfirrtl.simulation @myTestB, @MyTest {asserts = \"error\", userAttr = 9001}\n```\n\nTraits: `HasParent<firrtl::CircuitOp>`\n\nInterfaces: `SymbolOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `moduleName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `parameters` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\nOperation Definitions \u2013 Declarations\n------------------------------------\n\n### `firrtl.contract` (::circt::firrtl::ContractOp)\n\n*Contract declaration*\n\nSyntax:\n\n```\noperation ::= `firrtl.contract` ($inputs^ `:` type($inputs))? attr-dict-with-keyword $body\n```\n\nThe `firrtl.contract` operation defines values that adhere to a set of\nformal assertions and assumptions outlined in the contract\u2019s body.\n\nSee the `verif.contract` operation for more details.\n\nTraits: `NoTerminator`, `SingleBlock`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a passive base type (contain no flips) |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of a passive base type (contain no flips) |\n\n### `firrtl.domain.anon` (::circt::firrtl::DomainCreateAnonOp)\n\n*Create an anonymous domain, without parameters set*\n\nSyntax:\n\n```\noperation ::= `firrtl.domain.anon` attr-dict `:` type($result) `of` $domain\n```\n\nTraits: `HasParent<firrtl::ContractOp, firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::MatchOp, firrtl::WhenOp, sv::IfDefOp>`\n\nInterfaces: `InferTypeOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `domain` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a domain type |\n\n### `firrtl.instance_choice` (::circt::firrtl::InstanceChoiceOp)\n\n*Creates an instance of a module based on a option*\n\nThe instance choice operation creates an instance choosing the target based\non the value of an option if one is specified, instantiating a default\ntarget otherwise.\n\nThe port lists of all instance targets must match exactly.\n\nExamples:\n\n```\n%0 = firrtl.instance_choice foo @Foo alternatives @Opt { @FPGA -> @FPGAFoo }\n  (in io: !firrtl.uint)\n```\n\nTraits: `HasParent<firrtl::ContractOp, firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::MatchOp, firrtl::WhenOp, sv::IfDefOp>`\n\nInterfaces: `FNamableOp`, `HasCustomSSAName`, `InnerSymbolOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `moduleNames` | ::mlir::ArrayAttr | flat symbol ref array attribute |\n| `caseNames` | ::mlir::ArrayAttr | symbol ref array attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n| `nameKind` | ::circt::firrtl::NameKindEnumAttr | name kind |\n| `portDirections` | ::mlir::DenseBoolArrayAttr | i1 dense array attribute |\n| `portNames` | ::mlir::ArrayAttr | string array attribute |\n| `domainInfo` | ::mlir::ArrayAttr | domain attributes must be an empty array or array-of-arrays |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `portAnnotations` | ::mlir::ArrayAttr | Port annotations attribute |\n| `layers` | ::mlir::ArrayAttr | an array of layers |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `firrtl.instance` (::circt::firrtl::InstanceOp)\n\n*Instantiate a module*\n\nThis represents an instance of a module. The results are the modules inputs\nand outputs. The inputs have flip type, the outputs do not.\n\nExamples:\n\n```\n%0 = firrtl.instance foo @Foo(in io: !firrtl.uint)\n```\n\nTraits: `HasParent<firrtl::ContractOp, firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::MatchOp, firrtl::WhenOp, sv::IfDefOp>`\n\nInterfaces: `FInstanceLike`, `FNamableOp`, `HasCustomSSAName`, `InnerSymbolOpInterface`, `InstanceGraphInstanceOpInterface`, `InstanceOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `moduleName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n| `nameKind` | ::circt::firrtl::NameKindEnumAttr | name kind |\n| `portDirections` | ::mlir::DenseBoolArrayAttr | i1 dense array attribute |\n| `portNames` | ::mlir::ArrayAttr | string array attribute |\n| `domainInfo` | ::mlir::ArrayAttr | domain attributes must be an empty array or array-of-arrays |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `portAnnotations` | ::mlir::ArrayAttr | Port annotations attribute |\n| `layers` | ::mlir::ArrayAttr | an array of layers |\n| `lowerToBind` | ::mlir::UnitAttr | unit attribute |\n| `doNotPrint` | ::mlir::UnitAttr | unit attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `firrtl.mem` (::circt::firrtl::MemOp)\n\n*Define a new mem*\n\nSyntax:\n\n```\noperation ::= `firrtl.mem` (`sym` $inner_sym^)? `` custom<NameKind>($nameKind)\n              $ruw `` custom<MemOp>(attr-dict) `:` qualified(type($results))\n```\n\nTraits: `HasParent<firrtl::ContractOp, firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::MatchOp, firrtl::WhenOp, sv::IfDefOp>`\n\nInterfaces: `CombDataFlow`, `FNamableOp`, `HasCustomSSAName`, `InnerSymbolOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `readLatency` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0 |\n| `writeLatency` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 1 |\n| `depth` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n| `ruw` | ::circt::firrtl::RUWBehaviorAttr | read under write behavior |\n| `portNames` | ::mlir::ArrayAttr | string array attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n| `nameKind` | ::circt::firrtl::NameKindEnumAttr | name kind |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `portAnnotations` | ::mlir::ArrayAttr | Port annotations attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `init` | ::circt::firrtl::MemoryInitAttr | Information about the initial state of a memory |\n| `prefix` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of FIRRTLType |\n\n### `firrtl.node` (::circt::firrtl::NodeOp)\n\n*No-op to name a value*\n\nSyntax:\n\n```\noperation ::= `firrtl.node` (`sym` $inner_sym^)? `` custom<NameKind>($nameKind)\n              $input (`forceable` $forceable^)? `` custom<FIRRTLImplicitSSAName>(attr-dict) `:` qualified(type($input))\n```\n\nA node is simply a named intermediate value in a circuit. The node must\nbe initialized to a value with a passive type and cannot be connected to.\nNodes are often used to split a complicated compound expression into named\nsubexpressions.\n\n```\n  %result = firrtl.node %input : t1\n```\n\nTraits: `HasParent<firrtl::ContractOp, firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::MatchOp, firrtl::WhenOp, sv::IfDefOp>`\n\nInterfaces: `FNamableOp`, `Forceable`, `HasCustomSSAName`, `InferTypeOpInterface`, `InnerSymbolOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `nameKind` | ::circt::firrtl::NameKindEnumAttr | name kind |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `forceable` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a passive base type (contain no flips) |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a passive base type (contain no flips) |\n| `ref` | reference type |\n\n### `firrtl.object` (::circt::firrtl::ObjectOp)\n\n*Instantiate a class to produce an object*\n\nSyntax:\n\n```\noperation ::= `firrtl.object` `` custom<ImplicitSSAName>(attr-dict) custom<ClassInterface>(type($result))\n```\n\nThis represents an instance of a class. The results is the instantiated\nobject.\n\nExamples:\n\n```\n%0 = firrtl.object @Foo(in io: !firrtl.uint)\n```\n\nTraits: `HasParent<firrtl::FModuleOp, firrtl::ClassOp>`\n\nInterfaces: `FInstanceLike`, `InstanceGraphInstanceOpInterface`, `InstanceOpInterface`, `OpAsmOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | class type |\n\n### `firrtl.reg` (::circt::firrtl::RegOp)\n\n*Define a new register*\n\nSyntax:\n\n```\noperation ::= `firrtl.reg` (`sym` $inner_sym^)? `` custom<NameKind>($nameKind)\n              operands (`forceable` $forceable^)? `` custom<FIRRTLImplicitSSAName>(attr-dict) `:` type($clockVal) `,` qualified(type($result)) (`,` qualified(type($ref))^)?\n```\n\nDeclare a new register:\n\n```\n%name = firrtl.reg %clockVal : !firrtl.clock, t1\n```\n\nTraits: `HasParent<firrtl::ContractOp, firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::MatchOp, firrtl::WhenOp, sv::IfDefOp>`\n\nInterfaces: `CombDataFlow`, `FNamableOp`, `Forceable`, `HasCustomSSAName`, `InnerSymbolOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `nameKind` | ::circt::firrtl::NameKindEnumAttr | name kind |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `forceable` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clockVal` | clock |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a passive non-\u2018const\u2019 base type that does not contain analog |\n| `ref` | reference type |\n\n### `firrtl.regreset` (::circt::firrtl::RegResetOp)\n\n*Define a new register with a reset*\n\nSyntax:\n\n```\noperation ::= `firrtl.regreset` (`sym` $inner_sym^)? `` custom<NameKind>($nameKind)\n              operands (`forceable` $forceable^)? `` custom<FIRRTLImplicitSSAName>(attr-dict)\n              `:` type($clockVal) `,` qualified(type($resetSignal)) `,` qualified(type($resetValue)) `,` qualified(type($result)) (`,` qualified(type($ref))^)?\n```\n\nDeclare a new register:\n\n```\n  %name = firrtl.regreset %clockVal, %resetSignal, %resetValue : !firrtl.clock, t1\n```\n\nTraits: `HasParent<firrtl::ContractOp, firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::MatchOp, firrtl::WhenOp, sv::IfDefOp>`\n\nInterfaces: `CombDataFlow`, `FNamableOp`, `Forceable`, `HasCustomSSAName`, `InnerSymbolOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `nameKind` | ::circt::firrtl::NameKindEnumAttr | name kind |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `forceable` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clockVal` | clock |\n| `resetSignal` | Reset |\n| `resetValue` | a base type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a passive non-\u2018const\u2019 base type that does not contain analog |\n| `ref` | reference type |\n\n### `firrtl.wire` (::circt::firrtl::WireOp)\n\n*Define a new wire*\n\nSyntax:\n\n```\noperation ::= `firrtl.wire` (`sym` $inner_sym^)? `` custom<NameKind>($nameKind)\n              (`forceable` $forceable^)? `` custom<FIRRTLImplicitSSAName>(attr-dict) `:`\n              qualified(type($result)) (`,` qualified(type($ref))^)?\n```\n\nDeclare a new wire:\n\n```\n  %name = firrtl.wire : t1\n```\n\nTraits: `HasParent<firrtl::ContractOp, firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::MatchOp, firrtl::WhenOp, sv::IfDefOp>`\n\nInterfaces: `FNamableOp`, `Forceable`, `HasCustomSSAName`, `InnerSymbolOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `nameKind` | ::circt::firrtl::NameKindEnumAttr | name kind |\n| `annotations` | ::mlir::ArrayAttr | Annotation array attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `forceable` | ::mlir::UnitAttr | unit attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n| `ref` | reference type |\n\nStatement Operation \u2013 Statements\n--------------------------------\n\n### `firrtl.assert` (::circt::firrtl::AssertOp)\n\n*Assert Verification Statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.assert` $clock `,` $predicate `,` $enable `,`\n              $message (`(` $substitutions^ `)`)? `:` type($clock) `,` type($predicate) `,` type($enable) (`,` qualified(type($substitutions))^)?\n              custom<VerifAttrs>(attr-dict)\n```\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `message` | ::mlir::StringAttr | string attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n| `isConcurrent` | ::mlir::BoolAttr | bool attribute |\n| `eventControl` | ::circt::firrtl::EventControlAttr | edge control trigger |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | clock |\n| `predicate` | 1-bit uint |\n| `enable` | 1-bit uint |\n| `substitutions` | variadic of any type |\n\n### `firrtl.assume` (::circt::firrtl::AssumeOp)\n\n*Assume Verification Statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.assume` $clock `,` $predicate `,` $enable `,`\n              $message (`(` $substitutions^ `)`)? `:` type($clock) `,` type($predicate) `,` type($enable) (`,` qualified(type($substitutions))^)?\n              custom<VerifAttrs>(attr-dict)\n```\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `message` | ::mlir::StringAttr | string attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n| `isConcurrent` | ::mlir::BoolAttr | bool attribute |\n| `eventControl` | ::circt::firrtl::EventControlAttr | edge control trigger |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | clock |\n| `predicate` | 1-bit uint |\n| `enable` | 1-bit uint |\n| `substitutions` | variadic of any type |\n\n### `firrtl.attach` (::circt::firrtl::AttachOp)\n\n*Analog Attach Statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.attach` $attached attr-dict `:` qualified(type($attached))\n```\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `attached` | variadic of analog type |\n\n### `firrtl.bind` (::circt::firrtl::BindOp)\n\n*Indirect instantiation statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.bind` $instance attr-dict\n```\n\nIndirectly instantiate a module from the context of another module. BindOp\npairs with a `firrtl.instance` which tracks all information except the\nemission point for the bind.\n\nThis op exists to aid in the progressive lowering of FIRRTL surface level\nconstructs, such as layers, to system verilog (sv dialect).\n\nInterfaces: `InnerRefUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `instance` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n\n### `firrtl.connect` (::circt::firrtl::ConnectOp)\n\n*Connect two signals*\n\nSyntax:\n\n```\noperation ::= `firrtl.connect` $dest `,` $src  attr-dict `:` custom<OptionalBinaryOpTypes>(type($dest), type($src))\n```\n\nConnect Operation:\n\n```\n  firrtl.connect %dest, %src : t1, t2\n```\n\nInterfaces: `FConnectLike`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | a base type or foreign type |\n| `src` | a base type or foreign type |\n\n### `firrtl.cover` (::circt::firrtl::CoverOp)\n\n*Cover Verification Statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.cover` $clock `,` $predicate `,` $enable `,`\n              $message (`(` $substitutions^ `)`)? `:` type($clock) `,` type($predicate) `,` type($enable) (`,` qualified(type($substitutions))^)?\n              custom<VerifAttrs>(attr-dict)\n```\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `message` | ::mlir::StringAttr | string attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n| `isConcurrent` | ::mlir::BoolAttr | bool attribute |\n| `eventControl` | ::circt::firrtl::EventControlAttr | edge control trigger |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | clock |\n| `predicate` | 1-bit uint |\n| `enable` | 1-bit uint |\n| `substitutions` | variadic of any type |\n\n### `firrtl.domain.define` (::circt::firrtl::DomainDefineOp)\n\n*FIRRTL Define Domains.*\n\nSyntax:\n\n```\noperation ::= `firrtl.domain.define` $dest `,` $src  attr-dict\n```\n\nDefine a target domain to the source domain:\n\n```\n  firrtl.domain.define %dest, %src\n```\n\nUsed to statically route domains from source to destination\nthrough the design, one module at a time.\n\nSimilar to \u201cconnect\u201d but cannot have multiple define\u2019s to same\ndestination, and the define is never conditional even if under\na \u201cwhen\u201d.\n\nSource and destination must resolve statically.\n\nTraits: `SameTypeOperands`\n\nInterfaces: `FConnectLike`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | a domain type |\n| `src` | a domain type |\n\n### `firrtl.fflush` (::circt::firrtl::FFlushOp)\n\n*FFlush statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.fflush` $clock `,` $cond (`,` $outputFile `(` $outputFileSubstitutions^ `)`)?\n              attr-dict `:` type($clock) `,` type($cond)\n              (`,` qualified(type($outputFileSubstitutions))^)?\n```\n\nThis operation flushes the output buffer of the specified file descriptor. If\nno file descriptor is specified, the output buffer of the default output\nfile descriptor is flushed.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `outputFile` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | clock |\n| `cond` | 1-bit uint |\n| `outputFileSubstitutions` | variadic of a printf operand type (a FIRRTL base type or a format string type) |\n\n### `firrtl.fprintf` (::circt::firrtl::FPrintFOp)\n\n*Formatted File Print Statement*\n\nThis operation is similar to the \u201cfirrtl.printf\u201d operation, but it prints\nto a file instead of stdout.\n\nTraits: `AttrSizedOperandSegments`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `outputFile` | ::mlir::StringAttr | string attribute |\n| `formatString` | ::mlir::StringAttr | string attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | clock |\n| `cond` | 1-bit uint |\n| `outputFileSubstitutions` | variadic of a printf operand type (a FIRRTL base type or a format string type) |\n| `substitutions` | variadic of a printf operand type (a FIRRTL base type or a format string type) |\n\n### `firrtl.force` (::circt::firrtl::ForceOp)\n\n*Force procedural statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.force` $dest `,` $src attr-dict `:` qualified(type($dest)) `,` qualified(type($src))\n```\n\nMaps to the corresponding `sv.force` operation.\n\nTraits: `SameTypeOperands`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | a base type |\n| `src` | a base type |\n\n### `firrtl.layerblock` (::circt::firrtl::LayerBlockOp)\n\n*A definition of a layer block*\n\nSyntax:\n\n```\noperation ::= `firrtl.layerblock` $layerName $region attr-dict\n```\n\nThe `firrtl.layerblock` operation defines optional code that is\nconditionally part of a `firrtl.module` if its referenced `firrtl.layer` is\nenabled. This is typically used to store verification or debugging code\nthat is lowered to a module that is \u201cenabled\u201d using the `firrtl.layer`\u2019s\nconvention (e.g., remote instantiation via SystemVerilog `bind`). A layer\nblock can read from (capture) values defined in parent layer blocks or in\nthe parent module, but may not write to hardware declared outside the layer\nblock.\n\nA `firrtl.layerblock` must refer to an existing layer definition\n(`firrtl.layer`) via a symbol reference. A nested `firrtl.layerblock`\nrefers to a nested layer definition via a nested symbol reference.\n\nTraits: `HasParent<firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::WhenOp, firrtl::MatchOp>`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `layerName` | ::mlir::SymbolRefAttr | symbol reference attribute |\n\n### `firrtl.match` (::circt::firrtl::MatchOp)\n\n*Match Statement*\n\nThe \u201cfirrtl.match\u201d operation represents a pattern matching statement on a\nenumeration. This operation does not return a value and cannot be used as an\nexpression. Last connect semantics work similarly to a when statement.\n\nExample:\n\n```\n  firrtl.match %in : !firrtl.enum<Some: uint<1>, None: uint<0>> {\n    case Some(%arg0) {\n      !firrtl.matchingconnect %w, %arg0 : !firrtl.uint<1>\n    }\n    case None(%arg0) {\n      !firrt.matchingconnect %w, %c1 : !firrtl.uint<1>\n    }\n  }\n```\n\nTraits: `NoTerminator`, `RecursiveMemoryEffects`, `RecursivelySpeculatableImplTrait`, `SingleBlock`\n\nInterfaces: `ConditionallySpeculatable`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `tags` | ::mlir::ArrayAttr | 32-bit integer array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | enum type |\n\n### `firrtl.matchingconnect` (::circt::firrtl::MatchingConnectOp)\n\n*Connect two signals*\n\nSyntax:\n\n```\noperation ::= `firrtl.matchingconnect` $dest `,` $src  attr-dict `:`\n              custom<OptionalBinaryOpTypes>(type($dest), type($src))\n```\n\nConnect two values with matching type constraints. The types of the lhs and\nrhs must match:\n\n```\n  firrtl.matchingconnect %dest, %src : t1\n  firrtl.matchingconnect %dest, %src : t1, !firrtl.alias<foo, t1>\n```\n\nInterfaces: `FConnectLike`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | a sized passive base type (contains no uninferred widths, or flips) or foreign type |\n| `src` | a sized passive base type (contains no uninferred widths, or flips) or foreign type |\n\n### `firrtl.printf` (::circt::firrtl::PrintFOp)\n\n*Formatted Print Statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.printf` $clock `,` $cond `,` $formatString `` custom<PrintfAttrs>(attr-dict) ` `\n              (`(` $substitutions^ `)`)? `:` type($clock) `,` type($cond) (`,` qualified(type($substitutions))^)?\n```\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `formatString` | ::mlir::StringAttr | string attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | clock |\n| `cond` | 1-bit uint |\n| `substitutions` | variadic of a printf operand type (a FIRRTL base type or a format string type) |\n\n### `firrtl.propassign` (::circt::firrtl::PropAssignOp)\n\n*Assign to a sink property value.*\n\nSyntax:\n\n```\noperation ::= `firrtl.propassign` $dest `,` $src attr-dict `:` qualified(type($dest))\n```\n\nAssign an output property value. The types must match exactly.\n\nExample:\n\n```\n  firrtl.propassign %dest, %src : !firrtl.string\n```\n\nTraits: `HasParent<FModuleOp, ClassOp, LayerBlockOp>`, `SameTypeOperands`\n\nInterfaces: `FConnectLike`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | property type |\n| `src` | property type |\n\n### `firrtl.ref.define` (::circt::firrtl::RefDefineOp)\n\n*FIRRTL Define References*\n\nSyntax:\n\n```\noperation ::= `firrtl.ref.define` $dest `,` $src  attr-dict `:` qualified(type($dest))\n```\n\nDefine a target reference to the source reference:\n\n```\n  firrtl.ref.define %dest, %src : ref<t1>\n```\n\nUsed to statically route reference from source to destination\nthrough the design, one module at a time.\n\nSimilar to \u201cconnect\u201d but cannot have multiple define\u2019s to same\ndestination and the define is never conditional even if under\na \u201cwhen\u201d.\n\nSource and destination must resolve statically.\n\nTraits: `SameTypeOperands`\n\nInterfaces: `FConnectLike`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | reference type |\n| `src` | reference type |\n\n### `firrtl.ref.force_initial` (::circt::firrtl::RefForceInitialOp)\n\n*FIRRTL force\\_initial statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.ref.force_initial` $predicate `,` $dest `,` $src attr-dict `:` type($predicate) `,` qualified(type($dest)) `,` qualified(type($src))\n```\n\nForce a RWProbe to the specified value continuously.\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `predicate` | 1-bit uint |\n| `dest` | rwprobe type |\n| `src` | a base type |\n\n### `firrtl.ref.force` (::circt::firrtl::RefForceOp)\n\n*FIRRTL force statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.ref.force` $clock `,` $predicate `,` $dest `,` $src attr-dict `:` type($clock) `,` type($predicate) `,` qualified(type($dest)) `,` qualified(type($src))\n```\n\nForce a RWProbe to the specified value using the specified clock and predicate.\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | clock |\n| `predicate` | 1-bit uint |\n| `dest` | rwprobe type |\n| `src` | a base type |\n\n### `firrtl.ref.release_initial` (::circt::firrtl::RefReleaseInitialOp)\n\n*FIRRTL release\\_initial statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.ref.release_initial` $predicate `,` $dest attr-dict `:` type($predicate) `,` qualified(type($dest))\n```\n\nRelease the target RWProbe.\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `predicate` | 1-bit uint |\n| `dest` | rwprobe type |\n\n### `firrtl.ref.release` (::circt::firrtl::RefReleaseOp)\n\n*FIRRTL release statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.ref.release` $clock `,` $predicate `,` $dest attr-dict `:` type($clock) `,` type($predicate) `,` qualified(type($dest))\n```\n\nRelease the target RWProbe using the specified clock and predicate.\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | clock |\n| `predicate` | 1-bit uint |\n| `dest` | rwprobe type |\n\n### `firrtl.skip` (::circt::firrtl::SkipOp)\n\n*Skip statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.skip` attr-dict\n```\n\nSkip Statement:\n\n```\n   %firrtl.skip\n```\n\nThis is a no-op statement.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n### `firrtl.stop` (::circt::firrtl::StopOp)\n\n*Stop Statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.stop` $clock `,` $cond `,` $exitCode `` custom<StopAttrs>(attr-dict) `:` type($clock) `,` type($cond)\n```\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `exitCode` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | clock |\n| `cond` | 1-bit uint |\n\n### `firrtl.int.verif.assert` (::circt::firrtl::VerifAssertIntrinsicOp)\n\n*FIRRTL variant of `verif.assert`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.verif.assert` operands attr-dict `:` type(operands)\n```\n\nSee `verif.assert` op in the Verif dialect.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit uint |\n| `enable` | 1-bit uint |\n\n### `firrtl.int.verif.assume` (::circt::firrtl::VerifAssumeIntrinsicOp)\n\n*FIRRTL variant of `verif.assume`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.verif.assume` operands attr-dict `:` type(operands)\n```\n\nSee `verif.assume` op in the Verif dialect.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit uint |\n| `enable` | 1-bit uint |\n\n### `firrtl.int.verif.cover` (::circt::firrtl::VerifCoverIntrinsicOp)\n\n*FIRRTL variant of `verif.cover`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.verif.cover` operands attr-dict `:` type(operands)\n```\n\nSee `verif.cover` op in the Verif dialect.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit uint |\n| `enable` | 1-bit uint |\n\n### `firrtl.int.verif.ensure` (::circt::firrtl::VerifEnsureIntrinsicOp)\n\n*FIRRTL variant of `verif.ensure`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.verif.ensure` operands attr-dict `:` type(operands)\n```\n\nSee `verif.ensure` op in the Verif dialect.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit uint |\n| `enable` | 1-bit uint |\n\n### `firrtl.int.verif.require` (::circt::firrtl::VerifRequireIntrinsicOp)\n\n*FIRRTL variant of `verif.require`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.verif.require` operands attr-dict `:` type(operands)\n```\n\nSee `verif.require` op in the Verif dialect.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit uint |\n| `enable` | 1-bit uint |\n\n### `firrtl.when` (::circt::firrtl::WhenOp)\n\n*When Statement*\n\nSyntax:\n\n```\noperation ::= `firrtl.when` $condition `:` type($condition) $thenRegion (`else` $elseRegion^)? attr-dict-with-keyword\n```\n\nThe \u201cfirrtl.when\u201d operation represents a conditional. Connections within\na conditional statement that connect to previously declared components hold\nonly when the given condition is high. The condition must have a 1-bit\nunsigned integer type.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `condition` | 1-bit uint |\n\nOperation Definitions \u2013 Expressions\n-----------------------------------\n\n### `firrtl.add` (::circt::firrtl::AddPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.add` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint or uint type |\n\n### `firrtl.aggregateconstant` (::circt::firrtl::AggregateConstantOp)\n\n*Produce a constant of a passive aggregate value*\n\nSyntax:\n\n```\noperation ::= `firrtl.aggregateconstant` $fields attr-dict `:` type($result)\n```\n\nThe constant operation produces a constant value of an aggregate type. The\ntype must be passive. Clock and reset values are supported.\nFor nested aggregates, embedded arrays are used.\n\n```\n  %result = firrtl.aggregateconstant [1, 2, 3] : !firrtl.bundle<a: uint<8>, b: uint<5>, c: uint<4>>\n  %result = firrtl.aggregateconstant [1, 2, 3] : !firrtl.vector<uint<8>, 3>\n  %result = firrtl.aggregateconstant [[1, 2], [3, 5]] : !firrtl.vector<!firrtl.bundle<a: uint<8>, b: uint<5>>, 2>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fields` | ::mlir::ArrayAttr | array attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a aggregate type |\n\n### `firrtl.and` (::circt::firrtl::AndPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.and` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | uint type |\n\n### `firrtl.andr` (::circt::firrtl::AndRPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.andr` $input attr-dict `:` functional-type($input, $result)\n```\n\nHorizontally reduce a value to one bit, using the \u2018and\u2019 operation to merge\nbits. `andr(x)` is equivalent to `concat(x, 1b1) == ~0`. As such, it\nreturns 1 for zero-bit-wide operands.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.asAsyncReset` (::circt::firrtl::AsAsyncResetPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.asAsyncReset` $input attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit uint/sint/analog, reset, asyncreset, or clock |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | async reset type |\n\n### `firrtl.asClock` (::circt::firrtl::AsClockPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.asClock` $input attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit uint/sint/analog, reset, asyncreset, or clock |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | clock |\n\n### `firrtl.asSInt` (::circt::firrtl::AsSIntPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.asSInt` $input attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a base type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint type |\n\n### `firrtl.asUInt` (::circt::firrtl::AsUIntPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.asUInt` $input attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a base type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | uint type |\n\n### `firrtl.bitcast` (::circt::firrtl::BitCastOp)\n\n*Reinterpret one value to another value of the same size and\npotentially different type. This op is lowered to hw::BitCastOp.*\n\nSyntax:\n\n```\noperation ::= `firrtl.bitcast` $input attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a base type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a passive base type (contain no flips) |\n\n### `firrtl.bits` (::circt::firrtl::BitsPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.bits` $input $hi `to` $lo attr-dict `:` functional-type($input, $result)\n```\n\nThe `bits` operation extracts the bits between `hi` (inclusive) and `lo`\n(inclusive) from `input`. `hi` must be greater than or equal to `lo`. Both\n`hi` and `lo` must be non-negative and less than the bit width of `input`.\nThe result is `hi - lo + 1` bits wide.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `hi` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `lo` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | uint type |\n\n### `firrtl.bool` (::circt::firrtl::BoolConstantOp)\n\n*Produce a constant boolean value*\n\nSyntax:\n\n```\noperation ::= `firrtl.bool` $value attr-dict\n```\n\nProduces a constant value of boolean type.\n\nExample:\n\n```\n%0 = firrtl.bool true\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::BoolAttr | bool attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | boolean type |\n\n### `firrtl.bundlecreate` (::circt::firrtl::BundleCreateOp)\n\n*Produce a bundle value*\n\nSyntax:\n\n```\noperation ::= `firrtl.bundlecreate` $fields attr-dict `:` functional-type($fields, $result)\n```\n\nCreate an bundle from component values. This is equivalent in terms of\nflow to creating a node.\n\n```\n  %result = firrtl.bundlecreate %1, %2, %3 : !firrtl.bundle<a: uint<8>, b: uint<5>, c: uint<4>>\n```\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `fields` | variadic of a base type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | bundle type |\n\n### `firrtl.cat` (::circt::firrtl::CatPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.cat` $inputs attr-dict `:` functional-type($inputs, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | uint type |\n\n### `firrtl.constCast` (::circt::firrtl::ConstCastOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.constCast` $input attr-dict `:` functional-type($input, $result)\n```\n\nCast from a \u2018const\u2019 to a non-\u2018const\u2019 type.\n\n```\n%result = firrtl.constCast %in : (!firrtl.const.t1) -> !firrtl.t1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a passive base type (contain no flips) |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a passive base type (contain no flips) |\n\n### `firrtl.constant` (::circt::firrtl::ConstantOp)\n\n*Produce a constant value*\n\nThe constant operation produces a constant value of SInt or UInt type, it\nnever produces a zero bit wide result.\n\n```\n  %result = firrtl.constant 42 : t1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`, `FirstAttrDerivedResultType`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::IntegerAttr | arbitrary integer attribute with sign |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint or uint type |\n\n### `firrtl.cvt` (::circt::firrtl::CvtPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.cvt` $input attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint type |\n\n### `firrtl.dshl` (::circt::firrtl::DShlPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.dshl` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nA dynamic shift left operation. The width of `$result` is expanded to\n`width($lhs) + 1 << width($rhs) - 1`.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint or uint type |\n\n### `firrtl.dshlw` (::circt::firrtl::DShlwPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.dshlw` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nA dynamic shift left operation same as \u2018dshl\u2019 but with different width rule.\nThe width of `$result` is equal to `$lhs`.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint or uint type |\n\n### `firrtl.dshr` (::circt::firrtl::DShrPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.dshr` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint or uint type |\n\n### `firrtl.div` (::circt::firrtl::DivPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.div` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nDivides the first argument (the numerator) by the second argument\n(the denominator) truncating the result (rounding towards zero).\n\n**If the denominator is zero, the result is undefined.**\n\nThe compiler may optimize this undefined behavior in any way it\nwants. Notably `div(a, a)` will be optimized to `1`. This may cause\nerroneous formal equivalence mismatches between unoptimized and\noptimized FIRRTL dialects that are separately converted to Verilog.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint or uint type |\n\n### `firrtl.double` (::circt::firrtl::DoubleConstantOp)\n\n*Produce a constant double value*\n\nSyntax:\n\n```\noperation ::= `firrtl.double` $value attr-dict\n```\n\nProduces a constant value of double type.\n\nExample:\n\n```\n%0 = firrtl.double 3.2\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::FloatAttr | double-precision float |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | double type |\n\n### `firrtl.eq` (::circt::firrtl::EQPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.eq` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.elementwise_and` (::circt::firrtl::ElementwiseAndPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.elementwise_and` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | 1d vector with Int element type |\n| `rhs` | 1d vector with Int element type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1d vector with UInt element type |\n\n### `firrtl.elementwise_or` (::circt::firrtl::ElementwiseOrPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.elementwise_or` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | 1d vector with Int element type |\n| `rhs` | 1d vector with Int element type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1d vector with UInt element type |\n\n### `firrtl.elementwise_xor` (::circt::firrtl::ElementwiseXorPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.elementwise_xor` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | 1d vector with UInt element type |\n| `rhs` | 1d vector with Int element type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1d vector with UInt element type |\n\n### `firrtl.enumcreate` (::circt::firrtl::FEnumCreateOp)\n\n*Produce a enum value*\n\nCreate an enum from tag and value.\n\n```\n  %result = firrtl.enumcreate field-name(%input) : !firrtl.enum<None: uint<0>, Some: uint<8>>\n```\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldIndex` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a base type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | enum type |\n\n### `firrtl.integer` (::circt::firrtl::FIntegerConstantOp)\n\n*Produce a constant integer value*\n\nProduces a constant value of integer type.\n\nExample:\n\n```\n%0 = firrtl.integer 42\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::IntegerAttr | arbitrary integer attribute with sign |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | integer type |\n\n### `firrtl.geq` (::circt::firrtl::GEQPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.geq` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.gt` (::circt::firrtl::GTPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.gt` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.hwStructCast` (::circt::firrtl::HWStructCastOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.hwStructCast` $input attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `firrtl.head` (::circt::firrtl::HeadPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.head` $input `,` $amount attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `amount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | uint type |\n\n### `firrtl.fstring.hierarchicalmodulename` (::circt::firrtl::HierarchicalModuleNameOp)\n\n*An operation that represents the module name with its full path*\n\nSyntax:\n\n```\noperation ::= `firrtl.fstring.hierarchicalmodulename` attr-dict `:` type($result)\n```\n\nThis operation represents the name of the current module with a\nfully-qualified path in front of it. It returns a format string type which\ncan only be used as a substitution inside a printf. This operation is not\nrepresented in the FIRRTL spec.\n\nThis operation is the FIRRTL Dialect representation of the special\nsubstitution `{{HierarchicalModuleName}}`.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a format string type |\n\n### `firrtl.integer.add` (::circt::firrtl::IntegerAddOp)\n\n*Add two FIntegerType values*\n\nSyntax:\n\n```\noperation ::= `firrtl.integer.add` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nThe add operation result is the arbitrary precision signed integer\narithmetic sum of the two operands.\n\nExample:\n\n```\n%2 = firrtl.integer.add %0, %1 : (!firrtl.integer, !firrtl.integer) ->\n                                     !firrtl.integer\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | integer type |\n| `rhs` | integer type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | integer type |\n\n### `firrtl.integer.mul` (::circt::firrtl::IntegerMulOp)\n\n*Multiply two FIntegerType values*\n\nSyntax:\n\n```\noperation ::= `firrtl.integer.mul` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nThe multiply operation result is the arbitrary precision signed integer\narithmetic product of the two operands.\n\nExample:\n\n```\n%2 = firrtl.integer.mul %0, %1 : (!firrtl.integer, !firrtl.integer) ->\n                                     !firrtl.integer\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | integer type |\n| `rhs` | integer type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | integer type |\n\n### `firrtl.integer.shl` (::circt::firrtl::IntegerShlOp)\n\n*Shift an FIntegerType value left by an FIntegerType value*\n\nSyntax:\n\n```\noperation ::= `firrtl.integer.shl` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nThe shift left operation result is the arbitrary precision signed integer\nshift left of the lhs operand by the rhs operand. The rhs operand must be\nnon-negative.\n\nExample:\n\n```\n%2 = firrtl.integer.shl %0, %1 : (!firrtl.integer, !firrtl.integer) ->\n                                     !firrtl.integer\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | integer type |\n| `rhs` | integer type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | integer type |\n\n### `firrtl.integer.shr` (::circt::firrtl::IntegerShrOp)\n\n*Shift an FIntegerType value right by an FIntegerType value*\n\nSyntax:\n\n```\noperation ::= `firrtl.integer.shr` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nThe shift right operation result is the arbitrary precision signed integer\narithmetic shift right of the lhs operand by the rhs operand. The rhs\noperand must be non-negative.\n\nExample:\n\n```\n%2 = firrtl.integer.shr %0, %1 : (!firrtl.integer, !firrtl.integer) ->\n                                     !firrtl.integer\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | integer type |\n| `rhs` | integer type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | integer type |\n\n### `firrtl.invalidvalue` (::circt::firrtl::InvalidValueOp)\n\n*InvalidValue primitive*\n\nSyntax:\n\n```\noperation ::= `firrtl.invalidvalue` attr-dict `:` qualified(type($result))\n```\n\nThe InvalidValue operation returns an invalid value of a specified type:\n\n```\n  %result = firrtl.invalid : !firrtl.uint<1>\n```\n\nThis corresponds to the FIRRTL invalidate operation without the implicit\nconnect semantics. Each invalid op produces a unique invalid value.\nInvalidOp is not constant-like\n\nInterfaces: `HasCustomSSAName`, `MemoryEffectOpInterface (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a base type |\n\n### `firrtl.istag` (::circt::firrtl::IsTagOp)\n\n*Test the active variant of an enumeration*\n\nThis operation is used to test the active variant of an enumeration. The\ntag tested for must be one of the possible variants of the input type. If\nthe tag is the currently active variant the result will be 1, otherwise the\nresult will be 0.\n\nExample:\n\n```\n  %0 = firrtl.istag A %v : !firrtl.enum<A: UInt<0>, B: UInt<0>>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldIndex` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | enum type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.leq` (::circt::firrtl::LEQPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.leq` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.and` (::circt::firrtl::LTLAndIntrinsicOp)\n\n*FIRRTL variant of `ltl.and`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.and` operands attr-dict `:` functional-type(operands, results)\n```\n\nSee `ltl.and` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | 1-bit uint |\n| `rhs` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.clock` (::circt::firrtl::LTLClockIntrinsicOp)\n\n*FIRRTL variant of `ltl.clock`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.clock` $input `,` $clock attr-dict `:` functional-type(operands, results)\n```\n\nSee `ltl.clock` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit uint |\n| `clock` | clock |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.concat` (::circt::firrtl::LTLConcatIntrinsicOp)\n\n*FIRRTL variant of `ltl.concat`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.concat` operands attr-dict `:` functional-type(operands, results)\n```\n\nSee `ltl.concat` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | 1-bit uint |\n| `rhs` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.delay` (::circt::firrtl::LTLDelayIntrinsicOp)\n\n*FIRRTL variant of `ltl.delay`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.delay` $input `,` $delay (`,` $length^)? attr-dict `:`\n              functional-type(operands, results)\n```\n\nSee `ltl.delay` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `delay` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n| `length` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.eventually` (::circt::firrtl::LTLEventuallyIntrinsicOp)\n\n*FIRRTL variant of `ltl.eventually`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.eventually` operands attr-dict `:` functional-type(operands, results)\n```\n\nSee `ltl.eventually` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.goto_repeat` (::circt::firrtl::LTLGoToRepeatIntrinsicOp)\n\n*FIRRTL variant of `ltl.goto_repeat`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.goto_repeat` $input `,` $base `,` $more attr-dict `:`\n              functional-type(operands, results)\n```\n\nSee `ltl.goto_repeat` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `base` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n| `more` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.implication` (::circt::firrtl::LTLImplicationIntrinsicOp)\n\n*FIRRTL variant of `ltl.implication`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.implication` operands attr-dict `:` functional-type(operands, results)\n```\n\nSee `ltl.implication` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | 1-bit uint |\n| `rhs` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.intersect` (::circt::firrtl::LTLIntersectIntrinsicOp)\n\n*FIRRTL variant of `ltl.intersect`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.intersect` operands attr-dict `:` functional-type(operands, results)\n```\n\nSee `ltl.intersect` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | 1-bit uint |\n| `rhs` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.non_consecutive_repeat` (::circt::firrtl::LTLNonConsecutiveRepeatIntrinsicOp)\n\n*FIRRTL variant of `ltl.non_consecutive_repeat`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.non_consecutive_repeat` $input `,` $base `,` $more attr-dict `:`\n              functional-type(operands, results)\n```\n\nSee `ltl.non_consecutive_repeat` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `base` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n| `more` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.not` (::circt::firrtl::LTLNotIntrinsicOp)\n\n*FIRRTL variant of `ltl.not`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.not` operands attr-dict `:` functional-type(operands, results)\n```\n\nSee `ltl.not` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.or` (::circt::firrtl::LTLOrIntrinsicOp)\n\n*FIRRTL variant of `ltl.or`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.or` operands attr-dict `:` functional-type(operands, results)\n```\n\nSee `ltl.or` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | 1-bit uint |\n| `rhs` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.repeat` (::circt::firrtl::LTLRepeatIntrinsicOp)\n\n*FIRRTL variant of `ltl.repeat`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.repeat` $input `,` $base (`,` $more^)? attr-dict `:`\n              functional-type(operands, results)\n```\n\nSee `ltl.repeat` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `base` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n| `more` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.ltl.until` (::circt::firrtl::LTLUntilIntrinsicOp)\n\n*FIRRTL variant of `ltl.until`*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.ltl.until` operands attr-dict `:` functional-type(operands, results)\n```\n\nSee `ltl.until` op in the LTL dialect.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | 1-bit uint |\n| `rhs` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.lt` (::circt::firrtl::LTPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.lt` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.list.concat` (::circt::firrtl::ListConcatOp)\n\n*Concatenate multiple lists to produce a new list*\n\nSyntax:\n\n```\noperation ::= `firrtl.list.concat` $subLists attr-dict `:` type($result)\n```\n\nProduces a value of list type by concatenating the provided lists.\n\nExample:\n\n```\n%3 = firrtl.list.concat %0, %1, %2 : !firrtl.list<string>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `subLists` | variadic of list type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | list type |\n\n### `firrtl.list.create` (::circt::firrtl::ListCreateOp)\n\n*Produce a list value*\n\nProduces a value of list type containing the provided elements.\n\nExample:\n\n```\n%3 = firrtl.list.create %0, %1, %2 : !firrtl.list<string>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `elements` | variadic of property type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | list type |\n\n### `firrtl.mul` (::circt::firrtl::MulPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.mul` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint or uint type |\n\n### `firrtl.multibit_mux` (::circt::firrtl::MultibitMuxOp)\n\n*Multibit multiplexer*\n\nThe multibit mux expression dynamically selects operands. The\nindex must be an expression with an unsigned integer type.\n\n```\n  %result = firrtl.multibit_mux %index,\n            %v_{n-1}, ..., %v_2, %v_1, %v_0  : t1, t2\n```\n\nThe order of operands is defined in the same way as hw dialect.\nFor the example above, if `%index` is 0, then the value is `%v_0`.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `index` | uint type |\n| `inputs` | variadic of a base type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a base type |\n\n### `firrtl.int.mux2cell` (::circt::firrtl::Mux2CellIntrinsicOp)\n\n*An intrinsic lowered into 2-to-1 MUX cell in synthesis tools.*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.mux2cell` `(` operands `)` attr-dict `:` functional-type(operands, $result)\n```\n\nThis intrinsic exposes a low-level API to use 2-to-1 MUX cell in backend\nsynthesis tool. At FIRRTL level, this operation participates\nthe inference process in the same way as a normal mux operation.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `sel` | uint with width less than or equal to 1 bits or uint with uninferred width |\n| `high` | a passive base type (contain no flips) |\n| `low` | a passive base type (contain no flips) |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a passive base type (contain no flips) |\n\n### `firrtl.int.mux4cell` (::circt::firrtl::Mux4CellIntrinsicOp)\n\n*An intrinsic lowered into 4-to-1 MUX cell in synthesis tools.*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.mux4cell` `(` operands `)` attr-dict `:` functional-type(operands, $result)\n```\n\nThis intrinsic exposes a low-level API to use 4-to-1 MUX cell in backend\nsynthesis tool. At FIRRTL level, this operation participates\nthe inference process as a sugar of mux operation chains.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `sel` | uint with width less than or equal to 2 bits or uint with uninferred width |\n| `v3` | a passive base type (contain no flips) |\n| `v2` | a passive base type (contain no flips) |\n| `v1` | a passive base type (contain no flips) |\n| `v0` | a passive base type (contain no flips) |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a passive base type (contain no flips) |\n\n### `firrtl.mux` (::circt::firrtl::MuxPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.mux` `(` operands `)` attr-dict `:` functional-type(operands, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `sel` | uint with width less than or equal to 1 bits or uint with uninferred width |\n| `high` | a passive base type (contain no flips) |\n| `low` | a passive base type (contain no flips) |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a passive base type (contain no flips) |\n\n### `firrtl.neq` (::circt::firrtl::NEQPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.neq` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.neg` (::circt::firrtl::NegPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.neg` $input attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint type |\n\n### `firrtl.not` (::circt::firrtl::NotPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.not` $input attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | uint type |\n\n### `firrtl.object.anyref_cast` (::circt::firrtl::ObjectAnyRefCastOp)\n\n*Cast object reference to anyref.*\n\nSyntax:\n\n```\noperation ::= `firrtl.object.anyref_cast` $input attr-dict `:` type($input)\n```\n\nCast any object reference to AnyRef type. This is needed for passing objects\nof a known class to sinks that accept any reference.\n\nExample\n\n```\n  %0= firrtl.object.anyref_cast %object : !firrtl.class<@Foo()>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | class type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any reference type |\n\n### `firrtl.object.subfield` (::circt::firrtl::ObjectSubfieldOp)\n\n*Extract an element of an object*\n\nThe object.subfield expression refers to a subelement of an object.\n\n```\n%field = firrtl.object.subfield %object[field] : !firrt.class<@Class(field: !firrtl.string)>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `index` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | class type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | property type |\n\n### `firrtl.opensubfield` (::circt::firrtl::OpenSubfieldOp)\n\n*Extract a subfield of another value*\n\nThe subfield expression refers to a subelement of an expression with a\nbundle type.\n\n```\n  %result = firrtl.opensubfield %input[field-name] : !input-type\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldIndex` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | open bundle type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | FIRRTLType |\n\n### `firrtl.opensubindex` (::circt::firrtl::OpenSubindexOp)\n\n*Extract an element of a vector value*\n\nSyntax:\n\n```\noperation ::= `firrtl.opensubindex` $input `[` $index `]` attr-dict `:` qualified(type($input))\n```\n\nThe subindex expression statically refers, by index, to a subelement\nof an expression with a vector type. The index must be a non-negative\ninteger and cannot be equal to or exceed the length of the vector it\nindexes.\n\n```\n  %result = firrtl.opensubindex %input[index] : t1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `index` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | open vector type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | FIRRTLType |\n\n### `firrtl.or` (::circt::firrtl::OrPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.or` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | uint type |\n\n### `firrtl.orr` (::circt::firrtl::OrRPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.orr` $input attr-dict `:` functional-type($input, $result)\n```\n\nHorizontally reduce a value to one bit, using the \u2018or\u2019 operation to merge\nbits. `orr(x)` is equivalent to `concat(x, 1b0) != 0`. As such, it\nreturns 0 for zero-bit-wide operands.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.pad` (::circt::firrtl::PadPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.pad` $input `,` $amount attr-dict `:` functional-type($input, $result)\n```\n\nPad the input out to an `amount` wide integer, sign extending or zero\nextending according to `input`s type. If `amount` is less than the existing\nwidth of `input`, then input is unmodified.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `amount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint or uint type |\n\n### `firrtl.path` (::circt::firrtl::PathOp)\n\n*Produce a path value*\n\nSyntax:\n\n```\noperation ::= `firrtl.path` $targetKind $target attr-dict\n```\n\nProduces a value which represents a path to the target in a design.\n\nExample:\n\n```\nhw.hierpath @Path [@Foo::@bar, @Bar]\n%wire = firrtl.wire {annotations = [ {class = \"circt.tracker\", id = distinct[0]<>, circt.nonlocal = @Path} ]} : !firrtl.uint<1>\n%0 = firrtl.path reference distinct[0]<>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `targetKind` | ::circt::firrtl::TargetKindAttr | object model target kind |\n| `target` | ::mlir::DistinctAttr | distinct attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | path type |\n\n### `firrtl.ref.rwprobe` (::circt::firrtl::RWProbeOp)\n\n*FIRRTL RWProbe*\n\nSyntax:\n\n```\noperation ::= `firrtl.ref.rwprobe` $target attr-dict `:` type($result)\n```\n\nCreate a RWProbe for the target.\nTarget must be local.\n\n```\n  %result = firrtl.ref.rwprobe @mod::@sym : firrtl.rwprobe<t>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InnerRefUserOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `target` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | rwprobe type |\n\n### `firrtl.ref.cast` (::circt::firrtl::RefCastOp)\n\n*Cast between compatible reference types*\n\nSyntax:\n\n```\noperation ::= `firrtl.ref.cast` $input attr-dict `:` functional-type($input, $result)\n```\n\nLosslessly cast between compatible reference types.\nSource and destination must be recursively identical or destination\nhas uninferred variants of the corresponding element in source.\n\n```\n  %result = firrtl.ref.cast %ref : (t1) -> t2\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | reference type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | reference type |\n\n### `firrtl.ref.resolve` (::circt::firrtl::RefResolveOp)\n\n*FIRRTL Resolve a Reference*\n\nSyntax:\n\n```\noperation ::= `firrtl.ref.resolve` $ref attr-dict `:` qualified(type($ref))\n```\n\nResolve a remote reference for reading a remote value.\nIt takes a RefType input and returns the corresponding BaseType value.\nIf an XMR is emitted for this reference, it will be at the location\nof this operation.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `ref` | reference type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a base type |\n\n### `firrtl.ref.send` (::circt::firrtl::RefSendOp)\n\n*FIRRTL Send through Reference*\n\nSyntax:\n\n```\noperation ::= `firrtl.ref.send` $base attr-dict `:` qualified(type($base))\n```\n\nEndpoint of a remote reference. Send a value through a reference\nto be read from the firrtl.ref.resolve op.\nIt takes a BaseType input and returns the corresponding RefType value.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `base` | a base type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | reference type |\n\n### `firrtl.ref.sub` (::circt::firrtl::RefSubOp)\n\n*Extract an element of an aggregate RefType value*\n\nSyntax:\n\n```\noperation ::= `firrtl.ref.sub` $input `[` $index `]` attr-dict `:` qualified(type($input))\n```\n\nThe refsub expression statically refers, by index, to a sub-element\nof an expression with a RefType. The index must be a non-negative\ninteger and cannot be equal to or exceed the underlying vector size\nor number of elements in bundle.\n\n```\n  %result = firrtl.ref.sub %input[index] : t1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `index` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | reference type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | reference type |\n\n### `firrtl.rem` (::circt::firrtl::RemPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.rem` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint or uint type |\n\n### `firrtl.shl` (::circt::firrtl::ShlPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.shl` $input `,` $amount attr-dict `:` functional-type($input, $result)\n```\n\nThe `shl` operation concatenates `amount` zero bits to the least significant\nend of `input`. `amount` must be non-negative.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `amount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint or uint type |\n\n### `firrtl.shr` (::circt::firrtl::ShrPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.shr` $input `,` $amount attr-dict `:` functional-type($input, $result)\n```\n\nThe `shr` operation truncates least significant `amount` bits from `input`.\nIf `amount` is greater than of equal to `width(input)`, the value will be\nzero for unsigned types and the sign bit for signed types. `amount` must be\nnon-negative.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `amount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint or uint type |\n\n### `firrtl.int.sizeof` (::circt::firrtl::SizeOfIntrinsicOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.int.sizeof` $input attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a base type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 32-bit uint |\n\n### `firrtl.specialconstant` (::circt::firrtl::SpecialConstantOp)\n\n*Produce a constant Reset or Clock value*\n\nThe constant operation produces a constant value of Reset, AsyncReset, or\nClock type. The value can only be 0 or 1.\n\n```\n  %result = firrtl.specialconstant 1 : !firrtl.clock\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::BoolAttr | bool attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | clock or reset type or async reset type |\n\n### `firrtl.string` (::circt::firrtl::StringConstantOp)\n\n*Produce a constant string value*\n\nSyntax:\n\n```\noperation ::= `firrtl.string` $value attr-dict\n```\n\nProduces a constant value of string type.\n\nExample:\n\n```\n%0 = firrtl.string \"hello world\"\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | string type |\n\n### `firrtl.sub` (::circt::firrtl::SubPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.sub` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | sint or uint type |\n\n### `firrtl.subaccess` (::circt::firrtl::SubaccessOp)\n\n*Extract a dynamic element of a vector value*\n\nSyntax:\n\n```\noperation ::= `firrtl.subaccess` $input `[` $index `]` attr-dict `:` qualified(type($input)) `,` qualified(type($index))\n```\n\nThe subaccess expression dynamically refers to a subelement of a\nvector-typed expression using a calculated index. The index must be an\nexpression with an unsigned integer type.\n\n```\n  %result = firrtl.subaccess %input[%idx] : t1, t2\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | vector type |\n| `index` | uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a base type |\n\n### `firrtl.subfield` (::circt::firrtl::SubfieldOp)\n\n*Extract a subfield of another value*\n\nThe subfield expression refers to a subelement of an expression with a\nbundle type.\n\n```\n  %result = firrtl.subfield %input[field-name] : !input-type\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldIndex` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | bundle type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a base type |\n\n### `firrtl.subindex` (::circt::firrtl::SubindexOp)\n\n*Extract an element of a vector value*\n\nSyntax:\n\n```\noperation ::= `firrtl.subindex` $input `[` $index `]` attr-dict `:` qualified(type($input))\n```\n\nThe subindex expression statically refers, by index, to a subelement\nof an expression with a vector type. The index must be a non-negative\ninteger and cannot be equal to or exceed the length of the vector it\nindexes.\n\n```\n  %result = firrtl.subindex %input[index] : t1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `index` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | vector type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a base type |\n\n### `firrtl.subtag` (::circt::firrtl::SubtagOp)\n\n*Extract an element of a enum value*\n\nThe subtag expression refers to a subelement of a\nenum-typed expression.\n\n```\n  %result = firrtl.subtag %input[field-name] : !input-type\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldIndex` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | enum type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a base type |\n\n### `firrtl.tagextract` (::circt::firrtl::TagExtractOp)\n\n*Extract the tag from a value*\n\nSyntax:\n\n```\noperation ::= `firrtl.tagextract` $input attr-dict `:` qualified(type($input))\n```\n\nThe tagextract expression returns the binary value of the current tag of an\nenum value.\n\n```\n  %result = firrtl.tagextract %input : !input-type\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | enum type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | uint type |\n\n### `firrtl.tail` (::circt::firrtl::TailPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.tail` $input `,` $amount attr-dict `:` functional-type($input, $result)\n```\n\nThe `tail` operation truncates the `amount` most significant bits from\n`input`. `amount` must be non-negative and less than or equal to the bit\nwidth of e. The result is `width(input)-amount` bits wide.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `amount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | uint type |\n\n### `firrtl.fstring.time` (::circt::firrtl::TimeOp)\n\n*An operation that represents the current simulation time*\n\nSyntax:\n\n```\noperation ::= `firrtl.fstring.time` attr-dict `:` type($result)\n```\n\nThis operation represents the current simulation time. It returns a format\nstring type which can only be used as a substitution inside a printf. This\noperation is not represented in the FIRRTL spec.\n\nThis operation is the FIRRTL Dialect representation of the special\nsubstitution `{{SimulationTime}}`.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a format string type |\n\n### `firrtl.resetCast` (::circt::firrtl::UninferredResetCastOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.resetCast` $input attr-dict `:` functional-type($input, $result)\n```\n\nCast between reset types. This is used to enable matchingconnects early in\nthe pipeline by isolating all uninferred reset connections to a single op.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | Reset |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | Reset |\n\n### `firrtl.unknown` (::circt::firrtl::UnknownValueOp)\n\n*A property with an unknown value used to tie-off connections*\n\nSyntax:\n\n```\noperation ::= `firrtl.unknown` attr-dict `:` type($result)\n```\n\nAn operation that is used to tie-off property connections where we do not\ncare about the value.\n\nThis lowers to an `om::UnknownOp`.\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | property type |\n\n### `firrtl.unresolved_path` (::circt::firrtl::UnresolvedPathOp)\n\n*Produce a path value*\n\nSyntax:\n\n```\noperation ::= `firrtl.unresolved_path` $target attr-dict\n```\n\nProduces a value which represents a path to the target in a design.\n\nExample:\n\n```\n0 = firrtl.unresolved_path \"~Circuit|Module>w\"\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `target` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | path type |\n\n### `firrtl.unsafe_domain_cast` (::circt::firrtl::UnsafeDomainCastOp)\n\n*Cast an operand from one domain to another*\n\nSyntax:\n\n```\noperation ::= `firrtl.unsafe_domain_cast` $input (`domains` $domains^)? attr-dict-with-keyword `:` qualified(type($input))\n```\n\nThis operation is used to *unsafely* convert from the domain of an operand\nto another domain. This operation is inherently unsafe and unchecked.\n\nThis operation is necessary in order to describe certain constructs like\nsynchronizers which, from a domain type system perspective, violate normal\nconstraints.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a passive base type (contain no flips) |\n| `domains` | variadic of a domain type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a passive base type (contain no flips) |\n\n### `firrtl.vectorcreate` (::circt::firrtl::VectorCreateOp)\n\n*Produce a vector value*\n\nSyntax:\n\n```\noperation ::= `firrtl.vectorcreate` $fields attr-dict `:` functional-type($fields, $result)\n```\n\nCreate a vector from component values. This is equivalent in terms of\nflow to creating a node. The first operand indicates 0-th element of\nthe result.\n\n```\n  %result = firrtl.vectorcreate %1, %2, %3 : !firrtl.vector<uint<8>, 3>\n```\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `fields` | variadic of a base type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | vector type |\n\n### `firrtl.verbatim.expr` (::circt::firrtl::VerbatimExprOp)\n\n*Expression that expands to a value given SystemVerilog text*\n\nSyntax:\n\n```\noperation ::= `firrtl.verbatim.expr` $text (`(` $substitutions^ `)`)?\n              `:` functional-type($substitutions, $result) attr-dict\n```\n\nThis operation produces a typed value expressed by a string of\nSystemVerilog. This can be used to access macros and other values that are\nonly sensible as Verilog text.\n\nThe text string is expected to have the highest precedence, so you should\ninclude parentheses in the string if it isn\u2019t a single token. This is also\nassumed to not have side effects (use `sv.verbatim` if you need them).\n\n`firrtl.verbatim.expr` allows operand substitutions with `{{0}}` syntax.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `text` | ::mlir::StringAttr | string attribute |\n| `symbols` | ::mlir::ArrayAttr | name reference array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `substitutions` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a base type |\n\n### `firrtl.verbatim.wire` (::circt::firrtl::VerbatimWireOp)\n\n*Expression with wire semantics that expands to a value given SystemVerilog text*\n\nSyntax:\n\n```\noperation ::= `firrtl.verbatim.wire` $text (`(` $substitutions^ `)`)?\n              `:` functional-type($substitutions, $result) attr-dict\n```\n\nThis operation produces a typed value with wire semantics, expressed by a\nstring of SystemVerilog. This can be used to access macros and other values\nthat are only sensible as Verilog text.\n\nThe text string is expected to have the highest precedence, so you should\ninclude parentheses in the string if it isn\u2019t a single token. This is also\nassumed to not have side effects (use `sv.verbatim` if you need them).\n\n`firrtl.verbatim.wire` allows operand substitutions with `{{0}}` syntax.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `text` | ::mlir::StringAttr | string attribute |\n| `symbols` | ::mlir::ArrayAttr | name reference array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `substitutions` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a base type |\n\n### `firrtl.xmr.deref` (::circt::firrtl::XMRDerefOp)\n\n*FIRRTL XMR operation, reading an XMR target.*\n\nSyntax:\n\n```\noperation ::= `firrtl.xmr.deref` $ref (`,` $verbatimSuffix^)? attr-dict `:` qualified(type($dest))\n```\n\nA \u201cread at a distance\u201d, taking a (symbol-ref to a) hierarchical path,\nreturning the value of the target.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `ref` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `verbatimSuffix` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `dest` | a passive base type (contain no flips) |\n\n### `firrtl.xmr.ref` (::circt::firrtl::XMRRefOp)\n\n*FIRRTL XMR operation, targetable by ref ops.*\n\nSyntax:\n\n```\noperation ::= `firrtl.xmr.ref` $ref (`,` $verbatimSuffix^)? attr-dict `:` qualified(type($dest))\n```\n\nTakes a (symbol-ref to a) hierarchical path and returns a reference to\nthe target. Through this reference, the target can be read or written\n\u201cat a distance\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `ref` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `verbatimSuffix` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `dest` | reference type |\n\n### `firrtl.xor` (::circt::firrtl::XorPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.xor` $lhs `,` $rhs  attr-dict `:`\n              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `->` qualified(type($result))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsIntTypeKind`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | sint or uint type |\n| `rhs` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | uint type |\n\n### `firrtl.xorr` (::circt::firrtl::XorRPrimOp)\n\nSyntax:\n\n```\noperation ::= `firrtl.xorr` $input attr-dict `:` functional-type($input, $result)\n```\n\nHorizontally reduce a value to one bit, using the \u2018xor\u2019 operation to merge\nbits. `xorr(x)` is equivalent to `popcount(concat(x, 1b0)) & 1`. As\nsuch, it returns 0 for zero-bit-wide operands.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | sint or uint type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\nOperation Definitions \u2013 Intrinsics\n----------------------------------\n\n### `firrtl.int.clock_div` (::circt::firrtl::ClockDividerIntrinsicOp)\n\n*Produces a clock divided by a power of two*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.clock_div` $input `by` $pow2 attr-dict\n```\n\nThe `firrtl.int.clock_div` takes a clock signal and divides it by a\npower-of-two ratio. The output clock is phase-aligned to the input clock.\n\n```\n%div_clock = seq.clock_div %clock by 1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `pow2` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | clock |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | clock |\n\n### `firrtl.int.clock_gate` (::circt::firrtl::ClockGateIntrinsicOp)\n\n*Safely gates a clock with an enable signal*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.clock_gate` $input `,` $enable (`,` $test_enable^)? attr-dict\n```\n\nThe `int.clock_gate` enables and disables a clock safely, without glitches,\nbased on a boolean enable value. If the enable input is 1, the output clock\nproduced by the clock gate is identical to the input clock. If the enable\ninput is 0, the output clock is a constant zero.\n\nThe enable input is sampled at the rising edge of the input clock; any\nchanges on the enable before or after that edge are ignored and do not\naffect the output clock.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | clock |\n| `enable` | 1-bit uint |\n| `test_enable` | 1-bit uint |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | clock |\n\n### `firrtl.int.clock_inv` (::circt::firrtl::ClockInverterIntrinsicOp)\n\n*Inverts the clock signal*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.clock_inv` $input attr-dict\n```\n\nThe `firrtl.int.clock.inv` intrinsic takes a clock signal and inverts it.\nIt can be used to build registers and other operations which are triggered\nby a negative clock edge relative to a reference signal. The compiler is\nfree to optimize inverters (particularly double inverters).\n\nSee the corresponding `seq.clock_inv` operation.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | clock |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | clock |\n\n### `firrtl.int.dpi.call` (::circt::firrtl::DPICallIntrinsicOp)\n\n*Import and call DPI function*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.dpi.call` $functionName `(` $inputs `)` (`clock` $clock^)? (`enable` $enable^)?\n              attr-dict `:` functional-type($inputs, results)\n```\n\nThe `int.dpi.call` intrinsic calls an external function.\nSee Sim dialect DPI call op.\n\nTraits: `AttrSizedOperandSegments`\n\nInterfaces: `CombDataFlow`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `functionName` | ::mlir::StringAttr | string attribute |\n| `inputNames` | ::mlir::ArrayAttr | string array attribute |\n| `outputName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | clock |\n| `enable` | 1-bit uint |\n| `inputs` | variadic of a passive base type (contain no flips) |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a passive base type (contain no flips) |\n\n### `firrtl.int.fpga_probe` (::circt::firrtl::FPGAProbeIntrinsicOp)\n\n*Mark a value to be observed through FPGA debugging facilities*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.fpga_probe` $clock `,` $input attr-dict `:` type($input)\n```\n\nThe `firrtl.int.fpga_probe` intrinsic marks a value in\nthe IR to be made observable through FPGA debugging facilities. Most FPGAs\noffer a form of signal observation or logic analyzer to debug a design. This\noperation allows the IR to indicate which signals should be made observable\nfor debugging. Later FPGA-specific passes may then pick this information up\nand materialize the necessary logic analyzers or tool scripts.\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | any type |\n| `clock` | clock |\n\n### `firrtl.int.generic` (::circt::firrtl::GenericIntrinsicOp)\n\n*Generic intrinsic operation for FIRRTL intrinsics.*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.generic` $intrinsic custom<ParameterList>($parameters) ($operands^)? attr-dict-with-keyword `:` functional-type($operands, $result)\n```\n\nInterfaces: `HasCustomSSAName`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `intrinsic` | ::mlir::StringAttr | string attribute |\n| `parameters` | ::mlir::ArrayAttr | parameter array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operands` | variadic of a passive base type (contain no flips) |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a passive base type (contain no flips) |\n\n### `firrtl.int.has_been_reset` (::circt::firrtl::HasBeenResetIntrinsicOp)\n\n*Check that a proper reset has been seen.*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.has_been_reset` $clock `,` $reset attr-dict `:` type($reset)\n```\n\nThe result of `firrtl.int.has_been_reset` reads as 0 immediately after simulation\nstartup and after each power-cycle in a power-aware simulation. The result\nremains 0 before and during reset and only switches to 1 after the reset is\ndeasserted again.\n\nSee the corresponding `verif.has_been_reset` operation.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | clock |\n| `reset` | Reset |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.isX` (::circt::firrtl::IsXIntrinsicOp)\n\n*Test for \u2018x*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.isX` $arg attr-dict `:` type($arg)\n```\n\nThe `int.isX` expression checks that the operand is not a verilog literal\n\u2018x. FIRRTL doesn\u2019t have a notion of \u2018x per-se, but x can come in to the\nsystem from external modules and from SV constructs. Verification\nconstructs need to explicitly test for \u2018x.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `arg` | a base type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit uint |\n\n### `firrtl.int.plusargs.test` (::circt::firrtl::PlusArgsTestIntrinsicOp)\n\n*SystemVerilog `$test$plusargs` call*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.plusargs.test` $formatString attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `formatString` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `found` | 1-bit uint |\n\n### `firrtl.int.plusargs.value` (::circt::firrtl::PlusArgsValueIntrinsicOp)\n\n*SystemVerilog `$value$plusargs` call*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.plusargs.value` $formatString attr-dict `:` type($result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `formatString` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `found` | 1-bit uint |\n| `result` | any type |\n\n### `firrtl.int.unclocked_assume` (::circt::firrtl::UnclockedAssumeIntrinsicOp)\n\n*Special Assume Verification Statement to assume predicate*\n\nSyntax:\n\n```\noperation ::= `firrtl.int.unclocked_assume` $predicate `,` $enable `,` $message (`(` $substitutions^ `)`)? `:`\n              type($predicate) `,` type($enable) (`,` qualified(type($substitutions))^)?\n              custom<VerifAttrs>(attr-dict)\n```\n\nThe `firrtl.int.unclocked_assume` intrinsic is a special assume statement\nlowered into a SV concurrent assertion within always block that has the assumed\npredicate in a sensitivity list.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `message` | ::mlir::StringAttr | string attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `predicate` | 1-bit uint |\n| `enable` | 1-bit uint |\n| `substitutions` | variadic of any type |\n\n### `firrtl.view` (::circt::firrtl::ViewIntrinsicOp)\n\n*A SystemVerilog Interface only usable for waveform debugging*\n\nSyntax:\n\n```\noperation ::= `firrtl.view` $name `,` (`yaml` $yamlFile^ `,`)? $augmentedType (`,` $inputs^)? attr-dict (`:` type($inputs)^)?\n```\n\nThis will become a SystemVerilog Interface that is driven by its arguments.\nThis is *not* intended to be used for anything other than assistance when\ndebugging in a waveform. This is *not* a true SystemVerilog Interface, it\nis only lowered to one.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `yamlFile` | ::mlir::StringAttr | string attribute |\n| `augmentedType` | ::circt::firrtl::AugmentedBundleTypeAttr | GrandCentral AugmentedBundleType |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a ground type |\n\nType Definitions\n----------------\n\n### AnalogType\n\n*Analog signal*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| widthOrSentinel | `int32_t` |  |\n| isConst | `bool` |  |\n\n### AnyRefType\n\n*A reference to an instance of any class.*\n\nA reference of type AnyRef can be used in ports, property assignments, and\nany other Property \u201cplumbing\u201d ops. But it is opaque, and references to\nobjects of AnyRef type cannot be \u201cdereferenced\u201d. There is no information\nabout the referred to object\u2019s fields, so subfield access, etc. is illegal.\n\n### AsyncResetType\n\n*AsyncReset signal*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| isConst | `bool` |  |\n\n### BaseTypeAliasType\n\n*Type alias for firrtl base types*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| name | `StringAttr` |  |\n| innerType | `::circt::firrtl::FIRRTLBaseType` | An inner type |\n\n### BoolType\n\n*A boolean property. Not representable in hardware.*\n\n### BundleType\n\n*An aggregate of named elements. This is effectively a struct.*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elements | `ArrayRef<BundleElement>` |  |\n| isConst | `bool` |  |\n\n### ClassType\n\n\\_An instance of a class.\n\n```\nExample:\n```mlir\n!firrtl.class<@Module(in p0: !firrtl.uint<8>, out p1: !firrtl.uint<8>)>\n```_\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| name | `FlatSymbolRefAttr` |  |\n| elements | `::llvm::ArrayRef<ClassElement>` |  |\n\n### ClockType\n\n*Clock signal*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| isConst | `bool` |  |\n\n### DomainType\n\n*A domain type*\n\n### DoubleType\n\n*A double property. Not representable in hardware.*\n\n### FEnumType\n\n*A sum type of named elements.*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elements | `ArrayRef<EnumElement>` |  |\n| isConst | `bool` |  |\n\n### FStringType\n\n*A format string type*\n\n### FVectorType\n\n*A fixed size collection of elements, like an array.*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `::circt::firrtl::FIRRTLBaseType` | Type of vector elements |\n| numElements | `size_t` |  |\n| isConst | `bool` |  |\n\n### FIntegerType\n\n*An unlimited length signed integer type. Not representable in hardware.*\n\n### LHSType\n\n*A wrapper for LHS types.*\n\nA LHS type is a type usable for the destination of a strict connect\nand for field indexing. No other operations are valid. Any passive,\nstrict-connectable types are valid inside LHS types.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| type | `FIRRTLBaseType` |  |\n\n### ListType\n\n*A typed property list of any length. Not representable in hardware.*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `circt::firrtl::PropertyType` | element type |\n\n### OpenBundleType\n\n*An aggregate of named elements. This is effectively a struct.*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elements | `ArrayRef<BundleElement>` |  |\n| isConst | `bool` |  |\n\n### OpenVectorType\n\n*A fixed size collection of elements, like an array.*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `::circt::firrtl::FIRRTLType` | Type of vector elements |\n| numElements | `size_t` |  |\n| isConst | `bool` |  |\n\n### PathType\n\n*A path to a hardware entity. Not representable in hardware.*\n\n### RefType\n\n*A reference to a signal elsewhere.*\n\nA reference type, such as `firrtl.probe<uint<1>>` or `firrtl.rwprobe<uint<2>>`.\n\nUsed for remote reads and writes of the wrapped base type.\n\nParameterized over the referenced base type, with flips removed.\n\nNot a base type.\n\nValues of this type are used to capture dataflow paths,\nand do not represent a circuit element or entity.\n\nGenerally read-only (probe), optionally forceable (rwprobe).\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| type | `::circt::firrtl::FIRRTLBaseType` | Type of reference target |\n| forceable | `bool` |  |\n| layer | `::mlir::SymbolRefAttr` |  |\n\n### ResetType\n\n*Reset Signal*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| isConst | `bool` |  |\n\n### SIntType\n\n*A signed integer type, whose width may not be known.*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| widthOrSentinel | `int32_t` |  |\n| isConst | `bool` |  |\n\n### StringType\n\n*An unlimited length string type. Not representable in hardware.*\n\n### UIntType\n\n*An unsigned integer type, whose width may not be known.*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| widthOrSentinel | `int32_t` |  |\n| isConst | `bool` |  |\n\nAttribute Definitions\n---------------------\n\n### AugmentedBundleTypeAttr\n\n*GrandCentral AugmentedBundleType*\n\nSyntax:\n\n```\n#firrtl.augmentedBundle<\n  DictionaryAttr   # underlying\n>\n```\n\nUsed in the GrandCentralPass.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| underlying | `DictionaryAttr` |  |\n\n### AugmentedGroundTypeAttr\n\n*GrandCentral AugmentedGroundType*\n\nSyntax:\n\n```\n#firrtl.augmentedGround<\n  DictionaryAttr   # underlying\n>\n```\n\nUsed in the GrandCentralPass.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| underlying | `DictionaryAttr` |  |\n\n### AugmentedVectorTypeAttr\n\n*GrandCentral AugmentedVectorType*\n\nSyntax:\n\n```\n#firrtl.augmentedVector<\n  DictionaryAttr   # underlying\n>\n```\n\nUsed in the GrandCentralPass.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| underlying | `DictionaryAttr` |  |\n\n### DomainFieldAttr\n\n*A single field of a domain*\n\nSyntax:\n\n```\n#firrtl.domain.field<\n  ::mlir::StringAttr,   # name\n  ::circt::firrtl::PropertyType   # type\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| name | `::mlir::StringAttr` |  |\n| type | `::circt::firrtl::PropertyType` |  |\n\n### MemoryInitAttr\n\n*Information about the initial state of a memory*\n\nSyntax:\n\n```\n#firrtl.meminit<\n  ::mlir::StringAttr,   # filename\n  bool,   # isBinary\n  bool   # isInline\n>\n```\n\nThis attribute captures information about the external initialization of a\nmemory. This is the FIRRTL Dialect representation of both\n\u201cfirrtl.annotations.LoadMemoryFromFile\u201d and\n\u201cfirrtl.annotations.MemoryFileInlineAnnotation\u201d.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| filename | `::mlir::StringAttr` |  |\n| isBinary | `bool` |  |\n| isInline | `bool` |  |\n\n### ParamDeclAttr\n\n*Module or instance parameter definition*\n\nAn attribute describing a module parameter, or instance parameter\nspecification.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| name | `::mlir::StringAttr` |  |\n| type | `::mlir::Type` |  |\n| value | `::mlir::Attribute` |  |\n\nClassLike (`ClassLike`)\n-----------------------\n\nProvide common class information.\n\n### Methods:\n\n#### `getInstanceType`\n\n```\nClassType getInstanceType();\n```\n\nGet the type for instances of this class\n\nNOTE: This method *must* be implemented by the user.\n\n#### `verifyType`\n\n```\nLogicalResult verifyType(::circt::firrtl::ClassType type, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);\n```\n\nVerify that the given type agrees with this class\n\nNOTE: This method *must* be implemented by the user.\n\nFConnectLike (`FConnectLike`)\n-----------------------------\n\nProvide common connection information.\n\n### Methods:\n\n#### `getDest`\n\n```\nValue getDest();\n```\n\nReturn a destination of connection.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getSrc`\n\n```\nValue getSrc();\n```\n\nReturn a source of connection.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getConnectBehaviorKind`\n\n```\nstatic ConnectBehaviorKind getConnectBehaviorKind();\n```\n\nReturn connection behavior kind.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `hasStaticSingleConnectBehavior`\n\n```\nstatic bool hasStaticSingleConnectBehavior();\n```\n\nReturns true if ConnectBehavior is StaticSingleConnect.\n\n#### `hasLastConnectBehavior`\n\n```\nstatic bool hasLastConnectBehavior();\n```\n\nReturns true if ConnectBehavior is LastConnect.\n\nFInstanceLike (`FInstanceLike`)\n-------------------------------\n\nProvide common instance information.\n\n### Methods:\n\n#### `getReferencedModuleName`\n\n```\n::llvm::StringRef getReferencedModuleName();\n```\n\nGet the name of the instantiated module\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getReferencedModuleNameAttr`\n\n```\n::mlir::StringAttr getReferencedModuleNameAttr();\n```\n\nGet the name of the instantiated module\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getReferencedOperation`\n\n```\n::mlir::Operation *getReferencedOperation(const SymbolTable&symtbl);\n```\n\nGet the referenced module via a symbol table.\n\nNOTE: This method *must* be implemented by the user.\n\nFModuleLike (`FModuleLike`)\n---------------------------\n\nProvide common module information.\n\n### Methods:\n\n#### `getParameters`\n\n```\nArrayAttr getParameters();\n```\n\nGet the parameters\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getConventionAttr`\n\n```\nConventionAttr getConventionAttr();\n```\n\nGet the module\u2019s instantiation convention\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getConvention`\n\n```\nConvention getConvention();\n```\n\nGet the module\u2019s instantiation convention\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getLayersAttr`\n\n```\nArrayAttr getLayersAttr();\n```\n\nGet the module\u2019s enabled layers\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getLayers`\n\n```\nArrayRef<Attribute> getLayers();\n```\n\nGet the module\u2019s enabled layers.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortDirectionsAttr`\n\n```\nmlir::DenseBoolArrayAttr getPortDirectionsAttr();\n```\n\nGet the port directions attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortDirections`\n\n```\nArrayRef<bool> getPortDirections();\n```\n\nGet the port directions\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortDirection`\n\n```\nDirection getPortDirection(size_t portIndex);\n```\n\nGet a port direction\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortNamesAttr`\n\n```\nArrayAttr getPortNamesAttr();\n```\n\nGet the port names attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortNames`\n\n```\nArrayRef<Attribute> getPortNames();\n```\n\nGet the port names\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortNameAttr`\n\n```\nStringAttr getPortNameAttr(size_t portIndex);\n```\n\nGet a port name\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortName`\n\n```\nStringRef getPortName(size_t portIndex);\n```\n\nGet a port name\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortTypesAttr`\n\n```\nArrayAttr getPortTypesAttr();\n```\n\nGet the port types attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortTypes`\n\n```\nArrayRef<Attribute> getPortTypes();\n```\n\nGet the port types\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setPortTypesAttr`\n\n```\nvoid setPortTypesAttr(::mlir::ArrayAttr portTypes);\n```\n\nSet the types of all ports\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortTypeAttr`\n\n```\nTypeAttr getPortTypeAttr(size_t portIndex);\n```\n\nGet a port type\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortType`\n\n```\nType getPortType(size_t portIndex);\n```\n\nGet a port type\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortAnnotationsAttr`\n\n```\nArrayAttr getPortAnnotationsAttr();\n```\n\nGet the port annotations attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortAnnotations`\n\n```\nArrayRef<Attribute> getPortAnnotations();\n```\n\nGet the port annotations attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setPortAnnotationsAttr`\n\n```\nvoid setPortAnnotationsAttr(::mlir::ArrayAttr annotations);\n```\n\nSet the port annotations attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getAnnotationsAttrForPort`\n\n```\nArrayAttr getAnnotationsAttrForPort(size_t portIndex);\n```\n\nGet a port\u2019s annotations attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getAnnotationsForPort`\n\n```\nArrayRef<Attribute> getAnnotationsForPort(size_t portIndex);\n```\n\nGet a port\u2019s annotations\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortSymbolsAttr`\n\n```\nArrayAttr getPortSymbolsAttr();\n```\n\nGet the port symbols attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortSymbols`\n\n```\nArrayRef<Attribute> getPortSymbols();\n```\n\nGet the port symbols\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortSymbolAttr`\n\n```\ncirct::hw::InnerSymAttr getPortSymbolAttr(size_t portIndex);\n```\n\nGet the port symbol attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setPortSymbolsAttr`\n\n```\nvoid setPortSymbolsAttr(::mlir::ArrayAttr symbols);\n```\n\nSet the symbols of all ports and their fields\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setPortSymbols`\n\n```\nvoid setPortSymbols(::llvm::ArrayRef<Attribute> symbols);\n```\n\nSet the symbols of all ports and their fields\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setPortSymbolAttr`\n\n```\nvoid setPortSymbolAttr(size_t portIndex, circt::hw::InnerSymAttr symbol);\n```\n\nSet the symbols for a port including its fields\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortLocationsAttr`\n\n```\nArrayAttr getPortLocationsAttr();\n```\n\nGet the port locations attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortLocations`\n\n```\nArrayRef<Attribute> getPortLocations();\n```\n\nGet the port locations attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortLocationAttr`\n\n```\nLocationAttr getPortLocationAttr(size_t portIndex);\n```\n\nGet a port\u2019s location attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortLocation`\n\n```\nLocation getPortLocation(size_t portIndex);\n```\n\nGet a port\u2019s location\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getDomainInfoAttr`\n\n```\nArrayAttr getDomainInfoAttr();\n```\n\nGet domain information attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getDomainInfo`\n\n```\nArrayRef<Attribute> getDomainInfo();\n```\n\nGet domain information\n\n#### `getDomainInfoAttrForPort`\n\n```\nAttribute getDomainInfoAttrForPort(size_t portIndex);\n```\n\nGet a port\u2019s domain info attribute\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setDomainInfoAttr`\n\n```\nvoid setDomainInfoAttr(::mlir::ArrayAttr domainInfo);\n```\n\nSet the domain info of all ports\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPorts`\n\n```\nSmallVector<PortInfo> getPorts();\n```\n\nGet information about all ports\n\nNOTE: This method *must* be implemented by the user.\n\n#### `insertPorts`\n\n```\nvoid insertPorts(ArrayRef<std::pair<unsigned, PortInfo>> ports);\n```\n\nInserts the given ports at the corresponding indices\n\nNOTE: This method *must* be implemented by the user.\n\n#### `erasePorts`\n\n```\nvoid erasePorts(const llvm::BitVector&portIndices);\n```\n\nErases the ports that have their corresponding bit set in `portIndices`\n\nNOTE: This method *must* be implemented by the user.\n\nFNamableOp (`FNamableOp`)\n-------------------------\n\nThis interface provides common methods for namable operations.\n\n### Methods:\n\n#### `getNameAttr`\n\n```\n::mlir::StringAttr getNameAttr();\n```\n\nReturn the name.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getName`\n\n```\n::llvm::StringRef getName();\n```\n\nReturn the name.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setNameAttr`\n\n```\nvoid setNameAttr(::mlir::StringAttr name);\n```\n\nSet the name.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setName`\n\n```\nvoid setName(::llvm::StringRef name);\n```\n\nSet the name.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getNameKindAttr`\n\n```\n::circt::firrtl::NameKindEnumAttr getNameKindAttr();\n```\n\nGet the namekind\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getNameKind`\n\n```\n::circt::firrtl::NameKindEnum getNameKind();\n```\n\nGet the namekind\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setNameKindAttr`\n\n```\nvoid setNameKindAttr(::circt::firrtl::NameKindEnumAttr nameKind);\n```\n\nSet a namekind.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setNameKind`\n\n```\nvoid setNameKind(::circt::firrtl::NameKindEnum nameKind);\n```\n\nSet a namekind.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `hasDroppableName`\n\n```\nbool hasDroppableName();\n```\n\nReturn true if the name is droppable.\n\nNOTE: This method *must* be implemented by the user.\n\nForceable (`Forceable`)\n-----------------------\n\nInteraction with declarations of forceable hardware components,\nand managing references to them.\n\n### Methods:\n\n#### `isForceable`\n\n```\nbool isForceable();\n```\n\nReturn true if the operation is forceable.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getData`\n\n```\nmlir::TypedValue<FIRRTLBaseType> getData();\n```\n\nReturn data value that will be targeted.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getDataRaw`\n\n```\nValue getDataRaw();\n```\n\nReturn raw data value that will be targeted.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getDataType`\n\n```\nFIRRTLBaseType getDataType();\n```\n\nReturn data type that will be referenced.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getDataRef`\n\n```\nmlir::TypedValue<RefType> getDataRef();\n```\n\nReturn reference result, or null if not active.\n\nNOTE: This method *must* be implemented by the user.\n\n'firrtl' Dialect Docs\n---------------------\n\n* [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n* [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n* [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n\n [Prev - The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/ \"The Elastic Silicon Interconnect dialect\")\n[Next - FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/ \"FIRRTL Annotations\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/index.md"
  },
  {
    "role": "user",
    "content": "FIRRTL Annotations - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nFIRRTL Annotations\n==================\n\nThe Scala FIRRTL Compiler (SFC) provides a mechanism to encode arbitrary\nmetadata and associate it with zero or more \u201cthings\u201d in a FIRRTL circuit. This\nmechanism is an *Annotation* and the association is described using one or more\n*Targets*. Annotations should be viewed as an extension to the FIRRTL IR\nspecification, and can greatly affect the meaning and interpretation of the IR.\n\nAnnotations are represented as a dictionary, with a \u201cclass\u201d field which\ndescribes which annotation it is, and a \u201ctarget\u201d field which represents the IR\nobject it is attached to. The annotation\u2019s class matches the name of a Java\nclass in the Scala Chisel/FIRRTL code base. Annotations may have arbitrary\nadditional fields attached. Some annotation classes extend other annotations,\nwhich effectively means that the subclass annotation implies to effect of the\nparent annotation.\n\nAnnotations are serializable to JSON and either live in a separate file (e.g.,\nduring the handoff between Chisel and the SFC) or are stored in-memory (e.g.,\nduring SFC-based compilation). The SFC pass API requires that passes describe\nwhich targets in the circuit they update. SFC infrastructure then\nautomatically updates annotations so they are always synchronized with their\ncorresponding FIRRTL IR.\n\nAn example of an annotation is the `DontTouchAnnotation`, which can be used to\nindicate to the compiler that a wire \u201cfoo\u201d should not be optimized away.\n\n```\n{\n  \"class\":\"firrtl.transforms.DontTouchAnnotation\",\n  \"target\":\"~MyCircuit|MyModule>foo\"\n}\n```\n\nSome annotations have more complex interactions with the IR. For example the\n[BoringUtils](https://javadoc.io/doc/edu.berkeley.cs/chisel3_2.13/latest/chisel3/util/experimental/BoringUtils$.html)\nprovides FIRRTL with annotations which can be used to wire together any two\nthings across the module instance hierarchy.\n\nMotivation\u00a0[\u00b6](#motivation)\n---------------------------\n\nHistorically, annotations grew out of three choices in the design of FIRRTL IR:\n\n1. FIRRTL IR is not extensible with user-defined IR nodes.\n2. FIRRTL IR is not parameterized.\n3. FIRRTL IR does not support in-IR attributes.\n\nAnnotations have then been used for all manner of extensions including:\n\n1. Encoding SystemVerilog nodes into the IR using special printfs, an example of\n   working around (1) above.\n2. Setting the reset vector of different, identical CPU cores, an example of\n   working around (2) above.\n3. Encoding sources and sinks that should be wired together by an SFC pass, an\n   example of (3) above.\n\nTargets\u00a0[\u00b6](#targets)\n---------------------\n\nA circuit is described, stored, and optimized in a folded representation. For\nexample, there may be multiple instances of a module which will eventually\nbecome multiple physical copies of that module on the die.\n\nTargets are a mechanism to identify specific hardware in specific instances of\nmodules in a FIRRTL circuit. A target consists of a circuit, a root module, an\noptional instance hierarchy, and an optional reference. A target can only\nidentify hardware with a name, e.g., a circuit, module, instance, register,\nwire, or node. References may further refer to specific fields or subindices in\naggregates. A target with no instance hierarchy is local. A target with an\ninstance hierarchy is non-local.\n\nTargets use a shorthand syntax of the form:\n\n```\ntarget ::= \u201c~\u201d (circuit) (\u201c|\u201d (module) (\u201c/\u201d (instance) \u201c:\u201d (module) )* (\u201c>\u201d (ref) )?)?\n```\n\nA reference is a name inside a module and one or more qualifying tokens that\nencode subfields (of a bundle) or subindices (of a vector):\n\n```\nreference ::= (name) (\"[\" (index) \"]\" | \".\" (field))*\n```\n\nTargets are specific enough to refer to any specific module in a folded,\nunfolded, or partially folded representation.\n\nTo show some examples of what these look like, consider the following example\ncircuit. This consists of four instances of module `Baz`, two instances of\nmodule `Bar`, and one instance of module `Foo`:\n\n```\ncircuit Foo:\n  module Foo:\n    inst a of Bar\n    inst b of Bar\n  module Bar:\n    inst c of Baz\n    inst d of Baz\n  module Baz:\n    skip\n```\n\n| Folded Module | Unfolded Modules |\n| --- | --- |\n|  |  |\n\nUsing targets (or multiple targets), any specific module, instance, or\ncombination of instances can be expressed. Some examples include:\n\n| Target | Description |\n| --- | --- |\n| `~Foo` | refers to the whole circuit |\n| `~Foo|Foo` | refers to the top module |\n| `~Foo|Bar` | refers to module `Bar` (or both instances of module `Bar`) |\n| `~Foo|Foo/a:Bar` | refers just to one instance of module `Bar` |\n| `~Foo|Foo/b:Bar/c:Baz` | refers to one instance of module `Baz` |\n| `~Foo|Bar/d:Baz` | refers to two instances of module `Baz` |\n\nIf a target does not contain an instance path, it is a *local* target. A local\ntarget points to all instances of a module. If a target contains an instance\npath, it is a *non-local* target. A non-local target *may* not point to all\ninstances of a module. Additionally, a non-local target may have an equivalent\nlocal target representation.\n\nInline Annotations\u00a0[\u00b6](#inline-annotations)\n-------------------------------------------\n\nThe MLIR FIRRTL compiler supports an inline format for annotations as an\nextension to the FIRRTL syntax. These inline annotations are helpful for making\nsingle-file annotated FIRRTL code. This is not supported by the Scala FIRRTL\ncompiler.\n\nInline annotations are attached to the `circuit`, and are JSON wrapped in `%[`\nand `]`.\n\n```\ncircuit Foo: %[[{\"a\":\"a\",\"target\":\"~Foo\"}]]\n  module Foo:\n    skip\n```\n\nAnnotations in CIRCT\u00a0[\u00b6](#annotations-in-circt)\n-----------------------------------------------\n\nWe plan to provide full support for annotations in CIRCT. The FIRRTL dialect\ncurrent supports:\n\n1. All non-local annotations can be parsed and applied to the correct circuit\n   component.\n2. Annotations, with and without references, are copied to the correct ground\n   type in the `LowerTypes` pass.\n\nAnnotations can be parsed using the `--annotation-file` command line argument\nto the `firtool` utility. Alternatively, we provide a non-standard way of\nencoding annotations in the FIRRTL IR textual representation. We provide this\nnon-standard support primarily to make test writing easier. As an example of\nthis, consider the following JSON annotation file:\n\n```\n[\n  {\n    \"target\": \"~Foo|Foo\",\n    \"hello\": \"world\"\n  }\n]\n```\n\nThis can be equivalently, in CIRCT, expressed as:\n\n```\ncircuit Foo: %[[{\"target\":\"~Foo|Foo\",\"hello\":\"world\"}]]\n  module Foo:\n    skip\n```\n\nDuring parsing, annotations are \u201cscattered\u201d into the MLIR representation as\noperation or port attributes. As an example of this, the above parses into the\nfollowing MLIR representation:\n\n```\nfirrtl.circuit \"Foo\" {\n  firrtl.module @Foo() attributes {annotations = [{hello = \"world\"}]} {\n    firrtl.skip\n  }\n}\n```\n\nTargets without references have their targets stripped during scattering since\ntarget information is redundant once annotation metadata is attached to the IR.\nTargets with references have the reference portion of the target included in\nthe attribute. The `LowerTypes` pass then uses this reference information to\nattach annotation metadata to only the *lowered* portion of a targeted circuit\ncomponent.\n\nAnnotations are expected to be fully removed via custom transforms, conversion\nto other MLIR operations, or dropped. A warning will be emitted if there are\nany unused annotations still in the circuit. For example, the `ModuleInliner`\npass removes `firrtl.passes.InlineAnnotation` by inlining annotated modules or\ninstances. JSON Annotations map to the builtin MLIR attributes. An annotation\nis implemented using a DictionaryAttr, which holds the class, target, and any\nannotation specific data.\n\nAnnotations\u00a0[\u00b6](#annotations)\n-----------------------------\n\nAnnotations here are written in their JSON format. A \u201creference target\u201d\nindicates that the annotation could target any object in the hierarchy,\nalthough there may be further restrictions in the annotation.\n\n### [AttributeAnnotation](https://javadoc.io/doc/edu.berkeley.cs/firrtl_2.13/latest/firrtl/AttributeAnnotation.html)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `firrtl.AttributeAnnotation` |\n| target | string | A reference target |\n| description | string | An attribute |\n\nThis annotation attaches SV attributes to a specified target. A reference\ntarget must be a wire, node, reg, or module. This annotation doesn\u2019t prevent\noptimizations so it\u2019s necessary to add dontTouch annotation if users want to\npreserve the target.\n\nExample:\n\n```\n{\n  \"class\": \"firrtl.AttributeAnnotation\",\n  \"target\": \"~Foo|Foo>r\",\n  \"description\": \"debug = \\\"true\\\"\"\n}\n```\n\n### BlackBox\u00a0[\u00b6](#blackbox)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `firrtl.transforms.BlackBox` |\n| target | string | An ExtModule name target |\n\nThis annotation is attached to any external module created from any of the\nother blackbox annotations, such as `BlackBoxInlineAnno`. This is used when\ngenerating metadata about external modules to distinguish generated modules.\nThis annotation is internal to the MLIR FIRRTL compiler.\n\nExample:\n\n```\n{\n  \"class\": \"firrtl.transforms.BlackBox\",\n  \"target\": \"~Foo|Foo\",\n}\n```\n\n### [BlackBoxInlineAnno](https://javadoc.io/doc/edu.berkeley.cs/firrtl_2.13/latest/firrtl/transforms/BlackBoxInlineAnno.html)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `firrtl.transforms.BlackBoxInlineAnno` |\n| target | string | An ExtModule name target |\n| name | string | A full path to a file |\n| text | string | Literal verilog code. |\n\nSpecifies the black box source code (`text`) inline. Generates a file with\nthe given `name` in the target directory.\n\nExample:\n\n```\n{\n  \"class\": \"firrtl.transforms.BlackBoxInlineAnno\",\n  \"target\": \"~Foo|Foo\",\n  \"name\": \"blackbox-inline.v\",\n  \"text\": \"module ExtInline(); endmodule\\n\"\n}\n```\n\n### [BlackBoxPathAnno](https://javadoc.io/doc/edu.berkeley.cs/firrtl_2.13/latest/firrtl/transforms/BlackBoxPathAnno.html)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `firrtl.transforms.BlackBoxPathAnno` |\n| target | string | An ExtModule name target |\n| path | string | ModuleName target |\n\nSpecifies the file `path` as source code for the module. Copies the file\nto the target directory.\n\nExample:\n\n```\n{\n  \"class\": \"firrtl.transforms.BlackBoxPathAnno\",\n  \"target\": \"~Foo|Foo\",\n  \"path\": \"myfile.v\"\n}\n```\n\n### [BlackBoxTargetDirAnno](https://javadoc.io/doc/edu.berkeley.cs/firrtl_2.13/latest/firrtl/transforms/BlackBoxTargetDirAnno.html)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `firrtl.transforms.BlackBoxTargetDirAnno` |\n| targetDir | string | Output directory |\n\nOverrides the target directory into which black box source files are\nemitted.\n\nExample:\n\n```\n{\n  \"class\": \"firrtl.transforms.BlackBoxTargetDirAnno\",\n  \"targetDir\": \"/tmp/circt/output\"\n}\n```\n\n### VerbatimBlackBoxAnno\u00a0[\u00b6](#verbatimblackboxanno)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `circt.VerbatimBlackBoxAnno` |\n| target | string | An ExtModule name target |\n| files | array | Array of file objects |\n\nSpecifies verbatim black box source code with one or more files. Each file\nobject in the `files` array contains:\n\n* `content`: The literal source code content\n* `output_file`: Path to the output file\n\nThis annotation is used internally by CIRCT to represent partially lowered\nFIRRTL extmodules with verbatim content.\n\nExample:\n\n```\n{\n  \"class\": \"circt.VerbatimBlackBoxAnno\",\n  \"target\": \"~Foo|MyBlackBox\",\n  \"files\": [\n    {\n      \"content\": \"module MyBlackBox(\\n  input clk,\\n  output out\\n);\\n  assign out = clk;\\nendmodule\",\n      \"output_file\": \"blackbox.v\"\n    }\n  ]\n}\n```\n\n### Convention\u00a0[\u00b6](#convention)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `circt.ConventionAnnotation` |\n| convention | string | `scalarized` |\n| target | string | Reference target |\n\nSpecify the port convention for a module. The port convention controls how a\nmodule\u2019s ports are transformed, and how that module can be instantiated, in the\noutput format.\n\nThe options are:\n\n* `scalarized`: Convert aggregate ports (i.e. vector or bundles) into multiple\n  ground-typed ports.\n\n```\n{\n  \"class\": \"circt.ConventionAnnotation\",\n  \"convention\": \"scalarized\",\n  \"target\": \"~Foo|Bar/d:Baz\"\n}\n```\n\n### BodyTypeLoweringAnnotation\u00a0[\u00b6](#bodytypeloweringannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `circt.BodyTypeLoweringAnnotation` |\n| convention | string | See `Convention` annotation |\n| target | string | See `Convention` annotation |\n| includeHierarchy | bool | Apply the convention to all modules in the hierarchy |\n\nSpecify the type lowering option for module internal signals.\nThis is similar to the `Convention` annotation, but for internal signals\nrather than module ports. Refer to the `Convention` annotation for each\nproperty description.\n\nWhen `includeHierarchy` is `false`, it indicates the convention is applied only to\nthe specified module. If `includeHierarchy` is `true`, the convention is applied to\nall modules in the hierarchy. If there are multiple annotation instances that specify\nconventions, the `scalarized` convention takes precedence over the `internal` convention.\n\n```\n{\n  \"class\": \"circt.BodyTypeLoweringAnnotation\",\n  \"convention\": \"scalarized\",\n  \"target\": \"~Foo|Bar\",\n  \"includeHierarchy\": true\n}\n```\n\n### ElaborationArtefactsDirectory\u00a0[\u00b6](#elaborationartefactsdirectory)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.ElaborationArtefactsDirectory` |\n| dirname | string | The artifact output directory |\n\nThis annotation is used to indicate the output directory or artifacts generated\nby the ElaborationArtefacts transform.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.firrtl.ElaborationArtefactsDirectory\",\n  \"dirname\": \"output/artefacts\"\n}\n```\n\n### AddSeqMemPortAnnotation\u00a0[\u00b6](#addseqmemportannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.AddSeqMemPortAnnotation` |\n| name | string | The name of the port to insert |\n| input | bool | If true this is an input port, otherwise it is an output port |\n| width | integer | The width of the port |\n\nThis annotation causes an extra port to be added to all SRAMs modules in the\nDUT. The extra port is a regular module port of unsigned integer type with the\nspecified width. These extra ports are commonly used to implement SRAM features\nnot represented by the FIRRTL memory op, such as MBIST. The added port will be\nwired to the DUT, where it will be tied to 0.\n\nExample:\n\n```\n{\n  \"class\":\"sifive.enterprise.firrtl.AddSeqMemPortAnnotation\",\n  \"name\":\"user_outputs\",\n  \"input\":false,\n  \"width\":1\n}\n```\n\n### AddSeqMemPortsFileAnnotation\u00a0[\u00b6](#addseqmemportsfileannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.AddSeqMemPortsFileAnnotation` |\n| filename | string | The filename to output to |\n\nThis annotation is used to emit metadata about the extra ports created by\n`AddSeqMemPortAnnotation`. This file is emitted relative to the\n`MetadataDirAnnotation`. The file lists each SRAM and provides the mapping to\nwhere it is in the hierarchy, and gives its IO prefix at the DUT top level.\n\n```\n0 -> Dut.submodule.sram0.sram0_ext\n1 -> Dut.submodule.sram1.sram1_ext\n```\n\nExample:\n\n```\n{\n  \"class\":\"sifive.enterprise.firrtl.AddSeqMemPortsFileAnnotation\",\n  \"filename\":\"SRAMPorts.txt\"\n}\n```\n\n### [DocStringAnnotation](https://javadoc.io/doc/edu.berkeley.cs/firrtl_2.13/latest/firrtl/DocStringAnnotation.html)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `firrtl.DocStringAnnotation` |\n| target | string | A reference target |\n| description | string | An attribute |\n\nThis annotation attaches a comment to a specified target. A reference\ntarget must be a wire, node, reg, or module. This annotation doesn\u2019t prevent\noptimizations so it\u2019s necessary to add dontTouch annotation if users want to\npreserve the target.\n\nExample:\n\n```\n{\n  \"class\": \"firrtl.DocStringAnnotation\",\n  \"target\": \"~Foo|Foo>r\",\n  \"description\": \"comment\"\n}\n```\n\n### [DontTouchAnnotation](https://javadoc.io/doc/edu.berkeley.cs/firrtl_2.13/latest/firrtl/transforms/DontTouchAnnotation.html)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `firrtl.transforms.DontTouchAnnotation` |\n| target | string | Reference target |\n\nThe `DontTouchAnnotation` prevents the removal of elements through\noptimization. This annotation is an optimization barrier, for\nexample, it blocks constant propagation through it.\nThis annotation also ensures that the name of the object is\npreserved, and not discarded or modified.\n\nExample:\n\n```\n{\n  \"class\": \"firrtl.transforms.DontTouchAnnotation\",\n  \"target\": \"~Foo|Bar/d:Baz\"\n}\n```\n\n### [FlattenAnnotation](https://javadoc.io/doc/edu.berkeley.cs/firrtl_2.13/latest/firrtl/transforms/FlattenAnnotation.html)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `firrtl.transforms.FlattenAnnotation` |\n| target | string | Reference target |\n\nIndicates that the target should be flattened, which means that child instances\nwill be recursively inlined.\n\nExample:\n\n```\n{\n  \"class\": \"firrtl.transforms.FlattenAnnotation\",\n  \"target\": \"~Foo|Bar/d:Baz\"\n}\n```\n\n### FullResetAnnotation\u00a0[\u00b6](#fullresetannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `circt.FullAsyncResetAnnotation` |\n| target | string | Reference target |\n| resetType | string | \u201casync\u201d or \u201csync\u201d |\n\nThe target must be a signal that is a reset. The type of the signal must be (or inferred\nto be) the same as the reset type specified in the annotation.\n\nIndicates that all reset-less registers which are children of the module containing\nthe target will have the reset targeted attached, with a reset value of 0.\n\nThe module containing the target of this annotation is not allowed to reside in multiple\nhierarchies.\n\nExample:\n\n```\n{\n  \"class\": \"circt.FullResetAnnotation\",\n  \"target\": \"~Foo|Bar/d:Baz>reset\",\n  \"resetType\": \"async\"\n}\n```\n\n### ExcludeFromFullResetAnnotation\u00a0[\u00b6](#excludefromfullresetannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `circt.ExcludeFromFullResetAnnotation` |\n| target | string | Reference target |\n\nThis annotation indicates that the target moudle should be excluded from the\nFullResetAnnotation of a parent module.\n\nExample:\n\n```\n{\n  \"class\": \"circt.IgnoreFullAsyncResetAnnotation\",\n  \"target\": \"~Foo|Bar/d:Baz\"\n}\n```\n\n### FullAsyncResetAnnotation\u00a0[\u00b6](#fullasyncresetannotation)\n\n**Deprecated, use FullResetAnnotation**\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.FullAsyncResetAnnotation` |\n| target | string | Reference target |\n\nThe target must be a signal that is or is inferred to be an asynchronous reset.\n\nIndicates that all reset-less registers which are children of the module containing\nthe target will have the asynchronous reset targeted attached, with a reset value of 0.\n\nThe module containing the target of this annotation is not allowed to reside in multiple\nhierarchies.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.firrtl.FullAsyncResetAnnotation\",\n  \"target\": \"~Foo|Bar/d:Baz>reset\"\n}\n```\n\n### IgnoreFullAsyncResetAnnotation\u00a0[\u00b6](#ignorefullasyncresetannotation)\n\n**Deprecated, use ExcludeFromFullResetAnnotation**\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.IgnoreFullAsyncResetAnnotation` |\n| target | string | Reference target |\n\nThis annotation indicates that the target should be excluded from the\nFullAsyncResetAnnotation of a parent module.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.firrtl.IgnoreFullAsyncResetAnnotation\",\n  \"target\": \"~Foo|Bar/d:Baz\"\n}\n```\n\n### InjectDUTHierarchyAnnotation\u00a0[\u00b6](#injectduthierarchyannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.InjectDUTHierarchyAnnotation` |\n| name | string | The name of the module containing original DUT logic |\n| moveDut | boolean | Optional: if true, then treat the newly created module as the DUT. If unset, then treat as false. |\n\nThis annotation can be used to add an extra level of hierarchy in the design\nunder the DUT (indicated with a `MarkDUTAnnotation`). All logic in the original\nDUT will be moved into a module with the specified `name`. This is typically\nused in combination with `ExtractBlackBoxAnnotation` (or with passes that add\nthese annotations to extract components like clock gates or memories) to not\nintermix the original DUT contents with extracted module instantiations.\n\nIf the `moveDut` field is true, then the newly created module with the specified\n`name` will be treated as the design-under-test. The `MarkDUTAnnotation` will\nbe moved to this module. If this field is false, then the design-under-test\nwill not be changed.\n\nThis annotation should only appear zero or once.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.firrtl.InjectDUTHierarchyAnnotation\",\n  \"name\": \"Logic\",\n  \"moveDut\": false\n}\n```\n\n### [InlineAnnotation](https://javadoc.io/doc/edu.berkeley.cs/firrtl_2.13/latest/firrtl/passes/InlineAnnotation.html)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `firrtl.passes.InlineAnnotation` |\n| target | string | Reference target |\n\nIndicates that the target should be inlined.\n\nExample:\n\n```\n{\n  \"class\": \"firrtl.passes.InlineAnnotation\",\n  \"target\": \"~Foo|Bar/d:Baz\"\n}\n```\n\n### MarkDUTAnnotation\u00a0[\u00b6](#markdutannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.MarkDUTAnnotation` |\n| target | string | Reference target |\n\nThis annotation is used to mark the top module of the device under test. This\ncan be used to distinguish modules in the test harness from modules in the DUT.\n\nExample:\n\n```\n{\n  \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\n  \"target\":\"Core.Core\"\n}\n```\n\n### MetadataDirAnnotation\u00a0[\u00b6](#metadatadirannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.MetadataDirAnnotation` |\n| dirname | string | The directory to place generated metadata in |\n\nThis annotation is used to define the directory where metadata should be\nemitted. When this annotation is not present, metadata will be emitted to the\n\u201cmetadata\u201d directory by default.\n\nExample:\n\n```\n{\n  \"class\":\"sifive.enterprise.firrtl.MetadataDirAnnotation\",\n  \"dirname\":\"build/metadata\"\n}\n```\n\n### ModuleHierarchyAnnotation\u00a0[\u00b6](#modulehierarchyannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.ModuleHierarchyAnnotation` |\n| filename | string | The full output file path. |\n\nThis annotation indicates that a module hierarchy JSON file should be emitted\nfor the module hierarchy rooted at the design under test (DUT), as indicated by\nthe `MarkDUTAnnotation`. See the SV attribute, `firrtl.moduleHierarchyFile`, for\ninformation about the JSON file format.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.firrtl.ModuleHierarchyAnnotation\",\n  \"filename\": \"./dir/hier.json\"\n}\n```\n\n### MustDeduplicateAnnotation\u00a0[\u00b6](#mustdeduplicateannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `firrtl.transforms.MustDeduplicateAnnotation` |\n| modules | array | A list of module targets which must deduplicate. |\n\nThis annotation causes the deduplication pass to check that the listed modules\nare deduplicated with each other.\n\nExample:\n\n```\n{\n  \"class\":\"firrtl.transforms.MustDeduplicateAnnotation\",\n  \"modules\":[\n    \"~Top|A\"\n    \"~Top|B\"\n  ]\n}\n```\n\n### DedupGroupAnnotation\u00a0[\u00b6](#dedupgroupannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `firrtl.transforms.DedupGroupAnnotation` |\n| target | string | Module target |\n| group | string | The dedup group that the module belongs to |\n\nThis annotation assigns the targeted module to a dedup group. Modules that\nbelong to a dedup group may only be deduplicated with modules that are part of\nthe same group.\n\nExample:\n\n```\n{\n  \"class\":\"firrtl.transforms.DedupGroupAnnotation\",\n  \"target\": \"~Top|A\",\n  \"group\": \"foo\"\n}\n```\n\n### RetimeModuleAnnotation\u00a0[\u00b6](#retimemoduleannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `freechips.rocketchip.util.RetimeModuleAnnotation` |\n\nThis annotation is used to mark modules which should be retimed, and is\ngenerally just passed through to other tools.\n\nExample:\n\n```\n{\n    \"class\": \"freechips.rocketchip.util.RetimeModuleAnnotation\"\n}\n```\n\n### RetimeModulesAnnotation\u00a0[\u00b6](#retimemodulesannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.RetimeModulesAnnotation` |\n| filename | string | The filename with full path where it will be written |\n\nThis annotation triggers the creation of a file containing a JSON array\ncontaining the names of all modules annotated with the\n`RetimeModuleAnnotation`.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.firrtl.RetimeModulesAnnotation\",\n  \"filename\": \"retime_modules.json\"\n}\n```\n\n### SitestBlackBoxAnnotation\u00a0[\u00b6](#sitestblackboxannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.SitestBlackBoxAnnotation` |\n| filename | string | The file to write to |\n\nThis annotation triggers the creation of a file containing a JSON array of the\n`defname`s of all external modules in the device under test which are not imported\nor inlined blackbox modules. This will only collect modules which are\ninstantiated under a module annotated with `MarkDUTAnnotation`.\n\nIf any external modules (including imported and inlined blackboxes) have a\n`SitestBlackBoxLibrariesAnnotation`, the libraries specified in that annotation\nwill be included in the output.\n\nExample:\n\n```\n{\n  \"class\":\"sifive.enterprise.firrtl.SitestBlackBoxAnnotation\",\n  \"filename\":\"./blackboxes.json\"\n}\n```\n\n### SitestTestHarnessBlackBoxAnnotation\u00a0[\u00b6](#sitesttestharnessblackboxannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.SitestTestHarnessBlackBoxAnnotation` |\n| filename | string | The file to write to |\n\nThis annotation triggers the creation of a file containing a JSON array of the\n`defname`s of all external modules in the test harness which are not imported or\ninlined blackbox modules. This will only collect modules which are not\ninstantiated under a module annotated with `MarkDUTAnnotation`.\n\nIf any external modules (including imported and inlined blackboxes) have a\n`SitestBlackBoxLibrariesAnnotation`, the libraries specified in that annotation\nwill also be included in the output.\n\nExample:\n\n```\n{\n  \"class\":\"sifive.enterprise.firrtl.SitestTestHarnessBlackBoxAnnotation\",\n  \"filename\":\"./testharness_blackboxes.json\"\n}\n```\n\n### SitestBlackBoxLibrariesAnnotation\u00a0[\u00b6](#sitestblackboxlibrariesannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.SitestBlackBoxLibrariesAnnotation` |\n| libraries | array | Array of library names to include in blackbox metadata |\n\nThis annotation is used to specify additional library names that should be\nincluded in the blackbox metadata for an external module. When applied to an\nexternal module, the specified libraries will be added to the blackbox resource\nlist in the generated metadata. Both the `defname` and any libraries specified by\nthis annotation will be included in the metadata for non-imported and non-inlined\nblackboxes.\n\nExample:\n\n```\n{\n  \"class\":\"sifive.enterprise.firrtl.SitestBlackBoxLibrariesAnnotation\",\n  \"libraries\":[\"libmath\", \"libcrypto\", \"custom_lib\"]\n}\n```\n\n### TestBenchDirAnnotation\u00a0[\u00b6](#testbenchdirannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.TestBenchDirAnnotation` |\n| dirname | string | The output directory |\n\nThis annotation is used to indicate where to emit the test bench modules\ngenerated by GrandCentral.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.firrtl.TestBenchDirAnnotation\",\n  \"dirname\": \"output/testbench\"\n}\n```\n\n### TestHarnessHierarchyAnnotation\u00a0[\u00b6](#testharnesshierarchyannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.TestHarnessHierarchyAnnotation` |\n| filename | string | The full output file path. |\n\nThis annotation indicates that a module hierarchy JSON file should be emitted\nfor the module hierarchy rooted at the circuit root module, which is assumed to\nbe the test harness. See the SV attribute, `firrtl.moduleHierarchyFile`, for\ninformation about the JSON file format.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.firrtl.TestHarnessHierarchyAnnotation\",\n  \"filename\": \"./dir/hier.json\"\n}\n```\n\n### Instance Extraction\u00a0[\u00b6](#instance-extraction)\n\n#### ExtractBlackBoxAnnotation\u00a0[\u00b6](#extractblackboxannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.ExtractBlackBoxAnnotation` |\n| target | string | Reference target to the instance to be extracted |\n| filename | string | Output file to be filled with the applied hierarchy changes |\n| prefix | string | Prefix for the extracted instance |\n| dest | string | Name of an optional wrapper module under which to group extracted instances |\n\nThis annotation causes the `ExtractInstances` pass to move the annotated\ninstance, or all instances if the annotation is on a module, upwards in the\nhierarchy. If the `dest` field is present and non-empty, the instances are\nplaced in a module underneath the DUT (marked by `MarkDUTAnnotation`) with the\nname provided in that field. If the `dest` field is empty, the instances are\nextracted out of the DUT, such that the DUT gains additional ports that\ncorrespond to the extracted instance ports. This allows the DUT to be\ninstantiated and custom implementations for the extracted instances to be\nprovided at the instantiation site. Instances are never extracted out of the\nroot module of the design.\n\nApplies to modules and instances.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.firrtl.ExtractBlackBoxAnnotation\",\n  \"target\": \"~TestHarness|MyBlackBox\",\n  \"filename\": \"BlackBoxes.txt\",\n  \"prefix\": \"bb\",\n  \"dest\": \"BlackBoxes\" // optional\n}\n```\n\n#### ExtractClockGatesFileAnnotation\u00a0[\u00b6](#extractclockgatesfileannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.ExtractClockGatesFileAnnotation` |\n| filename | string | Output file to be filled with the applied hierarchy changes |\n| group | string | Name of an optional wrapper module under which to group extracted instances |\n\nThis annotation causes the `ExtractInstances` pass to move instances of\nextmodules whose defnames end in `EICG_wrapper` upwards in the hierarchy, either\nout of the DUT if `group` is omitted or empty, or into a submodule of the DUT\nwith the name given in `group`. The wiring prefix is hard-coded to `clock_gate`.\n\nApplies to the circuit.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.firrtl.ExtractClockGatesFileAnnotation\",\n  \"filename\": \"ClockGates.txt\",\n  \"group\": \"ClockGates\" // optional\n}\n```\n\n#### ExtractSeqMemsFileAnnotation\u00a0[\u00b6](#extractseqmemsfileannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.ExtractSeqMemsFileAnnotation` |\n| filename | string | Output file to be filled with the applied hierarchy changes |\n| group | string | Name of an optional wrapper module under which to group extracted instances |\n\nThis annotation causes the `ExtractInstances` pass to move memory instances\nupwards in the hierarchy, either out of the DUT if `group` is omitted or empty,\nor into a submodule of the DUT with the name given in `group`. The wiring\nprefix is hard-coded to `mem_wiring`.\n\nApplies to the circuit.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.firrtl.ExtractSeqMemsFileAnnotation\",\n  \"filename\": \"SeqMems.txt\",\n  \"group\": \"SeqMems\" // optional\n}\n```\n\nFIRRTL specific attributes applied to HW Modules\u00a0[\u00b6](#firrtl-specific-attributes-applied-to-hw-modules)\n-------------------------------------------------------------------------------------------------------\n\n### Design Under Test\u00a0[\u00b6](#design-under-test)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.firrtl.MarkDUTAnnotation` |\n| target | string | Reference target |\n\nMarks what is the DUT (and not the testbench). This annotation is lowered to the\nattribute `firrtl.DesignUnderTest` to indicate the module which is the DUT.\n\nGrand Central\u00a0[\u00b6](#grand-central)\n---------------------------------\n\nGrand Central provides annotations for creating cross module references and\nSystemVerilog interfaces.\n\n### Views\u00a0[\u00b6](#views)\n\nGrand Central views are used from Chisel to allow users to encapsulate monitor\nlogic that gets emitted separately from the DUT. The generated interfaces\nprovide a stable view of modules which are connected to the target module\nthrough SystemVerilog bind statements.\n\n#### TargetToken$Field\u00a0[\u00b6](#targettokenfield)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `firrtl.annotations.TargetToken$Field` |\n| value | string or integer | Index or element name |\n\nThis is used to represent an index in to an aggregate type, such as an index or\narray.\n\n#### ReferenceTarget\u00a0[\u00b6](#referencetarget)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| circuit | string | Name of the encapsulating circuit |\n| module | string | Name of the root module of this reference |\n| path | array | Path through instance and Modules |\n| ref | string | Name of the component |\n| component | array | List of TargetToken$Field subcomponent of this reference |\n\nA reference target is a JSON serialization of a regular reference target\nstring.\n\n#### AugmentedGroundType\u00a0[\u00b6](#augmentedgroundtype)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.grandcentral.AugmentedGroundType` |\n| ref | object | ReferenceTarget of the target component |\n\nCreates a SystemVerilog logic type.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\n  \"ref\": {\n    \"circuit\": \"GCTInterface\",\n    \"module\": \"GCTInterface\",\n    \"path\": [],\n    \"ref\": \"a\",\n    \"component\": [\n      {\n        \"class\": \"firrtl.annotations.TargetToken$Field\",\n        \"value\": \"_2\"\n      },\n      {\n        \"class\": \"firrtl.annotations.TargetToken$Index\",\n        \"value\": 0\n      }\n    ]\n  }\n}\n```\n\n#### AugmentedVectorType\u00a0[\u00b6](#augmentedvectortype)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.grandcentral.AugmentedVectorType` |\n| elements | array | List of augmented types. |\n\nCreates a SystemVerilog unpacked array.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.grandcentral.AugmentedVectorType\",\n  \"elements\": [\n    {\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\n      \"ref\": {\n        \"circuit\": \"GCTInterface\",\n        \"module\": \"GCTInterface\",\n        \"path\": [],\n        \"ref\": \"a\",\n        \"component\": []\n      },\n      \"tpe\": {\n        \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\n      }\n    },\n    {\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\n      \"ref\": {\n        \"circuit\": \"GCTInterface\",\n        \"module\": \"GCTInterface\",\n        \"path\": [],\n        \"ref\": \"b\",\n        \"component\": []\n      },\n      \"tpe\": {\n        \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\n      }\n    }\n  ]\n}\n```\n\n#### AugmentedField\u00a0[\u00b6](#augmentedfield)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| name | string | Name of the field |\n| description | string | A textual description of this type |\n| tpe | string | A nested augmented type |\n\nA field in an augmented bundle type. This can provide a small description of\nwhat the field in the bundle is.\n\n#### AugmentedBundleType\u00a0[\u00b6](#augmentedbundletype)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | sifive.enterprise.grandcentral.AugmentedBundleType |\n| defName | string | The name of the SystemVerilog interface |\n| elements | array | List of AugmentedFields |\n\nCreates a SystemVerilog interface for each bundle type.\n\n#### ViewAnnotation, GrandCentralView$SerializedViewAnnotation\u00a0[\u00b6](#viewannotation-grandcentralviewserializedviewannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation |\n| name | string | Name of the view, no affect on output |\n| companion | string | Module target of an empty module to insert cross module references in to |\n| parent | string | Module target of the module the interface will be referencing |\n| view | object | AugmentedBundleType representing the interface |\n\nThese annotations (which are equivalent) are used to represent a SystemVerilog\ninterface, a location in which it should be instantiated, and XMRs to drive the\ninterface. Any XMR sources receive `DontTouchAnnotation` to prevent these from\nbeing inadvertently deleted. Note: this currently differs from the SFC\nimplementation where constant propagation is not supposed to be blocked by an\nXMR. Instead the source should be promoted to a literal value and driven on the\ninterface.\n\nEither `ViewAnnotation` or `GrandCentralView$SerializedViewAnnotation` are the\nsame in CIRCT. The latter, has its \u201cview\u201d value serialized (again) to JSON and\nstring-escaped. When CIRCT sees any JSON string it tries to recursively\ndeserialize it. If this fails, this is deemed to be a string. If this\nsucceeds, then the JSON is unpacked.\n\nThe reason for this double serialization is due to a quirk of the JSON library\nthat the SFC uses. This JSON library uses a type class pattern for users to\ntell it how to deserialize custom types. Because the `ViewAnnotation`lives in a\nSiFive library, there is no mechanism to provide a type class implementation to\nthe function that does annotation deserialization inside the SFC. Doubly\nserializing enables the deserialization to be delayed until SFC Grand Central\npasses run and a type class implementation is available.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\n  \"name\": \"view\",\n  \"companion\": \"~GCTInterface|view_companion\",\n  \"parent\": \"~GCTInterface|GCTInterface\",\n  \"view\": {\n    \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\n    \"defName\": \"ViewName\",\n    \"elements\": [\n      {\n        \"name\": \"port\",\n        \"description\": \"the port 'a' in GCTInterface\",\n        \"tpe\": {\n          \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\n          \"ref\": {\n            \"module\": \"GCTInterface\",\n            \"path\": [],\n            \"ref\": \"a\",\n            \"component\": []\n          },\n          \"tpe\": {\n            \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n#### ExtractGrandCentralAnnotation\u00a0[\u00b6](#extractgrandcentralannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation |\n| directory | string | Directory where Grand Central outputs go, except a bindfile |\n| filename | string | Optional filename with full path where the bindfile will be written |\n\nThis annotation controls where to \u201cextract\u201d Grand Central collateral from the\ncircuit. This annotation is mandatory and can only appear once if the full\nGrand Central transform pipeline is run in the SFC. (An error is generated by\nthe `ExtractGrandCentralCode` transform.)\n\nThe directory member has no effect on the filename member, i.e., the directory\nwill not be prepended to the filename.\n\nThe filename is optional. When specified, all binds will be emitted to that\nfile. When omitted, each module will have an associated bindfile in `directory`\nnamed `<module>-bind.sv`.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\n  \"directory\": \"gct-dir\",\n  \"filename\": \"gct-dir/bindings.sv\"\n}\n```\n\n#### GrandCentralHierarchyFileAnnotation\u00a0[\u00b6](#grandcentralhierarchyfileannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation |\n| filename | string | A filename where a YAML representation of the interface should be placed |\n\nThis annotation, if present, will emit a\n[YAML](https://en.wikipedia.org/wiki/YAML) representation of all interfaces that\nwere generated by the Grand Central views pass. Equivalently, this is a\ndifferent serialization of the information contained in all `ViewAnnotation`s.\n\nAn example of this annotation is as follows:\n\n```\n{\n  \"class\" : \"sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation\",\n  \"filename\" : \"directory/file.yaml\"\n}\n```\n\nThe format of the produced YAML file is a one-to-one mapping of the\nSystemVerilog interface to YAML. Consider the following SystemVerilog interface\nproduced by GrandCentral:\n\n```\ninterface Foo;\n  // A 4-bit type\n  logic [3:0] a;\n  // A 2D vector of an 8-bit type\n  logic [7:0] b [1:0][0:0];\n  // A 1D vector of instances of Bar\n  Bar bar[4]();\nendinterface\n\ninterface Bar;\n  logic c;\nendinterface\n\ninterface Baz;\n  logic d;\nendinterface\n```\n\nThis will produce the following YAML representation:\n\n```\n- name: Foo\n  fields:\n    - name: a\n      description: A 4-bit type\n      dimensions: [  ]\n      width: 4\n    - name: b\n      description: A 2D vector of an 8-bit type\n      dimensions: [ 1, 2 ]\n      width: 8\n  instances:\n    - name: bar\n      description: A 1D vector of instances of Bar\n      dimensions: [ 4 ]\n      interface:\n        name: Bar\n        fields:\n          - name: c\n            dimensions: [ ]\n            width: 1\n        instances: []\n- name: Baz:\n  fields:\n    - name: d\n      dimensions: [ ]\n      width: 1\n  instances: []\n```\n\n### Memory Taps\u00a0[\u00b6](#memory-taps)\n\nMemory taps are a special version of data taps which are used for targeting the\nFIRRTL memory vectors.\n\n#### MemTapAnnotation\u00a0[\u00b6](#memtapannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | sifive.enterprise.grandcentral.MemTapAnnotation |\n| taps | array of strings | An array of components corresponding to the elements of the tap vector |\n| source | string | Reference target to a FIRRTL memory element |\n\n`MemoryTapAnnotation` is used to create a data tap to a FIRRTL memory. The\ncontents of the MemTap module are the cross-module references to each row of\nthe tapped memory. Attaching this annotation to memories with aggregate data\ntypes is not supported.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.grandcentral.MemTapAnnotation\",\n  \"taps\":[\n    \"GCTMemTap.MemTap.mem[0]\",\n    \"GCTMemTap.MemTap.mem[1]\"\n  ],\n  \"source\":\"~GCTMemTap|GCTMemTap>mem\"\n}\n```\n\n### OutputDirAnnotation\u00a0[\u00b6](#outputdirannotation)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `circt.OutputDirAnnotation` |\n| dirname | string | The output directory |\n| target | string | Reference target |\n\nSpecify the output directory for a module. The target must be a public module,\nand must be local.\n\nExample:\n\n```\n{\n  \"class\": \"circt.OutputDirAnnotation\",\n  \"dirname\": \"verification\",\n  \"target\": \"~Foo|Bar\"\n}\n```\n\nAttributes in SV\u00a0[\u00b6](#attributes-in-sv)\n---------------------------------------\n\nSome annotations transform into attributes consumed by non-FIRRTL passes. This\nsection describes well-defined attributes used by HW/SV passes.\n\n### firrtl.moduleHierarchyFile\u00a0[\u00b6](#firrtlmodulehierarchyfile)\n\nUsed by HWExportModuleHierarchy. Signifies a root from which to dump the module\nhierarchy as a json file. This attribute is a list of files to output to, and\nhas type `ArrayAttr<OutputFileAttr>`.\n\nThe exported JSON file encodes a recursive tree of module instances as JSON\nobjects, with each object containing the following members:\n\n* `instance_name` - A string describing the name of the instance. Note that the\n  root module will have its `instance_name` set to the module\u2019s name.\n* `module_name` - A string describing the name of the module.\n* `instances` - An array of objects, where each object is a direct instance\n  within the current module.\n\n### firrtl.extract.assert\u00a0[\u00b6](#firrtlextractassert)\n\nUsed by SVExtractTestCode. Specifies the output directory for extracted\nmodules. This attribute has type `OutputFileAttr`.\n\n### firrtl.extract.assume\u00a0[\u00b6](#firrtlextractassume)\n\nUsed by SVExtractTestCode. Specifies the output directory for extracted\nmodules. This attribute has type `OutputFileAttr`.\n\n### firrtl.extract.cover\u00a0[\u00b6](#firrtlextractcover)\n\nUsed by SVExtractTestCode. Specifies the output directory for extracted\nmodules. This attribute has type `OutputFileAttr`.\n\n### firrtl.extract.assert.bindfile\u00a0[\u00b6](#firrtlextractassertbindfile)\n\nUsed by SVExtractTestCode. Specifies the output file for extracted\nmodules\u2019 bind file. This attribute has type `OutputFileAttr`.\n\n### firrtl.extract.assume.bindfile\u00a0[\u00b6](#firrtlextractassumebindfile)\n\nUsed by SVExtractTestCode. Specifies the output file for extracted\nmodules\u2019 bind file. This attribute has type `OutputFileAttr`.\n\n### firrtl.extract.cover.bindfile\u00a0[\u00b6](#firrtlextractcoverbindfile)\n\nUsed by SVExtractTestCode. Specifies the output file for extracted\nmodules\u2019 bind file. This attribute has type `OutputFileAttr`.\n\n### firrtl.extract.[cover|assume|assert].extra\u00a0[\u00b6](#firrtlextractcoverassumeassertextra)\n\nUsed by SVExtractTestCode. Indicates a module whose instances should be\nextracted from the circuit in the indicated extraction type.\n\n [Prev - 'firrtl' Dialect](https://circt.llvm.org/docs/Dialects/FIRRTL/ \"'firrtl' Dialect\")\n[Next - FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/ \"FIRRTL Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect-](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/index.md"
  },
  {
    "role": "user",
    "content": "FIRRTL Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nFIRRTL Dialect Rationale\n========================\n\nThis document describes various design points of the FIRRTL dialect, why it is\nthe way it is, and current status and progress. This follows in the spirit of\nother\n[MLIR Rationale docs](https://mlir.llvm.org/docs/Rationale/).\n\n* [Introduction](#introduction)\n* [Specification](#specification)\n  + [Status](#status)\n  + [ABI](#abi)\n  + [Adding Features](#adding-features)\n  + [Handling Specification Releases](#handling-specification-releases)\n* [Naming](#naming)\n  + [Mandatory Renaming](#mandatory-renaming)\n  + [Temporaries](#temporaries)\n  + [Name Preservation Modes](#name-preservation-modes)\n* [Symbols and Inner Symbols](#symbols-and-inner-symbols)\n  + [Hierarchical Path](#hierarchical-path)\n* [Type system](#type-system)\n  + [Not using standard types](#not-using-standard-types)\n  + [Not Canonicalizing Flip Types](#not-canonicalizing-flip-types)\n  + [Flow](#flow)\n  + [Non-FIRRTL Types](#non-firrtl-types)\n  + [Const Types](#const-types)\n* [Operations](#operations)\n  + [Multiple result `firrtl.instance` operation](#multiple-result-firrtlinstance-operation)\n  + [Module bodies require def-before-use dominance instead of allowing graphs](#module-bodies-require-def-before-use-dominance-instead-of-allowing-graphs)\n  + [`input` and `output` Module Ports](#input-and-output-module-ports)\n  + [`firrtl.bitcast`](#firrtlbitcast)\n  + [`firrtl.mem`](#firrtlmem)\n  + [CHIRRTL Memories](#chirrtl-memories)\n  + [More things are represented as primitives](#more-things-are-represented-as-primitives)\n  + [`invalid` Invalidate Operation is an expression](#invalid-invalidate-operation-is-an-expression)\n  + [Inline SystemVerilog through `verbatim.expr` operation](#inline-systemverilog-through-verbatimexpr-operation)\n* [Interpretation of Undefined Behavior](#interpretation-of-undefined-behavior)\n  + [Invalid](#invalid)\n* [Intrinsics](#intrinsics)\n* [Split of Design and Verification](#split-of-design-and-verification)\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\n[The FIRRTL project](https://github.com/chipsalliance/firrtl) is an existing\nopen source compiler infrastructure used by the Chisel framework to lower \u201c.fir\u201d\nfiles to Verilog. It provides a number of useful compiler passes and\ninfrastructure that allows the development of domain specific passes. The\nFIRRTL project includes a\n[well documented IR\nspecification](https://github.com/chipsalliance/firrtl/blob/master/spec/spec.pdf)\nthat explains the semantics of its IR, an\n[ANTLR\ngrammar](https://github.com/chipsalliance/firrtl/blob/master/src/main/antlr4/FIRRTL.g4)\nincludes some extensions beyond it, and a compiler implemented in Scala which we\nrefer to as the *Scala FIRRTL Compiler* (SFC).\n\n*The FIRRTL dialect in CIRCT is designed to provide a drop-in replacement for\nthe SFC for the subset of FIRRTL IR that is produced by Chisel and in common\nuse.* The FIRRTL dialect also provides robust support for SFC *Annotations*.\n\nTo achieve these goals, the FIRRTL dialect follows the FIRRTL IR specification\nand the SFC implementation almost exactly. Where the FIRRTL specification\nallows for undefined behavior, FIRRTL dialect and its passes will choose the SFC\ninterpretation of specific undefined behavior. The small deviations we do make\nare discussed below. Early versions of the FIRRTL dialect made *heavy\ndeviations* from FIRRTL IR and the SFC (see the Type Canonicalization section\nbelow). These deviations, while elegant, led to difficult to resolve mismatches\nwith the SFC and the inability to verify FIRRTL IR. The remaining small\ndeviations introduced in the FIRRTL dialect are done to simplify the CIRCT\nimplementation of a FIRRTL compiler and to take advantage of MLIR\u2019s various\nfeatures.\n\nThis document generally assumes that you\u2019ve read and have a basic grasp of the\nFIRRTL IR spec, and it can be occasionally helpful to refer to the ANTLR\ngrammar.\n\nSpecification\u00a0[\u00b6](#specification)\n---------------------------------\n\n### Status\u00a0[\u00b6](#status)\n\nThe FIRRTL dialect and FIR parser is a generally complete implementation of the\nFIRRTL specification and is actively maintained, tracking new enhancements. The\nFIRRTL dialect supports some undocumented features and the \u201cCHIRRTL\u201d flavor of\nFIRRTL IR that is produced from Chisel. The FIRRTL dialect has support for\nparsing an SFC Annotation file and converting this to operation or argument\nattributes.\n\n### ABI\u00a0[\u00b6](#abi)\n\nAn auxillary spec has been written, shipped with the FIRRTL spec, which is the\nFIRRTL ABI spec. This spec was co-developed with the CIRCT implementation and\nthe CIRCT implementation conforms to that spec. That spec covers the effects\nof several annotations, naming, verilog structure, and other issues.\n\n### Adding Features\u00a0[\u00b6](#adding-features)\n\nThe FIRRTL parser uses the specification version declared in the FIR file to\nenable or disable certain features. To avoid having to develop the specification\nand parser in lock-step, the parser uses the `nextFIRVersion` and\n`missingSpecFIRVersion` constants to gate new language features. The `next*`\nmarker is used for features that are in the spec\u2019s main branch, but haven\u2019t been\nreleased yet. The `missingSpec*` marker is used for features that have not\nlanded in the spec yet. When a new spec version is released, the `next*` marker\nin the FIRRTL parser is replaced with a concrete `{x,y,z}` version tag.\n\nTo add new features to the FIRRTL parser and specification, use this procedure:\n\n1. Implement the feature in the FIRRTL parser and feature gate it behind the\n   `missingSpecFIRVersion` constant.\n2. Iterate on the feature and experiment and debug it.\n3. Create a PR in the FIRRTL specficiation repository describing the stable\n   version of the new feature.\n4. Once the spec PR lands, change the parser to use the `nextFIRVersion`\n   constant for your feature instead, which will include it in the next\n   release.\n\n### Handling Specification Releases\u00a0[\u00b6](#handling-specification-releases)\n\nWhen a new version of the FIRRTL spec is released, all features using the\n`nextFIRVersion` constant in the parser are part of that release. Search and\nreplace that constant with a concrete `{x,y,z}` version tag. Bump the\n`nextFIRVersion` constant to the next assumed release.\n\nNaming\u00a0[\u00b6](#naming)\n-------------------\n\nWhile this section is a useful discussion, it has been replaced by formally\ndefining the FIRRTL ABI, which we confirm too.\n\nNames in Verilog form part of the public API of a design and are used for many\npurposes and flows. Many things in verilog may have names, and those names\nspecify points of interaction with the design. For example, a wire has a name,\nand one can monitor the value on the wire from a testbench by knowing this name.\nInstances have names and form the core of hierarchical references through\ndesigns. Even always blocks and loops can have names, which are required and\nused.\n\nIt is therefore critical that Chisel, and by extension FIRRTL, have\nlanguage-level semantics about how entities are named and how named entities are\nused and transformed. This must specify which entities with names in Chisel\ngenerate predictable output. Since names serve multiple purposes in a design,\nfor example, debugging, test-bench attachment, hooks for physical layout, etc,\nwe must balance multiple needs. This section describes the base semantics,\nwhich are conservative and aimed at enabling debugging. The CIRCT\nimplementation of a FIRRTL compiler provides options to change the name\npreservation behavior to produce more debuggable or more optimized output.\n\nModules shall use the name given in Chisel, unless they conflict with a Verilog\nreserved word, not withstanding de-duplication or relevant annotations on the\nmodule.\n\nInstances shall use the name given in Chisel, unless they conflict with a\nVerilog reserved word. Instances have preferential use of the name in the\noutput in case of a conflict, after ports.\n\nChisel provides a \u201cDon\u2019t Touch\u201d annotation to protect entities from\ntransformation. A \u201cDon\u2019t Touch\u201d on a wire or node produces a wire in Verilog\nand preserves the data-flow through that wire. Even a wire driven by a constant\nshall not have the constant forwarded around the wire. This is because a \u201cDon\u2019t\nTouch\u201d annotation signals the possible public use of a wire and one common use\nis to provide a place to drive a new value into the logic from an external\ntest-bench. If the node or wire is named (and it always should be for Chisel\n\u201cDon\u2019t Touch\u201d), this name is used, unless it conflicts with a Verilog reserved\nword. This wire has preferential use of the name in the output in case of a\nconflict, after ports and instances.\n\nNamed wires and nodes in FIRRTL shall appear as a wire in the output verilog.\nThere is no requirement that data-flow through a wire be maintained, only that\nthe data-flow into a wire be maintained. This allows bypassing and forwarding\naround wires who exist solely because of their name. An implementation may\nchoose to not bypass trivial wires to reduce unused wire lint warnings, but\nshouldn\u2019t cause other lint warnings to avoid unused wire warnings. A named wire\nwithout a symbol is thus equivalent to a named read-probe in the circuit.\n\nAny name of an entity inside a module which starts with `_` may be discarded.\nThis name pattern indicates the name is for convenience in the Chisel code\n(often temporaries are required) and there is no expectation it exist in the\noutput.\n\n### Mandatory Renaming\u00a0[\u00b6](#mandatory-renaming)\n\nWe want the naming of Verilog objects to match the names used in the original\nChisel, but in several passes, there is mandatory renaming. It is important\nthat this be a predictable transformation. For example, after bundles are\nreplaced with scalars in the lower-types pass, each field should be prefixed\nwith the bundle name:\n\n```\ncircuit Example\n  module Example\n    reg myreg: { a :UInt<1>, b: UInt<1> }, clock\n; firrtl-lower-types =>\ncircuit Example\n  module Example\n    reg myreg_a: UInt<1>, clock\n    reg myreg_b: UInt<1>, clock\n```\n\nThe name transformations applied by the SFC have become part of the documented\nAPI, and people rely on the final names to take a certain form.\n\n### Temporaries\u00a0[\u00b6](#temporaries)\n\nThere are names for temporaries generated by the Chisel and FIRRTL tooling which\nare not important to maintain. These names are discarded when parsing, which\nsaves memory during compilation. New names are generated at Verilog export time,\nwhich has the effect of renumbering intermediate value names. Names generated\nby Chisel typically look like `_T_12`, and names generated by the SFC look like\n`_GEN_12`. The FIRRTL compiler will not discard these names if the object has an\narray attribute `annotations` containing the attribute `{class = \"firrtl.transforms.DontTouchAnnotation}`.\n\nChisel-generated temporaries will not be discarded in compilation modes which\npreserve all names.\n\n### Name Preservation Modes\u00a0[\u00b6](#name-preservation-modes)\n\nName preservation modes, compiler options that produce different name\npreservation behavior, was implemented as a compromise between two divergent and\nseemingly irreconcilable goals:\n\n1. A FIRRTL to Verilog compiler should apply heavy optimizations to improve its\n   own performance (early optimizations produce smaller IR which means later\n   passes need to do less work) and to improve the performance of tools\n   consuming output Verilog, e.g., Verilog simulator compilation and run time.\n2. Chisel users (design and verification engineers) want to see a one-to-one\n   correspondence between what they write in Chisel and the Verilog that a\n   FIRRTL compiler produces to enable debuggability.\n\nThese two goals are viewed as irreconcilable because certain increases to\noptimizations (1) necessarily detract from debuggability (2).\n\nCurrently CIRCT\u2019s FIRRTL compiler, `firtool`, provides two optimization modes,\ndebug and release, as well as finer grained options with lower-level flags:\n\n1. `-O=release` (or `-preserve-values=none`) may delete any component as part of\n   an optimization.\n2. `-O=debug` (or `-preserve-values=named`) keeps components with names that do\n   not begin with a leading underscore.\n3. `-preserve-values=all`, which has no exposed `-O` option, keeps all\n   components.\n\nAs an example of these modes consider the following FIRRTL circuit:\n\n```\ncircuit Foo:\n  module Foo:\n    input a: UInt<1>\n    output b: UInt<1>\n\n    node named = a\n    node _unnamed = named\n\n    b <= _unnamed\n```\n\nWhen compiled with `-O=release` (or `--preserve-values=none`), no intermediary\nnodes/wires are preserved because CIRCT inlines the usages of `a` into the\nassignment to `b`:\n\n```\nmodule Foo(\n  input  a,\n  output b);\n\n  assign b = a;\nendmodule\n```\n\nWhen compiled with `-O=debug` (or `-preserve-values=named`), the `_unnamed` node\nis removed, but the `named` node is preserved:\n\n```\nmodule Foo(\n  input  a,\n  output b);\n\n  wire named = a;\n  assign b = named;\nendmodule\n```\n\nWhen compiled with `-preserve-values=all` this produces the following Verilog\nthat preserves all nodes, regardless of name:\n\n```\nmodule Foo(\n  input  a,\n  output b);\n\n  wire named = a;\n  wire _unnamed = named;\n  assign b = _unnamed;\nendmodule\n```\n\nDesign teams are expected to use `-O=debug` debuggabilty. Verification teams\nand downstream tools are expected to use/consume `-O=release`.\n\nThis split of two different Verilog outputs initially created reproducibility\nproblems that CIRCT has attempted to solve with a guarantee of stable\nrandomization. Consider a situation where a verification team trips an\nassertion failure using a release build with a particular seed. Because release\nVerilog is highly optimized and difficult to debug, they want to switch to a\ndebug build. If the release build seed does not reproduce the failure in debug\nmode, the verification team needs to search for a failure. This proved to be a\ndrag on Chisel users. Towards alleviating this, CIRCT will now guarantee that\nregisters in debug or release mode will be randomized to the same value for the\nsame seed.\n\nIt is important to note that the debug/release split was born out of our\ninability to reconcile the goals at the top of this section. Discussion in the\nsubsequent section involves approaches to unify these two approaches.\n\n#### Alternative Approaches to Name Preservation Modes and Historical Background\u00a0[\u00b6](#alternative-approaches-to-name-preservation-modes-and-historical-background)\n\nThe following alternatives were implemented or considered instead of the\ndebug/release solution.\n\nFirst, we created dead wire taps *with symbols* for all \u201cnamed\u201d things in the\noriginal FIRRTL design. We would then try to use these dead wire taps in place\nof unnamed things when possible. This simple solution produced much more\nreadable Verilog. However, this also had a number of problems. Namely, leaving\nin dead wire taps would result in situations where ports that downstream users\nwere expecting to be removed were not. E.g., a module with dead wire taps would\nresult in more ports at a physical design boundary. Additionally, leaving in\ndead wire taps may introduce coverage holes for verification teams. We\nattempted to remove dead wire taps when possible. However, this was problematic\nas we had given them symbols which indicates that they may have external readers\n(e.g., from a manually written testbench) and was intended to indicate that\nlater passes could never remove these. We considered using an alternative to a\nsymbol, but this was rejected due to its highly special-cased nature\u2014it was\nforcing us to communicate a Chisel expectation/semantic all the way to HW/SV\ndialects.\n\nThese drawbacks are unfortunate because they stem from learned expectations of\nhow the Scala-based FIRRTL Compiler worked. A negative view of this is that\nsome level of optimization was required for a learned definition of correctness.\nIf CIRCT was the first FIRRTL compiler, we may have been able to circumvent\nthese problems with alternative means that included modifications to Chisel.\n\nSecond, we considered having CIRCT create \u201cdebug modules\u201d that included all\nnamed signals in the design. An instance of this debug module would then be\ninstantiated, via a SystemVerilog `bind` statement, inside the original module.\nThis was an early suggestion. However, a concern of users of any \u201cdebug module\u201d\nis that the debug module would not show usages of the named signals. E.g., the\nexample circuit shown above would compile to something like:\n\n```\nmodule Foo_debug(\n  input _0;\n\n  wire named = _0;\nendmodule\n\nbind Foo Foo_debug Foo_debug (\n  ._0(a)\n);\n\nmodule Foo(\n  input  a,\n  output b);\n\n  assign b = a;\nendmodule\n```\n\nThe main concern is that while users can see the value of `named` in a waveform,\nthey cannot trace back its usage in the computation of port `b` in module `Foo`.\nThis approach also suffers from the issues of the first approach of leaving in\nports and dead logic (that is only used when a debug instance is bound in).\n\nThis approach may be revisited in the future as it provides benefits of unifying\ndebug and release builds into a single release build with run-time debugging\ninformation that can be bound in. Additionally, use of FIRRTL `RefType`s that\nlower to Verilog cross-module references (XMRs) may alleviate some of the issues\nabove.\n\nThird, a single build that always preserved names was considered. At the time,\nthis introduced long Verilog compilation and simulation times. We were not able\nto discern an optimization design point which balanced the needs of\ndebuggability with compilation and simulation performance. This does not mean\nthat such a point does *not* exist, only that we were not able to find it. Such\na design point may exist and should be investigated.\n\nSince all these efforts happened, other work has occurred which may make\nreviving these efforts a fruitful endeavor. FIRRTL now has `RefType`s which are\noperations which lower to Verilog cross-module references (XMRs). This may\nprovide a mechanism to implement the \u201cbound debug instance\u201d approach above\nwithout perturbing port optimizations. Reliance on symbols to encode\noptimization blocking behavior has been largely rolled back. A\n`DontTouchAnnotation` is now encoded as an annotation as opposed to a symbol. A\nnew inter-module dead code elimination (IMDCE) pass was implemented which\nhandles port removal. The approaches above, or new approaches, may be able to\nbuild a better name preservation approach, but with certain optimizations\nenabled.\n\nSymbols and Inner Symbols\u00a0[\u00b6](#symbols-and-inner-symbols)\n---------------------------------------------------------\n\nSymbols and Inner Symbols are documented in\n[Symbol\nRationale](https://circt.llvm.org/docs/RationaleSymbols/). This documents how\nsymbols are used, their interaction with \u201cDon\u2019t Touch\u201d, and the semantics\nimposed by them.\n\nPublic Symbols indicate there are uses of an entity outside the analysis scope\nof the compiler. This requires the entity be preserved in such a way as the\noperations possible in the target language have the expected effect. For\nexample, a wire or port with a public symbol may be used by name in a test bench\nto read or write new values into the circuit. Therefore, these wires cannot be\ndetached form their original dataflow as this would break the remote write case,\nnor can their input dataflow be changed, as this would break the remote read\ncase. They cannot be renamed, as this would break all remote access.\n\nPrivate Symbols indicate there are symbolic references to the entity, but they\nare all within the scope of the compiler\u2019s IR and analysis. An entity with a\nprivate symbol may be arbitrarily transformed, so long as the transformation is\nsemantic preserving with respect to all uses of the private symbol. If it can\nbe proved a wire with a private symbol is only read from via its symbol and not\nwritten to, for example, the input can forwarded to the output (bypassing the\nwire) safely. If a private symbol is unused, it may be removed. Private\nsymbols impose no restriction on output; they only exist to enable non-local\neffects in the IR.\n\n\u201cDon\u2019t Touch\u201d is implemented as a public symbol on an entity. A conservative\ninterpretation of \u201cDon\u2019t Touch\u201d, and a common use case, is that the entity is\nreferred to by a testbench in unknown ways. This implies no transformation\nwhich would change observed behavior if the entity was arbitrarily read or\nwritten to remotely. This further implies the existence of the entity in the\noutput.\n\nImportantly, the existence of a symbol doesn\u2019t specify whether something is\nread-only, write-only, or read-write. Without analysis, a pass must assume the\nmost conservative case, and in the case of public symbols, must always assume\nthe most conservative case. To do better, all uses must be analyzed and\nunderstood (e.g. a symbol used by a verbatim has unknown use).\n\n### Hierarchical Path\u00a0[\u00b6](#hierarchical-path)\n\nIn the FIRRTL dialect, it might be necessary to identify specific instances of\noperations in the instance hierarchy. The FIRRTL `HierPathOp` operation\n(`firrtl.hierpath`) can be used to describe the path through an instance\nhierarchy to a declaration, which can be used by other operations or non-local\nannotations. Non-local anchors can refer to most declarations, such as modules,\ninstances, wires, registers, and memories.\n\nThe `firrtl.hierpath` operations defines a symbol and contains a namepath, which\nis a list of `InnerRefAttr` and `FlatSymbolRefAttr` attributes. A\n`FlatSymbolRefAttr` is used to identify modules, and is printed as `@Module`.\n`InnerRefAttr` identifies a declaration inside a module, and is printed as\n`@Module::@wire`. Each element along the Paths\u2019s namepath carries an annotation\nwith class `circt. nonlocal`, which has a matching `circt. nonlocal` field\npointing to the global op. Thus instances participating in nonlocal paths are\nreadily apparent.\n\nIn the following example, `@nla` specifies instance `@bar` in module `@Foo`,\nfollowed by instance `@baz` in module `@Bar`, followed by the wire named `@w` in\nmodule `@Baz`.\n\n```\nfirrtl.circuit \"Foo\" {\n  firrtl.hierpath @nla [@Foo::@bar, @Bar::@baz, @Baz::@w]\n  firrtl.module @Baz() {\n    %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @nla, class = \"ExampleAnno\"}]} : !firrtl.uint\n  }\n  firrtl.module @Bar() {\n    firrtl.instance baz sym @baz {annotations = [{circt.nonlocal = @nla, class = \"circt.nonlocal\"}]} @Baz()\n  }\n  firrtl.module @Foo() {\n    firrtl.instance bar sym @bar {annotations = [{circt.nonlocal = @nla, class = \"circt.nonlocal\"}]} @Bar()\n  }\n}\n```\n\nType system\u00a0[\u00b6](#type-system)\n-----------------------------\n\n### Not using standard types\u00a0[\u00b6](#not-using-standard-types)\n\nAt one point we tried to use the integer types in the standard dialect, like\n`si42` instead of `!firrtl.sint<42>`, but we backed away from this. While it\noriginally seemed appealing to use those types, FIRRTL operations generally need\nto work with \u201cunknown width\u201d integer types (i.e. `!firrtl.sint`).\n\nHaving the known width and unknown width types implemented with two different\nC++ classes was awkward, led to casting bugs, and prevented having a\n`FIRRTLType` class that unified all the FIRRTL dialect types.\n\n### Not Canonicalizing Flip Types\u00a0[\u00b6](#not-canonicalizing-flip-types)\n\nAn initial version of the FIRRTL dialect relied on canonicalization of flip\ntypes according to the following rules:\n\n1. `flip(flip(x))` == `x`.\n2. `flip(analog(x))` == `analog(x)` since analog types are implicitly\n   bidirectional.\n3. `flip(bundle(a,b,c,d))` == `bundle(flip(a), flip(b), flip(c), flip(d))` when\n   the bundle has non-passive type or contains an analog type. This forces the\n   flip into the subelements, where it recursively merges with the non-passive\n   subelements and analogs.\n4. `flip(vector(a, n))` == `vector(flip(a), n)` when the vector has non-passive\n   type or analogs. This forces the flip into the element type, generally\n   canceling it out.\n5. `bundle(flip(a), flip(b), flip(c), flip(d))` == `flip(bundle(a, b, c, d)`.\n   Due to the other rules, the operand to a flip must be a passive type, so the\n   entire bundle will be passive, and rule #3 won\u2019t be recursively reinvoked.\n\nWhile elegant in a number of ways (e.g., FIRRTL types are guaranteed to have a\ncanonical representation and can be compared using pointer equality, flips\npartially subsume port directionality and \u201cflow\u201d, and analog inputs and outputs\nare canonicalized to the same representation), this resulted in information loss\nduring canonicalization because the number of flip types can change. Namely,\nthree problems were identified:\n\n1. Type canonicalization may make illegal operations legal.\n2. The flow of connections could not be verified because flow is a function of\n   the number of flip types.\n3. The directionality of leaves in an aggregate could not be determined.\n\nAs an example of the first problem, consider the following circuit:\n\n```\nmodule Foo:\n  output a: { flip a: UInt<1> }\n  output b: { a: UInt<1> }\n\n  b <= a\n```\n\nThe connection `b <= a` *is illegal* FIRRTL due to a type mismatch where `{ flip a: UInt<1> }` is not equal to `{ a: UInt<1> }`. However, type canonicalization\nwould transform this circuit into the following circuit:\n\n```\nmodule Foo:\n  input a: { a: UInt<1> }\n  output b: { a: UInt<1> }\n\n  b <= a\n```\n\nHere, the connection `b <= a` *is legal* FIRRTL. This then makes it impossible\nfor a type canonical form to be type checked.\n\nAs an example of the second problem, consider the following circuit:\n\n```\nmodule Bar:\n  output a: { flip a: UInt<1> }\n  input b: { flip a: UInt<1> }\n\n  b <= a\n```\n\nHere, the connection `b <= a` *is illegal* FIRRTL because `b` is a source and\n`a` is a sink. However, type canonicalization converts this to the following\ncircuit:\n\n```\nmodule Bar:\n  input a: { a: UInt<1> }\n  output b: { a: UInt<1> }\n\n  b <= a\n```\n\nHere, the connect `b <= a` *is legal* FIRRTL because `b` is now a sink and `a`\nis now a source. This then makes it impossible for a type canonical form to be\nflow checked.\n\nAs an example of the third problem, consider the following circuit:\n\n```\nmodule Baz:\n  wire a: {flip a: {flip a: UInt<1>}}\n  wire b: {flip a: {flip a: UInt<1>}}\n\n  b.a <= a.a\n```\n\nThe connection `b.a <= a.a`, when lowered, results in the *reverse* connect\n`a.a.a <= b.a.a`. However, type canonicalization will remove the flips from the\ncircuit to produce:\n\n```\nmodule Baz:\n  wire a: {a: {a: UInt<1>}}\n  wire b: {a: {a: UInt<1>}}\n\n  b.a <= a.a\n```\n\nHere, the connect `b.a <= a.a`, when lowered, results in the normal connect\n`b.a.a <= a.a.a`. Type canonicalization has thereby changed the semantics of\nconnect.\n\nDue to the elegance of type canonicalization, we initially decided that we would\nuse type canonicalization and CIRCT would accept more circuits than the SFC.\nThe third problem (identified much later than the first two) convinced us to\nremove type canonicalization.\n\nFor a historical discussion of type canonicalization see:\n\n* [`llvm/circt#380`](https://github.com/llvm/circt/issues/380)\n* [`llvm/circt#919`](https://github.com/llvm/circt/issues/919)\n* [`llvm/circt#944`](https://github.com/llvm/circt/pull/944)\n\n### Flow\u00a0[\u00b6](#flow)\n\nThe FIRRTL specification describes the concept of \u201cflow\u201d. Flow encodes\nadditional information that determines the legality of operations. FIRRTL\ndefines three different flows: `sink`, `source`, and `duplex`. Module inputs,\ninstance outputs, and nodes are `source`, module outputs and instance inputs are\n`sink`, and wires and registers are `duplex`. A value with `sink` flow may only\nbe written to, but not read from (with the exception of module outputs and\ninstance inputs which may be also read from). A value with `source` flow may be\nread from, but not written to. A value with `duplex` flow may be read from or\nwritten to.\n\nFor FIRRTL connect statements, it follows that the left-hand-side must be `sink`\nor `duplex` and the right-hand-side must be `source`, `duplex`, or a\nport/instance `sink`.\n\nFlow is *not* represented as a first-class type in CIRCT. We instead provide\nutilities for computing flow when needed, e.g., for connect statement\nverification.\n\n### Non-FIRRTL Types\u00a0[\u00b6](#non-firrtl-types)\n\nThe FIRRTL dialect has limited support for foreign types, i.e., types that are\ndefined outside the FIRRTL dialect. Almost all operations expect to be dealing\nwith FIRRTL types, especially those that are sensitive to the type they operate\non, like `firrtl.add` or `firrtl.connect`. However, a restricted set of\noperations allows for simple pass-through semantics of foreign types. These\ninclude the following:\n\n* Ports on a `firrtl.module`, where the foreign types are treated as opaque values moving in and out of the module\n* Ports on a `firrtl.instance`\n* `firrtl.wire` to allow for def-after-use cases; the wire must have a single strict connect that uniquely defines the wire\u2019s value\n* `firrtl.matchingconnect` to module outputs, instance inputs, and wires\n\nThe expected lowering for strict connects is for the connect to be eliminated\nand the right-hand-side source value of the connect being instead materialized\nin all places where the left hand side is used. Basically we want wires and\nconnects to disappear, and all places where the wire is \u201cread\u201d should instead\nread the value that was driven onto the wire.\n\nThe reason we provide this foreign type support is to allow for partial lowering\nof FIRRTL to HW and other dialects. Passes might lower a subset of types and\noperations to the target dialect and we need a mechanism to have the lowered\nvalues be passed around the FIRRTL module hierarchy untouched alongside the\nFIRRTL ops that are yet to be lowered.\n\n### Const Types\u00a0[\u00b6](#const-types)\n\nFIRRTL hardware types can be specified as `const`, meaning they can only be\nassigned compile-time constant values or values of other `const` types.\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### Multiple result `firrtl.instance` operation\u00a0[\u00b6](#multiple-result-firrtlinstance-operation)\n\nThe FIRRTL spec describes instances as returning a bundle type, where each\nelement of the bundle corresponds to one of the ports of the module being\ninstanced. This makes sense in the Scala FIRRTL implementation, given that it\ndoes not support multiple ports.\n\nThe MLIR FIRRTL dialect takes a different approach, having each element of the\nbundle result turn into its own distinct result on the `firrtl.instance`\noperation. This is made possible by MLIR\u2019s robust support for multiple value\noperands, and makes the IR much easier to analyze and work with.\n\n### Module bodies require def-before-use dominance instead of allowing graphs\u00a0[\u00b6](#module-bodies-require-def-before-use-dominance-instead-of-allowing-graphs)\n\nMLIR allows regions with arbitrary graphs in their bodies, and this is used by\nthe HW dialect to allow direct expression of cyclic graphs etc. While this\nmakes sense for hardware in general, the FIRRTL dialect is intended to be a\npragmatic infrastructure focused on lowering of Chisel code to the HW dialect,\nit isn\u2019t intended to be a \u201cgenerally useful IR for hardware\u201d.\n\nWe recommend that non-Chisel frontends target the HW dialect, or a higher level\ndialect of their own creation that lowers to HW as appropriate.\n\n### `input` and `output` Module Ports\u00a0[\u00b6](#input-and-output-module-ports)\n\nThe FIRRTL specification describes two kinds of ports: `input` and `output`. In\nthe `firrtl.module` declaration we track this via an arbitrary precision integer\nattribute (`IntegerAttr`) where each bit encodes the directionality of the port\nat that index.\n\nOriginally, we encoded direction as the absence of an outer flip type (input) or\npresence of an outer flip type (output). This was done as part of the original\ntype canonicalization effort which combined input/output with the type system.\nHowever, once type canonicalization was removed flip type only became used in\nthree places: on the types of bundle fields, on the variadic return types of\ninstances or memories, and on ports. The first is the same as the FIRRTL\nspecification. The second is a deviation from the FIRRTL specification, but\nallowable as it takes advantage of the MLIR\u2019s variadic capabilities to simplify\nthe IR. The third was an inelegant abuse of an unrelated concept that added\nbloat to the type system. Many operations would have to check for an outer flip\non ports and immediately discard it.\n\nFor this reason, the `IntegerAttr` encoding implementation was chosen.\n\nFor a historical discussion of this issue and its development see:\n\n* [`llvm/circt#989`](https://github.com/llvm/circt/issues/989)\n* [`llvm/circt#992`](https://github.com/llvm/circt/pull/992)\n\n### `firrtl.bitcast`\u00a0[\u00b6](#firrtlbitcast)\n\nThe bitcast operation represents a bitwise reinterpretation (cast) of a value.\nIt can be used to cast a vector or bundle type to an int type or vice-versa.\nThe bit width of input and result types must be known. For an aggregate type,\nthe bit width of every field must be known. This always synthesizes away in\nhardware, and follows the same endianness policy as `hw.bitcast`.\n\n### `firrtl.mem`\u00a0[\u00b6](#firrtlmem)\n\nUnlike the SFC, the FIRRTL dialect represents each memory port as a distinct\nresult value of the `firrtl.mem` operation. Also, the `firrtl.mem` node does\nnot allow zero port memories for simplicity. Zero port memories are dropped by\nthe .fir file parser.\n\nIn the FIRRTL pipeline, the `firrtl.mem` op can be lowered into either a\nexternal module for macro replacement or a register of vector type. The\nconditions for macro replacement are as follows:\n\n1. `\u2013replSeqMem` option is passed and\n2. `readLatency >= 1` and\n3. `writeLatency >= 1` and\n4. `width(data) > 0`\n\nAny `MemOp` not satisfying the above conditions is lowered to Register vector.\n\n#### MemToRegOfVec transformation outline:\u00a0[\u00b6](#memtoregofvec-transformation-outline)\n\nThe `MemToRegOfVec` pass runs early in the pipeline, after the `LowerCHIRRTL`\npass and right before the `InferResets` pass.\n\n1. Select all MemOps that are not candidates for macro replacement,\n2. Create a reg\n3. Read ports return the value at the address when the enable signal is high.\n\n```\nif (enable) {\n  readOut = register[address]\n}\n```\n\n4. Write ports store the value at the address when the mask signal is high.\n\n```\nif (enable) {\n  if (mask[0])\n    register[0] = dataIn[0]\n  if (mask[1])\n    register[1] = dataIn[1]\n}\n```\n\n#### Handling of MemTaps\u00a0[\u00b6](#handling-of-memtaps)\n\nThe `sifive.enterprise.grandcentral.MemTapAnnotation` annotation is attached to\nthe `MemOp` and the corresponding Memtap module ports. After lowering the memory\nto registers, this annotation must be properly scattered such that\nGrandCentralTaps can generate the appropriate code.\n\nThe memtap module has memtap annotations, where the number of ports with the\nannotation is equal to the memory depth. In the `MemToRegOfVec` transformation,\nafter lowering the memory to the register vector, a subannotation is created for\neach sub-field of the data and the\n`sifive.enterprise.grandcentral.MemTapAnnotation` annotation is copied from the\noriginal `MemOp`. The `LowerTypes` pass will handle the subannotations\nappropriately.\n\n#### Interaction with AsyncReset Inference\u00a0[\u00b6](#interaction-with-asyncreset-inference)\n\nThe `AsyncReset` pass runs right after the `MemToRegOfVec`. It will transform\nthe memory registers to async registers if the corresponding annotations are\npresent.\n\n#### `firrtl.mem` Attributes\u00a0[\u00b6](#firrtlmem-attributes)\n\nA `firrtl.mem` has the following properties:\n\n1. Data type\n2. Mask bitwidth\n3. Depth\n4. Name\n5. Number of read ports, write ports, read-write ports\n6. Read under write behavior\n7. Read latency\n8. Write latency\n\n##### Mask bitwidth\u00a0[\u00b6](#mask-bitwidth)\n\nAny aggregate memory data type is lowered to ground type by the `LowerTypes`\npass. After lowering the data type, the data bitwidth must be divisible by mask\nbitwidth. And we define the property granularity as: `mask granularity = (Data bitwidth)/(Mask bitwidth)`.\n\nEach mask bit can guard the write to `mask granularity` number of data bits.\nFor a single-bit mask, one-bit guards write to the data, hence `mask granularity = data bitwidth`.\n\n#### Macro replacement\u00a0[\u00b6](#macro-replacement)\n\nMemories that satisfy the conditions above are candidates for macro replacement.\n\nA memory generator defines the external module definition corresponding to the\nmemory for macro replacement. Memory generators need metadata to generate the\nmemory definition. SFC uses some metadata files to communicate with the memory\ngenerators.\n\n`<design-name>.conf` is a file, that contains the metadata for the memories\nwhich are under the \u201cdesign-under-test\u201d module hierarchy. Following is a sample\ncontent of the file:\n\n```\nname dir_ext depth 512 width 248 ports mrw mask_gran 31\nname banks_0_ext depth 2048 width 72 ports rw\nname banks_1_ext depth 2048 width 72 ports rw\n```\n\n1. `name` followed by the memory name.\n2. `depth` followed by the memory depth.\n3. `width` followed by the data bitwidth.\n4. `ports` followed by the `mrw` for read-write port, `mwrite` for a write port\n   and `read` for a read port.\n5. `mask_gran` followed by the mask granularity.\n\n### CHIRRTL Memories\u00a0[\u00b6](#chirrtl-memories)\n\nFIRRTL has two different representations of memories: Chisel `cmemory`\noperations, `smem` and `cmem`, and the standard FIRRTL `mem` operation. Chisel\nmemory operations exist to make it easy to produce FIRRTL code from Chisel, and\nclosely match the Chisel API for memories. Chisel memories are intended to be\nreplaced with standard FIRRTL memories early in the pipeline. The set of\noperations related to Chisel memories are often referred to as CHIRRTL.\n\nThe main difference between Chisel and FIRRTL memories is that Chisel memories\nhave an operation to add a memory port to a memory, while FIRRTL memories\nrequire all ports to be defined up front. Another difference is that Chisel\nmemories have \u201cenable inference\u201d, and are usually inferred to be enabled where\nthey are declared. The following example shows a CHIRRTL memory declaration, and\nthe standard FIRRTL memory equivalent.\n\n```\nsmem mymemory : UInt<4>[8]\nwhen p:\n  read mport port0 = mymemory[address], clock\n```\n\n```\nmem mymemory:\n    data-type => UInt<4>\n    depth => 8\n    read-latency => 0\n    write-latency => 1\n    reader => port0\n    read-under-write => undefined\n\nmymemory.port0.en <= p\nmymemory.port0.clk <= clock\nmymemory.port0.addr <= address\n```\n\nFIRRTL memory operations were created because it was thought that a concrete\nmemory primitive, that looks like an instance, is a better design for a compiler\nIR. It was originally intended that Chisel would be modified to emit FIRRTL\nmemory operations directly, and the CHIRRTL operations would be retired. The\nlowering from Chisel memories to FIRRTL memories proved far more complicated\nthan originally envisioned, specifically surrounding the type of ports,\ninference of enable signals, and inference of clocks.\n\nCHIRRTL operations have since stuck around, but their strange behavior has lead\nto discussions to remove, improve, or totally redesign them. For some current\ndiscussion about this see [1](#fn:1), [2](#fn:2). Since CIRCT is attempting to be a drop in\nreplacement FIRRTL compiler, we are not attempting to implement these new ideas\nfor Chisel memories. Instead, we are trying to implement what exists today.\n\nThere is, however, a major compatibility issue with the existing implementation\nof Chisel memories which made them difficult to support in CIRCT. The FIRRTL\nspecification disallows using any declaration outside of the scope where it is\ncreated. This means that a Chisel memory port declared inside of a `when` block\ncan only be used inside the scope of the `when` block. Unfortunately, this\ninvariant is not enforced for memory ports, and this leniency has been abused by\nthe Chisel standard library. Due to the way clock and enable inference works, we\ncouldn\u2019t just hoist the declaration into the outer scope.\n\nTo support escaping memory port definitions, we decided to split the memory port\noperation into two operations. We created a `chirrtl.memoryport` operation to\ndeclare the memory port, and a `chirrtl.memoryport.access` operation to enable\nthe memory port. The following is an example of how FIRRTL translates into the\nCIRCT dialect:\n\n```\nsmem mymem : UInt<1>[8]\nwhen cond:\n  infer mport myport = mymem[addr], clock\nout <= myport\n```\n\n```\n%mymem = chirrtl.seqmem Undefined  : !chirrtl.cmemory<uint<1>, 8>\n%myport_data, %myport_port = chirrtl.memoryport Infer %mymem {name = \"myport\"}  : (!chirrtl.cmemory<uint<1>, 8>) -> (!firrtl.uint<1>, !chirrtl.cmemoryport)\nfirrtl.when %cond : !firrtl.uint<1> {\n  chirrtl.memoryport.access %myport_port[%addr], %clock : !chirrtl.cmemoryport, !firrtl.uint<3>, !firrtl.clock\n}\nfirrtl.connect %out, %myport_data : !firrtl.uint<1>, !firrtl.uint<1\n```\n\nThe CHIRRTL operations and types are contained in the CHIRRTL dialect. The is\nprimary reason to move them into their own dialect was to keep the CHIRRTL types\nout of the FIRRTL dialect type hierarchy. We tried to have the CHIRRTL dialect\ndepend on the FIRRTL dialect, but the flow checking in FIRRTL had to know about\nCHIRRTL operations, which created a circular dependency. To simplify how this\nis handled, both dialects are contained in the same library.\n\nFor a historical discussion of this issue and its development see\n[`llvm/circt#1561`](https://github.com/llvm/circt/issues/1561).\n\n### More things are represented as primitives\u00a0[\u00b6](#more-things-are-represented-as-primitives)\n\nWe describe the `mux` expression as \u201cprimitive\u201d, whereas the IR spec and grammar\nimplement it as a special kind of expression.\n\nWe do this to simplify the implementation: These expressions have the same\nstructure as primitives, and modeling them as such allows reuse of the parsing\nlogic instead of duplication of grammar rules.\n\n### `invalid` Invalidate Operation is an expression\u00a0[\u00b6](#invalid-invalidate-operation-is-an-expression)\n\nThe FIRRTL spec describes an `is invalid` statement that logically computes an\ninvalid value and connects it to `x` according to flow semantics. This behavior\nmakes analysis and transformation a bit more complicated, because there are now\ntwo things that perform connections: `firrtl.connect` and the `is invalid`\noperation.\n\nTo make things easier to reason about, we split the `is invalid` operation into\ntwo different ops: an `firrtl.invalidvalue` op that takes no operands and\nreturns an invalid value, and a standard `firrtl.connect` operation that\nconnects the invalid value to the destination (or a `firrtl.attach` for analog\nvalues). This has the same expressive power as the standard FIRRTL\nrepresentation but is easier to work with.\n\nDuring parsing, we break up an `x is invalid` statement into leaf connections.\nAs an example, consider the following FIRRTL module where a bi-directional\naggregate, `a` is invalidated:\n\n```\nmodule Foo:\n  output a: { a: UInt<1>, flip b: UInt<1> }\n\n  a is invalid\n```\n\nThis is parsed into the following MLIR. Here, only `a.a` is invalidated:\n\n```\nfirrtl.module @Foo(out %a: !firrtl.bundle<a: uint<1>, b: flip<uint<1>>>) {\n  %0 = firrtl.subfield %a[a] : !firrtl.bundle<a: uint<1>, b: flip<uint<1>>>\n  %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\n  firrtl.connect %0, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\n}\n```\n\n### Inline SystemVerilog through `verbatim.expr` operation\u00a0[\u00b6](#inline-systemverilog-through-verbatimexpr-operation)\n\nThe FIRRTL dialect offers a `firrtl.verbatim.expr` operation that allows for\nSystemVerilog expressions to be embedded verbatim in the IR. It is lowered to\nthe corresponding `sv.verbatim.expr` operation of the underlying SystemVerilog\ndialect, which embeds it in the emitted output. The operation has a FIRRTL\nresult type, and a variadic number of operands can be accessed from within the\ninline SystemVerilog source text through string interpolation of `{{0}}`-style\nplaceholders.\n\nThe rationale behind this verbatim operation is to offer an escape hatch\nanalogous to `asm (\"...\")` in C/C++ and other languages, giving the user or\ncompiler passes full control of what exactly gets embedded in the\noutput. Usually, though, you would rather add a new operation to the IR to\nproperly represent additional constructs.\n\nAs an example, a verbatim expression could be used to interact with\nyet-unsupported SystemVerilog constructs such as parametrized class typedef\nmembers:\n\n```\nfirrtl.module @Magic (out %n : !firrtl.uint<32>) {\n  %0 = firrtl.verbatim.expr \"$bits(SomeClass #(.Param(1))::SomeTypedef)\" : !firrtl.uint<32>\n  firrtl.connect %n, %0 : !firrtl.uint<32>, !firrtl.uint<32>\n}\n```\n\nThis would lower through the other dialects to SystemVerilog as you would\nexpect:\n\n```\nmodule Magic (output [31:0] n);\n  assign n = $bits(SomeClass #(.Param(1))::SomeTypedef);\nendmodule\n```\n\nInterpretation of Undefined Behavior\u00a0[\u00b6](#interpretation-of-undefined-behavior)\n-------------------------------------------------------------------------------\n\nThe\n[FIRRTL\nSpecification](https://github.com/chipsalliance/firrtl/blob/master/spec/spec.pdf)\nhas undefined behavior for certain features. For compatibility reasons, FIRRTL\ndialect *always* chooses to implement undefined behavior in the same manner as\nthe SFC.\n\n### Invalid\u00a0[\u00b6](#invalid)\n\nThe SFC has multiple context-sensitive interpretations of invalid. Failure to\nimplement all of these can result in formal equivalence failures when comparing\nCIRCT-generated Verilog with SFC-generated Verilog. A list of these\ninterpretations is enumerated below and then described in more detail.\n\n1. An invalid value driving the initialization value of a register (looking\n   through wires and connections within module scope) removes the reset from the\n   register.\n2. An invalid value used in a `when`-encoded multiplexer tree results in a\n   direct connection to the non-invalid leg of the multiplexer.\n3. Any other use of an invalid value is treated as constant zero.\n\nInterpretation (1) is a mechanism to remove unnecessary reset connections in a\ncircuit as fewer resets can enable a higher performance design. The SFC\nimplementation of this works as a dedicated pass that does a module-local\nanalysis looking for registers with resets whose initialization values come from\ninvalidated signals. This analysis only looks through wires and connections.\nIt is legal to use an invalidated output port or instance input port.\n\nAs an example, the following module should have register `r` converted to a\nreset-less register:\n\n```\nwire inv: UInt<8>\ninv is invalid\n\nwire tmp: UInt<8>\ntmp <= inv\n\nreg r: UInt<8>, clock with : (reset => (reset, tmp))\n```\n\nNotably, if `tmp` is a `node`, this optimization should not be performed.\n\nInterpretation (2) means that the following circuit should be optimized to a\ndirect connection from `bar` to `foo`:\n\n```\nfoo is invalid\nwhen cond:\n  foo <= bar\n```\n\nNote that the SFC implementation of this optimization is handled via two passes.\nAn `ExpandWhens` (later refactored as `ExpandWhensAndCheck`) pass converts all\n`when` blocks to multiplexer trees. Any invalid values that arise from this\nconversion produce `validif` expressions. (This is the \u201cconditionally valid\u201d\nexpression which is an internal detail of the SFC which was removed from the\nFIRRTL specification.) A later pass, `RemoveValidIfs` optimizes/removes\n`validif` by replacing it with a direct connection.\n\nIt is important to note that the above formulations using `when` or the\nSFC-internal representation using `validif` *are not equivalent to a mux\nformulation* like the following. The code below should be optimized using\nInterpretation (3) of invalid as constant zero:\n\n```\nwire inv: UInt<8>\ninv is invalid\n\nfoo <= mux(cond, bar, inv)\n```\n\nA legal lowering of this is only to:\n\n```\nfoo <= mux(cond, bar, UInt<8>(0))\n```\n\nInterpretation (3) is used in all other situations involving an invalid value.\n\n**Critically, the nature of an invalid value has context-sensitive information\nthat relies on the exact structural nature of the circuit.** It follows that\nany seemingly mundane optimization can result in an end-to-end miscompilations\nwhere the SFC is treated as ground truth.\n\nAs an example, consider a reformulation of the `when` example above, but using a\ntemporary, single-use, invalidated wire:\n\n```\nwire inv: UInt<8>\ninv is invalid\n\nb <= inv\nwhen cond:\n  b <= a\n```\n\nThis should *not* produce a direction connection to `b` and should instead lower\nto:\n\n```\nb <= mux(cond, a, inv)\n```\n\nIt follows that interpretation (3) will then convert the false leg of the `mux`\nto a constant zero.\n\nIntrinsics\u00a0[\u00b6](#intrinsics)\n---------------------------\n\nIntrinsics are implementation-defined constructs. Intrinsics provide a way to\nextend the system with functionality without changing the language. They form\nan implementation-specific built-in library. Unlike traditional libraries,\nimplementations of intrinsics have access to internals of the compiler, allowing\nthem to implement features not possible in the language.\n\nSplit of Design and Verification\u00a0[\u00b6](#split-of-design-and-verification)\n-----------------------------------------------------------------------\n\nThe compilation of FIRRTL circuits inherited many undocumented semantics from\ncustom SiFive annotations and transforms. One such semantic is a partitioning\nof the circuit into *design* and *design verification*. Practically, this means\nthat parts of the circuit are intended for FPGA or ASIC synthesis and,\nultimately, fabrication. Other parts of the circuit are only used for\nverification, debugging, or other *non-design* reasons.\n\nThis split was historically handled with an optional\n`sifive.enterprise.firrtl.MarkDUTAnnotation` on exactly one module in the\ndesign. The module with this annotation is then the design-under-test (DUT).\nOther modules can then be said to be \u201cin\u201d or \u201cunder\u201d the DUT if that module is\never reachable, by instantiation, from the DUT.\n\nFor circuits which have no `sifive.enterprise.firrtl.MarkDUTAnnotation`, then a\nproblem arises about what to do. In this situation, transforms typically treat\nthe main module as the DUT. To differentiate between a DUT which may or may not\nexist, the notion of an *effective DUT* was added. This is the DUT if the\nannotation is present or the main module if the annotation is absent.\n\nThe `InstanceInfo` analysis centralizes the determination of DUT and effective\nDUT as well as queries of if a module is partially (has any instance) or fully\n(has all instances) under these definitions of the DUT. This is centralized to\navoid having per-pass interpretations of these semantics which may be subtly\ndifferent. These semantics are *not* made first-class in FIRRTL dialect because\nthey are viewed as something that should be replaced. E.g., a pass like\n`CreateSiFiveMetadata` which adds metadata based on whether or not something is\nunder the effective DUT should be removed in favor of directly encoding the\nmetadata the user wants in the FIRRTL.\n\nAs the FIRRTL language has been extended with new features, this has created\nfriction with legacy passes which roughly assumed this partitioning. A number\nof language features and non-standard extensions (annotations) have been added.\nAll features or extensions listed below are deemed as non-design features and\nare treated the same by the `InstanceInfo` analysis:\n\n1. Layers \u2013 a FIRRTL language feature to create Verilog that can be\n   elaboration-time configured (either via SystemVerilog\u2019s `bind` directive or\n   by setting certain `` `define `` textual macros).\n2. Grand Central Views \u2013 an annotation-based way to create debug-only\n   SystemVerilog intrinsics. Grand Central Views are intended to be replaced\n   with layers.\n\n---\n\n1. <https://github.com/chipsalliance/firrtl/issues/727>\u00a0[\u21a9\ufe0e](#fnref:1)\n2. <https://github.com/chipsalliance/firrtl/pull/1821>\u00a0[\u21a9\ufe0e](#fnref:2)\n\n [Prev - FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/ \"FIRRTL Annotations\")\n[Next - Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/ \"Intrinsics\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect-](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/index.md"
  },
  {
    "role": "user",
    "content": "Intrinsics - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nIntrinsics\n==========\n\nIntrinsics provide an implementation-specific way to extend the FIRRTL language\nwith new operations.\n\n* [Motivation](#motivation)\n* [Supported Intrinsics](#supported-intrinsics)\n  + [circt\\_plusargs\\_value](#circt_plusargs_value)\n  + [circt\\_plusargs\\_test](#circt_plusargs_test)\n  + [circt\\_clock\\_gate](#circt_clock_gate)\n  + [circt\\_chisel\\_assert](#circt_chisel_assert)\n  + [circt\\_chisel\\_ifelsefatal](#circt_chisel_ifelsefatal)\n  + [circt\\_chisel\\_assume](#circt_chisel_assume)\n  + [circt\\_chisel\\_cover](#circt_chisel_cover)\n  + [circt\\_unclocked\\_assume](#circt_unclocked_assume)\n  + [circt\\_dpi\\_call](#circt_dpi_call)\n  + [circt\\_view](#circt_view)\n  + [circt\\_verif\\_assert](#circt_verif_assert)\n  + [circt\\_verif\\_assume](#circt_verif_assume)\n  + [circt\\_verif\\_cover](#circt_verif_cover)\n  + [circt\\_verif\\_require](#circt_verif_require)\n  + [circt\\_verif\\_ensure](#circt_verif_ensure)\n\nMotivation\u00a0[\u00b6](#motivation)\n---------------------------\n\nIntrinsics provide a way to add functionality to FIRRTL without having to extend\nthe FIRRTL language. This allows a fast path for prototyping new operations to\nrapidly respond to output requirements. Intrinsics maintain strict definitions\nand type checking.\n\nSupported Intrinsics\u00a0[\u00b6](#supported-intrinsics)\n-----------------------------------------------\n\n### circt\\_plusargs\\_value\u00a0[\u00b6](#circt_plusargs_value)\n\nTests and extracts a value from simulator command line options with SystemVerilog\n`$value$plusargs`. This is described in SystemVerilog 2012 section 21.6.\n\nWe do not currently check that the format string substitution flag matches the\ntype of the result.\n\n| Parameter | Type | Description |\n| --- | --- | --- |\n| FORMAT | string | Format string per SV 21.6 |\n\n| Result | Type | Description |\n| --- | --- | --- |\n| found | UInt<1> | found in args |\n| result | AnyType | value of the argument |\n\n### circt\\_plusargs\\_test\u00a0[\u00b6](#circt_plusargs_test)\n\nTests simulator command line options with SystemVerilog `$test$plusargs`. This\nis described in SystemVerilog 2012 section 21.6.\n\n| Parameter | Type | Description |\n| --- | --- | --- |\n| FORMAT | string | Format string per SV 21.6 |\n\n| Result | Type | Description |\n| --- | --- | --- |\n| found | UInt<1> | found in args |\n\n### circt\\_clock\\_gate\u00a0[\u00b6](#circt_clock_gate)\n\nEnables and disables a clock safely, without glitches, based on a boolean enable value. If the enable input is 1, the output clock produced by the clock gate is identical to the input clock. If the enable input is 0, the output clock is a constant zero.\n\nThe enable input is sampled at the rising edge of the input clock; any changes on the enable before or after that edge are ignored and do not affect the output clock.\n\n| Argument | Type | Description |\n| --- | --- | --- |\n| in | Clock | input clock |\n| en | UInt<1> | enable for the output clock |\n\n| Result | Type | Description |\n| --- | --- | --- |\n| out | Clock | gated output clock |\n\n### circt\\_chisel\\_assert\u00a0[\u00b6](#circt_chisel_assert)\n\nGenerate a clocked SV assert statement, with optional formatted error message.\n\n| Parameter | Type | Description |\n| --- | --- | --- |\n| format | string | FIRRTL format string. Optional. |\n| label | string | Label for assert/assume. Optional. |\n| guards | string | Semicolon-delimited list of pre-processor tokens to use as ifdef guards. Optional. |\n\n| Argument | Type | Description |\n| --- | --- | --- |\n| clock | Clock | input clock |\n| predicate | UInt<1> | predicate to assert/assume |\n| enable | UInt<1> | enable signal |\n| \u2026 | Signals | arguments to format string |\n\nExample output:\n\n```\nwire _GEN = ~enable | cond;\nassert__label: assert property (@(posedge clock) _GEN) else $error(\"message\");\n```\n\n### circt\\_chisel\\_ifelsefatal\u00a0[\u00b6](#circt_chisel_ifelsefatal)\n\nGenerate a particular Verilog sequence that\u2019s similar to an assertion.\n\nHas legacy special behavior and should not be used by new code.\n\n| Parameter | Type | Description |\n| --- | --- | --- |\n| format | string | FIRRTL format string. Optional. |\n\nThis intrinsic also accepts the `label` and `guard` parameters which\nare recorded but not used in the normal emission.\n\n| Argument | Type | Description |\n| --- | --- | --- |\n| clock | Clock | input clock |\n| predicate | UInt<1> | predicate to check |\n| enable | UInt<1> | enable signal |\n| \u2026 | Signals | arguments to format string |\n\nExample SV output:\n\n```\n`ifndef SYNTHESIS\n  always @(posedge clock) begin\n    if (enable & ~cond) begin\n      if (`ASSERT_VERBOSE_COND_)\n        $error(\"message\");\n      if (`STOP_COND_)\n        $fatal;\n    end\n  end // always @(posedge)\n`endif // not def SYNTHESIS\n```\n\n### circt\\_chisel\\_assume\u00a0[\u00b6](#circt_chisel_assume)\n\nGenerate a clocked SV assume statement, with optional formatted error message.\n\n| Parameter | Type | Description |\n| --- | --- | --- |\n| format | string | FIRRTL format string. Optional. |\n| label | string | Label for assume statement. Optional. |\n| guards | string | Semicolon-delimited list of pre-processor tokens to use as ifdef guards. Optional. |\n\n| Argument | Type | Description |\n| --- | --- | --- |\n| clock | Clock | input clock |\n| predicate | UInt<1> | predicate to assume |\n| enable | UInt<1> | enable signal |\n| \u2026 | Signals | arguments to format string |\n\nExample SV output:\n\n```\nassume__label: assume property (@(posedge clock) ~enable | cond) else $error(\"message\");\t\n```\n\n### circt\\_chisel\\_cover\u00a0[\u00b6](#circt_chisel_cover)\n\nGenerate a clocked SV cover statement.\n\n| Parameter | Type | Description |\n| --- | --- | --- |\n| label | string | Label for cover statement. Optional. |\n| guards | string | Semicolon-delimited list of pre-processor tokens to use as ifdef guards. Optional. |\n\n| Argument | Type | Description |\n| --- | --- | --- |\n| clock | Clock | input clock |\n| predicate | UInt<1> | predicate to cover |\n| enable | UInt<1> | enable signal |\n\nExample SV output:\n\n```\ncover__label: cover property (@(posedge clock) enable & cond);\n```\n\n### circt\\_unclocked\\_assume\u00a0[\u00b6](#circt_unclocked_assume)\n\nGenerate a SV assume statement whose predicate is used in a sensitivity list of the enclosing always block.\n\n| Parameter | Type | Description |\n| --- | --- | --- |\n| format | string | FIRRTL format string. Optional. |\n| label | string | Label for assume statement. Optional. |\n| guards | string | Semicolon-delimited list of pre-processor tokens to use as ifdef guards. Optional. |\n\n| Argument | Type | Description |\n| --- | --- | --- |\n| predicate | UInt<1> | predicate to assume |\n| enable | UInt<1> | enable signal |\n| \u2026 | Signals | arguments to format string |\n\nExample SV output:\n\n```\nifdef USE_FORMAL_ONLY_CONSTRAINTS\n `ifdef USE_UNR_ONLY_CONSTRAINTS\n   wire _GEN = ~enable | pred;\n   always @(edge _GEN)\n     assume_label: assume(_GEN) else $error(\"Conditional compilation example for UNR-only and formal-only assert\");\n `endif // USE_UNR_ONLY_CONSTRAINTS\nendif // USE_FORMAL_ONLY_CONSTRAINTS\n```\n\n### circt\\_dpi\\_call\u00a0[\u00b6](#circt_dpi_call)\n\nCall a DPI function. `clock` is optional and if `clock` is not provided,\nthe callee is invoked when input values are changed.\nIf provided, the dpi function is called at clock\u2019s posedge. The result values behave\nlike registers and the DPI function is used as a state transfer function of them.\n\n`enable` operand is used to conditionally call the DPI since DPI call could be quite\nmore expensive than native constructs. When `enable` is low, results of unclocked\ncalls are undefined and evaluated into `X`. Users are expected to gate result values\nby another `enable` to model a default value of results.\n\nFor clocked calls, a low enable means that its register state transfer function is\nnot called. Hence their values will not be modify in that clock.\n\n| Parameter | Type | Description |\n| --- | --- | --- |\n| isClocked | int | Set 1 if the dpi call is clocked. |\n| functionName | string | Specify the function name. |\n| inputNames | string | Semicolon-delimited list of input names. Optional. |\n| outputName | string | Output name. Optional. |\n\n| Argument | Type | Description |\n| --- | --- | --- |\n| clock (optional) | Clock | Optional clock operand |\n| enable | UInt<1> | Enable signal |\n| \u2026 | Signals | Arguments to DPI function call |\n\n| Result | Type | Description |\n| --- | --- | --- |\n| result (optional) | Signal | Optional result of the dpi call |\n\n#### DPI Intrinsic ABI\u00a0[\u00b6](#dpi-intrinsic-abi)\n\nFunction Declaration:\n\n* Imported DPI function must be a void function that has input arguments which correspond to operand types, and an output argument which correspond to a result type.\n* Output argument must be a last argument.\n\nTypes:\n\n* Operand and result types must be passive.\n* A vector is lowered to an unpacked open array type, e.g. `a: Vec<4, UInt<8>>` to `byte a []`.\n* A bundle is lowered to a packed struct.\n* Integer types are lowered into into 2-state types.\n* Small integer types (< 64 bit) must be compatible to C-types and arguments are passed by values. Users are required to use specific integer types for small integers shown in the table below. Large integers are lowered to `bit` and passed by a reference.\n\n| Width | Verilog Type | Argument Passing Modes |\n| --- | --- | --- |\n| 1 | bit | value |\n| 8 | byte | value |\n| 16 | shortint | value |\n| 32 | int | value |\n| 64 | longint | value |\n| > 64 | bit [w-1:0] | reference |\n\nExample SV output:\n\n```\nnode result = intrinsic(circt_dpi_call<isClocked = 1, functionName=\"dpi_func\"> : UInt<64>, clock, enable, uint_8_value, uint_32_value, uint_8_vector)\n```\n\n```\nimport \"DPI-C\" function void dpi_func(\n  input  byte    in_0,\n         int     in_1,\n         byte    in_2[],\n  output longint out_0\n);\n\n...\n\nlogic [63:0] _dpi_func_0;\nreg   [63:0] _GEN;\nalways @(posedge clock) begin\n  if (enable) begin\n    dpi_func(in1, in2, _dpi_func_0);\n    _GEN <= _dpi_func_0;\n  end\nend\n```\n\n### circt\\_view\u00a0[\u00b6](#circt_view)\n\nThis will become a SystemVerilog Interface that is driven by its arguments.\nThis is *not* a true SystemVerilog Interface, it is only lowered to one.\n\n| Parameter | Type | Description |\n| --- | --- | --- |\n| name | string | Instance name of the view. |\n| info | string | JSON encoding the view structure. |\n| yaml | string | Optional path to emit YAML description. |\n\n| Argument | Type | Description |\n| --- | --- | --- |\n| \u2026 | Ground | Leaf ground values for the view |\n\nThe structure of the view is encoded using JSON, with the top-level object\nrequired to be an `AugmentedBundleType`.\n\nThe intrinsic operands correspond to the `AugmentedGroundType` leaves,\nand must be of ground type.\n\nThis encoding is a trimmed version of what\u2019s used for the old GrandCentral View\nannotation.\n\nExample usage:\n\n```\ncircuit ViewExample:\n  public module ViewExample:\n    input in : { x : UInt<2>, y : { z : UInt<3>[2] } }\n    intrinsic(circt_view<name=\"view\", info=\"{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedBundleType\\\",\\\"defName\\\":\\\"ViewName\\\",\\\"elements\\\":[{\\\"description\\\":\\\"X marks the spot\\\",\\\"name\\\":\\\"x\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\"}},{\\\"description\\\":\\\"y bundle\\\",\\\"name\\\":\\\"y\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedBundleType\\\",\\\"defName\\\":\\\"YView\\\",\\\"elements\\\":[{\\\"name\\\":\\\"z\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedVectorType\\\",\\\"elements\\\":[{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\"},{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\"}]}}]}}]}\">, in.x, in.y.z[0], in.y.z[1])\n```\n\nExample Output:\n\n```\nmodule ViewExample(\n  input [1:0] in_x,\n  input [2:0] in_y_z_0,\n              in_y_z_1\n);\n\n  ViewName view();\n  assign view.x = in_x;\n  assign view.y.z[0] = in_y_z_0;\n  assign view.y.z[1] = in_y_z_1;\nendmodule\n\n// VCS coverage exclude_file\ninterface ViewName;\n  // X marks the spot\n  logic [1:0] x;\n  // y bundle\n  YView y();\nendinterface\n\n// VCS coverage exclude_file\ninterface YView;\n  logic [2:0] z[0:1];\nendinterface\n```\n\n#### AugmentedGroundType\u00a0[\u00b6](#augmentedgroundtype)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.grandcentral.AugmentedGroundType` |\n\nCreates a SystemVerilog logic type.\n\nEach ground type corresponds to an operand to the view intrinsic.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\"\n}\n```\n\n#### AugmentedVectorType\u00a0[\u00b6](#augmentedvectortype)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | `sifive.enterprise.grandcentral.AugmentedVectorType` |\n| elements | array | List of augmented types. |\n\nCreates a SystemVerilog unpacked array.\n\nExample:\n\n```\n{\n  \"class\": \"sifive.enterprise.grandcentral.AugmentedVectorType\",\n  \"elements\": [\n    {\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\"\n    },\n    {\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\"\n    }\n  ]\n}\n```\n\n#### AugmentedField\u00a0[\u00b6](#augmentedfield)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| name | string | Name of the field |\n| description | string | A textual description of this type |\n| tpe | string | A nested augmented type |\n\nA field in an augmented bundle type. This can provide a small description of\nwhat the field in the bundle is.\n\n#### AugmentedBundleType\u00a0[\u00b6](#augmentedbundletype)\n\n| Property | Type | Description |\n| --- | --- | --- |\n| class | string | sifive.enterprise.grandcentral.AugmentedBundleType |\n| defName | string | The name of the SystemVerilog interface. May be renamed. |\n| elements | array | List of AugmentedFields |\n\nCreates a SystemVerilog interface for each bundle type.\n\n### circt\\_verif\\_assert\u00a0[\u00b6](#circt_verif_assert)\n\nAsserts that a property holds.\nThe property may be an boolean, sequence, or property.\nBooleans are represented as `UInt<1>` values.\nSequences and properties are defined by the corresponding `circt_ltl_*` intrinsics and are also represented as `UInt<1>`, but are converted into dedicated sequence and property types later in the compiler.\n\n| Parameter | Type | Description |\n| --- | --- | --- |\n| label | string | Optional user-defined label |\n\n| Argument | Type | Description |\n| --- | --- | --- |\n| property | UInt<1> | A property to be checked. |\n| enable | UInt<1> | Optional enable condition. |\n|  |  | If 0, behaves as if the assert was not present. |\n\n### circt\\_verif\\_assume\u00a0[\u00b6](#circt_verif_assume)\n\nAssumes that a property holds.\nOtherwise behaves like\n[`circt_verif_assert`](#circt_verif_assert).\n\n### circt\\_verif\\_cover\u00a0[\u00b6](#circt_verif_cover)\n\nChecks that a property holds at least once, or can hold at all.\nOtherwise behaves like\n[`circt_verif_assert`](#circt_verif_assert).\n\n### circt\\_verif\\_require\u00a0[\u00b6](#circt_verif_require)\n\nRequires that a property holds as a pre-condition to a contract.\nGets converted into an assert if used outside of a FIRRTL `contract`.\nOtherwise behaves like\n[`circt_verif_assert`](#circt_verif_assert).\n\n### circt\\_verif\\_ensure\u00a0[\u00b6](#circt_verif_ensure)\n\nEnsures that a property holds as a post-condition of a contract.\nGets converted into an assert if used outside of a FIRRTL `contract`.\nOtherwise behaves like\n[`circt_verif_assert`](#circt_verif_assert).\n\n [Prev - FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/ \"FIRRTL Dialect Rationale\")\n[Next - 'fsm' Dialect](https://circt.llvm.org/docs/Dialects/FSM/ \"'fsm' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect-](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/FSM/index.md"
  },
  {
    "role": "user",
    "content": "'fsm' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'fsm' Dialect\n=============\n\n*Types and operations for FSM dialect*\n\nThis dialect defines the `fsm` dialect, which is intended to represent\nfinite-state machines.\n\n* [Operations](#operations)\n  + [`fsm.hw_instance` (::circt::fsm::HWInstanceOp)](#fsmhw_instance-circtfsmhwinstanceop)\n  + [`fsm.instance` (::circt::fsm::InstanceOp)](#fsminstance-circtfsminstanceop)\n  + [`fsm.machine` (::circt::fsm::MachineOp)](#fsmmachine-circtfsmmachineop)\n  + [`fsm.output` (::circt::fsm::OutputOp)](#fsmoutput-circtfsmoutputop)\n  + [`fsm.return` (::circt::fsm::ReturnOp)](#fsmreturn-circtfsmreturnop)\n  + [`fsm.state` (::circt::fsm::StateOp)](#fsmstate-circtfsmstateop)\n  + [`fsm.transition` (::circt::fsm::TransitionOp)](#fsmtransition-circtfsmtransitionop)\n  + [`fsm.trigger` (::circt::fsm::TriggerOp)](#fsmtrigger-circtfsmtriggerop)\n  + [`fsm.update` (::circt::fsm::UpdateOp)](#fsmupdate-circtfsmupdateop)\n  + [`fsm.variable` (::circt::fsm::VariableOp)](#fsmvariable-circtfsmvariableop)\n* [Types](#types)\n  + [InstanceType](#instancetype)\n\nOperations\n----------\n\n### `fsm.hw_instance` (::circt::fsm::HWInstanceOp)\n\n*Create a hardware-style instance of a state machine*\n\nSyntax:\n\n```\noperation ::= `fsm.hw_instance` $name $machine attr-dict `(` $inputs `)`\n              `,` `clock` $clock `,` `reset` $reset `:` functional-type($inputs, $outputs)\n```\n\n`fsm.hw_instance` represents a hardware-style instance of a state machine,\nincluding an instance name and a symbol reference of the machine. The inputs\nand outputs are correponding to the inputs and outputs of the referenced\nmachine.\n\nInterfaces: `InstanceOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `machine` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n| `clock` | A type for clock-carrying wires |\n| `reset` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `fsm.instance` (::circt::fsm::InstanceOp)\n\n*Create an instance of a state machine*\n\nSyntax:\n\n```\noperation ::= `fsm.instance` $name $machine attr-dict\n```\n\n`fsm.instance` represents an instance of a state machine, including an\ninstance name and a symbol reference of the machine.\n\nInterfaces: `HasCustomSSAName`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `machine` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `instance` | An FSM instance type |\n\n### `fsm.machine` (::circt::fsm::MachineOp)\n\n*Define a finite-state machine*\n\n`fsm.machine` represents a finite-state machine, including a machine name,\nthe type of machine state, and the types of inputs and outputs. This op also\nincludes a `$body` region that contains internal variables and states.\n\nTraits: `NoTerminator`, `SymbolTable`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallableOpInterface`, `FunctionOpInterface`, `ModuleOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `initialState` | ::mlir::StringAttr | string attribute |\n| `function_type` | ::mlir::TypeAttr | type attribute of function type |\n| `arg_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `res_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `argNames` | ::mlir::ArrayAttr | string array attribute |\n| `resNames` | ::mlir::ArrayAttr | string array attribute |\n\n### `fsm.output` (::circt::fsm::OutputOp)\n\n*Output values from a state machine*\n\nSyntax:\n\n```\noperation ::= `fsm.output` attr-dict ($operands^ `:` qualified(type($operands)))?\n```\n\n\u201cfsm.output\u201d represents the outputs of a machine under a specific state. The\ntypes of `$operands` should be consistent with the output types of the state\nmachine.\n\nTraits: `HasParent<StateOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `RegionBranchTerminatorOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operands` | variadic of any type |\n\n### `fsm.return` (::circt::fsm::ReturnOp)\n\n*Return values from a region*\n\nSyntax:\n\n```\noperation ::= `fsm.return` attr-dict ($operand^)?\n```\n\n\u201cfsm.return\u201d marks the end of a region of `fsm.transition` and return\nvalues if the parent region is a `$guard` region.\n\nTraits: `HasParent<TransitionOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `RegionBranchTerminatorOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operand` | 1-bit signless integer |\n\n### `fsm.state` (::circt::fsm::StateOp)\n\n*Define a state of a machine*\n\nSyntax:\n\n```\noperation ::= `fsm.state` $sym_name attr-dict (`output` $output^)? (`transitions` $transitions^)?\n```\n\n`fsm.state` represents a state of a state machine. This op includes an\n`$output` region with an `fsm.output` as terminator to define the machine\noutputs under this state. This op also includes a `transitions` region that\ncontains all the transitions of this state.\n\nTraits: `HasParent<MachineOp>`, `NoTerminator`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `fsm.transition` (::circt::fsm::TransitionOp)\n\n*Define a transition of a state*\n\nSyntax:\n\n```\noperation ::= `fsm.transition` $nextState attr-dict (`guard` $guard^)? (`action` $action^)?\n```\n\n`fsm.transition` represents a transition of a state with a symbol reference\nof the next state. This op includes an optional `$guard` region with an `fsm.return`\nas terminator that returns a Boolean value indicating the guard condition of\nthis transition. This op also includes an optional `$action` region that represents\nthe actions to be executed when this transition is taken.\n\nTraits: `HasParent<StateOp>`, `NoTerminator`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `nextState` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n### `fsm.trigger` (::circt::fsm::TriggerOp)\n\n*Trigger an instance*\n\nSyntax:\n\n```\noperation ::= `fsm.trigger` $instance attr-dict `(` $inputs `)` `:` functional-type($inputs, $outputs)\n```\n\n`fsm.trigger` triggers a state machine instance. The inputs and outputs are\ncorreponding to the inputs and outputs of the referenced machine of the\ninstance.\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n| `instance` | An FSM instance type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `fsm.update` (::circt::fsm::UpdateOp)\n\n*Update a variable in a state machine*\n\nSyntax:\n\n```\noperation ::= `fsm.update` attr-dict $variable `,` $value `:` qualified(type($value))\n```\n\n`fsm.update` updates the `$variable` with the `$value`. The definition op of\n`$variable` should be an `fsm.variable`. This op should *only* appear in the\n`action` region of a transtion.\n\nTraits: `HasParent<TransitionOp>`, `SameTypeOperands`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `variable` | any type |\n| `value` | any type |\n\n### `fsm.variable` (::circt::fsm::VariableOp)\n\n*Declare a variable in a state machine*\n\nSyntax:\n\n```\noperation ::= `fsm.variable` $name attr-dict `:` qualified(type($result))\n```\n\n`fsm.variable` represents an internal variable in a state machine with an\ninitialization value.\n\nTraits: `FirstAttrDerivedResultType`, `HasParent<MachineOp>`\n\nInterfaces: `HasCustomSSAName`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `initValue` | ::mlir::Attribute | any attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\nTypes\n-----\n\n### InstanceType\n\n*An FSM instance type*\n\nSyntax: `!fsm.instance`\n\nRepresents an FSM instance.\n\n'fsm' Dialect Docs\n------------------\n\n* [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n\n [Prev - Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/ \"Intrinsics\")\n[Next - FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/ \"FSM Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/FSM/RationaleFSM/index.md"
  },
  {
    "role": "user",
    "content": "FSM Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nFSM Dialect Rationale\n=====================\n\nThis document describes various design points of the FSM dialect, why they are\nthe way they are, and current status. This follows in the spirit of other\n[MLIR Rationale docs](https://mlir.llvm.org/docs/Rationale/).\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\n[Finite-state machine (FSM)](https://en.wikipedia.org/wiki/Finite-state_machine)\nis an abstract machine that can be in exactly one of a finite number of states\nat any given time. The FSM can change from one state to another in response to\nsome inputs; the change from one state to another is called a transition.\nVerification, Hardware IP block control, system state control, hardware design,\nand software design have aspects that are succinctly described as some form of\nFSM. For integrated development purposes, late design-time choice, and\nper-project choice, we want to encode system descriptions in an FSM form. We\nwant a compiler to be able to manipulate, query, and generate code in multiple\ndomains, such as SW drivers, firmware, RTL hardware, and verification.\n\nThe FSM dialect in CIRCT is designed to provide a set of abstractions for FSM\nwith the following features:\n\n1. Provide explicit and structural representations of states, transitions, and\n   internal variables of an FSM, allowing convenient analysis and transformation.\n2. Provide a target-agnostic representation of FSM, allowing the state machine\n   to be instantiated and attached to other dialects from different domains.\n3. By cooperating with two conversion passes, FSMToSV and FSMToStandard, allow\n   to lower the FSM abstraction into HW+Comb+SV (Hardware) and Standard+SCF+MemRef\n   (Software) dialects for the purposes of simulation, code generation, etc.\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### Two ways of instantiation\u00a0[\u00b6](#two-ways-of-instantiation)\n\nA state machine is defined by an `fsm.machine` operation, which contains all\nthe states and transitions of the state machine. `fsm.machine` has a list of\ninputs and outputs and explicit state type:\n\n```\nfsm.machine @foo(%arg0: i1) -> i1 attributes {stateType = i1} {\n  ...\n}\n```\n\nFSM dialect provides two ways to instantiate a state machine: `fsm.hw_instance`\nis intended for use in HW context (usually described by graph regions) and\n`fsm.instance`+`fsm.trigger` is intended for use in a SW context (usually\ndescribed by CFG regions). In HW IRs (such as HW+Comb+SV and FIRRTL), although\nan MLIR value is only defined once in the IR, it is actually \u201cdriven\u201d by its\npredecessors continuously during the runtime and can \u201chold\u201d different values at\ndifferent moments. However, in the world of SW IRs (such as Standard+SCF), we\ndon\u2019t have such a semantics \u2013 SW IRs \u201crun\u201d sequentially.\n\nHere we define that each *trigger* causes the possibility of a transition from\none state to another state through exactly one transition. In a SW context,\n`fsm.instance` generates an `InstanceType` value to represent a state machine\ninstance. Each `fsm.trigger` targets a machine instance and explicitly causes a\n*trigger*. Therefore, `fsm.trigger` may change the state of the machine\ninstance thus is a side-effecting operation. The following MLIR code shows an\nexample of instantiating and triggering the state machine defined above:\n\n```\nfunc @bar() {\n  %foo_inst = fsm.instance \"foo_inst\" @foo\n  %in0 = ...\n  %out0 = fsm.trigger %foo_inst(%in0) : (i1) -> i1\n  ...\n  %in1 = ...\n  %out1 = fsm.trigger %foo_inst(%in1) : (i1) -> i1\n  return\n}\n```\n\nIn the contrast, to comply with the HW semantics, `fsm.hw_instance` directly\nconsumes inputs and generates results. The operand and result types must align\nwith the type of the referenced `fsm.machine`. In a HW context, *trigger*s are\nimplicitly initiated by the processors of `fsm.hw_instance`. The following\nMLIR code shows an example of instantiating the same state machine in HW IRs:\n\n```\nhw.module @qux() {\n  %in = ...\n  %out = fsm.hw_instance \"foo_inst\" @foo(%in) : (i1) -> i1\n}\n```\n\n### Explicit state and transition representation\u00a0[\u00b6](#explicit-state-and-transition-representation)\n\nEach state of an FSM is represented explicitly with an `fsm.state` operation.\n`fsm.state` must have an `output` CFG region representing the combinational\nlogic of generating the state machine\u2019s outputs. The output region must have an\n`fsm.output` operation as terminator and the operand types of the `fsm.output`\nmust align with the result types of the state machine. `fsm.state` also\ncontains a list of `fsm.transition` operations representing the outgoing\ntransitions that can be triggered from the current state. `fsm.state` also has\na symbol name that can be referred to by `fsm.transition`s as the next state.\nThe following MLIR code shows a running example:\n\n```\nfsm.machine @foo(%arg0: i1) -> i1 attributes {stateType = i1} {\n  fsm.state \"IDLE\" output  {\n    %true = constant true\n    fsm.output %true : i1\n  } transitions  {\n    fsm.transition @BUSY ...\n  }\n\n  fsm.state \"BUSY\" output  {\n    %false = constant false\n    fsm.output %false : i1\n  } transitions  {\n    fsm.transition @BUSY ...\n    fsm.transition @IDLE ...\n  }\n}\n```\n\n### Guard region of transitions\u00a0[\u00b6](#guard-region-of-transitions)\n\n`fsm.transition` has an optional `guard` CFG region, which must be terminated\nwith an `fsm.return` operation returning a Boolean value to indicate whether\nthe transition is taken:\n\n```\nfsm.machine @foo(%arg0: i1) -> i1 attributes {stateType = i1} {\n  fsm.state \"IDLE\" output  {\n    %true = constant true\n    fsm.output %true : i1\n  } transitions  {\n    fsm.transition @BUSY guard  {\n      fsm.return %arg0 : i1\n    }\n  }\n  ...\n}\n```\n\nIf a state has more than one transition, multiple transitions are prioritized\nin the order that they appear in the transitions region. Guards must also not\ncontain any operations with side effects, enabling the evaluation of guards to\nbe parallelized. Note that an empty guard region is evaluated as true, which\nmeans the corresponding transition is always taken.\n\n### Action region of transitions and internal variables\u00a0[\u00b6](#action-region-of-transitions-and-internal-variables)\n\nTo avoid *state explosion*, we introduce `fsm.variable` operation (similar to\nthe\n[extended state](https://en.wikipedia.org/wiki/UML_state_machine) in UML\nstate machine) which represents a variable associated with an FSM instance and\ncan hold a value of any type, which can be updated through `fsm.update`\noperations.\n\n`fsm.transition` has an optional `action` CFG region representing the actions\nassociated with the current transition. The action region can contain\nside-effecting operations. `fsm.update` must be contained by the action region\nof a transition. The following MLIR code shows a running example:\n\n```\nfsm.machine @foo(%arg0: i1) -> i1 attributes {stateType = i1} {\n  %cnt = fsm.variable \"cnt\" {initValue = 0 : i16} : i16\n  fsm.state \"IDLE\" output  {\n    %true = constant true\n    fsm.output %true : i1\n  } transitions  {\n    fsm.transition @BUSY guard  {\n      fsm.return %arg0 : i1\n    } action  {\n      %c256_i16 = constant 256 : i16\n      fsm.update %cnt, %c256_i16 : i16\n    }\n  }\n  ...\n}\n```\n\n [Prev - 'fsm' Dialect](https://circt.llvm.org/docs/Dialects/FSM/ \"'fsm' Dialect\")\n[Next - 'handshake' Dialect](https://circt.llvm.org/docs/Dialects/Handshake/ \"'handshake' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect-](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Handshake/index.md"
  },
  {
    "role": "user",
    "content": "'handshake' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'handshake' Dialect\n===================\n\n*Types and operations for the handshake dialect*\n\nThis dialect defined the `handshake` dialect, modeling dataflow circuits.\nHandshake/dataflow IR is describes independent, unsynchronized processes\ncommunicating data through First-in First-out (FIFO) communication channels.\n\n* [Operations](#operations)\n  + [`handshake.br` (::circt::handshake::BranchOp)](#handshakebr-circthandshakebranchop)\n  + [`handshake.buffer` (::circt::handshake::BufferOp)](#handshakebuffer-circthandshakebufferop)\n  + [`handshake.cond_br` (::circt::handshake::ConditionalBranchOp)](#handshakecond_br-circthandshakeconditionalbranchop)\n  + [`handshake.constant` (::circt::handshake::ConstantOp)](#handshakeconstant-circthandshakeconstantop)\n  + [`handshake.control_merge` (::circt::handshake::ControlMergeOp)](#handshakecontrol_merge-circthandshakecontrolmergeop)\n  + [`handshake.esi_instance` (::circt::handshake::ESIInstanceOp)](#handshakeesi_instance-circthandshakeesiinstanceop)\n  + [`handshake.extmemory` (::circt::handshake::ExternalMemoryOp)](#handshakeextmemory-circthandshakeexternalmemoryop)\n  + [`handshake.fork` (::circt::handshake::ForkOp)](#handshakefork-circthandshakeforkop)\n  + [`handshake.func` (::circt::handshake::FuncOp)](#handshakefunc-circthandshakefuncop)\n  + [`handshake.instance` (::circt::handshake::InstanceOp)](#handshakeinstance-circthandshakeinstanceop)\n  + [`handshake.join` (::circt::handshake::JoinOp)](#handshakejoin-circthandshakejoinop)\n  + [`handshake.lazy_fork` (::circt::handshake::LazyForkOp)](#handshakelazy_fork-circthandshakelazyforkop)\n  + [`handshake.load` (::circt::handshake::LoadOp)](#handshakeload-circthandshakeloadop)\n  + [`handshake.memory` (::circt::handshake::MemoryOp)](#handshakememory-circthandshakememoryop)\n  + [`handshake.merge` (::circt::handshake::MergeOp)](#handshakemerge-circthandshakemergeop)\n  + [`handshake.mux` (::circt::handshake::MuxOp)](#handshakemux-circthandshakemuxop)\n  + [`handshake.never` (::circt::handshake::NeverOp)](#handshakenever-circthandshakeneverop)\n  + [`handshake.pack` (::circt::handshake::PackOp)](#handshakepack-circthandshakepackop)\n  + [`handshake.return` (::circt::handshake::ReturnOp)](#handshakereturn-circthandshakereturnop)\n  + [`handshake.sink` (::circt::handshake::SinkOp)](#handshakesink-circthandshakesinkop)\n  + [`handshake.source` (::circt::handshake::SourceOp)](#handshakesource-circthandshakesourceop)\n  + [`handshake.store` (::circt::handshake::StoreOp)](#handshakestore-circthandshakestoreop)\n  + [`handshake.sync` (::circt::handshake::SyncOp)](#handshakesync-circthandshakesyncop)\n  + [`handshake.unpack` (::circt::handshake::UnpackOp)](#handshakeunpack-circthandshakeunpackop)\n* [Attributes](#attributes-7)\n  + [BufferTypeEnumAttr](#buffertypeenumattr)\n* [Enums](#enums)\n  + [BufferTypeEnum](#buffertypeenum)\n\nOperations\n----------\n\n### `handshake.br` (::circt::handshake::BranchOp)\n\n*Branch operation*\n\nThe branch operation represents an unconditional\nbranch. The single data input is propagated to the single\nsuccessor. The input must be triggered by some predecessor to\navoid continous triggering of a successor block.\n\nExample:\n\n```\n%1 = br %0 : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `InferTypeOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dataOperand` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `dataResult` | any type |\n\n### `handshake.buffer` (::circt::handshake::BufferOp)\n\n*Buffer operation*\n\nThe buffer operation represents a buffer operation. $slots\nmust be an unsigned integer larger than 0. $bufferType=BufferTypeEnum::seq indicates a\nnontransparent buffer, while $bufferType=BufferTypeEnum::fifo indicates a transparent\nbuffer.\n\nAn \u2018initValues\u2019 attribute containing a list of integer values may be provided.\nThe list must be of the same length as the number of slots. This will\ninitialize the buffer with the given values upon reset.\nFor now, only sequential buffers are allowed to have initial values.\n@todo: How to support different init types? these have to be stored (and\nretrieved) as attributes, hence they must be of a known type.\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `InferTypeOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `slots` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 1 |\n| `bufferType` | ::circt::handshake::BufferTypeEnumAttr | BufferOp seq or fifo |\n| `initValues` | ::mlir::ArrayAttr | 64-bit integer array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operand` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `handshake.cond_br` (::circt::handshake::ConditionalBranchOp)\n\n*Conditional branch operation*\n\nThe cbranch operation represents a conditional\nbranch. The data input is propagated to one of the two outputs\nbased on the condition input.\n\nExample:\n\n```\n%true, %false = conditional_branch %cond, %data : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `InferTypeOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `conditionOperand` | 1-bit signless integer |\n| `dataOperand` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `trueResult` | any type |\n| `falseResult` | any type |\n\n### `handshake.constant` (::circt::handshake::ConstantOp)\n\n*Constant operation*\n\nSyntax:\n\n```\noperation ::= `handshake.constant` $ctrl attr-dict `:` qualified(type($result))\n```\n\nThe const has a constant value. When triggered by its\nsingle `ctrl` input, it sends the constant value to its single\nsuccessor.\n\nExample:\n\n```\n%0 = constant %ctrl {value = 42 : i32} : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::TypedAttr | TypedAttr instance |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `ctrl` | none type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `handshake.control_merge` (::circt::handshake::ControlMergeOp)\n\n*Control merge operation*\n\nThe control\\_merge operation represents a\n(nondeterministic) control merge. Any input is propagated to the\nfirst output and the index of the propagated input is sent to the\nsecond output. The number of inputs corresponds to the number of\npredecessor blocks.\n\nExample:\n\n```\n%0, %idx = control_merge %a, %b, %c {attributes} : i32, index\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `MergeLikeOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dataOperands` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n| `index` | any type |\n\n### `handshake.esi_instance` (::circt::handshake::ESIInstanceOp)\n\n*Instantiate a Handshake circuit*\n\nSyntax:\n\n```\noperation ::= `handshake.esi_instance` $module $instName `clk` $clk `rst` $rst\n              `(` $opOperands `)` attr-dict `:` functional-type($opOperands, results)\n```\n\nInstantiate (call) a Handshake function in a non-Handshake design using ESI\nchannels as the outside connections.\n\nTraits: `HasClock`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `module` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `instName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `opOperands` | variadic of an ESI channel |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| \u00abunnamed\u00bb | variadic of an ESI channel |\n\n### `handshake.extmemory` (::circt::handshake::ExternalMemoryOp)\n\n*External memory*\n\nSyntax:\n\n```\noperation ::= `handshake.extmemory` `[` `ld` `=` $ldCount `,` `st` `=`  $stCount `]` `(` $memref `:` qualified(type($memref)) `)` `(` $inputs `)` attr-dict `:` functional-type($inputs, $outputs)\n```\n\nAn ExternalMemoryOp represents a wrapper around a memref input to a\nhandshake function. The semantics of the load/store operands are identical\nto what is decribed for MemoryOp. The only difference is that the first\noperand to this operand is a `memref` value.\nUpon lowering to FIRRTL, a handshake interface will be created in the\ntop-level component for each load- and store which connected to this memory.\n\nExample:\n\n```\nhandshake.func @main(%i: index, %v: i32, %mem : memref<10xi32>, %ctrl: none) -> none {\n  %stCtrl = extmemory[ld = 0, st = 1](%mem : memref<10xi32>)(%vout, %addr) {id = 0 : i32} : (i32, index) -> (none)\n  %vout, %addr = store(%v, %i, %ctrl) : (i32, index, none) -> (i32, index)\n  ...\n}\n```\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `NamedIOInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `ldCount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `stCount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `id` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `memref` | memref of any type values |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `handshake.fork` (::circt::handshake::ForkOp)\n\n*Fork operation*\n\nThe fork operation represents a fork operation. A\nsingle input is replicated to N outputs and distributed to each\noutput as soon as the corresponding successor is available.\n\nExample:\n\n```\n%1:2 = fork [2] %0 : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operand` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | variadic of any type |\n\n### `handshake.func` (::circt::handshake::FuncOp)\n\n*Handshake dialect function.*\n\nThe func operation represents a handshaked function.\nThis is almost exactly like a standard FuncOp, except that it has\nsome extra verification conditions. In particular, each Value must\nonly have a single use.\n\nTraits: `HasClock`, `IsolatedFromAbove`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallableOpInterface`, `FineGrainedDataflowRegionOpInterface`, `FunctionOpInterface`, `OpAsmOpInterface`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `function_type` | ::mlir::TypeAttr | type attribute of function type |\n| `arg_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `res_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n\n### `handshake.instance` (::circt::handshake::InstanceOp)\n\n*Module instantiate operation*\n\nSyntax:\n\n```\noperation ::= `handshake.instance` $module `(` $opOperands `)` attr-dict `:` functional-type($opOperands, results)\n```\n\nThe `instance` operation represents the instantiation of a module. This\nis similar to a function call, except that different instances of the\nsame module are guaranteed to have their own distinct state.\nThe instantiated module is encoded as a symbol reference attribute named\n\u201cmodule\u201d. An instance operation takes a control input as its last argument\nand returns a control output as its last result.\n\nExample:\n\n```\n%2:2 = handshake.instance @my_add(%0, %1, %ctrl) : (f32, f32, none) -> (f32, none)\n```\n\nTraits: `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`, `ControlInterface`, `NamedIOInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `module` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `opOperands` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| \u00abunnamed\u00bb | variadic of any type |\n\n### `handshake.join` (::circt::handshake::JoinOp)\n\n*Join operation*\n\nA control-only synchronizer. Produces a valid output when all\ninputs become available.\n\nExample:\n\n```\n%0 = join %a, %b, %c : i32, i1, none\n```\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `InferTypeOpInterface`, `NamedIOInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `data` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | none type |\n\n### `handshake.lazy_fork` (::circt::handshake::LazyForkOp)\n\n*Lazy fork operation*\n\nThe lazy\\_fork operation represents a lazy fork operation.\nA single input is replicated to N outputs and distributed to each\noutput when all successors are available.\n\nExample:\n\n```\n%1:2 = lazy_fork [2] %0 : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operand` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | variadic of any type |\n\n### `handshake.load` (::circt::handshake::LoadOp)\n\n*Load operation*\n\nLoad memory port, sends load requests to MemoryOp. From dataflow\npredecessor, receives address indices and a control-only value\nwhich signals completion of all previous memory accesses which\ntarget the same memory. When all inputs are received, the load\nsends the address indices to MemoryOp. When the MemoryOp returns\na piece of data, the load sends it to its dataflow successor.\n\nOperands: address indices (from predecessor), data (from MemoryOp), control-only input.\nResults: data (to successor), address indices (to MemoryOp).\n\nExample:\n\n```\n%dataToSucc, %addr1ToMem, %addr2ToMem = load [%addr1, %addr2] %dataFromMem, %ctrl : i8, i16, index\n```\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `NamedIOInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `addresses` | variadic of any type |\n| `data` | any type |\n| `ctrl` | none type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `dataResult` | any type |\n| `addressResults` | variadic of any type |\n\n### `handshake.memory` (::circt::handshake::MemoryOp)\n\n*Memory*\n\nSyntax:\n\n```\noperation ::= `handshake.memory` `[` `ld` `=` $ldCount `,` `st` `=`  $stCount `]` `(` $inputs `)` attr-dict `:` $memRefType `,` functional-type($inputs, $outputs)\n```\n\nEach MemoryOp represents an independent memory or memory region (BRAM or external memory).\nIt receives memory access requests from load and store operations. For every request,\nit returns data (for load) and a data-less token indicating completion.\nThe memory op represents a flat, unidimensional memory.\nOperands: all stores (stdata1, staddr1, stdata2, staddr2, \u2026), then all loads (ldaddr1, ldaddr2,\u2026)\nOutputs: all load outputs, ordered the same as\nload data (lddata1, lddata2, \u2026), followed by all none outputs,\nordered as operands (stnone1, stnone2,\u2026ldnone1, ldnone2,\u2026)\n\nTraits: `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `MemoryOpInterface`, `NamedIOInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `ldCount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `stCount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `id` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `memRefType` | ::mlir::TypeAttr | memref type attribute |\n| `lsq` | ::mlir::IntegerAttr | 1-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `handshake.merge` (::circt::handshake::MergeOp)\n\n*Merge operation*\n\nThe merge operation represents a (nondeterministic)\nmerge operation. Any input is propagated to the single output. The\nnumber of inputs corresponds to the number of predecessor\nblocks.\n\nExample:\n\n```\n%0 = merge %a, %b, %c : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `MergeLikeOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dataOperands` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `handshake.mux` (::circt::handshake::MuxOp)\n\n*Mux operation*\n\nThe mux operation represents a(deterministic) merge operation.\nOperands: select, data0, data1, data2, \u2026\n\nThe \u2018select\u2019 operand is received from ControlMerge of the same\nblock and it represents the index of the data operand that the mux\nshould propagate to its single output. The number of data inputs\ncorresponds to the number of predecessor blocks.\n\nThe mux operation is intended solely for control+dataflow selection.\nFor purely dataflow selection, use the \u2018select\u2019 operation instead.\n\nExample:\n\n```\n%0 = mux %select [%data0, %data1, %data2] {attributes}: index, i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `InferTypeOpInterface`, `MergeLikeOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `selectOperand` | any type |\n| `dataOperands` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `handshake.never` (::circt::handshake::NeverOp)\n\n*Never operation*\n\nSyntax:\n\n```\noperation ::= `handshake.never` attr-dict `:` qualified(type($result))\n```\n\nThe never operation represents disconnected data\nsource. The source never sets any \u2018valid\u2019 signal which will\nnever trigger the successor at any point in time.\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `handshake.pack` (::circt::handshake::PackOp)\n\n*Packs a tuple*\n\nThe `pack` operation constructs a tuple from separate values.\nThe number of operands corresponds to the number of tuple elements.\nSimilar to `join`, the output is ready when all inputs are ready.\n\nExample:\n\n```\n%tuple = handshake.pack %a, %b {attributes} : tuple<i32, i64>\n```\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `NamedIOInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | Fixed-sized collection of other types |\n\n### `handshake.return` (::circt::handshake::ReturnOp)\n\n*Handshake dialect return.*\n\nSyntax:\n\n```\noperation ::= `handshake.return` attr-dict ($opOperands^ `:` type($opOperands))?\n```\n\nThe return operation represents a handshaked\nfunction. This is almost exactly like a standard ReturnOp, except\nthat it exists in a handshake.func. It has the same operands as\nstandard ReturnOp which it replaces and an additional control -\nonly operand(exit point of control - only network).\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`, `Terminator`\n\nInterfaces: `ControlInterface`, `NamedIOInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `opOperands` | variadic of any type |\n\n### `handshake.sink` (::circt::handshake::SinkOp)\n\n*Sink operation*\n\nThe sink operation discards any data that arrives at its\ninput.The sink has no successors and it can continuously consume data.\n\nExample:\n\n```\nsink %data : i32\n```\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `NamedIOInterface`, `SOSTInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operand` | any type |\n\n### `handshake.source` (::circt::handshake::SourceOp)\n\n*Source operation*\n\nThe source operation represents continuous token\nsource. The source continously sets a \u2018valid\u2019 signal which the\nsuccessor can consume at any point in time.\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `handshake.store` (::circt::handshake::StoreOp)\n\n*Store operation*\n\nStore memory port, sends store requests to MemoryOp. From dataflow\npredecessors, receives address indices, data, and a control-only\nvalue which signals completion of all previous memory accesses\nwhich target the same memory. When all inputs are received, the\nstore sends the address and data to MemoryOp.\n\nOperands: address indices, data, control-only input.\nResults: data and address indices (sent to MemoryOp).\nTypes: data type followed by address type.\n\nExample:\n\n```\n%dataToMem, %addrToMem = store [%addr1, %addr2] %dataFromPred , %ctrl : i8, i16, index\n```\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `NamedIOInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `addresses` | variadic of any type |\n| `data` | any type |\n| `ctrl` | none type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `dataResult` | any type |\n| `addressResult` | variadic of any type |\n\n### `handshake.sync` (::circt::handshake::SyncOp)\n\n*Sync operation*\n\nSyntax:\n\n```\noperation ::= `handshake.sync` $operands attr-dict `:` type($operands)\n```\n\nSynchronizes an arbitrary set of inputs. Synchronization implies applying\njoin semantics in between all in- and output ports.\n\nExample:\n\n```\n%aSynced, %bSynced, %cSynced = sync %a, %b, %c : i32, i1, none\n```\n\nTraits: `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `NamedIOInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operands` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `handshake.unpack` (::circt::handshake::UnpackOp)\n\n*Unpacks a tuple*\n\nThe `unpack` operation assigns each value of a tuple to a separate\nvalue for further processing. The number of results corresponds\nto the number of tuple elements.\nSimilar to `fork`, each output is distributed as soon as the corresponding\nsuccessor is ready.\n\nExample:\n\n```\n%a, %b = handshake.unpack %tuple {attributes} : tuple<i32, i64>\n```\n\nTraits: `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `NamedIOInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | Fixed-sized collection of other types |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\nAttributes\n----------\n\n### BufferTypeEnumAttr\n\n*BufferOp seq or fifo*\n\nSyntax:\n\n```\n#handshake.buffer_type_enum<\n  ::BufferTypeEnum   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `::BufferTypeEnum` | an enum of type BufferTypeEnum |\n\nEnums\n-----\n\n### BufferTypeEnum\n\n*BufferOp seq or fifo*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| seq | `0` | seq |\n| fifo | `1` | fifo |\n\n'handshake' Dialect Docs\n------------------------\n\n* [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n\n [Prev - FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/ \"FSM Dialect Rationale\")\n[Next - Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/ \"Handshake Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/index.md"
  },
  {
    "role": "user",
    "content": "Handshake Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nHandshake Dialect Rationale\n===========================\n\n* [Principle](#principle)\n* [Choice of MLIR](#choice-of-mlir)\n* [IR Representation](#ir-representation)\n* [Conventions](#conventions)\n* [Talks, Resources and Related Publications](#talks-resources-and-related-publications)\n* [Operation definitions](#operation-definitions)\n* [Operations](#operations)\n  + [`handshake.br` (::circt::handshake::BranchOp)](#handshakebr-circthandshakebranchop)\n  + [`handshake.buffer` (::circt::handshake::BufferOp)](#handshakebuffer-circthandshakebufferop)\n  + [`handshake.cond_br` (::circt::handshake::ConditionalBranchOp)](#handshakecond_br-circthandshakeconditionalbranchop)\n  + [`handshake.constant` (::circt::handshake::ConstantOp)](#handshakeconstant-circthandshakeconstantop)\n  + [`handshake.control_merge` (::circt::handshake::ControlMergeOp)](#handshakecontrol_merge-circthandshakecontrolmergeop)\n  + [`handshake.esi_instance` (::circt::handshake::ESIInstanceOp)](#handshakeesi_instance-circthandshakeesiinstanceop)\n  + [`handshake.extmemory` (::circt::handshake::ExternalMemoryOp)](#handshakeextmemory-circthandshakeexternalmemoryop)\n  + [`handshake.fork` (::circt::handshake::ForkOp)](#handshakefork-circthandshakeforkop)\n  + [`handshake.func` (::circt::handshake::FuncOp)](#handshakefunc-circthandshakefuncop)\n  + [`handshake.instance` (::circt::handshake::InstanceOp)](#handshakeinstance-circthandshakeinstanceop)\n  + [`handshake.join` (::circt::handshake::JoinOp)](#handshakejoin-circthandshakejoinop)\n  + [`handshake.lazy_fork` (::circt::handshake::LazyForkOp)](#handshakelazy_fork-circthandshakelazyforkop)\n  + [`handshake.load` (::circt::handshake::LoadOp)](#handshakeload-circthandshakeloadop)\n  + [`handshake.memory` (::circt::handshake::MemoryOp)](#handshakememory-circthandshakememoryop)\n  + [`handshake.merge` (::circt::handshake::MergeOp)](#handshakemerge-circthandshakemergeop)\n  + [`handshake.mux` (::circt::handshake::MuxOp)](#handshakemux-circthandshakemuxop)\n  + [`handshake.never` (::circt::handshake::NeverOp)](#handshakenever-circthandshakeneverop)\n  + [`handshake.pack` (::circt::handshake::PackOp)](#handshakepack-circthandshakepackop)\n  + [`handshake.return` (::circt::handshake::ReturnOp)](#handshakereturn-circthandshakereturnop)\n  + [`handshake.sink` (::circt::handshake::SinkOp)](#handshakesink-circthandshakesinkop)\n  + [`handshake.source` (::circt::handshake::SourceOp)](#handshakesource-circthandshakesourceop)\n  + [`handshake.store` (::circt::handshake::StoreOp)](#handshakestore-circthandshakestoreop)\n  + [`handshake.sync` (::circt::handshake::SyncOp)](#handshakesync-circthandshakesyncop)\n  + [`handshake.unpack` (::circt::handshake::UnpackOp)](#handshakeunpack-circthandshakeunpackop)\n* [Attributes](#attributes-7)\n  + [BufferTypeEnumAttr](#buffertypeenumattr)\n* [Enums](#enums)\n  + [BufferTypeEnum](#buffertypeenum)\n\nThis document also explains in a high-level manner how different components are\norganized, the principles behind them and the conventions we followed.\nThe document assume that you have basic understanding of\n[asynchronous digital circuits](https://en.wikipedia.org/wiki/Asynchronous_circuit)\nat the behavioral level of abstraction.\n\nPrinciple\u00a0[\u00b6](#principle)\n-------------------------\n\nHandshake/dataflow IR describes independent, unsynchronized processes\ncommunicating data through First-in First-out (FIFO) communication channels.\nThis can be implemented in many ways, such as using synchronous logic, or with\nprocessors.\n\nChoice of MLIR\u00a0[\u00b6](#choice-of-mlir)\n-----------------------------------\n\nMLIR is a common infrastructure to build your own specific IR to target\ndifferent architectures and needs. We use MLIR because of its extensibility. We\ncan apply the various transformations and optimization of MLIR on this IR. We\ncan also lower the std MLIR produced by different frontends to Handshake IR.\n\n```\n TensorFlow     LLVM       Pytorch\n      |           |           | \n |-----------------------------------|    \n |   MLIR                            |\n |         -----------------         |\n |         | opt/transform |         |\n |         -----------------         |\n |                                   |\n |         -----------------         |\n |         | opt/transform |         |\n |         -----------------         |\n |                                   |\n |-----------------------------------|\n    |        |        |             | \n   GPU      LLVM    Affine     **Dataflow**\n```\n\nIR Representation\u00a0[\u00b6](#ir-representation)\n-----------------------------------------\n\nSimple Handshake IR snippet for an add function looks like this -\n\n```\nhandshake.func @simple_addi(%arg0: index, %arg1: index, %arg2: none, ...) -> (index, none) {\n        %0 = addi %arg0, %arg1 : index\n        handshake.return %0, %arg2 : index, none\n}\n```\n\nIt accepts two input streams (modeled as MLIR operands) and produces one\noutput stream (modeled as an MLIR result).\n\nConventions\u00a0[\u00b6](#conventions)\n-----------------------------\n\nThe Handshake dialect adopts the following conventions for IR:\n\n* The prefix for all Handshake types and operations are `handshake.`.\n\nTalks, Resources and Related Publications\u00a0[\u00b6](#talks-resources-and-related-publications)\n----------------------------------------------------------------------------------------\n\n* (10/2022)\n  [Multi-Level Rewriting for Stream Processing to RTL compilation (M.Sc. Thesis) - Christian Ulmann](https://www.research-collection.ethz.ch/bitstream/handle/20.500.11850/578713/1/Ulmann_Christian.pdf)\n* (03/2022)\n  [HLS from PyTorch to System Verilog with MLIR and CIRCT (Workshop paper) - Mike Urbach, Morten Borup Petersen](https://capra.cs.cornell.edu/latte22/paper/2.pdf)\n* (01/2022)\n  [A Dynamically Scheduled HLS Flow in MLIR (M.Sc. Thesis) - Morten Borup Petersen](https://infoscience.epfl.ch/record/292189)\n* (06/2020) MLIR Handshake Dialect-\n  [slides](https://drive.google.com/file/d/1UYQAfHrzcsdXUZ93bHPTPNwrscwx89M-/view?usp=sharing) by Stephen Neuendorffer (Xilinx) + Lana Josipovi\u0107 (EPFL)\n\nOperation definitions\u00a0[\u00b6](#operation-definitions)\n-------------------------------------------------\n\n*Types and operations for the handshake dialect*\n\nThis dialect defined the `handshake` dialect, modeling dataflow circuits.\nHandshake/dataflow IR is describes independent, unsynchronized processes\ncommunicating data through First-in First-out (FIFO) communication channels.\n\n* [Principle](#principle)\n* [Choice of MLIR](#choice-of-mlir)\n* [IR Representation](#ir-representation)\n* [Conventions](#conventions)\n* [Talks, Resources and Related Publications](#talks-resources-and-related-publications)\n* [Operation definitions](#operation-definitions)\n* [Operations](#operations)\n  + [`handshake.br` (::circt::handshake::BranchOp)](#handshakebr-circthandshakebranchop)\n  + [`handshake.buffer` (::circt::handshake::BufferOp)](#handshakebuffer-circthandshakebufferop)\n  + [`handshake.cond_br` (::circt::handshake::ConditionalBranchOp)](#handshakecond_br-circthandshakeconditionalbranchop)\n  + [`handshake.constant` (::circt::handshake::ConstantOp)](#handshakeconstant-circthandshakeconstantop)\n  + [`handshake.control_merge` (::circt::handshake::ControlMergeOp)](#handshakecontrol_merge-circthandshakecontrolmergeop)\n  + [`handshake.esi_instance` (::circt::handshake::ESIInstanceOp)](#handshakeesi_instance-circthandshakeesiinstanceop)\n  + [`handshake.extmemory` (::circt::handshake::ExternalMemoryOp)](#handshakeextmemory-circthandshakeexternalmemoryop)\n  + [`handshake.fork` (::circt::handshake::ForkOp)](#handshakefork-circthandshakeforkop)\n  + [`handshake.func` (::circt::handshake::FuncOp)](#handshakefunc-circthandshakefuncop)\n  + [`handshake.instance` (::circt::handshake::InstanceOp)](#handshakeinstance-circthandshakeinstanceop)\n  + [`handshake.join` (::circt::handshake::JoinOp)](#handshakejoin-circthandshakejoinop)\n  + [`handshake.lazy_fork` (::circt::handshake::LazyForkOp)](#handshakelazy_fork-circthandshakelazyforkop)\n  + [`handshake.load` (::circt::handshake::LoadOp)](#handshakeload-circthandshakeloadop)\n  + [`handshake.memory` (::circt::handshake::MemoryOp)](#handshakememory-circthandshakememoryop)\n  + [`handshake.merge` (::circt::handshake::MergeOp)](#handshakemerge-circthandshakemergeop)\n  + [`handshake.mux` (::circt::handshake::MuxOp)](#handshakemux-circthandshakemuxop)\n  + [`handshake.never` (::circt::handshake::NeverOp)](#handshakenever-circthandshakeneverop)\n  + [`handshake.pack` (::circt::handshake::PackOp)](#handshakepack-circthandshakepackop)\n  + [`handshake.return` (::circt::handshake::ReturnOp)](#handshakereturn-circthandshakereturnop)\n  + [`handshake.sink` (::circt::handshake::SinkOp)](#handshakesink-circthandshakesinkop)\n  + [`handshake.source` (::circt::handshake::SourceOp)](#handshakesource-circthandshakesourceop)\n  + [`handshake.store` (::circt::handshake::StoreOp)](#handshakestore-circthandshakestoreop)\n  + [`handshake.sync` (::circt::handshake::SyncOp)](#handshakesync-circthandshakesyncop)\n  + [`handshake.unpack` (::circt::handshake::UnpackOp)](#handshakeunpack-circthandshakeunpackop)\n* [Attributes](#attributes-7)\n  + [BufferTypeEnumAttr](#buffertypeenumattr)\n* [Enums](#enums)\n  + [BufferTypeEnum](#buffertypeenum)\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `handshake.br` (::circt::handshake::BranchOp)\u00a0[\u00b6](#handshakebr-circthandshakebranchop)\n\n*Branch operation*\n\nThe branch operation represents an unconditional\nbranch. The single data input is propagated to the single\nsuccessor. The input must be triggered by some predecessor to\navoid continous triggering of a successor block.\n\nExample:\n\n```\n%1 = br %0 : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `InferTypeOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `dataOperand` | any type |\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| `dataResult` | any type |\n\n### `handshake.buffer` (::circt::handshake::BufferOp)\u00a0[\u00b6](#handshakebuffer-circthandshakebufferop)\n\n*Buffer operation*\n\nThe buffer operation represents a buffer operation. $slots\nmust be an unsigned integer larger than 0. $bufferType=BufferTypeEnum::seq indicates a\nnontransparent buffer, while $bufferType=BufferTypeEnum::fifo indicates a transparent\nbuffer.\n\nAn \u2018initValues\u2019 attribute containing a list of integer values may be provided.\nThe list must be of the same length as the number of slots. This will\ninitialize the buffer with the given values upon reset.\nFor now, only sequential buffers are allowed to have initial values.\n@todo: How to support different init types? these have to be stored (and\nretrieved) as attributes, hence they must be of a known type.\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `InferTypeOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `slots` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 1 |\n| `bufferType` | ::circt::handshake::BufferTypeEnumAttr | BufferOp seq or fifo |\n| `initValues` | ::mlir::ArrayAttr | 64-bit integer array attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `operand` | any type |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `handshake.cond_br` (::circt::handshake::ConditionalBranchOp)\u00a0[\u00b6](#handshakecond_br-circthandshakeconditionalbranchop)\n\n*Conditional branch operation*\n\nThe cbranch operation represents a conditional\nbranch. The data input is propagated to one of the two outputs\nbased on the condition input.\n\nExample:\n\n```\n%true, %false = conditional_branch %cond, %data : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `InferTypeOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `conditionOperand` | 1-bit signless integer |\n| `dataOperand` | any type |\n\n#### Results:\u00a0[\u00b6](#results-2)\n\n| Result | Description |\n| --- | --- |\n| `trueResult` | any type |\n| `falseResult` | any type |\n\n### `handshake.constant` (::circt::handshake::ConstantOp)\u00a0[\u00b6](#handshakeconstant-circthandshakeconstantop)\n\n*Constant operation*\n\nSyntax:\n\n```\noperation ::= `handshake.constant` $ctrl attr-dict `:` qualified(type($result))\n```\n\nThe const has a constant value. When triggered by its\nsingle `ctrl` input, it sends the constant value to its single\nsuccessor.\n\nExample:\n\n```\n%0 = constant %ctrl {value = 42 : i32} : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::TypedAttr | TypedAttr instance |\n\n#### Operands:\u00a0[\u00b6](#operands-3)\n\n| Operand | Description |\n| --- | --- |\n| `ctrl` | none type |\n\n#### Results:\u00a0[\u00b6](#results-3)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `handshake.control_merge` (::circt::handshake::ControlMergeOp)\u00a0[\u00b6](#handshakecontrol_merge-circthandshakecontrolmergeop)\n\n*Control merge operation*\n\nThe control\\_merge operation represents a\n(nondeterministic) control merge. Any input is propagated to the\nfirst output and the index of the propagated input is sent to the\nsecond output. The number of inputs corresponds to the number of\npredecessor blocks.\n\nExample:\n\n```\n%0, %idx = control_merge %a, %b, %c {attributes} : i32, index\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `MergeLikeOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-4)\n\n| Operand | Description |\n| --- | --- |\n| `dataOperands` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-4)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n| `index` | any type |\n\n### `handshake.esi_instance` (::circt::handshake::ESIInstanceOp)\u00a0[\u00b6](#handshakeesi_instance-circthandshakeesiinstanceop)\n\n*Instantiate a Handshake circuit*\n\nSyntax:\n\n```\noperation ::= `handshake.esi_instance` $module $instName `clk` $clk `rst` $rst\n              `(` $opOperands `)` attr-dict `:` functional-type($opOperands, results)\n```\n\nInstantiate (call) a Handshake function in a non-Handshake design using ESI\nchannels as the outside connections.\n\nTraits: `HasClock`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-2)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `module` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `instName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-5)\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n| `opOperands` | variadic of an ESI channel |\n\n#### Results:\u00a0[\u00b6](#results-5)\n\n| Result | Description |\n| --- | --- |\n| \u00abunnamed\u00bb | variadic of an ESI channel |\n\n### `handshake.extmemory` (::circt::handshake::ExternalMemoryOp)\u00a0[\u00b6](#handshakeextmemory-circthandshakeexternalmemoryop)\n\n*External memory*\n\nSyntax:\n\n```\noperation ::= `handshake.extmemory` `[` `ld` `=` $ldCount `,` `st` `=`  $stCount `]` `(` $memref `:` qualified(type($memref)) `)` `(` $inputs `)` attr-dict `:` functional-type($inputs, $outputs)\n```\n\nAn ExternalMemoryOp represents a wrapper around a memref input to a\nhandshake function. The semantics of the load/store operands are identical\nto what is decribed for MemoryOp. The only difference is that the first\noperand to this operand is a `memref` value.\nUpon lowering to FIRRTL, a handshake interface will be created in the\ntop-level component for each load- and store which connected to this memory.\n\nExample:\n\n```\nhandshake.func @main(%i: index, %v: i32, %mem : memref<10xi32>, %ctrl: none) -> none {\n  %stCtrl = extmemory[ld = 0, st = 1](%mem : memref<10xi32>)(%vout, %addr) {id = 0 : i32} : (i32, index) -> (none)\n  %vout, %addr = store(%v, %i, %ctrl) : (i32, index, none) -> (i32, index)\n  ...\n}\n```\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `NamedIOInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-3)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `ldCount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `stCount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `id` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-6)\n\n| Operand | Description |\n| --- | --- |\n| `memref` | memref of any type values |\n| `inputs` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-6)\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `handshake.fork` (::circt::handshake::ForkOp)\u00a0[\u00b6](#handshakefork-circthandshakeforkop)\n\n*Fork operation*\n\nThe fork operation represents a fork operation. A\nsingle input is replicated to N outputs and distributed to each\noutput as soon as the corresponding successor is available.\n\nExample:\n\n```\n%1:2 = fork [2] %0 : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-7)\n\n| Operand | Description |\n| --- | --- |\n| `operand` | any type |\n\n#### Results:\u00a0[\u00b6](#results-7)\n\n| Result | Description |\n| --- | --- |\n| `result` | variadic of any type |\n\n### `handshake.func` (::circt::handshake::FuncOp)\u00a0[\u00b6](#handshakefunc-circthandshakefuncop)\n\n*Handshake dialect function.*\n\nThe func operation represents a handshaked function.\nThis is almost exactly like a standard FuncOp, except that it has\nsome extra verification conditions. In particular, each Value must\nonly have a single use.\n\nTraits: `HasClock`, `IsolatedFromAbove`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallableOpInterface`, `FineGrainedDataflowRegionOpInterface`, `FunctionOpInterface`, `OpAsmOpInterface`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-4)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `function_type` | ::mlir::TypeAttr | type attribute of function type |\n| `arg_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `res_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n\n### `handshake.instance` (::circt::handshake::InstanceOp)\u00a0[\u00b6](#handshakeinstance-circthandshakeinstanceop)\n\n*Module instantiate operation*\n\nSyntax:\n\n```\noperation ::= `handshake.instance` $module `(` $opOperands `)` attr-dict `:` functional-type($opOperands, results)\n```\n\nThe `instance` operation represents the instantiation of a module. This\nis similar to a function call, except that different instances of the\nsame module are guaranteed to have their own distinct state.\nThe instantiated module is encoded as a symbol reference attribute named\n\u201cmodule\u201d. An instance operation takes a control input as its last argument\nand returns a control output as its last result.\n\nExample:\n\n```\n%2:2 = handshake.instance @my_add(%0, %1, %ctrl) : (f32, f32, none) -> (f32, none)\n```\n\nTraits: `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`, `ControlInterface`, `NamedIOInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-5)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `module` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-8)\n\n| Operand | Description |\n| --- | --- |\n| `opOperands` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-8)\n\n| Result | Description |\n| --- | --- |\n| \u00abunnamed\u00bb | variadic of any type |\n\n### `handshake.join` (::circt::handshake::JoinOp)\u00a0[\u00b6](#handshakejoin-circthandshakejoinop)\n\n*Join operation*\n\nA control-only synchronizer. Produces a valid output when all\ninputs become available.\n\nExample:\n\n```\n%0 = join %a, %b, %c : i32, i1, none\n```\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `InferTypeOpInterface`, `NamedIOInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-9)\n\n| Operand | Description |\n| --- | --- |\n| `data` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-9)\n\n| Result | Description |\n| --- | --- |\n| `result` | none type |\n\n### `handshake.lazy_fork` (::circt::handshake::LazyForkOp)\u00a0[\u00b6](#handshakelazy_fork-circthandshakelazyforkop)\n\n*Lazy fork operation*\n\nThe lazy\\_fork operation represents a lazy fork operation.\nA single input is replicated to N outputs and distributed to each\noutput when all successors are available.\n\nExample:\n\n```\n%1:2 = lazy_fork [2] %0 : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-10)\n\n| Operand | Description |\n| --- | --- |\n| `operand` | any type |\n\n#### Results:\u00a0[\u00b6](#results-10)\n\n| Result | Description |\n| --- | --- |\n| `result` | variadic of any type |\n\n### `handshake.load` (::circt::handshake::LoadOp)\u00a0[\u00b6](#handshakeload-circthandshakeloadop)\n\n*Load operation*\n\nLoad memory port, sends load requests to MemoryOp. From dataflow\npredecessor, receives address indices and a control-only value\nwhich signals completion of all previous memory accesses which\ntarget the same memory. When all inputs are received, the load\nsends the address indices to MemoryOp. When the MemoryOp returns\na piece of data, the load sends it to its dataflow successor.\n\nOperands: address indices (from predecessor), data (from MemoryOp), control-only input.\nResults: data (to successor), address indices (to MemoryOp).\n\nExample:\n\n```\n%dataToSucc, %addr1ToMem, %addr2ToMem = load [%addr1, %addr2] %dataFromMem, %ctrl : i8, i16, index\n```\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `NamedIOInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-11)\n\n| Operand | Description |\n| --- | --- |\n| `addresses` | variadic of any type |\n| `data` | any type |\n| `ctrl` | none type |\n\n#### Results:\u00a0[\u00b6](#results-11)\n\n| Result | Description |\n| --- | --- |\n| `dataResult` | any type |\n| `addressResults` | variadic of any type |\n\n### `handshake.memory` (::circt::handshake::MemoryOp)\u00a0[\u00b6](#handshakememory-circthandshakememoryop)\n\n*Memory*\n\nSyntax:\n\n```\noperation ::= `handshake.memory` `[` `ld` `=` $ldCount `,` `st` `=`  $stCount `]` `(` $inputs `)` attr-dict `:` $memRefType `,` functional-type($inputs, $outputs)\n```\n\nEach MemoryOp represents an independent memory or memory region (BRAM or external memory).\nIt receives memory access requests from load and store operations. For every request,\nit returns data (for load) and a data-less token indicating completion.\nThe memory op represents a flat, unidimensional memory.\nOperands: all stores (stdata1, staddr1, stdata2, staddr2, \u2026), then all loads (ldaddr1, ldaddr2,\u2026)\nOutputs: all load outputs, ordered the same as\nload data (lddata1, lddata2, \u2026), followed by all none outputs,\nordered as operands (stnone1, stnone2,\u2026ldnone1, ldnone2,\u2026)\n\nTraits: `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `MemoryOpInterface`, `NamedIOInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-6)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `ldCount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `stCount` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `id` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `memRefType` | ::mlir::TypeAttr | memref type attribute |\n| `lsq` | ::mlir::IntegerAttr | 1-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-12)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-12)\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `handshake.merge` (::circt::handshake::MergeOp)\u00a0[\u00b6](#handshakemerge-circthandshakemergeop)\n\n*Merge operation*\n\nThe merge operation represents a (nondeterministic)\nmerge operation. Any input is propagated to the single output. The\nnumber of inputs corresponds to the number of predecessor\nblocks.\n\nExample:\n\n```\n%0 = merge %a, %b, %c : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `MergeLikeOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-13)\n\n| Operand | Description |\n| --- | --- |\n| `dataOperands` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-13)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `handshake.mux` (::circt::handshake::MuxOp)\u00a0[\u00b6](#handshakemux-circthandshakemuxop)\n\n*Mux operation*\n\nThe mux operation represents a(deterministic) merge operation.\nOperands: select, data0, data1, data2, \u2026\n\nThe \u2018select\u2019 operand is received from ControlMerge of the same\nblock and it represents the index of the data operand that the mux\nshould propagate to its single output. The number of data inputs\ncorresponds to the number of predecessor blocks.\n\nThe mux operation is intended solely for control+dataflow selection.\nFor purely dataflow selection, use the \u2018select\u2019 operation instead.\n\nExample:\n\n```\n%0 = mux %select [%data0, %data1, %data2] {attributes}: index, i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `ExecutableOpInterface`, `InferTypeOpInterface`, `MergeLikeOpInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-14)\n\n| Operand | Description |\n| --- | --- |\n| `selectOperand` | any type |\n| `dataOperands` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-14)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `handshake.never` (::circt::handshake::NeverOp)\u00a0[\u00b6](#handshakenever-circthandshakeneverop)\n\n*Never operation*\n\nSyntax:\n\n```\noperation ::= `handshake.never` attr-dict `:` qualified(type($result))\n```\n\nThe never operation represents disconnected data\nsource. The source never sets any \u2018valid\u2019 signal which will\nnever trigger the successor at any point in time.\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\u00a0[\u00b6](#results-15)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `handshake.pack` (::circt::handshake::PackOp)\u00a0[\u00b6](#handshakepack-circthandshakepackop)\n\n*Packs a tuple*\n\nThe `pack` operation constructs a tuple from separate values.\nThe number of operands corresponds to the number of tuple elements.\nSimilar to `join`, the output is ready when all inputs are ready.\n\nExample:\n\n```\n%tuple = handshake.pack %a, %b {attributes} : tuple<i32, i64>\n```\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `NamedIOInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-15)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-16)\n\n| Result | Description |\n| --- | --- |\n| `result` | Fixed-sized collection of other types |\n\n### `handshake.return` (::circt::handshake::ReturnOp)\u00a0[\u00b6](#handshakereturn-circthandshakereturnop)\n\n*Handshake dialect return.*\n\nSyntax:\n\n```\noperation ::= `handshake.return` attr-dict ($opOperands^ `:` type($opOperands))?\n```\n\nThe return operation represents a handshaked\nfunction. This is almost exactly like a standard ReturnOp, except\nthat it exists in a handshake.func. It has the same operands as\nstandard ReturnOp which it replaces and an additional control -\nonly operand(exit point of control - only network).\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`, `Terminator`\n\nInterfaces: `ControlInterface`, `NamedIOInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-16)\n\n| Operand | Description |\n| --- | --- |\n| `opOperands` | variadic of any type |\n\n### `handshake.sink` (::circt::handshake::SinkOp)\u00a0[\u00b6](#handshakesink-circthandshakesinkop)\n\n*Sink operation*\n\nThe sink operation discards any data that arrives at its\ninput.The sink has no successors and it can continuously consume data.\n\nExample:\n\n```\nsink %data : i32\n```\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `NamedIOInterface`, `SOSTInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-17)\n\n| Operand | Description |\n| --- | --- |\n| `operand` | any type |\n\n### `handshake.source` (::circt::handshake::SourceOp)\u00a0[\u00b6](#handshakesource-circthandshakesourceop)\n\n*Source operation*\n\nThe source operation represents continuous token\nsource. The source continously sets a \u2018valid\u2019 signal which the\nsuccessor can consume at any point in time.\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ConditionallySpeculatable`, `ControlInterface`, `NamedIOInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SOSTInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\u00a0[\u00b6](#results-17)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `handshake.store` (::circt::handshake::StoreOp)\u00a0[\u00b6](#handshakestore-circthandshakestoreop)\n\n*Store operation*\n\nStore memory port, sends store requests to MemoryOp. From dataflow\npredecessors, receives address indices, data, and a control-only\nvalue which signals completion of all previous memory accesses\nwhich target the same memory. When all inputs are received, the\nstore sends the address and data to MemoryOp.\n\nOperands: address indices, data, control-only input.\nResults: data and address indices (sent to MemoryOp).\nTypes: data type followed by address type.\n\nExample:\n\n```\n%dataToMem, %addrToMem = store [%addr1, %addr2] %dataFromPred , %ctrl : i8, i16, index\n```\n\nTraits: `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `NamedIOInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-18)\n\n| Operand | Description |\n| --- | --- |\n| `addresses` | variadic of any type |\n| `data` | any type |\n| `ctrl` | none type |\n\n#### Results:\u00a0[\u00b6](#results-18)\n\n| Result | Description |\n| --- | --- |\n| `dataResult` | any type |\n| `addressResult` | variadic of any type |\n\n### `handshake.sync` (::circt::handshake::SyncOp)\u00a0[\u00b6](#handshakesync-circthandshakesyncop)\n\n*Sync operation*\n\nSyntax:\n\n```\noperation ::= `handshake.sync` $operands attr-dict `:` type($operands)\n```\n\nSynchronizes an arbitrary set of inputs. Synchronization implies applying\njoin semantics in between all in- and output ports.\n\nExample:\n\n```\n%aSynced, %bSynced, %cSynced = sync %a, %b, %c : i32, i1, none\n```\n\nTraits: `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `NamedIOInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-19)\n\n| Operand | Description |\n| --- | --- |\n| `operands` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-19)\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `handshake.unpack` (::circt::handshake::UnpackOp)\u00a0[\u00b6](#handshakeunpack-circthandshakeunpackop)\n\n*Unpacks a tuple*\n\nThe `unpack` operation assigns each value of a tuple to a separate\nvalue for further processing. The number of results corresponds\nto the number of tuple elements.\nSimilar to `fork`, each output is distributed as soon as the corresponding\nsuccessor is ready.\n\nExample:\n\n```\n%a, %b = handshake.unpack %tuple {attributes} : tuple<i32, i64>\n```\n\nTraits: `HasClock`, `HasParentInterface<FineGrainedDataflowRegionOpInterface>`\n\nInterfaces: `ControlInterface`, `ExecutableOpInterface`, `GeneralOpInterface`, `NamedIOInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-20)\n\n| Operand | Description |\n| --- | --- |\n| `input` | Fixed-sized collection of other types |\n\n#### Results:\u00a0[\u00b6](#results-20)\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\nAttributes\u00a0[\u00b6](#attributes-7)\n-----------------------------\n\n### BufferTypeEnumAttr\u00a0[\u00b6](#buffertypeenumattr)\n\n*BufferOp seq or fifo*\n\nSyntax:\n\n```\n#handshake.buffer_type_enum<\n  ::BufferTypeEnum   # value\n>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `::BufferTypeEnum` | an enum of type BufferTypeEnum |\n\nEnums\u00a0[\u00b6](#enums)\n-----------------\n\n### BufferTypeEnum\u00a0[\u00b6](#buffertypeenum)\n\n*BufferOp seq or fifo*\n\n#### Cases:\u00a0[\u00b6](#cases)\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| seq | `0` | seq |\n| fifo | `1` | fifo |\n\n [Prev - 'handshake' Dialect](https://circt.llvm.org/docs/Dialects/Handshake/ \"'handshake' Dialect\")\n[Next - 'hw' Dialect](https://circt.llvm.org/docs/Dialects/HW/ \"'hw' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect-](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/HW/index.md"
  },
  {
    "role": "user",
    "content": "'hw' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'hw' Dialect\n============\n\nThis dialect defines the `hw` dialect, which is intended to be a generic\nrepresentation of HW outside of a particular use-case.\n\n* [Operation Definitions \u2013 Structure](#operation-definitions----structure)\n  + [`hw.generator.schema` (::circt::hw::HWGeneratorSchemaOp)](#hwgeneratorschema-circthwhwgeneratorschemaop)\n  + [`hw.module.extern` (::circt::hw::HWModuleExternOp)](#hwmoduleextern-circthwhwmoduleexternop)\n  + [`hw.module.generated` (::circt::hw::HWModuleGeneratedOp)](#hwmodulegenerated-circthwhwmodulegeneratedop)\n  + [`hw.module` (::circt::hw::HWModuleOp)](#hwmodule-circthwhwmoduleop)\n  + [`hw.hierpath` (::circt::hw::HierPathOp)](#hwhierpath-circthwhierpathop)\n  + [`hw.instance_choice` (::circt::hw::InstanceChoiceOp)](#hwinstance_choice-circthwinstancechoiceop)\n  + [`hw.instance` (::circt::hw::InstanceOp)](#hwinstance-circthwinstanceop)\n  + [`hw.output` (::circt::hw::OutputOp)](#hwoutput-circthwoutputop)\n  + [`hw.triggered` (::circt::hw::TriggeredOp)](#hwtriggered-circthwtriggeredop)\n* [Operation Definitions \u2013 Miscellaneous](#operation-definitions----miscellaneous)\n  + [`hw.bitcast` (::circt::hw::BitcastOp)](#hwbitcast-circthwbitcastop)\n  + [`hw.constant` (::circt::hw::ConstantOp)](#hwconstant-circthwconstantop)\n  + [`hw.enum.cmp` (::circt::hw::EnumCmpOp)](#hwenumcmp-circthwenumcmpop)\n  + [`hw.enum.constant` (::circt::hw::EnumConstantOp)](#hwenumconstant-circthwenumconstantop)\n  + [`hw.param.value` (::circt::hw::ParamValueOp)](#hwparamvalue-circthwparamvalueop)\n  + [`hw.wire` (::circt::hw::WireOp)](#hwwire-circthwwireop)\n* [Operation Definitions \u2013 Aggregates](#operation-definitions----aggregates)\n  + [`hw.aggregate_constant` (::circt::hw::AggregateConstantOp)](#hwaggregate_constant-circthwaggregateconstantop)\n  + [`hw.array_concat` (::circt::hw::ArrayConcatOp)](#hwarray_concat-circthwarrayconcatop)\n  + [`hw.array_create` (::circt::hw::ArrayCreateOp)](#hwarray_create-circthwarraycreateop)\n  + [`hw.array_get` (::circt::hw::ArrayGetOp)](#hwarray_get-circthwarraygetop)\n  + [`hw.array_inject` (::circt::hw::ArrayInjectOp)](#hwarray_inject-circthwarrayinjectop)\n  + [`hw.array_slice` (::circt::hw::ArraySliceOp)](#hwarray_slice-circthwarraysliceop)\n  + [`hw.struct_create` (::circt::hw::StructCreateOp)](#hwstruct_create-circthwstructcreateop)\n  + [`hw.struct_explode` (::circt::hw::StructExplodeOp)](#hwstruct_explode-circthwstructexplodeop)\n  + [`hw.struct_extract` (::circt::hw::StructExtractOp)](#hwstruct_extract-circthwstructextractop)\n  + [`hw.struct_inject` (::circt::hw::StructInjectOp)](#hwstruct_inject-circthwstructinjectop)\n  + [`hw.union_create` (::circt::hw::UnionCreateOp)](#hwunion_create-circthwunioncreateop)\n  + [`hw.union_extract` (::circt::hw::UnionExtractOp)](#hwunion_extract-circthwunionextractop)\n* [Operation Definitions \u2013 Type Declarations](#operation-definitions----type-declarations)\n  + [`hw.type_scope` (::circt::hw::TypeScopeOp)](#hwtype_scope-circthwtypescopeop)\n  + [`hw.typedecl` (::circt::hw::TypedeclOp)](#hwtypedecl-circthwtypedeclop)\n* [Attribute Definitions](#attribute-definitions)\n  + [EnumFieldAttr](#enumfieldattr)\n  + [OutputFileAttr](#outputfileattr)\n  + [ParamDeclAttr](#paramdeclattr)\n  + [ParamDeclRefAttr](#paramdeclrefattr)\n  + [ParamExprAttr](#paramexprattr)\n  + [ParamVerbatimAttr](#paramverbatimattr)\n  + [InnerRefAttr](#innerrefattr)\n* [Type Definitions](#type-definitions)\n  + [`hw.type_scope` (::circt::hw::TypeScopeOp)](#hwtype_scope-circthwtypescopeop-1)\n  + [`hw.typedecl` (::circt::hw::TypedeclOp)](#hwtypedecl-circthwtypedeclop-1)\n  + [ArrayType](#arraytype)\n  + [EnumType](#enumtype)\n  + [StringType](#stringtype)\n  + [InOutType](#inouttype)\n  + [IntType](#inttype)\n  + [ModuleType](#moduletype)\n  + [StructType](#structtype)\n  + [TypeAliasType](#typealiastype)\n  + [UnionType](#uniontype)\n  + [UnpackedArrayType](#unpackedarraytype)\n* [CombDataFlow (`CombDataflow`)](#combdataflow-combdataflow)\n  + [Methods:](#methods)\n* [HWEmittableModuleLike (`HWEmittableModuleLike`)](#hwemittablemodulelike-hwemittablemodulelike)\n  + [Methods:](#methods-1)\n* [HWInstanceLike (`HWInstanceLike`)](#hwinstancelike-hwinstancelike)\n  + [Methods:](#methods-2)\n* [HWModuleLike (`HWModuleLike`)](#hwmodulelike-hwmodulelike)\n  + [Methods:](#methods-3)\n* [HWMutableModuleLike (`HWMutableModuleLike`)](#hwmutablemodulelike-hwmutablemodulelike)\n  + [Methods:](#methods-4)\n* [InnerRefUserOpInterface (`InnerRefUserOpInterface`)](#innerrefuseropinterface-innerrefuseropinterface)\n  + [Methods:](#methods-5)\n* [InnerSymbolOpInterface (`InnerSymbol`)](#innersymbolopinterface-innersymbol)\n  + [Methods:](#methods-6)\n* [PortList (`PortList`)](#portlist-portlist)\n  + [Methods:](#methods-7)\n* [BitWidthTypeInterface (`BitWidthTypeInterface`)](#bitwidthtypeinterface-bitwidthtypeinterface)\n  + [Methods:](#methods-8)\n* [FieldIDTypeInterface (`FieldIDTypeInterface`)](#fieldidtypeinterface-fieldidtypeinterface)\n  + [Methods:](#methods-9)\n\nOperation Definitions \u2013 Structure\n---------------------------------\n\n### `hw.generator.schema` (::circt::hw::HWGeneratorSchemaOp)\n\n*HW Generator Schema declaration*\n\nSyntax:\n\n```\noperation ::= `hw.generator.schema` $sym_name `,` $descriptor `,` $requiredAttrs attr-dict\n```\n\nThe \u201chw.generator.schema\u201d operation declares a kind of generated module by\ndeclaring the schema of meta-data required.\nA generated module instance of a schema is independent of the external\nmethod of producing it. It is assumed that for well known schema instances,\nmultiple external tools might exist which can process it. Generator nodes\nlist attributes required by hw.module.generated instances.\n\nExample:\n\n```\ngenerator.schema @MEMORY, \"Simple-Memory\", [\"ports\", \"write_latency\", \"read_latency\"]\nmodule.generated @mymem, @MEMORY(ports)\n  -> (ports) {write_latency=1, read_latency=1, ports=[\"read\",\"write\"]}\n```\n\nTraits: `HasParent<mlir::ModuleOp>`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `descriptor` | ::mlir::StringAttr | string attribute |\n| `requiredAttrs` | ::mlir::ArrayAttr | string array attribute |\n\n### `hw.module.extern` (::circt::hw::HWModuleExternOp)\n\n*HW external Module*\n\nThe \u201chw.module.extern\u201d operation represents an external reference to a\nVerilog module, including a given name and a list of ports.\n\nThe \u2018verilogName\u2019 attribute (when present) specifies the spelling of the\nmodule name in Verilog we can use. TODO: This is a hack because we don\u2019t\nhave proper parameterization in the hw.dialect. We need a way to represent\nparameterized types instead of just concrete types.\n\nTraits: `HasParent<mlir::ModuleOp>`, `InnerSymbolTable`\n\nInterfaces: `HWModuleLike`, `HWMutableModuleLike`, `InstanceGraphModuleOpInterface`, `OpAsmOpInterface`, `PortList`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `module_type` | ::mlir::TypeAttr | type attribute of a module |\n| `per_port_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `port_locs` | ::mlir::ArrayAttr | location array attribute |\n| `parameters` | ::mlir::ArrayAttr | parameter array attribute |\n| `verilogName` | ::mlir::StringAttr | string attribute |\n\n### `hw.module.generated` (::circt::hw::HWModuleGeneratedOp)\n\n*HW Generated Module*\n\nThe \u201chw.module.generated\u201d operation represents a reference to an external\nmodule that will be produced by some external process.\nThis represents the name and list of ports to be generated.\n\nThe \u2018verilogName\u2019 attribute (when present) specifies the spelling of the\nmodule name in Verilog we can use. See hw.module for an explanation.\n\nTraits: `HasParent<mlir::ModuleOp>`, `InnerSymbolTable`, `IsolatedFromAbove`\n\nInterfaces: `HWModuleLike`, `HWMutableModuleLike`, `InstanceGraphModuleOpInterface`, `OpAsmOpInterface`, `PortList`, `SymbolUserOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `generatorKind` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `module_type` | ::mlir::TypeAttr | type attribute of a module |\n| `per_port_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `port_locs` | ::mlir::ArrayAttr | location array attribute |\n| `parameters` | ::mlir::ArrayAttr | parameter array attribute |\n| `verilogName` | ::mlir::StringAttr | string attribute |\n\n### `hw.module` (::circt::hw::HWModuleOp)\n\n*HW Module*\n\nThe \u201chw.module\u201d operation represents a Verilog module, including a given\nname, a list of ports, a list of parameters, and a body that represents the\nconnections within the module.\n\nTraits: `HasParent<mlir::ModuleOp>`, `InnerSymbolTable`, `IsolatedFromAbove`, `SingleBlockImplicitTerminator<OutputOp>`, `SingleBlock`\n\nInterfaces: `Emittable`, `HWEmittableModuleLike`, `HWModuleLike`, `HWMutableModuleLike`, `InstanceGraphModuleOpInterface`, `OpAsmOpInterface`, `PortList`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `module_type` | ::mlir::TypeAttr | type attribute of a module |\n| `per_port_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `result_locs` | ::mlir::ArrayAttr | location array attribute |\n| `parameters` | ::mlir::ArrayAttr | parameter array attribute |\n| `comment` | ::mlir::StringAttr | string attribute |\n\n### `hw.hierpath` (::circt::hw::HierPathOp)\n\n*Hierarchical path specification*\n\nThe \u201chw.hierpath\u201d operation represents a path through the hierarchy.\nThis is used to specify namable things for use in other operations, for\nexample in verbatim substitution. Non-local annotations also use these.\n\nTraits: `IsolatedFromAbove`\n\nInterfaces: `InnerRefUserOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `namepath` | ::mlir::ArrayAttr | name reference array attribute |\n\n### `hw.instance_choice` (::circt::hw::InstanceChoiceOp)\n\n*Represents an instance with a target-specific reference*\n\nThis represents an instance to a module which is determined based on the\ntarget through the ABI. Besides a default implementation, other targets can\nbe associated with a string, which will later determined which reference\nis chosen.\n\nFor the purposes of analyses and transformations, it is assumed that any of\nthe targets is a possibility.\n\nExample:\n\n```\n%b = hw.instance_choice \"inst\" sym\n    @TargetDefault or\n    @TargetA if \"A\" or\n    @TargetB if \"B\"\n    (a: %a: i32) -> (b: i32)\n```\n\nInterfaces: `HWInstanceLike`, `InnerSymbolOpInterface`, `InstanceGraphInstanceOpInterface`, `InstanceOpInterface`, `OpAsmOpInterface`, `PortList`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `instanceName` | ::mlir::StringAttr | string attribute |\n| `moduleNames` | ::mlir::ArrayAttr | flat symbol ref array attribute |\n| `optionName` | ::mlir::StringAttr | string attribute |\n| `caseNames` | ::mlir::ArrayAttr | string array attribute |\n| `argNames` | ::mlir::ArrayAttr | string array attribute |\n| `resultNames` | ::mlir::ArrayAttr | string array attribute |\n| `parameters` | ::mlir::ArrayAttr | parameter array attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `doNotPrint` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `hw.instance` (::circt::hw::InstanceOp)\n\n*Create an instance of a module*\n\nThis represents an instance of a module. The inputs and outputs are\nthe referenced module\u2019s inputs and outputs. The `argNames` and\n`resultNames` attributes must match the referenced module.\n\nAny parameters in the \u201cold\u201d format (slated to be removed) are stored in the\n`oldParameters` dictionary.\n\nInterfaces: `HWInstanceLike`, `InnerSymbolOpInterface`, `InstanceGraphInstanceOpInterface`, `OpAsmOpInterface`, `PortList`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `instanceName` | ::mlir::StringAttr | string attribute |\n| `moduleName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `argNames` | ::mlir::ArrayAttr | string array attribute |\n| `resultNames` | ::mlir::ArrayAttr | string array attribute |\n| `parameters` | ::mlir::ArrayAttr | parameter array attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `doNotPrint` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `hw.output` (::circt::hw::OutputOp)\n\n*HW termination operation*\n\nSyntax:\n\n```\noperation ::= `hw.output` attr-dict ($outputs^ `:` qualified(type($outputs)))?\n```\n\n\u201chw.output\u201d marks the end of a region in the HW dialect and the values\nto put on the output ports.\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<HWModuleOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `hw.triggered` (::circt::hw::TriggeredOp)\n\n*A procedural region with a trigger condition*\n\nSyntax:\n\n```\noperation ::= `hw.triggered` $event $trigger  (`(` $inputs^ `)` `:` type($inputs))? $body attr-dict\n```\n\nA procedural region that can be triggered by an event. The trigger\ncondition is a 1-bit value that is activated based on some event control\nattribute.\nThe operation is `IsolatedFromAbove`, and thus requires values passed into\nthe trigger region to be explicitly passed in through the `inputs` list.\n\nTraits: `IsolatedFromAbove`, `NoTerminator`, `SingleBlock`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `event` | circt::hw::EventControlAttr | edge control trigger |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `trigger` | 1-bit signless integer |\n| `inputs` | variadic of any type |\n\nOperation Definitions \u2013 Miscellaneous\n-------------------------------------\n\n### `hw.bitcast` (::circt::hw::BitcastOp)\n\n*Reinterpret one value to another value of the same size and\npotentially different type. See the `hw` dialect rationale document for\nmore details.*\n\nSyntax:\n\n```\noperation ::= `hw.bitcast` $input attr-dict `:` functional-type($input, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | Type wherein the bitwidth in hardware is known |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | Type wherein the bitwidth in hardware is known |\n\n### `hw.constant` (::circt::hw::ConstantOp)\n\n*Produce a constant value*\n\nThe constant operation produces a constant value of standard integer type\nwithout a sign.\n\n```\n  %result = hw.constant 42 : t1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`, `FirstAttrDerivedResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferIntRangeInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `OpAsmOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::IntegerAttr | arbitrary integer attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `hw.enum.cmp` (::circt::hw::EnumCmpOp)\n\n*Compare two values of an enumeration*\n\nSyntax:\n\n```\noperation ::= `hw.enum.cmp` $lhs `,` $rhs attr-dict `:` qualified(type($lhs)) `,` qualified(type($rhs))\n```\n\nThis operation compares two values with the same canonical enumeration\ntype, returning 0 if they are different, and 1 if they are the same.\n\nExample:\n\n```\n  %enumcmp = hw.enum.cmp %A, %B : !hw.enum<A, B, C>, !hw.enum<A, B, C>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a EnumType |\n| `rhs` | a EnumType |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit signless integer |\n\n### `hw.enum.constant` (::circt::hw::EnumConstantOp)\n\n*Produce a constant enumeration value.*\n\nThe enum.constant operation produces an enumeration value of the specified\nenum value attribute.\n\n```\n  %0 = hw.enum.constant A : !hw.enum<A, B, C>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `OpAsmOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `field` | ::circt::hw::EnumFieldAttr | Enumeration field attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a EnumType |\n\n### `hw.param.value` (::circt::hw::ParamValueOp)\n\n*Return the value of a parameter expression as an SSA value that may be used\nby other ops.*\n\nSyntax:\n\n```\noperation ::= `hw.param.value` custom<ParamValue>($value, qualified(type($result))) attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`, `FirstAttrDerivedResultType`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::Attribute | any attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a known primitive element |\n\n### `hw.wire` (::circt::hw::WireOp)\n\n*Assign a name or symbol to an SSA edge*\n\nSyntax:\n\n```\noperation ::= `hw.wire` $input (`sym` $inner_sym^)? custom<ImplicitSSAName>($name) attr-dict\n              `:` qualified(type($input))\n```\n\nAn `hw.wire` is used to assign a human-readable name or a symbol for remote\nreferences to an SSA edge. It takes a single operand and returns its value\nunchanged as a result. The operation guarantees the following:\n\n* If the wire has a symbol, the value of its operand remains observable\n  under that symbol within the IR.\n* If the wire has a name, the name is treated as a hint. If the wire\n  persists until code generation the resulting wire will have this name,\n  with a potential suffix to ensure uniqueness. If the wire is canonicalized\n  away, its name is propagated to its input operand as a name hint.\n* The users of its result will always observe the operand through the\n  operation itself, meaning that optimizations cannot bypass the wire. This\n  ensures that if the wire\u2019s value is *forced*, for example through a\n  Verilog force statement, the forced value will affect all users of the\n  wire in the output.\n\nExample:\n\n```\n%1 = hw.wire %0 : i42\n%2 = hw.wire %0 sym @mySym : i42\n%3 = hw.wire %0 name \"myWire\" : i42\n%myWire = hw.wire %0 : i42\n```\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`, `InnerSymbolOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\nOperation Definitions \u2013 Aggregates\n----------------------------------\n\n### `hw.aggregate_constant` (::circt::hw::AggregateConstantOp)\n\n*Produce a constant aggregate value*\n\nSyntax:\n\n```\noperation ::= `hw.aggregate_constant` $fields attr-dict `:` type($result)\n```\n\nThis operation produces a constant value of an aggregate type. Clock and\nreset values are supported. For nested aggregates, embedded arrays are\nused.\n\nExamples:\n\n```\n  %result = hw.aggregate_constant [1 : i1, 2 : i2, 3 : i2] : !hw.struct<a: i8, b: i8, c: i8>\n  %result = hw.aggregate_constant [1 : i1, [2 : i2, 3 : i2]] : !hw.struct<a: i8, b: vector<i8, 2>>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fields` | ::mlir::ArrayAttr | array attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | an ArrayType or StructType |\n\n### `hw.array_concat` (::circt::hw::ArrayConcatOp)\n\n*Concatenate some arrays*\n\nSyntax:\n\n```\noperation ::= `hw.array_concat` $inputs attr-dict `:` custom<ArrayConcatTypes>(type($inputs), qualified(type($result)))\n```\n\nCreates an array by concatenating a variable set of arrays. One or more\nvalues must be listed.\n\n```\n// %a, %b, %c are hw arrays of i4 with sizes 2, 5, and 4 respectively.\n%array = hw.array_concat %a, %b, %c : (2, 5, 4 x i4)\n// %array is !hw.array<11 x i4>\n```\n\nSee the HW-SV rationale document for details on operand ordering.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of an ArrayType |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | an ArrayType |\n\n### `hw.array_create` (::circt::hw::ArrayCreateOp)\n\n*Create an array from values*\n\nCreates an array from a variable set of values. One or more values must be\nlisted.\n\n```\n// %a, %b, %c are all i4\n%array = hw.array_create %a, %b, %c : i4\n```\n\nSee the HW-SV rationale document for details on operand ordering.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a type without inout |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | an ArrayType |\n\n### `hw.array_get` (::circt::hw::ArrayGetOp)\n\n*Extract an element from an array*\n\nSyntax:\n\n```\noperation ::= `hw.array_get` $input `[` $index `]`\n              attr-dict `:` type($input) `,` type($index)\n```\n\nExtracts the element at `index` from the given `input` array. The index must\nbe exactly `ceil(log2(length(input)))` bits wide.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an ArrayType |\n| `index` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a type without inout |\n\n### `hw.array_inject` (::circt::hw::ArrayInjectOp)\n\n*Inject an element into an array*\n\nSyntax:\n\n```\noperation ::= `hw.array_inject` $input `[` $index `]` `,` $element\n              attr-dict `:` type($input) `,` type($index)\n```\n\nTakes an `input` array, changes the element at `index` to the given\n`element` value, and returns the updated array value as a result. The index\nmust be exactly `ceil(log2(length(input)))` bits wide. The element type\nmust match the input array\u2019s element type.\n\nIf the `index` is out of bounds, the result is undefined.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an ArrayType |\n| `index` | a signless integer bitvector |\n| `element` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | an ArrayType |\n\n### `hw.array_slice` (::circt::hw::ArraySliceOp)\n\n*Get a range of values from an array*\n\nSyntax:\n\n```\noperation ::= `hw.array_slice` $input`[`$lowIndex`]` attr-dict `:`\n              `(` custom<SliceTypes>(type($input), qualified(type($lowIndex))) `)` `->` qualified(type($dst))\n```\n\nExtracts a sub-range from an array. The range is from `lowIndex` to\n`lowIndex` + the number of elements in the return type, non-inclusive on\nthe high end. For instance,\n\n```\n// Slices 16 elements starting at '%offset'.\n%subArray = hw.slice %largerArray at %offset :\n    (!hw.array<1024xi8>) -> !hw.array<16xi8>\n```\n\nWidth of \u2018idx\u2019 is defined to be the precise number of bits required to\nindex the \u2018input\u2019 array. More precisely: for an input array of size M,\nthe width of \u2018idx\u2019 is ceil(log2(M)). Lower and upper bound indexes which\nare larger than the size of the \u2018input\u2019 array results in undefined\nbehavior.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an ArrayType |\n| `lowIndex` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `dst` | an ArrayType |\n\n### `hw.struct_create` (::circt::hw::StructCreateOp)\n\n*Create a struct from constituent parts.*\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | variadic of a type without inout |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a StructType |\n\n### `hw.struct_explode` (::circt::hw::StructExplodeOp)\n\n*Expand a struct into its constituent parts.*\n\n```\n%result:2 = hw.struct_explode %input : !hw.struct<foo: i19, bar: i7>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `OpAsmOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a StructType |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | variadic of a type without inout |\n\n### `hw.struct_extract` (::circt::hw::StructExtractOp)\n\n*Extract a named field from a struct.*\n\n```\n%result = hw.struct_extract %input[\"field\"] : !hw.struct<field: type>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `OpAsmOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldIndex` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a StructType |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a type without inout |\n\n### `hw.struct_inject` (::circt::hw::StructInjectOp)\n\n*Inject a value into a named field of a struct.*\n\n```\n%result = hw.struct_inject %input[\"field\"], %newValue\n    : !hw.struct<field: type>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldIndex` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a StructType |\n| `newValue` | a type without inout |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a StructType |\n\n### `hw.union_create` (::circt::hw::UnionCreateOp)\n\n*Create a union with the specified value.*\n\nCreate a union with the value \u2018input\u2019, which can then be accessed via the\nspecified field.\n\n```\n  %x = hw.constant 0 : i3\n  %z = hw.union_create \"bar\", %x : !hw.union<bar: i3, baz: i8>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldIndex` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a type without inout |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a UnionType |\n\n### `hw.union_extract` (::circt::hw::UnionExtractOp)\n\n*Get a union member.*\n\nGet the value of a union, interpreting it as the type of the specified\nmember field. Extracting a value belonging to a different field than the\nunion was initially created will result in undefined behavior.\n\n```\n  %u = ...\n  %v = hw.union_extract %u[\"foo\"] : !hw.union<foo: i3, bar: i16>\n  // %v is of type 'i3'\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldIndex` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a UnionType |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a type without inout |\n\nOperation Definitions \u2013 Type Declarations\n-----------------------------------------\n\n### `hw.type_scope` (::circt::hw::TypeScopeOp)\n\n*Type declaration wrapper.*\n\nSyntax:\n\n```\noperation ::= `hw.type_scope` $sym_name $body attr-dict\n```\n\nAn operation whose one body block contains type declarations. This op\nprovides a scope for type declarations at the top level of an MLIR module.\nIt is a symbol that may be looked up within the module, as well as a symbol\ntable itself, so type declarations may be looked up.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\nInterfaces: `Emittable`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `hw.typedecl` (::circt::hw::TypedeclOp)\n\n*Type declaration.*\n\nSyntax:\n\n```\noperation ::= `hw.typedecl` $sym_name (`,` $verilogName^)? `:` $type attr-dict\n```\n\nAssociate a symbolic name with a type.\n\nTraits: `HasParent<TypeScopeOp>`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `type` | ::mlir::TypeAttr | any type attribute |\n| `verilogName` | ::mlir::StringAttr | string attribute |\n\nAttribute Definitions\n---------------------\n\n### EnumFieldAttr\n\n*Enumeration field attribute*\n\nThis attribute represents a field of an enumeration.\n\nExamples:\n\n```\n  #hw.enum.value<A, !hw.enum<A, B, C>>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| field | `::mlir::StringAttr` |  |\n| type | `::mlir::TypeAttr` |  |\n\n### OutputFileAttr\n\n*Output file attribute*\n\nThis attribute represents an output file for something which will be\nprinted. The `filename` string is the file to be output to. If `filename`\nends in a `/` it is considered an output directory.\n\nWhen ExportVerilog runs, one of the files produced is a list of all other\nfiles which are produced. The flag `excludeFromFileList` controls if this\nfile should be included in this list. If any `OutputFileAttr` referring to\nthe same file sets this to `true`, it will be included in the file list.\nThis option defaults to `false`.\n\nFor each file emitted by the verilog emitter, certain prelude output will\nbe included before the main content. The flag `includeReplicatedOps` can\nbe used to disable the addition of the prelude text. All `OutputFileAttr`s\nreferring to the same file must use a consistent setting for this value.\nThis option defaults to `true`.\n\nExamples:\n\n```\n  #hw.ouput_file<\"/home/tester/t.sv\">\n  #hw.ouput_file<\"t.sv\", excludeFromFileList, includeReplicatedOps>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| filename | `::mlir::StringAttr` |  |\n| excludeFromFilelist | `::mlir::BoolAttr` |  |\n| includeReplicatedOps | `::mlir::BoolAttr` |  |\n\n### ParamDeclAttr\n\n*Module or instance parameter definition*\n\nAn attribute describing a module parameter, or instance parameter\nspecification.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| name | `::mlir::StringAttr` |  |\n| type | `::mlir::Type` |  |\n| value | `::mlir::Attribute` |  |\n\n### ParamDeclRefAttr\n\n*Is a reference to a parameter value.*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| name | `::mlir::StringAttr` |  |\n| type | `::mlir::Type` |  |\n\n### ParamExprAttr\n\n*Parameter expression combining operands*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| opcode | `PEO` |  |\n| operands | `::llvm::ArrayRef<::mlir::TypedAttr>` |  |\n| type | `::mlir::Type` |  |\n\n### ParamVerbatimAttr\n\n*Represents text to emit directly to SystemVerilog for a parameter*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `::mlir::StringAttr` |  |\n| type | `::mlir::Type` |  |\n\n### InnerRefAttr\n\n*Refer to a name inside a module*\n\nThis works like a symbol reference, but to a name inside a module.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| moduleRef | `::mlir::FlatSymbolRefAttr` |  |\n| name | `::mlir::StringAttr` |  |\n\nType Definitions\n----------------\n\n### `hw.type_scope` (::circt::hw::TypeScopeOp)\n\n*Type declaration wrapper.*\n\nSyntax:\n\n```\noperation ::= `hw.type_scope` $sym_name $body attr-dict\n```\n\nAn operation whose one body block contains type declarations. This op\nprovides a scope for type declarations at the top level of an MLIR module.\nIt is a symbol that may be looked up within the module, as well as a symbol\ntable itself, so type declarations may be looked up.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\nInterfaces: `Emittable`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `hw.typedecl` (::circt::hw::TypedeclOp)\n\n*Type declaration.*\n\nSyntax:\n\n```\noperation ::= `hw.typedecl` $sym_name (`,` $verilogName^)? `:` $type attr-dict\n```\n\nAssociate a symbolic name with a type.\n\nTraits: `HasParent<TypeScopeOp>`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `type` | ::mlir::TypeAttr | any type attribute |\n| `verilogName` | ::mlir::StringAttr | string attribute |\n\n### ArrayType\n\n*Fixed-sized array*\n\nSyntax:\n\n```\n!hw.array<\n  ::mlir::Type,   # elementType\n  ::mlir::Attribute   # sizeAttr\n>\n```\n\nFixed sized HW arrays are roughly similar to C arrays. On the wire (vs.\nin a memory), arrays are always packed. Memory layout is not defined as\nit does not need to be since in silicon there is not implicit memory\nsharing.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `::mlir::Type` |  |\n| sizeAttr | `::mlir::Attribute` |  |\n\n### EnumType\n\n*HW Enum type*\n\nRepresents an enumeration of values. Enums are interpreted as integers with\na synthesis-defined encoding.\n\n```\n!hw.enum<field1, field2>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| fields | `mlir::ArrayAttr` |  |\n\n### StringType\n\n*String type*\n\nSyntax: `!hw.string`\n\nDefines a string type for the hw-centric dialects\n\n### InOutType\n\n*Inout type*\n\nSyntax:\n\n```\n!hw.inout<\n  ::mlir::Type   # elementType\n>\n```\n\nInOut type is used for model operations and values that have \u201cconnection\u201d\nsemantics, instead of typical dataflow behavior. This is used for wires\nand inout ports in Verilog.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `::mlir::Type` |  |\n\n### IntType\n\n*Parameterized-width integer*\n\nParameterized integer types are equivalent to the MLIR standard integer\ntype: it is signless, and may be any width integer. This type represents\nthe case when the width is a parameter in the HW dialect sense.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| width | `::mlir::TypedAttr` |  |\n\n### ModuleType\n\n*Module Type*\n\nModule types have ports.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| ports | `::llvm::ArrayRef<::circt::hw::ModulePort>` | port list |\n\n### StructType\n\n*HW struct type*\n\nRepresents a structure of name, value pairs.\n\n```\n!hw.struct<fieldName1: Type1, fieldName2: Type2>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elements | `::llvm::ArrayRef<::circt::hw::StructType::FieldInfo>` | struct fields |\n\n### TypeAliasType\n\n*An symbolic reference to a type declaration*\n\nA TypeAlias is parameterized by a SymbolRefAttr, which points to a\nTypedeclOp. The root reference should refer to a TypeScope within the same\nouter ModuleOp, and the leaf reference should refer to a type within that\nTypeScope. A TypeAlias is further parameterized by the inner type, which is\nneeded to be known at the time the type is parsed.\n\nUpon construction, a TypeAlias stores the symbol reference and type, and\ncanonicalizes the type to resolve any nested type aliases. The canonical\ntype is also cached to avoid recomputing it when needed.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| ref | `mlir::SymbolRefAttr` |  |\n| innerType | `mlir::Type` |  |\n| canonicalType | `mlir::Type` |  |\n\n### UnionType\n\n*An untagged union of types*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elements | `::llvm::ArrayRef<::circt::hw::UnionType::FieldInfo>` | union fields |\n\n### UnpackedArrayType\n\n*SystemVerilog \u2018unpacked\u2019 fixed-sized array*\n\nSyntax:\n\n```\n!hw.uarray<\n  ::mlir::Type,   # elementType\n  ::mlir::Attribute   # sizeAttr\n>\n```\n\nUnpacked arrays are a more flexible array representation than packed arrays,\nand are typically used to model memories. See SystemVerilog Spec 7.4.2.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `::mlir::Type` |  |\n| sizeAttr | `::mlir::Attribute` |  |\n\nCombDataFlow (`CombDataflow`)\n-----------------------------\n\nThis interface is used for specifying the combinational dataflow that exists\nin the results and operands of an operation.\nAny operation that doesn\u2019t implement this interface is assumed to have a\ncombinational dependence from each operand to each result.\n\n### Methods:\n\n#### `computeDataFlow`\n\n```\nllvm::SmallVector<std::pair<circt::FieldRef, circt::FieldRef>> computeDataFlow();\n```\n\nGet the combinational dataflow relations between the operands and the results.\nThis returns a pair of ground type fieldrefs. The first element is the destination\nand the second is the source of the dependence. The default implementation returns\nan empty list, which implies that the operation is not combinational.\n\nNOTE: This method *must* be implemented by the user.\n\nHWEmittableModuleLike (`HWEmittableModuleLike`)\n-----------------------------------------------\n\nThis interface indicates that the module like op is emittable in SV and\nrequires SV legalization on its body.\n\n### Methods:\n\nHWInstanceLike (`HWInstanceLike`)\n---------------------------------\n\nProvide common instance information.\n\n### Methods:\n\n#### `getInputName`\n\n```\n::mlir::StringAttr getInputName(size_t idx);\n```\n\nReturn the name of the specified input port or null if it cannot be\ndetermined.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getOutputName`\n\n```\n::mlir::StringAttr getOutputName(size_t idx);\n```\n\nReturn the name of the specified result or null if it cannot be\ndetermined.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setInputName`\n\n```\nvoid setInputName(size_t idx, ::mlir::StringAttr name);\n```\n\nChange the name of the specified input port.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setOutputName`\n\n```\nvoid setOutputName(size_t idx, ::mlir::StringAttr name);\n```\n\nChange the name of the specified output port.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getInputNames`\n\n```\n::mlir::ArrayAttr getInputNames();\n```\n\nReturn the names of all input ports. If the instance operation stores the\nnames in an ArrayAttr this can avoid attribute constructions.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getOutputNames`\n\n```\n::mlir::ArrayAttr getOutputNames();\n```\n\nReturn the name of all ouput ports. If the instance operation stores the\nnames in an ArrayAttr this can avoid attribute constructions.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setInputNames`\n\n```\nvoid setInputNames(::mlir::ArrayAttr names);\n```\n\nChange the names of all input ports. If all names have to be changed, this\ncan avoid repeated intermediate attribute constructions.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setOutputNames`\n\n```\nvoid setOutputNames(::mlir::ArrayAttr names);\n```\n\nChange the names of all output ports. If all names have to be changed, this\ncan avoid repeated intermediate attribute constructions.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getDoNotPrint`\n\n```\nbool getDoNotPrint();\n```\n\nTrue if this instance is a phony placeholder\n\nNOTE: This method *must* be implemented by the user.\n\nHWModuleLike (`HWModuleLike`)\n-----------------------------\n\nProvide common module information.\n\n### Methods:\n\n#### `getHWModuleType`\n\n```\n::circt::hw::ModuleType getHWModuleType();\n```\n\nGet the module type\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getAllPortAttrs`\n\n```\nArrayRef<Attribute> getAllPortAttrs();\n```\n\nGet the port Attributes. This will return either an empty array or an array of size numPorts.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setAllPortAttrs`\n\n```\nvoid setAllPortAttrs(ArrayRef<Attribute> attrs);\n```\n\nSet the port Attributes\n\nNOTE: This method *must* be implemented by the user.\n\n#### `removeAllPortAttrs`\n\n```\nvoid removeAllPortAttrs();\n```\n\nRemove the port Attributes\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getAllPortLocs`\n\n```\nSmallVector<Location> getAllPortLocs();\n```\n\nGet the port Locations\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setAllPortLocsAttrs`\n\n```\nvoid setAllPortLocsAttrs(ArrayRef<Attribute> locs);\n```\n\nSet the port Locations\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setHWModuleType`\n\n```\nvoid setHWModuleType(::circt::hw::ModuleType type);\n```\n\nSet the module type (and port names)\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setAllPortNames`\n\n```\nvoid setAllPortNames(ArrayRef<Attribute> names);\n```\n\nSet the port names\n\nNOTE: This method *must* be implemented by the user.\n\nHWMutableModuleLike (`HWMutableModuleLike`)\n-------------------------------------------\n\nProvide methods to mutate a module.\n\n### Methods:\n\n#### `getPortLookupInfo`\n\n```\n::circt::hw::ModulePortLookupInfo getPortLookupInfo();\n```\n\nGet a handle to a utility class which provides by-name lookup of port indices. The returned object does *not* update if the module is mutated.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `modifyPorts`\n\n```\nvoid modifyPorts(ArrayRef<std::pair<unsigned, circt::hw::PortInfo>> insertInputs, ArrayRef<std::pair<unsigned, circt::hw::PortInfo>> insertOutputs, ArrayRef<unsigned> eraseInputs, ArrayRef<unsigned> eraseOutputs);\n```\n\nInsert and remove input and output ports\n\n#### `insertPorts`\n\n```\nvoid insertPorts(ArrayRef<std::pair<unsigned, circt::hw::PortInfo>> insertInputs, ArrayRef<std::pair<unsigned, circt::hw::PortInfo>> insertOutputs);\n```\n\nInsert ports into this module\n\nNOTE: This method *must* be implemented by the user.\n\n#### `erasePorts`\n\n```\nvoid erasePorts(ArrayRef<unsigned> eraseInputs, ArrayRef<unsigned> eraseOutputs);\n```\n\nErase ports from this module\n\nNOTE: This method *must* be implemented by the user.\n\n#### `appendOutputs`\n\n```\nvoid appendOutputs(ArrayRef<std::pair<StringAttr, Value>> outputs);\n```\n\nAppend output values to this module\n\nNOTE: This method *must* be implemented by the user.\n\nInnerRefUserOpInterface (`InnerRefUserOpInterface`)\n---------------------------------------------------\n\nThis interface describes an operation that may use a `InnerRef`. This\ninterface allows for users of inner symbols to hook into verification and\nother inner symbol related utilities that are either costly or otherwise\ndisallowed within a traditional operation.\n\n### Methods:\n\n#### `verifyInnerRefs`\n\n```\n::mlir::LogicalResult verifyInnerRefs(::circt::hw::InnerRefNamespace&ns);\n```\n\nVerify the inner ref uses held by this operation.\n\nNOTE: This method *must* be implemented by the user.\n\nInnerSymbolOpInterface (`InnerSymbol`)\n--------------------------------------\n\nThis interface describes an operation that may define an\n`inner_sym`. An `inner_sym` operation resides\nin arbitrarily-nested regions of a region that defines a\n`InnerSymbolTable`.\nInner Symbols are different from normal symbols due to\nMLIR symbol table resolution rules. Specifically normal\nsymbols are resolved by first going up to the closest\nparent symbol table and resolving from there (recursing\ndown for complex symbol paths). In HW and SV, modules\ndefine a symbol in a circuit or std.module symbol table.\nFor instances to be able to resolve the modules they\ninstantiate, the symbol use in an instance must resolve\nin the top-level symbol table. If a module were a\nsymbol table, instances resolving a symbol would start from\ntheir own module, never seeing other modules (since\nresolution would start in the parent module of the\ninstance and be unable to go to the global scope).\nThe second problem arises from nesting. Symbols defining\nops must be immediate children of a symbol table. HW\nand SV operations which define a inner\\_sym are grandchildren,\nat least, of a symbol table and may be much further nested.\nLastly, ports need to define inner\\_sym, something not allowed\nby normal symbols.\n\nAny operation implementing an InnerSymbol may have the inner symbol be\noptional and all methods should be robuse to the attribute not being\ndefined.\n\n### Methods:\n\n#### `getInnerNameAttr`\n\n```\n::mlir::StringAttr getInnerNameAttr();\n```\n\nReturns the name of the top-level inner symbol defined by this operation, if present.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getInnerName`\n\n```\n::std::optional<::mlir::StringRef> getInnerName();\n```\n\nReturns the name of the top-level inner symbol defined by this operation, if present.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setInnerSymbol`\n\n```\nvoid setInnerSymbol(::mlir::StringAttr name);\n```\n\nSets the name of the top-level inner symbol defined by this operation to the specified string, dropping any symbols on fields.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `setInnerSymbolAttr`\n\n```\nvoid setInnerSymbolAttr(::circt::hw::InnerSymAttr sym);\n```\n\nSets the inner symbols defined by this operation.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getInnerRef`\n\n```\n::circt::hw::InnerRefAttr getInnerRef();\n```\n\nReturns an InnerRef to this operation\u2019s top-level inner symbol, which must be present.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getInnerSymAttr`\n\n```\n::circt::hw::InnerSymAttr getInnerSymAttr();\n```\n\nReturns the InnerSymAttr representing all inner symbols defined by this operation.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `supportsPerFieldSymbols`\n\n```\nstatic bool supportsPerFieldSymbols();\n```\n\nReturns whether per-field symbols are supported for this operation type.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getTargetResultIndex`\n\n```\nstatic std::optional<size_t> getTargetResultIndex();\n```\n\nReturns the index of the result the innner symbol targets, if applicable. Per-field symbols are resolved into this.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getTargetResult`\n\n```\nOpResult getTargetResult();\n```\n\nReturns the result the innner symbol targets, if applicable. Per-field symbols are resolved into this.\n\nNOTE: This method *must* be implemented by the user.\n\nPortList (`PortList`)\n---------------------\n\nOperations which produce a unified port list representation\n\n### Methods:\n\n#### `getPortList`\n\n```\nSmallVector<::circt::hw::PortInfo> getPortList();\n```\n\nGet port list\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPort`\n\n```\n::circt::hw::PortInfo getPort(size_t idx);\n```\n\nGet port list\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortIdForInputId`\n\n```\nsize_t getPortIdForInputId(size_t idx);\n```\n\nGet the port a specific input\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getPortIdForOutputId`\n\n```\nsize_t getPortIdForOutputId(size_t idx);\n```\n\nGet the port a specific output\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getNumPorts`\n\n```\nsize_t getNumPorts();\n```\n\nGet the number of ports\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getNumInputPorts`\n\n```\nsize_t getNumInputPorts();\n```\n\nGet the number of input ports\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getNumOutputPorts`\n\n```\nsize_t getNumOutputPorts();\n```\n\nGet the number of output ports\n\nNOTE: This method *must* be implemented by the user.\n\nBitWidthTypeInterface (`BitWidthTypeInterface`)\n-----------------------------------------------\n\nType interface for types that have a statically computable bit width.\nThis allows types from different dialects to participate in bit width\ncalculations, enabling operations like hw.bitcast to work with non-HW types.\n\n### Methods:\n\n#### `getBitWidth`\n\n```\nstd::optional<int64_t> getBitWidth();\n```\n\nReturn the hardware bit width of the type. Does not reflect any encoding,\npadding, or storage scheme, just the bit (and wire width) of a\nstatically-sized type. Reflects the number of wires needed to transmit a\nvalue of this type. Returns std::nullopt if the type\u2019s bit width cannot\nbe statically computed.\n\nNOTE: This method *must* be implemented by the user.\n\nFieldIDTypeInterface (`FieldIDTypeInterface`)\n---------------------------------------------\n\nCommon methods for types which can be indexed by a FieldID.\nFieldID is a depth-first numbering of the elements of a type. For example:\n\n```\nstruct a  /* 0 */ {\n  int b; /* 1 */\n  struct c /* 2 */ {\n    int d; /* 3 */\n  }\n}\n\nint e; /* 0 */\n```\n\n### Methods:\n\n#### `getMaxFieldID`\n\n```\nuint64_t getMaxFieldID();\n```\n\nGet the maximum field ID for this type\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getSubTypeByFieldID`\n\n```\nstd::pair<::mlir::Type, uint64_t> getSubTypeByFieldID(uint64_t fieldID);\n```\n\nGet the sub-type of a type for a field ID, and the subfield\u2019s ID. Strip\noff a single layer of this type and return the sub-type and a field ID\ntargeting the same field, but rebased on the sub-type.\n\nThe resultant type *may* not be a FieldIDTypeInterface if the resulting\nfieldID is zero. This means that leaf types may be ground without\nimplementing an interface. An empty aggregate will also appear as a\nzero.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `projectToChildFieldID`\n\n```\nstd::pair<uint64_t, bool> projectToChildFieldID(uint64_t fieldID, uint64_t index);\n```\n\nReturns the effective field id when treating the index field as the\nroot of the type. Essentially maps a fieldID to a fieldID after a\nsubfield op. Returns the new id and whether the id is in the given\nchild.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getIndexForFieldID`\n\n```\nuint64_t getIndexForFieldID(uint64_t fieldID);\n```\n\nReturns the index (e.g. struct or vector element) for a given FieldID.\nThis returns the containing index in the case that the fieldID points to a\nchild field of a field.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getFieldID`\n\n```\nuint64_t getFieldID(uint64_t index);\n```\n\nReturn the fieldID of a given index (e.g. struct or vector element).\nField IDs start at 1, and are assigned\nto each field in a recursive depth-first walk of all\nelements. A field ID of 0 is used to reference the type itself.\n\nNOTE: This method *must* be implemented by the user.\n\n#### `getIndexAndSubfieldID`\n\n```\nstd::pair<uint64_t, uint64_t> getIndexAndSubfieldID(uint64_t fieldID);\n```\n\nFind the index of the element that contains the given fieldID.\nAs well, rebase the fieldID to the element.\n\nNOTE: This method *must* be implemented by the user.\n\n'hw' Dialect Docs\n-----------------\n\n* [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n\n [Prev - Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/ \"Handshake Dialect Rationale\")\n[Next - HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/ \"HW Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/HW/RationaleHW/index.md"
  },
  {
    "role": "user",
    "content": "HW Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nHW Dialect Rationale\n====================\n\nThis document describes various design points of the `hw` dialect as well as\nglobal perspective on the `hw`, `comb`, and `sv` dialects, why\nthey are the way they are, and current status. This follows in the spirit of\nother\n[MLIR Rationale docs](https://mlir.llvm.org/docs/Rationale/). For more\ninformation about the other dialects, please see the\n[Comb Dialect Rationale](/docs/Dialects/Comb/RationaleComb/) and\n[SV Dialect\nRationale](/docs/Dialects/SV/RationaleSV/).\n\n* [HW Dialect Rationale](#hw-dialect-rationale)\n  + [General Introduction](#general-introduction)\n  + [Introduction to the `hw` Dialect](#introduction-to-the-hw-dialect)\n  + [`hw` Type System](#hw-type-system)\n  + [`hw.module` and `hw.instance`](#hwmodule-and-hwinstance)\n    - [Instance paths](#instance-paths)\n  + [Parameterized Modules](#parameterized-modules)\n    - [Valid Parameter Expression Attributes](#valid-parameter-expression-attributes)\n    - [Parameter Expression Canonicalization](#parameter-expression-canonicalization)\n    - [Using parameters in the body of a module](#using-parameters-in-the-body-of-a-module)\n    - [Parameterized Types](#parameterized-types)\n    - [Answers to other common questions](#answers-to-other-common-questions)\n  + [Type declarations](#type-declarations)\n    - [Type declaration IR](#type-declaration-ir])\n    - [Type declaration System Verilog output](#type-declaration-system-verilog-output)\n    - [Type canonicalization](#type-canonicalization)\n    - [Open Issues](#open-issues)\n  + [Symbols and Visibility](#symbols-and-visibility)\n  + [Future Directions](#future-directions)\n\nGeneral Introduction\u00a0[\u00b6](#general-introduction)\n-----------------------------------------------\n\n[SystemVerilog](https://en.wikipedia.org/wiki/SystemVerilog) is an industry\nstandard language for hardware design and verification, is known by a large\nnumber of engineers who write it manually, and is\nan important interchange format between EDA tools. However, while it is\nubiquitous, SystemVerilog is not easy to generate or transform. Furthermore, it\nis non-trivial for compiler tools to generate high-quality human-readable\nSystemVerilog.\n\nThe `hw`, `comb` and `sv` dialects attempt to address these problems with\nseveral major contributions:\n\n1. The `hw` dialect provides unifying structure and\n   abstractions that are useful for a wide range of hardware modeling problems.\n   It allows other dialects to \u201cmix in\u201d with it to provide higher level\n   functionality.\n2. The `comb` dialect provides a common set of operations for combinational\n   logic. This dialect is designed to allow easy analysis and transformation.\n3. The `sv` dialect provides direct access to a wide variety\n   of SystemVerilog constructs, including behavioral constructs, syntactic\n   sugar constructs, and even idioms like `ifdef` blocks.\n4. The `circt` project provides a high quality implementation and a number of useful compiler\n   passes for analyzing and transforming these dialects, and a SystemVerilog\n   emitter that generates pretty output.\n\nThe combination of these capabilities provides a useful suite of functionality\nfor compiler tools that want to generate high quality SystemVerilog.\n\nIntroduction to the `hw` Dialect\u00a0[\u00b6](#introduction-to-the-hw-dialect)\n---------------------------------------------------------------------\n\nThe `hw` dialect defines a set of common functionality, such as `hw.module` and\n`hw.instance` for representing hardware modules, as well as common types (e.g.\n`hw.array<xx>`) and attributes. It is *not* designed to model SystemVerilog or\nany other hardware\ndesign language directly, and doesn\u2019t contain combinational or sequential\noperations and does not have \u201cconnect\u201d semantics. Instead, it is designed to be\na flexible and extensible substrate that may be extended with higher level\ndialects mixed into it (like `sv`, `comb`, and `seq` in the future, etc).\n\n`hw` Type System\u00a0[\u00b6](#hw-type-system)\n-------------------------------------\n\nTODO: Describe inout types. Analogy to lvalues vs rvalues. Array indices for\nboth forms. Arrays, structs,\nmoving\n[UnpackedArray](https://github.com/llvm/circt/issues/389) to SV someday.\n\nCLEANUP: InOut types is defined in the `hw` dialect, but logically lives at the\n`sv` dialect level. `sv` provides connects, wires and other syntactic\nconstructs that work with the inout type. These aren\u2019t necessary\nfor combinational logic, but are nonetheless pretty useful when generating\nVerilog.\n\n### `enum` Type\u00a0[\u00b6](#enum-type)\n\nEnum types have the property that the bit width of the type is the minimum\nnecessary to hold the tag values. Tag values are either explicit or\nsequentially numbered in tag order from 0. Enum tags are unsigned values.\n\n### `union` Type\u00a0[\u00b6](#union-type)\n\nUnion types contain a single data element (which may be an aggregate). They\noptionally have an offset per variant which allows non-SV layouts.\n\n`hw.module` and `hw.instance`\u00a0[\u00b6](#hwmodule-and-hwinstance)\n-----------------------------------------------------------\n\nThe basic structure of a hardware design is made up an \u201cinstance tree\u201d of\n\u201cmodules\u201d and \u201cinstances\u201d that refer to them. There are loose analogies to\nsoftware programs which have corresponding \u201cfunctions\u201d and \u201ccalls\u201d (but there\nare also major differences, see \u201c\n[Instance paths](#instance-paths)\u201d below).\nModules can have a\ndefinition `hw.module`, they can be a definition of an external module whose\nsignature is known but whose body is provided separately `hw.module.extern`,\nand can be a definition of an external module with a known signature that\ncan/will be generated in the future on demand (`hw.module.generated`).\n\nA simple example module looks like this (many more can be found in the\ntestsuite):\n\n```\nhw.module @two_and_three(%in: i4) -> (twoX: i4, threeX: i4) {\n  %0 = comb.add %in, %in : i4\n  %1 = comb.add %a, %0 : i4\n  hw.output %0, %1 : i4, i4\n}\n```\n\nThe signature of a modules have these major components:\n\n1. A symbol `name` which specifies the MLIR name for the module\n   (`@two_and_three` in the example above). This is what connects instances to\n   modules in a stable way.\n2. A list of input ports, each of which has a type (`%in: i4` in the example\n   above). Each input port is available as an SSA value through a block\n   argument in the entry block of an `hw.module`, allowing them to be used\n   within its body. \u201cinout\u201d ports are modeled as inputs with an `!hw.inout<T>`\n   type. Input port names are prefixed with a `%` because they are available\n   as SSA values in the body.\n3. A list of result port names and types (`twoX: i4` and `threeX: i4` in the\n   example above). In a `hw.module` definition, the values for the\n   results are provided by the operands to the `hw.output` terminator in the\n   body block. The names of result ports are not prefixed with `%` because\n   they are not MLIR SSA values.\n4. A list of module \u201cparameters\u201d, which provide parametric polymorphism\n   capabilities (somewhat similar to C++ templates) for modules. These are\n   described in more detail in the \u201c\n   [Parameterized\n   Modules](#parameterized-modules) section below.\n5. The `verilogName` attribute can be used to override the name for an external\n   module. TODO: we should eliminate this in the future and just use the symbol.\n6. Other ad-hoc attributes. The `hw` dialect is intended to allow open\n   extensibility by other dialects. Ad-hoc attributes put on `hw` dialect\n   modules should be namespace qualified according to the dialect they come\n   from to avoid conflicts.\n\nThis definition is fairly close to the Verilog family, but there are some\nnotable differences: for example:\n\n* We split output ports from input ports, don\u2019t use `hw.output` instead of\n  connects to specify the results. This allows better SSA dataflow\n  analysis from the `hw.output` which is useful for inter-module analyses.\n* We allow arbitrary types for module ports. The `hw` dialect is generally\n  designed to be extensible by other dialects, and thus being permissive here\n  is useful. That said, the\n  [Verilog exporter](/docs/VerilogGeneration/) does not\n  support arbitrary user-defined types.\n* The `comb` dialect in particular does not use signed integer types, but do\n  support zero-width integer types. Modules in the `hw` dialect,\n  support both of these. Zero width ports and wires are omitted (printed as\n  comments) when generating Verilog.\n\n### GlobalRefOp\u00a0[\u00b6](#globalrefop)\n\nThe GlobalRefOp operation (`hw.globalRef`) can be used to identify the unique\ninstance path of an operation globally.\n`hw.globalRef` can be used to attach nonlocal annotations in FIRRTL dialect\nand also for metadata emission.\n`hw.globalRef` defines a symbol and contains a list of module local\n`hw.innerNameRef` symbols to define the instance path.\nFor example, in the following example, `@glbl_B_M1` specifies instance\n\u201ch1\u201d in module `@A`, followed by instance\n\u201cM1\u201d in module `@B`.\n\n`hw.globalRef` can define a unique instance path, and each element along the way\ncarries an attribute `circt.globalRef`, pointing to the global op.\nThus instances participating in nonlocal paths are readily apparent.\n\n```\n  hw.globalRef @glbl_B_M1 [#hw.innerNameRef<@A::@inst_1>, #hw.innerNameRef<@B::@memInst>]\n  hw.globalRef @glbl_D_M1 [#hw.innerNameRef<@A::@inst_0>, #hw.innerNameRef<@C::@inst>, #hw.innerNameRef<@D::@memInst>]\n  hw.globalRef @glbl_D_M2 [#hw.innerNameRef<@A::@SF>, #hw.innerNameRef<@F::@symA>]\n  hw.globalRef @glbl_D_M3 [#hw.innerNameRef<@A::@SF>, #hw.innerNameRef<@F::@symB>]\n  hw.module @D() -> () {\n    hw.instance \"M1\" sym @memInst @FIRRTLMem() -> () {circt.globalRef = [#hw.globalNameRef<@glbl_D_M1>]}\n  }\n  hw.module @B() -> () {\n     hw.instance \"M1\" sym @memInst @FIRRTLMem() -> () {circt.globalRef = [#hw.globalNameRef<@glbl_B_M1>]}\n  }\n  hw.module @C() -> () {\n    hw.instance \"m\" sym @inst @D() -> () {circt.globalRef = [#hw.globalNameRef<@glbl_D_M1>]}\n  }\n  hw.module @A() -> () {\n    hw.instance \"h1\" sym @inst_1 @B() -> () {circt.globalRef = [#hw.globalNameRef<@glbl_B_M1>]}\n    hw.instance \"h2\" sym @inst_0 @C() -> () {circt.globalRef = [#hw.globalNameRef<@glbl_D_M1>]}\n    %c0 = hw.constant 0 : i1\n    %2 = hw.instance \"ab\" sym @SF  @F (a1: %c0: i1) -> (a2 : i1) {circt.globalRef = [#hw.globalNameRef<@glbl_D_M2>, #hw.globalNameRef<@glbl_D_M3>]}\n  }\n  hw.module.extern  @F(%a1: i1 {hw.exportPort = @symA, circt.globalRef = [#hw.globalNameRef<@glbl_D_M2>]}) -> (a2: i1 {hw.exportPort = @symB, circt.globalRef = [#hw.globalNameRef<@glbl_D_M3>]}) attributes {}\n\nsv.verbatim \"{{0}}\" { symbols = [@glbl_D_M1] }\nsv.verbatim \"{{0}}\" { symbols = [@glbl_B_M1] }\n```\n\n### Instance paths\u00a0[\u00b6](#instance-paths)\n\nAn IR for Hardware is different than an IR for Software in a very important way:\nwhile each function in a software program usually compiles into one blob of\nbinary code no matter how many times it is called, each instance in a hardware\ndesign is typically fully instantiated, because different instances turn into\ndifferent gates. The consequence of this is that the instance tree is really a\ncompression mechanism that is eventually elaborated away.\n\nThis compression approach has major advantages: it is much better for memory\nand compile time to represent a single definition of a hardware block than the\n(possibly thousands or millions) of concrete instances that will eventually be\nrequired. However, hardware engineers often do need to reason about and control\nthe different instances in some cases (e.g. providing physical layout\nconstraints for one instance but not the rest).\n\nTODO: Bake out a design for instance path references, an equivalent to the\nFIRRTL dialect `InstanceGraph` type, etc.\n\nParameterized Modules\u00a0[\u00b6](#parameterized-modules)\n-------------------------------------------------\n\nThe `hw` dialect supports parametric \u201ccompile-time\u201d polymorphism for modules.\nThis allows for metaprogramming along the instance tree, guaranteed\n\u201cinstantiation time\u201d optimizations and code generation, further enables\nthe \u201cIR compression\u201d benefits of using instances in the first place, and enables\nthe generation of parameters in generated Verilog (which can increase the\nperceived readability of the generated code).\n\nParameters are declared on modules (including generated and external ones)\nwith angle brackets: each parameter has a name and type, and can optionally\nhave a default value. Instances of a parameterized module provide a value for\neach parameter (even defaulted ones) in the same order:\n\n```\n// This module has two parameters \"p1\" and \"p2\".\nhw.module.extern @parameterized<p1: i42 = 17, p2: i1>(%in: i8) -> (out: i8)\n\nhw.module @UseParameterized(%a: i8) -> (ww: i8) {\n  %r0 = hw.instance \"inst\" @parameters<p1: i42 = 17, p2: i1 = 1>(in: %a: i8) -> (out: i8)\n  hw.output %r0 : i8\n}\n```\n\nThis approach makes analysis and transformation of the IR simple, predictable,\nand efficient: because the parameter list on instances and on modules always\nline up, they are indexable by integers (instead of strings), intermodule\nanalysis is straight-forward (no filling in of default values etc), and\nVerilog generation is always predictable: the default value for a parameter\nis used when the instance and the module default are the same (e.g. in the\nexample above, `p1` is not printed at the instance site because it is the same\nas the default.\n\nThe `sv` dialect provides the `sv.localparam` operation, which is used for\nnaming constants. These may be derived from module parameters or may just be\nnicely named constants intended to improve readability. This is part of the\n`sv` dialect (not the `hw` dialect) because it only makes sense as a concept\nwhen generating Verilog.\n\n**Compatibility with classic Verilog**\n\nNote that typed parameters are a SystemVerilog extension, many Verilog-only\ntools do not support them. If you need compatibility with Verilog-only tools,\nplease use `i32` integer, `f64`, and string parameters only. All module\nparameter definitions\n[should have default values](https://github.com/llvm/circt/issues/1848#issuecomment-933558192) for maximum tool compatibility as well, even if\nthey are always overridden.\n\n**TODO:** CIRCT could do parameter legalization to convert parameters smaller or\nlarger than 32-bits to 32-bits when generating Verilog-only output.\n\n### Valid Parameter Expression Attributes\u00a0[\u00b6](#valid-parameter-expression-attributes)\n\nThe following attributes may be used as expressions involving parameters at\nan instance site or in the default value for a parameter declaration on a\nmodule:\n\n* IntegerAttr/FloatAttr/StringAttr constants may be used as simple leaf values.\n* The `#hw.param.decl.ref` attribute is used to refer to the value of a\n  parameter in the current module. This is valid in most positions where a\n  parameter attribute is used - except in the default value for a module.\n* The `#hw.param.expr` operator allows combining other parameter expressions\n  into an expression tree. Expression trees have important canonicalization\n  rules to ensure important cases are canonicalized to uniquable\n  representations.\n* `#hw.param.verbatim<\"some string\">` may be used to provide an opaque blob of\n  textual Verilog that is uniqued by its string contents. This is intended\n  as a general \u201cescape hatch\u201d that allows frontend authors to express anything\n  Verilog cannot, even if first-class IR support doesn\u2019t exist yet. CIRCT does not\n  provide any checking to ensure that this is correct or safe, and assumes it\n  is single expression - parenthesize the string contents if not to be safe.\n  This\n  [should eventually support\n  substitutions](https://github.com/llvm/circt/issues/1881) like\n  `sv.verbatim.expr`.\n\nBecause parameter expressions are MLIR attributes, they are immortal values\nthat are uniqued based on their structure. This has several important\nimplications, including:\n\n* A parameter reference (`#hw.param.decl.ref`) to a parameter `x` doesn\u2019t know\n  what module it is in. The verifier checks that parameter expressions are\n  valid within the body of a module, and that the types line up between the\n  parameter reference and the declaration (after all, two different modules can\n  have two different parameters named `x` with different types).\n* We want to depend on MLIR canonicalizing and uniquing the pointer address of\n  attributes in a predictable way to ensure that further derived uniqued objects\n  (e.g. a parameterized integer type) is also uniqued correctly. For example,\n  we do not want the types `hw.int<x+1>` and `hw.int<1+x>` to turn into\n  different types. See the\n  [Parameter Expression\n  Canonicalization](#parameter-expression-canonicalization) section below for\n  more details.\n* Whereas the rest of the `hw` dialect is generally open for extension, the\n  current grammar of attribute expressions is closed: you have to hack the\n  HW dialect verifier and VerilogEmitter to add new kinds of valid expressions.\n  This is considered a limitation, we\u2019d like to move to an attribute interface\n  at some point that would allow dialect-defined attributes. For example, this\n  would allow moving `hw.param.verbatim` attribute down to the `sv` dialect.\n\nNote that there is no parameter expression equivalent for `comb.sub`:\n`(sub x, y)` is represented with `(add x, (mul y, -1))` which makes maintaining\ncanonical form simpler and more consistent.\n\n### Parameter Expression Canonicalization\u00a0[\u00b6](#parameter-expression-canonicalization)\n\nAs mentioned above, it is important to canonicalize parameter expressions. This\nslightly reduces memory usage, but more importantly ensures that equivalent\nparameter expressions are pointer equivalent: we don\u2019t want `x+1` and `1+x` to\nbe different, because that would cause everything derived from them to be as\nwell.\n\nOn the other hand, we expect to support a lot of weird expressions over time (at\nleast the full complement that Verilog supports) and canonicalizing arbitrary\nexpressions in a predictable way is untenable. As such, we support\ncanonicalizing a fixed set of expressions predictably: more may be added in\nthe future.\n\nThis set includes:\n\n* Constant folding: parameter expressions with all integer constant operands\n  are folded to their corresponding result.\n* Constant identities are simplified, e.g. `p1 & 0` into `0`, `p1 * 1` into\n  `p1`, `p1 << 0` into `p1`, `p1 >> 0` into `p1`, `p1 / 1` into `p1` and\n  `p1 % 1` into `0`.\n* Constant operand merging: any constant operands in associative operations are\n  merged into a single operand and moved to the right, e.g. `(add 4, x, 2)`\n  into `(add x, 6)`.\n* Fully associative operators flatten subexpressions, e.g.\n  `(add x, (add y, z))` into `(add x, y, z)`.\n* We simplify affine expressions into a sum of products representation, pulling\n  additions out of products, e.g. `(a+b)*c*d` into `(a*c*d + b*c*d)`\n* Operands of fully-associative expressions are put into a stable order, at\n  least for the case of affine expressions involving constant integers and\n  named parameters. For example `p2+p1` turns into `p1+p2` reliably. The\n  actual ordering moves subexpressions to the start of the list (more complex\n  ones first) followed by verbatims, followed by parameter references, followed\n  by constants, each group sorted w.r.t. each other.\n* Common operand factoring for adds, e.g. `(a+b+a)` into `(2*a + b)` and\n  `(a*4 + a)` into `(a*5)`\n* Shift left by constant is canonicalized into multiply to compose correctly\n  with affine expression canonicalization, e.g. `(shl x, 1)` into\n  `(mul x, 2)`.\n* As mentioned above, `sub` is not supported as a ParamExprAttr - it is\n  represented as multiply by `-1`. This allows it to trivially compose\n  with affine expression canonicalizations.\n\n### clog2 Parameter Expression\u00a0[\u00b6](#clog2-parameter-expression)\n\nA `clog2` parameter expression opcode is provided, which calculates the ceiling\nof log base 2 of its argument. This is useful for calculating things like the\nminimum bitwidth needed to address memory of a parameterized size.\n\nNote that `clog2(0)` is `0`, which follows the Verilog spec.\n\n### Using parameters in the body of a module\u00a0[\u00b6](#using-parameters-in-the-body-of-a-module)\n\nParameters are not\n[SSA values](https://en.wikipedia.org/wiki/Static_single_assignment_form), so they cannot directly be used within the body\nof the module. Just like you use `hw.constant` to project a constant integer\nvalue into the SSA domain, you can use the `hw.param.value` to project a\nparameter expression, like so:\n\n```\nhw.module @M1<param1: i1>(%clock : i1, ...) {\n  ...\n  %param1 = hw.param.value i1 = #hw.param.decl.ref<\"param1\">\n  ...\n    sv.if %param1 {  // Compile-time conditional on parameter.\n      sv.fwrite \"Only happens when the parameter is set\\n\"\n    }\n  ...\n}\n```\n\nAlternately, you can project them with a specific name, you can use the\n`sv.localparam` declaration like so:\n\n```\nhw.module @M1<param1: i1>(%clock : i1, ...) {\n  ...\n  %param1 = sv.localparam : i1 { value = #hw.param.decl.ref<\"param1\">: i1 }\n  ...\n    sv.if %param1 {  // Compile-time conditional on parameter.\n      sv.fwrite \"Only happens when the parameter is set\\n\"\n    }\n  ...\n}\n```\n\nUsing `sv.localparam` is helpful when you\u2019re looking to produce specifically\npretty Verilog for human consumption. The optimizer won\u2019t fold aggressively\naround these names.\n\n### Parameterized Types\u00a0[\u00b6](#parameterized-types)\n\nTODO: Not done yet.\n\n### Answers to other common questions\u00a0[\u00b6](#answers-to-other-common-questions)\n\nDuring the design work on parameterized modules, we had several proposals for\nalternative designs a lot of discussion on this. See in particular, these\ndiscussions at the open design meetings:\n\n* [September 15, 2021](https://docs.google.com/document/d/1fOSRdyZR2w75D87yU2Ma9h2-_lEPL4NxvhJGJd-s5pk/edit#heading=h.gdy95njn5105):\n  discussion about using SSA values vs attributes for expressions, whether\n  parameters should just be a \u201cspecial kind of port\u201d etc.\n* [September 22, 2021](https://docs.google.com/document/d/1fOSRdyZR2w75D87yU2Ma9h2-_lEPL4NxvhJGJd-s5pk/edit#heading=h.tcwfqa9fi7u2):\n  discussions on expression canonicalization, parameterized type casting and\n  other topics.\n\nThis section tries to condense some of those discussions into key points:\n\n**Why do instances repeat default parameters from modules?**\n\nAs described above, the full set of module parameters are specified on an\ninstance, even if some have default values. The reason for this is that we want\nthe IR to be simple and efficient to analyze by the compiler: keeping (and\nverifying that) instance parameters are in canonical form means that we can\nindex them with integers instead of names (just like module input and result\nports), and intermodule analysis/optimization doesn\u2019t have to handle default\nvalues as a special case. Instead they are just a matter for frontends and\nthe Verilog exporter to care about.\n\n**Why model parameters with attributes instead of SSA values?**\n\nIt seems unfortunate to replicate some parts of the `comb` dialect (e.g.\n`comb.add`) as attributes rather than just reusing the existing attributes.\nSuch a design has historical familiarity (e.g. LLVM\u2019s `ConstantExpr` class)\nwhich led to a bunch of complexity in LLVM that would have been better avoided\n(and yes - there are much better designs for LLVM\u2019s purposes than what it has\nnow).\n\nAll that said, using attributes is the right thing for a number of reasons:\n\n1. This arithmetic happens at metaprogramming time, these ops do not turn into\n   hardware. It use important and useful to be able to know that structurally.\n2. We need to verify parameter expressions are valid for the module they are\n   defined in - it isn\u2019t generally ok for the verifier of the `hw.instance` op\n   to walk an arbitrary amount of IR to check that an SSA value is valid as a\n   parameter.\n3. We need to support parameterized types like `!hw.int<n>`: because MLIR types\n   are immortal and uniqued, they can refer to attributes but cannot refer to\n   [SSA values](https://en.wikipedia.org/wiki/Static_single_assignment_form)\n   (which may be destroyed).\n4. Operations need to be able to compute their own type without creating other\n   operations. For example, we need to compute that the result type of\n   `comb.concat %a, %b : (i1, !hw.int<n>)` is `!hw.int<n+1>` without introducing\n   a new `comb.add` node to \u201cadd one to n\u201d.\n5. In practice, comb ops and the canonicalizations that apply to them have very\n   different goals than the canonicalizations we apply to parameter expressions.\n\nType declarations\u00a0[\u00b6](#type-declarations)\n-----------------------------------------\n\n**Type declaration IR**\n\n*Type Scope Operation*\n\nA\n[Type Scope](Dialects/HW/#hwtype_scope-circthwtypescopeop) declares a single\nregion with a single block that contains type declarations. Type scopes provide\na means to group type declarations. Type scopes have a symbol and are themselves\nsymbol tables, so they may be looked up, and type declarations may be looked up\nwithin them.\n\n*Type Declaration Operation*\n\nA\n[Type Declaration](https://circt.llvm.org/docs/Dialects/HW/#hwtypedecl-circthwtypedeclop)\ndeclares a symbolic name for a type. It consists of:\n\n* A symbolic name, which can be referred to in the IR by a Type Alias Type.\n* A type attribute, which contains the underlying type the name refers to\n* An optional string attribute, which specifies a name to give the type in the\n  output. If not specified, the symbolic name is used in the output.\n\n*Type Alias Type*\n\nA\n[Type Alias](https://circt.llvm.org/docs/Dialects/HW/#an-symbolic-reference-to-a-type-declaration)\nrefers to a type declaration symbolically. It consists of:\n\n* A symbolic reference to a Type Scope and Type Declaration within the scope\n* A copy of the underlying type, cached in type storage\n* A copy of the canonical type, cached in type storage\n\n**Type declaration System Verilog output**\n\nIn ExportVerilog, Type Scopes may be split into their own output file, included\nat the top of multiple split output files, or included via a header file.\n\nEach Type Declaration will be emitted according to the System Verilog spec,\nsection 6.18, User-defined types. For example:\n\n```\ntypedef logic mytype;\n```\n\n**Type canonicalization**\n\nWe take an approach to type canonicalization similar to\n[Clang](https://clang.llvm.org/docs/InternalsManual.html#canonical-types).\n\nTo implement this, CIRCT has an extra layer of indirection in the ODS\ndeclarations of types that may be targeted by Type Declarations. This layer\nmakes it possible to generically let operations declare their operands and\nresults to be of a specific type, and also accept type declarations that\ncanonicalize to that type.\n\nThe HW dialect types are declared in\n[HWTypesImpl.td](https://github.com/llvm/circt/blob/main/include/circt/Dialect/HW/HWTypesImpl.td),\nwhich declares the actual type and is used to generate the C++ wrappers. To make\nthese types usable in ODS operations in a generic way that support type\ndeclarations, wrapper types are declared in\n[HWTypes.td](https://github.com/llvm/circt/blob/main/include/circt/Dialect/HW/HWTypes.td),\nwhich uses helpers to define dialect types that may be either the declared type,\nor a type declaration whose canonical type is the declared type.\n\nIn order to \u201csee through\u201d type declarations and get at the canonical type, a set\nof helper functions are added to the hardware dialect: `hw::type_isa`,\n`hw::type_cast`, and `hw::type_dyn_cast`. These should generally be used instead\nof the MLIR `Type::isa`, `Type::cast`, and `Type::dyn_cast`, because they\ntransparently support type declarations.\n\nAs the Clang docs state: \u201cThe only hard part here is remembering not to use the\nisa/cast/dyn\\_cast operations.\u201d\n\n**Open Issues**\n\n*Duplicated type in Type Alias Type IR*\n\nIn order to support Type canonicalization, the Type Alias Type keeps a copy of\nthe underlying type, as well as what it canonicalizes to, cached in Type\nstorage. This allows the helpers like `hw::type_isa` to efficiently query the\nunderlying type or canonical type in constant time.\n\nIdeally, the Type Alias Type would only contain a symbolic reference to the\ndeclaration, and at construction time (during parsing or when built\nprogrammatically) look up and cache the underlying type and its canonical type.\n\nUnfortunately, this is not currently possible with the MLIR parser API. There is\nsome discussion about this on\n[Discourse](https://discourse.llvm.org/t/contextual-type-verification/4525),\nand it seems like a good enhancement. This is tracked in issue\n[#1642](https://github.com/llvm/circt/issues/1642).\nUntil then, we must duplicate the type in the IR.\n\nSymbols and Visibility\u00a0[\u00b6](#symbols-and-visibility)\n---------------------------------------------------\n\nVerilog has a broad notion of what can be named outside the context of its\ndeclaration. This is compounded by the many tools which have additional source\nfiles which refer to Verilog names (e.g. tcl files). However, we do not want to\nrequire that every wire, register, instance, localparam, port, etc which can be\nnamed not be touched by passes. We want only entities marked as public facing\nto impede transformation.\n\nFor this reason, wires, registers, and instances may optionally define a symbol.\nWhen the symbol is defined, the entity is considered part of the visible\ninterface and should be preserved in transformation. Entities without a symbol\ndefined are considered private and may be changed by transformation.\n\n**Implementation constraints**\n\nCurrently, MLIR restricts symbol resolution to looking in and downward through\nany nested symbol tables when resolving symbols. This assumption has\nimplications for verification, the pass manager, and threading. Until symbol\nreferences are more general, SV and HW dialects do not define symbol tables for\nmodules. Therefore, wires, registers, and interfaces exist in the same\nnamespace as modules. It is encouraged that one prefaces the names to avoid\nconflict with modules. The symbol names on these entities has no bearing on the\noutput Verilog, each of these entities has a defined way to assign its name (SSA\nvalue name for wires and regs, a non-optional string for instances).\n\nAs MLIR symbol support improves, it is desired to move to per-module symbol\ntables and to unify names with symbol names.\n\n**Ports**\n\nModule ports are remotely nameable entities in Verilog, but are not easily named\nwith symbols. A suggested workaround is to attach a wire to a port and use its\nsymbol for remote references. Instance ports have a similar problem.\n\nFuture Directions\u00a0[\u00b6](#future-directions)\n-----------------------------------------\n\nThere are many possible future directions that we anticipate tackling, when and\nif the need arises:\n\n**More support for IR**\n\nMany in the CIRCT community are interested in adding first-class support for\nparametric modules \u2013 similar but more general than SystemVerilog module\nparameters. It isn\u2019t clear yet whether this should be part of the HW dialect\nor something higher level.\n\nSeparate from a \u201cgood\u201d representation of parametric modules, the SV dialect\ncould grow direct support for representing the SystemVerilog functionality\nin this space, including even things like \u201cgenerate\u201d blocks.\n\n**EDA Tool-specific Subdialects**\n\nThe EDA tool ecosystem is filled with a wide range of tools with different\ncapabilities \u2013 for example\n[see this\ntable](https://symbiflow.github.io/sv-tests-results/) for one compilation of\ndifferent systems and their capabilities. As such, we expect that the day will\ncome where a frontend wants to generate fancy features for some modern systems,\nbut cannot afford to break compatibility with other ecosystem tools.\n\nGiven the design of the HW/SV dialects, there is no need to resort to \u201clowest\ncommon denominator\u201d approach here: we can allow frontends to generate \u201cfancy\u201d\nfeatures, then use progressive lowering when dealing with tools that can\u2019t\nhandle them. This can also allow IP providers to decide what flavor\nof features they want to provide to their customers (or provide multiple\ndifferent choices).\n\n**SystemVerilog Parser**\n\nAs the SV dialect grows out, it becomes natural to think about building a high\nquality parser that reads SystemVerilog source code and parses it into the SV\ndialect. Such functionality could be very useful to help build tooling for the\nSystemVerilog ecosystem.\n\nSuch a parser should follow clang-style principles of producing high quality\ndiagnostics, preserving source location information, being built as a library,\netc.\n\n [Prev - 'hw' Dialect](https://circt.llvm.org/docs/Dialects/HW/ \"'hw' Dialect\")\n[Next - 'hwarith' Dialect](https://circt.llvm.org/docs/Dialects/HWArith/ \"'hwarith' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect-](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/HWArith/index.md"
  },
  {
    "role": "user",
    "content": "'hwarith' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'hwarith' Dialect\n=================\n\n*Types and operations for the HWArith dialect*\n\nThis dialect defines the `HWArith` dialect, modeling bit-width aware\narithmetic operations.\n\n* [Operations](#operations)\n  + [`hwarith.add` (::circt::hwarith::AddOp)](#hwarithadd-circthwarithaddop)\n  + [`hwarith.cast` (::circt::hwarith::CastOp)](#hwarithcast-circthwarithcastop)\n  + [`hwarith.constant` (::circt::hwarith::ConstantOp)](#hwarithconstant-circthwarithconstantop)\n  + [`hwarith.div` (::circt::hwarith::DivOp)](#hwarithdiv-circthwarithdivop)\n  + [`hwarith.icmp` (::circt::hwarith::ICmpOp)](#hwarithicmp-circthwarithicmpop)\n  + [`hwarith.mul` (::circt::hwarith::MulOp)](#hwarithmul-circthwarithmulop)\n  + [`hwarith.sub` (::circt::hwarith::SubOp)](#hwarithsub-circthwarithsubop)\n* [Type constraints](#type-constraints)\n  + [an arbitrary precision integer with signedness semantics](#an-arbitrary-precision-integer-with-signedness-semantics)\n* [Enums](#enums)\n  + [ICmpPredicate](#icmppredicate)\n\nOperations\n----------\n\n### `hwarith.add` (::circt::hwarith::AddOp)\n\n*Bitwidth-aware integer addition.*\n\nSyntax:\n\n```\noperation ::= `hwarith.add` $inputs attr-dict `:` functional-type($inputs, $result)\n```\n\nThe `add` operation takes two operands and returns one result. The result\ntype is inferred from the operand types, which may be signed or unsigned\nscalar integer types of arbitrary bitwidth.\n\n| LHS type | RHS type | Result type |\n| --- | --- | --- |\n| `ui<a>` | `ui<b>` | `ui<r>`, *r* = max(*a*, *b*) + 1 |\n| `si<a>` | `si<b>` | `si<r>`, *r* = max(*a*, *b*) + 1 |\n| `ui<a>` | `si<b>` | `si<r>`, *r* = *a* + 2 **if** *a* \u2265 *b* |\n|  |  | `si<r>`, *r* = *b* + 1 **if** *a* < *b* |\n| `si<a>` | `ui<b>` | Same as `ui<b> + si<a>` |\n\nExamples:\n\n```\n%0 = hwarith.add %10, %11 : (ui3, ui4) -> ui5\n%1 = hwarith.add %12, %13 : (si3, si3) -> si4\n%2 = hwarith.add %14, %15 : (ui3, si4) -> si5\n%3 = hwarith.add %16, %17 : (si4, ui6) -> si8\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of an arbitrary precision integer with signedness semantics |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | an arbitrary precision integer with signedness semantics |\n\n### `hwarith.cast` (::circt::hwarith::CastOp)\n\n*Signedness-aware cast.*\n\nSyntax:\n\n```\noperation ::= `hwarith.cast` $in attr-dict `:` functional-type($in, $out)\n```\n\nThe `cast` operation takes one operand and returns one result. Both, the\nresult type and the operand type can be of any scalar integer type with\narbitrary bitwidth. However, at least one of them needs to be a\nHWArithIntegerType.\n\n| Input type | Result type | Behavior |\n| --- | --- | --- |\n| `ui<a>` | `ui<b>`/`si<b>`/`i<b>` | zero-extension **if** *b* \u2265 *a* |\n|  |  | truncation **if** *b* < *a* |\n| `si<a>` | `ui<b>`/`si<b>`/`i<b>` | sign-extension **if** *b* \u2265 *a* |\n|  |  | truncation **if** *b* < *a* |\n| `i<a>` | `ui<b>`/`si<b>` | truncation **if** *b* **\u2264** *a* |\n| `i<a>` | `ui<b>`/`si<b>` | prohibited\u2020 **if** *b* > *a* |\n\n\u2020) prohibited because of the ambiguity whether a sign or a zero extension\nis required.\n\nExamples:\n\n```\n%0 = hwarith.cast %10 : (ui3) -> si5\n%1 = hwarith.cast %11 : (si3) -> si4\n%2 = hwarith.cast %12 : (si7) -> ui4\n%3 = hwarith.cast %13 : (i7) -> si5\n%3 = hwarith.cast %13 : (si14) -> i4\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `in` | integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `out` | integer |\n\n### `hwarith.constant` (::circt::hwarith::ConstantOp)\n\n*Produce a constant value*\n\nThe constant operation produces a sign-aware constant value.\n\n```\n  %result = hwarith.constant 42 : t1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`, `FirstAttrDerivedResultType`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `rawValue` | ::mlir::IntegerAttr | arbitrary integer attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | an arbitrary precision integer with signedness semantics |\n\n### `hwarith.div` (::circt::hwarith::DivOp)\n\n*Bitwidth-aware integer division.*\n\nSyntax:\n\n```\noperation ::= `hwarith.div` $inputs attr-dict `:` functional-type($inputs, $result)\n```\n\nThe `div` operation takes two operands and returns one result. The result\ntype is inferred from the operand types, which may be signed or unsigned\nscalar integer types of arbitrary bitwidth.\n\n| LHS type | RHS type | Result type |\n| --- | --- | --- |\n| `ui<a>` | `ui<b>` | `ui<r>`, *r* = *a* |\n| `si<a>` | `si<b>` | `si<r>`, *r* = *a* + 1 |\n| `ui<a>` | `si<b>` | `si<r>`, *r* = *a* + 1 |\n| `si<a>` | `ui<b>` | `si<r>`, *r* = *a* |\n\nExamples:\n\n```\n%0 = hwarith.div %10, %11 : (ui3, ui4) -> ui3\n%1 = hwarith.div %12, %13 : (si3, si3) -> si4\n%2 = hwarith.div %14, %15 : (ui3, si4) -> si4\n%3 = hwarith.div %16, %17 : (si4, ui6) -> si4\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of an arbitrary precision integer with signedness semantics |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | an arbitrary precision integer with signedness semantics |\n\n### `hwarith.icmp` (::circt::hwarith::ICmpOp)\n\n*Sign- and bitwidth-aware integer comparison.*\n\nSyntax:\n\n```\noperation ::= `hwarith.icmp` $predicate $lhs `,` $rhs  attr-dict `:` type($lhs) `,` type($rhs)\n```\n\nThe `icmp` operation compares two integers using a predicate. If the\npredicate is true, returns 1, otherwise returns 0. This operation always\nreturns a one bit wide result of type `i1`. Both operand types may be\nsigned or unsigned scalar integer types of arbitrary bitwidth.\n\n| LHS type | RHS type | Comparison type | Result type |\n| --- | --- | --- | --- |\n| `ui<a>` | `ui<b>` | `ui<r>`, *r* = max(*a*, *b*) | `i1` |\n| `si<a>` | `si<b>` | `si<r>`, *r* = max(*a*, *b*) | `i1` |\n| `ui<a>` | `si<b>` | `si<r>`, *r* = *a* + 1 **if** *a* \u2265 *b* | `i1` |\n|  |  | `si<r>`, *r* = *b* **if** *a* < *b* | `i1` |\n| `si<a>` | `ui<b>` | Same as `ui<b> si<a>` | `i1` |\n\nExamples:\n\n```\n%0 = hwarith.icmp lt %10, %11 : ui5, ui6\n%1 = hwarith.icmp lt %12, %13 : si3, si4\n%2 = hwarith.icmp lt %12, %11 : si3, ui6\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `predicate` | circt::hwarith::ICmpPredicateAttr | hwarith.icmp comparison predicate |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | an arbitrary precision integer with signedness semantics |\n| `rhs` | an arbitrary precision integer with signedness semantics |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit signless integer |\n\n### `hwarith.mul` (::circt::hwarith::MulOp)\n\n*Bitwidth-aware integer multiplication.*\n\nSyntax:\n\n```\noperation ::= `hwarith.mul` $inputs attr-dict `:` functional-type($inputs, $result)\n```\n\nThe `mul` operation takes two operands and returns one result. The result\ntype is inferred from the operand types, which may be signed or unsigned\nscalar integer types of arbitrary bitwidth.\n\n| LHS type | RHS type | Result type |\n| --- | --- | --- |\n| `ui<a>` | `ui<b>` | `ui<r>`, *r* = *a* + *b* |\n| `si<a>` | `si<b>` | `si<r>`, *r* = *a* + *b* |\n| `ui<a>` | `si<b>` | `si<r>`, *r* = *a* + *b* |\n| `si<a>` | `ui<b>` | `si<r>`, *r* = *a* + *b* |\n\nExamples:\n\n```\n%0 = hwarith.mul %10, %11 : (ui3, ui4) -> ui7\n%1 = hwarith.mul %12, %13 : (si3, si3) -> si6\n%2 = hwarith.mul %14, %15 : (si3, ui5) -> si8\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of an arbitrary precision integer with signedness semantics |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | an arbitrary precision integer with signedness semantics |\n\n### `hwarith.sub` (::circt::hwarith::SubOp)\n\n*Bitwidth-aware integer subtraction.*\n\nSyntax:\n\n```\noperation ::= `hwarith.sub` $inputs attr-dict `:` functional-type($inputs, $result)\n```\n\nThe `sub` operation takes two operands and returns one result. The result\ntype is inferred from the operand types, which may be signed or unsigned\nscalar integer types of arbitrary bitwidth.\n\n| LHS type | RHS type | Result type |\n| --- | --- | --- |\n| `ui<a>` | `ui<b>` | `si<r>`, *r* = max(*a*, *b*) + 1 |\n| `si<a>` | `si<b>` | `si<r>`, *r* = max(*a*, *b*) + 1 |\n| `ui<a>` | `si<b>` | `si<r>`, *r* = *a* + 2 **if** *a* \u2265 *b* |\n|  |  | `si<r>`, *r* = *b* + 1 **if** *a* < *b* |\n| `si<a>` | `ui<b>` | Same as `ui<b> - si<a>` |\n\nExamples:\n\n```\n%0 = hwarith.sub %10, %11 : (ui3, ui4) -> si5\n%1 = hwarith.sub %12, %13 : (si3, si3) -> si4\n%2 = hwarith.sub %14, %15 : (ui3, si4) -> si5\n%3 = hwarith.sub %16, %17 : (si4, ui6) -> si8\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of an arbitrary precision integer with signedness semantics |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | an arbitrary precision integer with signedness semantics |\n\nType constraints\n----------------\n\n### an arbitrary precision integer with signedness semantics\n\nEnums\n-----\n\n### ICmpPredicate\n\n*Hwarith.icmp comparison predicate*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| eq | `0` | eq |\n| ne | `1` | ne |\n| lt | `2` | lt |\n| ge | `3` | ge |\n| le | `4` | le |\n| gt | `5` | gt |\n\n'hwarith' Dialect Docs\n----------------------\n\n* [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n\n [Prev - HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/ \"HW Dialect Rationale\")\n[Next - HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/ \"HW Arith Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/index.md"
  },
  {
    "role": "user",
    "content": "HW Arith Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nHW Arith Dialect Rationale\n==========================\n\nThis document describes the various design points of the HWArith dialect, a\ndialect that is used to represent bitwidth extending arithmetic. This follows in the\nspirit of other\n[MLIR Rationale docs](https://mlir.llvm.org/docs/Rationale/).\n\n* [HW Arith Dialect Rationale](#hw-arith-dialect-rationale)\n  + [Introduction](#introduction)\n    - [Q&A](#qa)\n  + [Bit Width Rules](#bit-width-rules)\n  + [Lowering](#lowering)\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\nThe `hwarith` dialect provides a collection of operations that define typical\ninteger arithmetic operations which are bitwidth extending. These semantics\nare expressed through return type inference rules that, based on the types of an\noperation and its input operands, infers the type of the result operand.\nImportantly, for the initial implementation of this dialect, we do not allow\ntypes with uninferred width in the IR. A user is expected to iteratively build\noperations, expect operation return types, and use this to further construct IR.\nThis dialect is **not** intended to be a \u201ccore\u201d RTL dialect which takes part in\nRTL codegen, and instead mainly serves as a frontend target. The lifetime of the\noperations should be considered short, and lowered to their `comb` counterparts\nearly in the compilation pipeline.\n\nIn general, the bit width inference rules are designed to model SystemVerilog\nsemantics. However, unlike SystemVerilog, the aim of this dialect is to provide\na strongly-typed hardware arithmetic library with the width inference rules for\nevery operator explained in a clear and understandable way to avoid ambiguity.\n\nTo serve this goal of being strongly typed, the operations of the dialect\nexplicitly do not accept signless types. As such, only `ui#`, `si#` types are\nallowed. A casting operation is provided to serve signedness casting as well as\ntruncation and padding.\n\nBelow we try to capture some common questions on the capabilities of such a\ndialect, and how we\u2019ve addressed/think about the issue.\n\n### Q&A\u00a0[\u00b6](#qa)\n\n* **Q:** Does this support n-ary operations?\n  + n-ary operations in this dialect would have to solve the issue of how\n    width rules in expressions such as the following are handled: `%0 = hwarith.add %0, %1, %2 : si6, si5, si4`  \n    In the short term, we envision this dialect to be considering strictly\n    binary operations. Defining width inference rules for these is simpler and\n    fits the immediate usecase. If, in the future, a need for n-ary operations\n    comes up and is motivated clearly (e.g. for optimization purposes), the\n    dialect should be adapted to support it. In this case, we expect n-ary\n    operation rules to be a superset of those defined for binary operations.\n* **Q:** Does this support 0-width operands?\n  + 0-width values might arise from arithmetic rules which reduce the bit\n    width of an expression wrt. the operands to that expression. One case\n    where such rules *may* apply is in the implementation of modulo\n    operations.  \n    We refrain from adding support at this point in time, since support for\n    0-width values in the remainder of the RTL dialects is, at time of writing,\n    lacking/undefined. Once support is added in these downstream dialects,\n    0-width support in `hwarith` should be reconsidered.\n* **Q:** Does this support width inferred types?\n  + Relying on width inference is relevant when referencing results of other\n    width-inferred value. Without this, a user/frontend must itself know and\n    apply width inference rules while generating the IR (either explicitly, or\n    implicitly, through op builders). Having width-inferred types will be\n    convenient not only for generating IR, but also to leave room for width\n    inference rules and optimizations to apply recursively. As an example:\n\n  ```\n  %1 = hwarith.add %a, %b : (ui4, ui4) -> (un) // %1 is an unsigned integer of inferred width\n  %2 = hwarith.add %c, %1 : (ui3, ui) -> (un)\n  ```\n\n  We see merit in having inferred width types, but recognize that the work\n  required to get this right is non-trivial and will require significant\n  effort. Once need arises, and resources are available, we find width\n  inferred types to be a valuable contribution to the dialect, but it will not\n  be part of the initial implementation.\n* **Q:** Does this support user-provided/alternative rules?\n  + Initially, we want to settle on a set of common-case rules which describe\n    the semantics required by the immediate users of the dialect, so this will\n    not be an immediate goal of the dialect.\n* **Q:** What about fixed point operations?\n  + Fixed point operations and values may eventually be relevant in an\n    `hwarith` context. However, the immediate needs of this dialect is to\n    provide bitwidth-extending arithmetic for integer values.\n* **Q:** What about floating point operations?\n  + As above, with the additional consideration that handling floating point\n    operations in hardware usually involves inferring external IP. Considering\n    how float operations are added to `hwarith` should only be considered\n    after the problem of operator libraries have been solved for CIRCT.\n\nBit Width Rules\u00a0[\u00b6](#bit-width-rules)\n-------------------------------------\n\nThe core capability of the dialect is the bit width inference rules implemented\nfor each operation. These define the semantics for how arithmetic overflow is to\nbe handled both with respect to the width and signedness of operation results,\nas well as how this is communicated to a `comb` lowering.\n\n### Preliminaries\u00a0[\u00b6](#preliminaries)\n\nThe MLIR `ui<w>` types represents values in the interval *[0, 2^w - 1]*. Its\nsigned counterpart, `si<w>`, represents values in the interval *[-2^(w-1),\n2^(w-1) - 1]*. For example, `ui4` covers values between *0* and *15*, whereas\n`si4` ranges from *-8* to *7*. For a given bit-width, the unsigned and the\nsigned type contain the same number of values, but the represented interval is\nshifted by half the interval\u2019s size.\n\n```\n         \u2502                  \n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \n         \u2502     ui4      \u2502   \n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \n \u2502     si4      \u2502           \n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\n-8       0      7      15\n```\n\nWe use the notation `UI_MIN<w>`, `UI_MAX<w>`, `SI_MIN<w>` and `SI_MAX<w>` to\ndenote the smallest and largest values representable by an unsigned/signed type\nof the given bit-width. For example, `UI_MAX<4>` = *15*, and `SI_MIN<4>` = *-8*.\n\nThe following relations for all `w > 0` are handy:\n\n```\nUI_MIN<w>     = 0\n2 * UI_MAX<w> = 2^(w+1) - 2\nUI_MAX<w+1>   = 2 * UI_MAX<w> + 1 \n\nSI_MIN<w>     < 0\n2 * SI_MIN<w> = -2^w\nSI_MIN<w+1>   = 2 * SI_MIN<w>\n2 * SI_MAX<w> = 2^w - 2\nSI_MAX<w+1>   = 2 * SI_MAX<w> + 1\n```\n\nThe following result type inference rules are chosen to prevent a loss of\nprecision and sign information associated with over- and underflows. The\nreasoning usually takes the smallest and largest possible result values into\naccount. For example, if the result can be negative, then the result type must\nbe signed.\n\n### Addition\u00a0[\u00b6](#addition)\n\n#### Overview\u00a0[\u00b6](#overview)\n\n|  | LHS type | RHS type | Result type |\n| --- | --- | --- | --- |\n| (U) | `ui<a>` | `ui<b>` | `ui<r>`, *r* = max(*a*, *b*) + 1 |\n| (S) | `si<a>` | `si<b>` | `si<r>`, *r* = max(*a*, *b*) + 1 |\n| (M) | `ui<a>` | `si<b>` | `si<r>`, *r* = *a* + 2 **if** *a* \u2265 *b* |\n|  |  |  | `si<r>`, *r* = *b* + 1 **if** *a* < *b* |\n| (M) | `si<a>` | `ui<b>` | Same as `ui<b> + si<a>` |\n\n#### Unsigned addition (U)\u00a0[\u00b6](#unsigned-addition-u)\n\nResult value range: `[0 + 0, UI_MAX<a> + UI_MAX<b>]`\n\nW.l.o.g., let `ui<b>` be the wider type. Then the following inequalities hold:\n\n```\nUI_MAX<b> < UI_MAX<a> + UI_MAX<b> \u2264 2 * UI_MAX<b> \u2264 UI_MAX<b+1>\n```\n\nExample:\n\n```\n%0 = hwarith.add %10, %11 : (ui3, ui4) -> ui5\n```\n\n#### Signed addition (S)\u00a0[\u00b6](#signed-addition-s)\n\nResult value range: `[SI_MIN<a> + SI_MIN<b>, SI_MAX<a> + SI_MAX<b>]`\n\nWe apply the same reasoning as in (U). W.l.o.g., let `si<b>` be the wider type.\nThen the following inequalities hold:\n\n```\nSI_MIN<b> > SI_MIN<a> + SI_MIN<b> \u2265 2 * SI_MIN<b> \u2265 SI_MIN<b+1>\nSI_MAX<b> < SI_MAX<a> + SI_MAX<b> \u2264 2 * SI_MAX<b> \u2264 SI_MAX<b+1>\n```\n\nExample:\n\n```\n%1 = hwarith.add %12, %13 : (si3, si3) -> si4\n```\n\n#### Mixed addition (M)\u00a0[\u00b6](#mixed-addition-m)\n\nThe result type must be signed, as the addition of a positive and a negative\nvalue may yield a negative result. Due to commutativity, we only consider\n`ui<a> + si<b>`. We distinguish two situations:\n\n* `a \u2265 b`, i.e. the unsigned operand\u2019s width is greater or equal the signed\n  operand\u2019s width.\n\n  The smallest signed type to represent all values of `ui<a>` is `si<a+1>`.\n  We know that `a + 1 > b`, and derive from (S) that the result type must be\n  `si<(a+1) + 1>` = `si<a+2>`.\n* `a < b`, i.e. the unsigned operand\u2019s width is strictly less than the signed\n  operand\u2019s width.\n\n  As `a + 1 \u2264 b`, the result via (S) is `si<b+1>`.\n\nExamples:\n\n```\n%2 = hwarith.add %14, %15 : (ui3, si4) -> si5\n%3 = hwarith.add %16, %17 : (si4, ui6) -> si8\n```\n\n### Subtraction\u00a0[\u00b6](#subtraction)\n\n#### Overview\u00a0[\u00b6](#overview-1)\n\n|  | LHS type | RHS type | Result type |\n| --- | --- | --- | --- |\n| (U) | `ui<a>` | `ui<b>` | `si<r>`, *r* = max(*a*, *b*) + 1 |\n| (S) | `si<a>` | `si<b>` | `si<r>`, *r* = max(*a*, *b*) + 1 |\n| (M) | `ui<a>` | `si<b>` | `si<r>`, *r* = *a* + 2 **if** *a* \u2265 *b* |\n|  |  |  | `si<r>`, *r* = *b* + 1 **if** *a* < *b* |\n| (M) | `si<a>` | `ui<b>` | Same as `ui<b> - si<a>` |\n\n#### Unsigned subtraction (U)\u00a0[\u00b6](#unsigned-subtraction-u)\n\nResult value range: `[0 - UI_MAX<b>, UI_MAX<a> - 0]`\n\nAs the result can be negative, the result type must be signed. `-UI_MAX<b>` is\ncovered by `si<b+1>`, and `UI_MAX<a>` is covered by `si<a+1>`, so the narrowest\ntype capable of representing both extremal values is `si<r>` with\n*r* = max(*a*, *b*) + 1.\n\nExample:\n\n```\n%0 = hwarith.sub %10, %11 : (ui3, ui4) -> si5\n```\n\n#### Signed subtraction (S)\u00a0[\u00b6](#signed-subtraction-s)\n\nResult value range: `[SI_MIN<a> - SI_MAX<b>, SI_MAX<a> - SI_MIN<b>]`\n\nWe rewrite the value range and then apply the same reasoning as for the\n[signed addition](#signed-addition-S):\n\n```\n  [SI_MIN<a> - SI_MAX<b>, SI_MAX<a> - SI_MIN<b>]\n= [SI_MIN<a> + -2^(b-1) + 1, SI_MAX<a> + 2^(b-1)]\n= [SI_MIN<a> + SI_MIN<b> + 1, SI_MAX<a> + SI_MAX<b> + 1]\n```\n\nW.l.o.g., let `si<b>` be the wider type. Then the following inequalities hold:\n\n```\nSI_MIN<b> > SI_MIN<a> + SI_MIN<b> + 1 \u2265 2 * SI_MIN<b> + 1 \u2265 SI_MIN<b+1>\nSI_MAX<b> < SI_MAX<a> + SI_MAX<b> + 1 \u2264 2 * SI_MAX<b> + 1 \u2264 SI_MAX<b+1>\n```\n\nExample:\n\n```\n%1 = hwarith.sub %12, %13 : (si3, si3) -> si4\n```\n\n### Mixed subtraction (M)\u00a0[\u00b6](#mixed-subtraction-m)\n\nSee\n[mixed addition](#mixed-addition-M).\n\nExamples:\n\n```\n%2 = hwarith.sub %14, %15 : (ui3, si4) -> si5\n%3 = hwarith.sub %16, %17 : (si4, ui6) -> si8\n```\n\n### Multiplication\u00a0[\u00b6](#multiplication)\n\n#### Overview\u00a0[\u00b6](#overview-2)\n\n|  | LHS type | RHS type | Result type |\n| --- | --- | --- | --- |\n| (U) | `ui<a>` | `ui<b>` | `ui<r>`, *r* = *a* + *b* |\n| (S) | `si<a>` | `si<b>` | `si<r>`, *r* = *a* + *b* |\n| (M) | `ui<a>` | `si<b>` | `si<r>`, *r* = *a* + *b* |\n| (M) | `si<a>` | `ui<b>` | `si<r>`, *r* = *a* + *b* |\n\n#### Unsigned multiplication (U)\u00a0[\u00b6](#unsigned-multiplication-u)\n\nResult value range: `[0 * 0, UI_MAX<a> * UI_MAX<b>]`\n\nThe result type must be at least *a* + \\*b bits wide:\n\n```\nUI_MAX<a> * UI_MAX<b> = (2^a - 1) * (2^b - 1)\n                      = 2^(a + b) - 2^a - 2^b + 1 \n                      \u2264 2^(a + b) - 1 = UI_MAX<a+b>\n```\n\nThe result type cannot be smaller than `ui<a+b>`, as the following\ncounter-example shows:\n\n```\nUI_MAX<3> * UI_MAX<4> = 7 * 15 = 105 > UI_MAX<3+4-1>\n```\n\nExample:\n\n```\n%0 = hwarith.mul %10, %11 : (ui3, ui4) -> ui7\n```\n\n#### Signed multiplication (S)\u00a0[\u00b6](#signed-multiplication-s)\n\nResult value range:\n`[min(SI_MIN<a> * SI_MAX<b>, SI_MAX<a> * SI_MIN<b>), SI_MAX<a> * SI_MAX<b>]`\n\nWith the same reasoning as in (U), we know that `si<a+b>` is the narrowest type\nto accommodate `SI_MAX<a> * SI_MAX<b>`. This type also covers the negative\nextremal value (w.l.o.g. let `si<b>` be the wider type here):\n\n```\nSI_MIN<a> * SI_MAX<b> = -2^(a-1) * (2^(b-1) - 1)\n                      = -2^(a + b - 2) + 2^(a-1)\n                      \u2265 -2^(a + b - 1) = SI_MIN<a+b>\n```\n\nExample:\n\n```\n%1 = hwarith.mul %12, %13 : (si3, si3) -> si6\n```\n\n#### Mixed multiplication (M)\u00a0[\u00b6](#mixed-multiplication-m)\n\nThe result type must be signed. Let us consider `ui<a> * si<b>`; the flipped\ncase `si<a> * ui<b>` follows analogously.\n\nResult value range: `[UI_MAX<a> * SI_MIN<b>, UI_MAX<a> * SI_MAX<b>]`\n\nAnalogously to the previous cases, the result type must be at least *a* + *b*\nbits wide:\n\n```\nUI_MAX<a> * SI_MIN<b> = (2^a - 1) * -2^(b-1)\n                      = -2^(a + b - 1) + 2^(b-1)\n                      \u2265 2^(a + b - 1) = SI_MIN<a+b>\n\nUI_MAX<a> * SI_MAX<b> = (2^a - 1) * (2^(b-1) - 1)\n                      = 2^(a + b - 1) - 2^a - 2^(b-1) + 1\n                      \u2264 2^(a + b - 1) - 1 = SI_MAX<a+b>\n```\n\nAgain, we cannot choose a narrower type according to the following\ncounter-example:\n\n```\nUI_MAX<3> * SI_MAX<4> = 7 * 7 = 49 \u2265 SI_MAX<3+4-1>\n```\n\nExample:\n\n```\n%2 = hwarith.mul %14, %15 : (si3, ui5) -> si8\n```\n\n### Division\u00a0[\u00b6](#division)\n\n#### Overview\u00a0[\u00b6](#overview-3)\n\n|  | LHS type | RHS type | Result type |\n| --- | --- | --- | --- |\n| (U) | `ui<a>` | `ui<b>` | `ui<r>`, *r* = *a* |\n| (S) | `si<a>` | `si<b>` | `si<r>`, *r* = *a* + 1 |\n| (M1) | `ui<a>` | `si<b>` | `si<r>`, *r* = *a* + 1 |\n| (M2) | `si<a>` | `ui<b>` | `si<r>`, *r* = *a* |\n\n#### Unsigned division (U)\u00a0[\u00b6](#unsigned-division-u)\n\nResult value range: `[0 / 1, UI_MAX<a> / 1]`\n\nThe result is also less or equal the dividend, so the result type is `ui<a>`.\n\nExample:\n\n```\n%0 = hwarith.div %10, %11 : (ui3, ui4) -> ui3\n```\n\n#### Signed division (S)\u00a0[\u00b6](#signed-division-s)\n\nResult value range: `[SI_MIN<a> / 1, SI_MIN<a> / -1]`\n\n`- SI_MIN<a>` is not covered by `si<a>`, so we have to widen the result type to\n`si<a+1>`.\n\nExample:\n\n```\n%1 = hwarith.div %12, %13 : (si3, si3) -> si4\n```\n\n#### Division with signed divisor (M1)\u00a0[\u00b6](#division-with-signed-divisor-m1)\n\nIf at least one operand is signed, then the result type must be signed as well.\n\nResult value range: `[UI_MAX<a> / -1, UI_MAX<a> / 1]`\n\nThe result type must be `si<a+1>` in order to accommodate `UI_MAX<a>`.\n\nExample:\n\n```\n%2 = hwarith.div %14, %15 : (ui3, si4) -> si4\n```\n\n#### Division with signed dividend (M2)\u00a0[\u00b6](#division-with-signed-dividend-m2)\n\nIf at least one operand is signed, then the result type must be signed as well.\n\nResult value range: `[SI_MIN<a> / 1, SI_MAX<a> / 1]`]\n\nThe type of the dividend, `si<a>`, already covers the entire result value range.\n\nExample:\n\n```\n%3 = hwarith.div %16, %17 : (si4, ui6) -> si4\n```\n\n### Casting\u00a0[\u00b6](#casting)\n\nCasting between signless and sign-aware types is essential for `HWArith` to\ncoexist and interact with core dialects such as `HW` and `Comb`. Defining\ncasting rules can be split into two sub-problems: bit-extension and truncation.\nTruncation to a type with identical or smaller bitwidth is simply implemented\nby extracting the least significant bits of the operand. Hence, it is identical\nfor sign-aware and signless types. Bit-extension on the other hand needs to\nconsider the signedness of the operand to preserve the operand\u2019s value. As\nsignless types do not express such information by design, no bit-extension can\nbe performed. Values of type `si<w>` or `ui<w>` are sign-extended or\nzero-extended, respectively, regardless of the target\u2019s signedness or lack\nthereof. Thus, when casting in `HWArith`, first the bitwidth is adjusted to the\ntarget size, then in a second step the signedness is changed in a bitcast\nmanner.\n\nTo visualize this behavior study the following example:\n\n```\n%1 = hwarith.cast %10 : (ui3) -> ui5\n%2 = hwarith.cast %1 : (ui5) -> si5\n// ^-- both casts can be combined into one equivalent cast:\n%0 = hwarith.cast %10 : (ui3) -> si5\n// ^-- this would be lowered to something like this:\n%zero_padding = hw.constant 0 : i2\n%0_lowered = comb.concat %zero_padding, %10 : i2, i3\n```\n\nAs an alternative to the proposed *all-in-one* cast op, we considered\nimplementing a set of ops with distinct concerns, for example, an op for\nbitcasting between types of the same bitwidth, an op to implementing the\ntruncation and two ops for the different bit extension types. Yet, considering\nthat `HWArith` is currently intended as a short-lived dialect, being immediately\nlowered to `comb`, no obvious benefits emerge. This could also significantly\nincrease the code redundancy during IR generation as well as when lowering to\n`comb`.\n\n#### Overview\u00a0[\u00b6](#overview-4)\n\n|  | Input type | Result type | Behavior |\n| --- | --- | --- | --- |\n| (U) | `ui<a>` | `ui<b>`/`si<b>`/`i<b>` | zero-extension **if** *b* \u2265 *a* |\n|  |  |  | truncation **if** *b* < *a* |\n| (S) | `si<a>` | `ui<b>`/`si<b>`/`i<b>` | sign-extension **if** *b* \u2265 *a* |\n|  |  |  | truncation **if** *b* < *a* |\n| (I) | `i<a>` | `ui<b>`/`si<b>` | truncation **if** *b* **\u2264** *a* |\n|  | `i<a>` | `ui<b>`/`si<b>` | prohibited\u2020 **if** *b* > *a* |\n\n\u2020) prohibited because of the ambiguity whether a sign or a zero extension is\nrequired.\n\n#### Examples\u00a0[\u00b6](#examples)\n\n```\n%0 = hwarith.cast %10 : (ui3) -> si5 // (U)\n%1 = hwarith.cast %11 : (si3) -> si4 // (S)\n%2 = hwarith.cast %12 : (si7) -> ui4 // (S)\n%3 = hwarith.cast %13 : (i7) -> si5  // (I)\n%3 = hwarith.cast %13 : (si14) -> i4 // (S)\n```\n\n### Comparison\u00a0[\u00b6](#comparison)\n\nIn order to compare two sign-aware operands, a common type must first be found\nthat is able to preserve the values of the two operands. Once determined, the\noperands are casted to this comparison type as specified in the\n[casting section](#casting). To simplify the use as well as the IR generation\nof the dialect, the necessary casting steps are hidden from the user and\napplied during the lowering. Thus, the following code:\n\n```\n%2 = hwarith.cast %0 : (si3) -> si6\n%3 = hwarith.cast %1 : (ui5) -> si6\n%4 = hwarith.icmp lt %2, %3 : si6, si6\n```\n\ncan be simplified to:\n\n```\n%4 = hwarith.icmp lt %0, %1 : si3, ui5\n```\n\nNote that the result of the comparison is *always* of type `i1` since the\nlogical result is a boolean, which doesn\u2019t have signedness semantics.\n\n#### Overview\u00a0[\u00b6](#overview-5)\n\n|  | LHS type | RHS type | Comparison type | Result type |\n| --- | --- | --- | --- | --- |\n| (U) | `ui<a>` | `ui<b>` | `ui<r>`, *r* = max(*a*, *b*) | `i1` |\n| (S) | `si<a>` | `si<b>` | `si<r>`, *r* = max(*a*, *b*) | `i1` |\n| (M) | `ui<a>` | `si<b>` | `si<r>`, *r* = *a* + 1 **if** *a* \u2265 *b* | `i1` |\n|  |  |  | `si<r>`, *r* = *b* **if** *a* < *b* | `i1` |\n| (M) | `si<a>` | `ui<b>` | Same as `ui<b> si<a>` | `i1` |\n\n#### Examples\u00a0[\u00b6](#examples-1)\n\n```\n%0 = hwarith.icmp lt %10, %11 : ui5, ui6 // (U)\n%1 = hwarith.icmp lt %12, %13 : si3, si4 // (S)\n%2 = hwarith.icmp lt %12, %11 : si3, ui6 // (M)\n```\n\n### Additional operators\u00a0[\u00b6](#additional-operators)\n\n**TODO**: elaborate once operators are provided.\n\n* `hwarith.mod %0, %1 : (#l0, #l1) -> (#l2)`:\n\nLowering\u00a0[\u00b6](#lowering)\n-----------------------\n\nThe general lowering style of the dialect operations consists of padding the\noperands of an operation based on an operation rule, and subsequently feeding\nthese operands to the corresponding `comb` operator.\n\nFor instance, given `%res = hwarith.add %lhs, %rhs` and a rule stating `w(res)`\n= `max(w(lhs), w(rhs)) + 1` the lowering would be:\n\n```\n%res = hwarith.add %lhs, %rhs : (ui3, ui4) -> (ui5)\n\n// lowers to\n%z2 = hw.constant 0 : i2\n%z1 = hw.constant 0 : i1\n%lhs_padded = comb.concat %z2, %lhs : i2, i3\n%rhs_padded = comb.concat %z1, %rhs : i1, i4\n%res = comb.add %lhs_padded, %rhs_padded : i5\n```\n\n [Prev - 'hwarith' Dialect](https://circt.llvm.org/docs/Dialects/HWArith/ \"'hwarith' Dialect\")\n[Next - 'kanagawa' Dialect](https://circt.llvm.org/docs/Dialects/Kanagawa/ \"'kanagawa' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect-](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Kanagawa/index.md"
  },
  {
    "role": "user",
    "content": "'kanagawa' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'kanagawa' Dialect\n==================\n\n*Types and operations for Kanagawa dialect*\n\nThe `kanagawa` dialect is intended to support porting and eventual open sourcing\nof an internal hardware development language.\n\n* [Operations](#operations)\n  + [`kanagawa.call` (::circt::kanagawa::CallOp)](#kanagawacall-circtkanagawacallop)\n  + [`kanagawa.class` (::circt::kanagawa::ClassOp)](#kanagawaclass-circtkanagawaclassop)\n  + [`kanagawa.container` (::circt::kanagawa::ContainerOp)](#kanagawacontainer-circtkanagawacontainerop)\n  + [`kanagawa.container.instance` (::circt::kanagawa::ContainerInstanceOp)](#kanagawacontainerinstance-circtkanagawacontainerinstanceop)\n  + [`kanagawa.design` (::circt::kanagawa::DesignOp)](#kanagawadesign-circtkanagawadesignop)\n  + [`kanagawa.get_port` (::circt::kanagawa::GetPortOp)](#kanagawaget_port-circtkanagawagetportop)\n  + [`kanagawa.get_var` (::circt::kanagawa::GetVarOp)](#kanagawaget_var-circtkanagawagetvarop)\n  + [`kanagawa.instance` (::circt::kanagawa::InstanceOp)](#kanagawainstance-circtkanagawainstanceop)\n  + [`kanagawa.method` (::circt::kanagawa::MethodOp)](#kanagawamethod-circtkanagawamethodop)\n  + [`kanagawa.method.df` (::circt::kanagawa::DataflowMethodOp)](#kanagawamethoddf-circtkanagawadataflowmethodop)\n  + [`kanagawa.path` (::circt::kanagawa::PathOp)](#kanagawapath-circtkanagawapathop)\n  + [`kanagawa.pipeline.header` (::circt::kanagawa::PipelineHeaderOp)](#kanagawapipelineheader-circtkanagawapipelineheaderop)\n  + [`kanagawa.port.input` (::circt::kanagawa::InputPortOp)](#kanagawaportinput-circtkanagawainputportop)\n  + [`kanagawa.port.output` (::circt::kanagawa::OutputPortOp)](#kanagawaportoutput-circtkanagawaoutputportop)\n  + [`kanagawa.port.read` (::circt::kanagawa::PortReadOp)](#kanagawaportread-circtkanagawaportreadop)\n  + [`kanagawa.port.write` (::circt::kanagawa::PortWriteOp)](#kanagawaportwrite-circtkanagawaportwriteop)\n  + [`kanagawa.return` (::circt::kanagawa::ReturnOp)](#kanagawareturn-circtkanagawareturnop)\n  + [`kanagawa.sblock` (::circt::kanagawa::StaticBlockOp)](#kanagawasblock-circtkanagawastaticblockop)\n  + [`kanagawa.sblock.dc` (::circt::kanagawa::DCBlockOp)](#kanagawasblockdc-circtkanagawadcblockop)\n  + [`kanagawa.sblock.inline.begin` (::circt::kanagawa::InlineStaticBlockBeginOp)](#kanagawasblockinlinebegin-circtkanagawainlinestaticblockbeginop)\n  + [`kanagawa.sblock.inline.end` (::circt::kanagawa::InlineStaticBlockEndOp)](#kanagawasblockinlineend-circtkanagawainlinestaticblockendop)\n  + [`kanagawa.sblock.isolated` (::circt::kanagawa::IsolatedStaticBlockOp)](#kanagawasblockisolated-circtkanagawaisolatedstaticblockop)\n  + [`kanagawa.sblock.return` (::circt::kanagawa::BlockReturnOp)](#kanagawasblockreturn-circtkanagawablockreturnop)\n  + [`kanagawa.var` (::circt::kanagawa::VarOp)](#kanagawavar-circtkanagawavarop)\n  + [`kanagawa.wire.input` (::circt::kanagawa::InputWireOp)](#kanagawawireinput-circtkanagawainputwireop)\n  + [`kanagawa.wire.output` (::circt::kanagawa::OutputWireOp)](#kanagawawireoutput-circtkanagawaoutputwireop)\n* [Attributes](#attributes-19)\n  + [PathStepAttr](#pathstepattr)\n* [Types](#types)\n  + [PortRefType](#portreftype)\n  + [ScopeRefType](#scopereftype)\n* [Enums](#enums)\n  + [Direction](#direction)\n  + [PathDirection](#pathdirection)\n\nOperations\n----------\n\n### `kanagawa.call` (::circt::kanagawa::CallOp)\n\n*Kanagawa method call*\n\nSyntax:\n\n```\noperation ::= `kanagawa.call` $callee `(` $operands `)` attr-dict `:` functional-type($operands, results)\n```\n\nDispatch a call to an Kanagawa method.\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`, `InnerRefUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `callee` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operands` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| \u00abunnamed\u00bb | variadic of any type |\n\n### `kanagawa.class` (::circt::kanagawa::ClassOp)\n\n*Kanagawa class*\n\nSyntax:\n\n```\noperation ::= `kanagawa.class` ($name^)? `sym` $inner_sym attr-dict-with-keyword $body\n```\n\nKanagawa has the notion of a class which can contain methods and member\nvariables.\n\nIn the low-level Kanagawa representation, the ClassOp becomes a container for\n`kanagawa.port`s, `kanagawa.container`s, and contain logic for member variables.\n\nTraits: `HasParent<DesignOp>`, `IsolatedFromAbove`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `InnerSymbol`, `InstanceGraphModuleOpInterface`, `NamedInnerSymbol`, `RegionKindInterface`, `ScopeOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `name` | ::mlir::StringAttr | string attribute |\n\n### `kanagawa.container` (::circt::kanagawa::ContainerOp)\n\n*Kanagawa container*\n\nSyntax:\n\n```\noperation ::= `kanagawa.container` ($name^)? `sym` $inner_sym (`top_level` $isTopLevel^)? attr-dict-with-keyword $body\n```\n\nAn kanagawa container describes a collection of logic nested within an Kanagawa class.\n\nTraits: `HasParent<DesignOp, ClassOp>`, `IsolatedFromAbove`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `InnerSymbol`, `InstanceGraphModuleOpInterface`, `NamedInnerSymbolInterface`, `NamedInnerSymbol`, `RegionKindInterface`, `ScopeOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `isTopLevel` | ::mlir::UnitAttr | unit attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n\n### `kanagawa.container.instance` (::circt::kanagawa::ContainerInstanceOp)\n\n*Kanagawa container instance*\n\nSyntax:\n\n```\noperation ::= `kanagawa.container.instance` $inner_sym `,` $targetName attr-dict\n              custom<ScopeRefFromName>(type($scopeRef), ref($targetName))\n```\n\nInstantiates an Kanagawa container.\n\nInterfaces: `HasCustomSSAName`, `InnerRefUserOpInterface`, `InnerSymbolOpInterface`, `InstanceGraphInstanceOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `targetName` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `scopeRef` |  |\n\n### `kanagawa.design` (::circt::kanagawa::DesignOp)\n\n*All Kanagawa containers must be inside this op*\n\nSyntax:\n\n```\noperation ::= `kanagawa.design` $sym_name attr-dict-with-keyword $body\n```\n\nTraits: `InnerSymbolTable`, `IsolatedFromAbove`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `kanagawa.get_port` (::circt::kanagawa::GetPortOp)\n\n*Kanagawa get port*\n\nSyntax:\n\n```\noperation ::= `kanagawa.get_port` $instance `,` $portSymbol `:` qualified(type($instance)) `->`\n              qualified(type($port)) attr-dict\n```\n\nGiven an Kanagawa class reference, returns a port of said class. The port\nis specified by the symbol name of the port in the referenced class.\n\nImportantly, the user must specify how they intend to use the op, by\nspecifying the direction of the portref type that this op is generated with.\nIf the request port is to be read from, the type must be `!kanagawa.portref<out T>`\nand if the port is to be written to, the type must be `!kanagawa.portref<in T>`.\nThis is to ensure that the usage is reflected in the get\\_port type which in\nturn is used by the tunneling passes to create the proper ports through the\nhierarchy.\n\nThis implies that the portref direction of the get\\_port op is independent of\nthe actual direction of the target port, and only the inner portref type\nmust match.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InnerRefUserOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `portSymbol` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `instance` |  |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `port` |  |\n\n### `kanagawa.get_var` (::circt::kanagawa::GetVarOp)\n\n*Dereferences an kanagawa member variable through a scoperef*\n\nSyntax:\n\n```\noperation ::= `kanagawa.get_var` $instance `,` $varName attr-dict `:` qualified(type($instance)) `->` qualified(type($var))\n```\n\nInterfaces: `HasCustomSSAName`, `InnerRefUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `varName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `instance` |  |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `var` | memref of any type values |\n\n### `kanagawa.instance` (::circt::kanagawa::InstanceOp)\n\n*Kanagawa class instance*\n\nSyntax:\n\n```\noperation ::= `kanagawa.instance` $inner_sym `,` $targetName attr-dict\n              custom<ScopeRefFromName>(type($scopeRef), ref($targetName))\n```\n\nInstantiates an Kanagawa class.\n\nInterfaces: `HasCustomSSAName`, `InnerRefUserOpInterface`, `InnerSymbolOpInterface`, `InstanceGraphInstanceOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `targetName` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `scopeRef` |  |\n\n### `kanagawa.method` (::circt::kanagawa::MethodOp)\n\n*Kanagawa method*\n\nKanagawa methods are a lot like software functions: a list of named arguments\nand unnamed return values with imperative control flow.\n\nTraits: `AutomaticAllocationScope`, `HasParent<ClassOp>`, `IsolatedFromAbove`\n\nInterfaces: `InnerSymbolOpInterface`, `MethodLikeOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `function_type` | ::mlir::TypeAttr | type attribute of function type |\n| `argNames` | ::mlir::ArrayAttr | array attribute |\n| `arg_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `res_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n\n### `kanagawa.method.df` (::circt::kanagawa::DataflowMethodOp)\n\n*Kanagawa dataflow method*\n\nKanagawa dataflow methods share the same interface as an `kanagawa.method` but\nwithout imperative CFG-based control flow. Instead, this method implements a\ngraph region, and control flow is expected to be defined by dataflow operations.\n\nTraits: `HasParent<ClassOp>`, `IsolatedFromAbove`, `SingleBlockImplicitTerminator<kanagawa::ReturnOp>`, `SingleBlock`\n\nInterfaces: `FineGrainedDataflowRegionOpInterface`, `InnerSymbolOpInterface`, `MethodLikeOpInterface`, `RegionKindInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `function_type` | ::mlir::TypeAttr | type attribute of function type |\n| `argNames` | ::mlir::ArrayAttr | array attribute |\n| `arg_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `res_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n\n### `kanagawa.path` (::circt::kanagawa::PathOp)\n\n*Kanagawa path*\n\nSyntax:\n\n```\noperation ::= `kanagawa.path` $path attr-dict\n```\n\nThe `kanagawa.path` operation describes an instance hierarchy path relative to\nthe current scope. The path is specified by a list of either parent or\nchild identifiers (navigating up or down the hierarchy, respectively).\n\nScopes along the path are optionally typed, however, An `kanagawa.path` must\nlways terminate in a fully typed specifier, i.e. never an `!kanagawa.scoperef<>`.\n\nThe operation returns a single `!kanagawa.scoperef`-typed value representing\nthe scope at the end of the path.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `InnerRefUserOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `path` | ::mlir::ArrayAttr | Path step array attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `instance` |  |\n\n### `kanagawa.pipeline.header` (::circt::kanagawa::PipelineHeaderOp)\n\n*Kanagawa pipeline header operation*\n\nSyntax:\n\n```\noperation ::= `kanagawa.pipeline.header` attr-dict\n```\n\nThis operation defines the hardware-like values used to drive a pipeline,\nsuch as clock and reset.\nThis is an intermediate operation, meaning that it\u2019s strictly used to\nfacilitate progressive lowering of kanagawa static blocks to scheduled pipelines.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `clock` | A type for clock-carrying wires |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n| `stall` | 1-bit signless integer |\n\n### `kanagawa.port.input` (::circt::kanagawa::InputPortOp)\n\n*Kanagawa input port*\n\nSyntax:\n\n```\noperation ::= `kanagawa.port.input` ($name^)? `sym` $inner_sym `:` $type attr-dict\n```\n\nAn kanagawa port has an attached \u2019name\u2019 attribute. This is a name-hint used\nto generate the final port name. The port name and port symbol are not\nrelated, and all references to a port is done through the port symbol.\n\nTraits: `HasParent<ClassOp, ContainerOp>`\n\nInterfaces: `HasCustomSSAName`, `InferTypeOpInterface`, `InnerSymbol`, `NamedInnerSymbol`, `PortOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `type` | ::mlir::TypeAttr | type attribute of any type |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `port` |  |\n\n### `kanagawa.port.output` (::circt::kanagawa::OutputPortOp)\n\n*Kanagawa output port*\n\nSyntax:\n\n```\noperation ::= `kanagawa.port.output` ($name^)? `sym` $inner_sym `:` $type attr-dict\n```\n\nAn kanagawa port has an attached \u2019name\u2019 attribute. This is a name-hint used\nto generate the final port name. The port name and port symbol are not\nrelated, and all references to a port is done through the port symbol.\n\nTraits: `HasParent<ClassOp, ContainerOp>`\n\nInterfaces: `HasCustomSSAName`, `InferTypeOpInterface`, `InnerSymbol`, `NamedInnerSymbol`, `PortOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `type` | ::mlir::TypeAttr | type attribute of any type |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `port` |  |\n\n### `kanagawa.port.read` (::circt::kanagawa::PortReadOp)\n\n*Kanagawa port read*\n\nSyntax:\n\n```\noperation ::= `kanagawa.port.read` $port attr-dict `:` qualified(type($port))\n```\n\nRead the value of a port reference.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `port` |  |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | any type |\n\n### `kanagawa.port.write` (::circt::kanagawa::PortWriteOp)\n\n*Kanagawa port write*\n\nSyntax:\n\n```\noperation ::= `kanagawa.port.write` $port `,` $value attr-dict `:` qualified(type($port))\n```\n\nWrite a value to a port reference.\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `port` |  |\n| `value` | any type |\n\n### `kanagawa.return` (::circt::kanagawa::ReturnOp)\n\n*Kanagawa method terminator*\n\nSyntax:\n\n```\noperation ::= `kanagawa.return` ($retValues^)? attr-dict (`:` type($retValues)^)?\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<MethodOp, DataflowMethodOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `retValues` | variadic of any type |\n\n### `kanagawa.sblock` (::circt::kanagawa::StaticBlockOp)\n\n*Kanagawa block*\n\nThe `kanagawa.sblock` operation defines a block wherein a group of operations\nare expected to be statically scheduleable.\nThe operation is not isolated from above to facilitate ease of construction.\nHowever, once a program has been constructed and lowered to a sufficient\nlevel, the user may run `--kanagawa-argify-blocks` to effectively isolate the\nblock from above, by converting SSA values referenced through dominanes into\narguments of the block\n\nThe block may contain additional attributes to specify constraints on\nthe block further down the compilation pipeline.\n\nTraits: `AutomaticAllocationScope`, `SingleBlockImplicitTerminator<BlockReturnOp>`, `SingleBlock`\n\nInterfaces: `BlockOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `maxThreads` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `kanagawa.sblock.dc` (::circt::kanagawa::DCBlockOp)\n\n*DC-interfaced Kanagawa block*\n\nThe `kanagawa.sblock.dc` operation is like an `kanagawa.sblock` operation with\na few differences, being:\n\n1. The operation is DC-interfaced, meaning that all arguments and results\n   are dc-value typed.\n2. The operation is IsolatedFromAbove.\n\nTraits: `AutomaticAllocationScope`, `IsolatedFromAbove`, `SingleBlockImplicitTerminator<BlockReturnOp>`, `SingleBlock`\n\nInterfaces: `BlockOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `maxThreads` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `kanagawa.sblock.inline.begin` (::circt::kanagawa::InlineStaticBlockBeginOp)\n\n*Kanagawa inline static block begin marker*\n\nSyntax:\n\n```\noperation ::= `kanagawa.sblock.inline.begin` attr-dict\n```\n\nThe `kanagawa.sblock.inline.begin` operation is a marker that indicates the\nbegin of an inline static block.\nThe operation is used to maintain `kanagawa.sblocks` while in the Kanagawa inline\nphase (to facilitate e.g. mem2reg).\n\nThe operation:\n\n1. denotes the begin of the sblock\n2. carries whatever attributes that the source `kanagawa.sblock` carried.\n3. is considered side-effectfull.\n\nTraits: `HasParent<MethodOp>`\n\n### `kanagawa.sblock.inline.end` (::circt::kanagawa::InlineStaticBlockEndOp)\n\n*Kanagawa inline static block end marker*\n\nSyntax:\n\n```\noperation ::= `kanagawa.sblock.inline.end` attr-dict\n```\n\nThe `kanagawa.sblock.inline.end` operation is a marker that indicates the\nend of an inline static block.\nThe operation is used to maintain `kanagawa.sblocks` while in the Kanagawa inline\nphase (to facilitate e.g. mem2reg).\n\nTraits: `HasParent<MethodOp>`\n\n### `kanagawa.sblock.isolated` (::circt::kanagawa::IsolatedStaticBlockOp)\n\n*Kanagawa isolated block*\n\nThe `kanagawa.sblock.isolated` operation is like an `kanagawa.sblock` operation\nbut with an IsolatedFromAbove condition, meaning that all arguments and\nresults are passed through the block as arguments and results.\n\nTraits: `AutomaticAllocationScope`, `IsolatedFromAbove`, `SingleBlockImplicitTerminator<BlockReturnOp>`, `SingleBlock`\n\nInterfaces: `BlockOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `maxThreads` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `kanagawa.sblock.return` (::circt::kanagawa::BlockReturnOp)\n\n*Kanagawa static block terminator*\n\nSyntax:\n\n```\noperation ::= `kanagawa.sblock.return` ($retValues^)? attr-dict (`:` type($retValues)^)?\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<StaticBlockOp, IsolatedStaticBlockOp, DCBlockOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `retValues` | variadic of any type |\n\n### `kanagawa.var` (::circt::kanagawa::VarOp)\n\n*Kanagawa variable definition*\n\nSyntax:\n\n```\noperation ::= `kanagawa.var` $inner_sym `:` $type attr-dict\n```\n\nDefines an Kanagawa class member variable. The variable is typed with a\n`memref.memref` type, and may define either a singleton or uni-dimensional\narray of values.\n`kanagawa.var` defines a symbol within the encompassing class scope which can\nbe dereferenced through a `!kanagawa.scoperef` value of the parent class.\n\nInterfaces: `InnerSymbolOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `type` | ::mlir::TypeAttr | any memref type |\n\n### `kanagawa.wire.input` (::circt::kanagawa::InputWireOp)\n\n*Kanagawa input wire*\n\nSyntax:\n\n```\noperation ::= `kanagawa.wire.input` $inner_sym `:` qualified(type($output)) attr-dict\n```\n\nAn input wire defines an `kanagawa.portref<in T>` port alongside a value\nof type `T` which represents the value to-be-written to the wire.\n\nTraits: `HasParent<ClassOp, ContainerOp>`\n\nInterfaces: `HasCustomSSAName`, `InnerSymbolOpInterface`, `InnerSymbol`, `NamedInnerSymbol`, `PortOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `port` |  |\n| `output` | any type |\n\n### `kanagawa.wire.output` (::circt::kanagawa::OutputWireOp)\n\n*Kanagawa output wire*\n\nSyntax:\n\n```\noperation ::= `kanagawa.wire.output` $inner_sym `,` $input `:` qualified(type($input)) attr-dict\n```\n\nAn output wire defines an `kanagawa.portref<out T>` port that can be read.\nThe operation takes an input value of type `T` which represents the value\non the output portref.\n\nTraits: `HasParent<ClassOp, ContainerOp>`\n\nInterfaces: `HasCustomSSAName`, `InferTypeOpInterface`, `InnerSymbolOpInterface`, `InnerSymbol`, `NamedInnerSymbol`, `PortOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `port` |  |\n\nAttributes\n----------\n\n### PathStepAttr\n\nSyntax:\n\n```\n#kanagawa.step<\n  PathDirection,   # direction\n  ::mlir::Type,   # type\n  mlir::FlatSymbolRefAttr   # child\n>\n```\n\nUsed to describe a single step in a path\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| direction | `PathDirection` |  |\n| type | `::mlir::Type` |  |\n| child | `mlir::FlatSymbolRefAttr` |  |\n\nTypes\n-----\n\n### PortRefType\n\nSyntax:\n\n```\n!kanagawa.portref<\n  TypeAttr,   # portTypeAttr\n  kanagawa::Direction   # direction\n>\n```\n\nA reference to an Kanagawa port.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| portTypeAttr | `TypeAttr` |  |\n| direction | `kanagawa::Direction` |  |\n\n### ScopeRefType\n\nA reference to an Kanagawa scope. May be either a reference to a specific\nscope (given a `$scopeName` argument) or an opaque reference.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| scopeRef | `::circt::hw::InnerRefAttr` |  |\n\nEnums\n-----\n\n### Direction\n\n*Kanagawa port direction*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Input | `0` | in |\n| Output | `1` | out |\n\n### PathDirection\n\n*Path direction*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Parent | `0` | parent |\n| Child | `1` | child |\n\n'kanagawa' Dialect Docs\n-----------------------\n\n* [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n\n [Prev - HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/ \"HW Arith Dialect Rationale\")\n[Next - `kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/ \"`kanagawa` Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/index.md"
  },
  {
    "role": "user",
    "content": "`kanagawa` Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n`kanagawa` Dialect Rationale\n============================\n\nLowering flow\u00a0[\u00b6](#lowering-flow)\n---------------------------------\n\n1. Containerization:\n   At this level, one may have relative references to ports `get_port` accesses\n   to `!kanagawa.scoperef`s\n2. Tunneling:\n   Relative `!kanagawa.scoperef` references are defined via `kanagawa.path` operations.\n   In this pass, we lower `kanagawa.path` operations by tunneling `portref`s through\n   the instance hierarchy, based on the `get_port` operations that were present\n   in the various containers. After this, various `portref<in portref<#dir, T>>`\n   ports are present in the design, which represents the actual ports that are\n   being passed around.\n3. `portref` lowering\n   Next, we need to convert `portref<in portref<#dir, T>>`-typed ports into\n   `T` typed in- or output ports. We do this by analyzing how a portref is used\n   inside a container, and then creating an in- or output port based on that.\n   That is:\n\n* write to `portref<in portref<in, T>>` becomes `out T`\n* read from `portref<in portref<out, T>>` becomes `in T`\n* write to `portref<out portref<out, T>>` becomes `out T` (a port reference\n  inside the module will be driven by a value from the outside)\n* read from `portref<out portref<in, T>>` becomes `in T` (a port reference\n  inside the module will be driven by a value from the outside)\n\n4. Removal of self-driving inputs:\n   In cases where children drive parent ports, the prior case may create\n   situations where a container drives its own input ports (and by extension, no\n   other instantiating container is expected to drive that port of the instance,\n   if the IR is correct). We thus run `kanagawa-clean-selfdrivers` to replace these\n   self-driven ports by the actual values that are being driven into them.\n5. HW lowering:\n   At this point, there no longer exist any relative references in the Kanagawa IR,\n   and all instantiations should (if the IR is correct) have all of their inputs\n   driven. This means that we can now lower the IR to `hw.module`s.\n\n [Prev - 'kanagawa' Dialect](https://circt.llvm.org/docs/Dialects/Kanagawa/ \"'kanagawa' Dialect\")\n[Next - 'loopschedule' Dialect](https://circt.llvm.org/docs/Dialects/LoopSchedule/ \"'loopschedule' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect-](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/LoopSchedule/index.md"
  },
  {
    "role": "user",
    "content": "'loopschedule' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'loopschedule' Dialect\n======================\n\n*Representation of scheduled loops*\n\n* [Operations](#operations)\n  + [`loopschedule.pipeline` (::circt::loopschedule::LoopSchedulePipelineOp)](#loopschedulepipeline-circtloopscheduleloopschedulepipelineop)\n  + [`loopschedule.pipeline.stage` (::circt::loopschedule::LoopSchedulePipelineStageOp)](#loopschedulepipelinestage-circtloopscheduleloopschedulepipelinestageop)\n  + [`loopschedule.register` (::circt::loopschedule::LoopScheduleRegisterOp)](#loopscheduleregister-circtloopscheduleloopscheduleregisterop)\n  + [`loopschedule.terminator` (::circt::loopschedule::LoopScheduleTerminatorOp)](#loopscheduleterminator-circtloopscheduleloopscheduleterminatorop)\n\nOperations\n----------\n\n### `loopschedule.pipeline` (::circt::loopschedule::LoopSchedulePipelineOp)\n\n*LoopSchedule dialect pipeline-loop.*\n\nThe `loopschedule.pipeline` operation represents a statically scheduled\npipeline stucture that executes while a condition is true. For more details,\nsee:\n<https://llvm.discourse.group/t/rfc-representing-pipelined-loops/4171>.\n\nA pipeline captures the result of scheduling, and is not generally safe to\ntransform, besides lowering to hardware dialects. For more discussion about\nrelaxing this, see:\n<https://github.com/llvm/circt/issues/2204>.\n\nThis is the top-level operation representing a high-level pipeline. It is\nnot isolated from above, but could be if this is helpful. A pipeline\ncontains two regions: `condition` and `stages`.\n\nThe pipeline may accept an optional `iter_args`, similar to the SCF dialect,\nfor representing loop-carried values like induction variables or reductions.\nWhen the pipeline starts execution, the registers indicated as `iter_args`\nby `pipeline.terminator` should be initialized to the initial\nvalues specified in the `iter_args` section here. The `iter_args` relate to\nthe initiation interval of the loop. The maximum distance in stages between\nwhere an `iter_arg` is used and where that `iter_arg` is registered must be\nless than the loop\u2019s initiation interval. For example, with II=1, each\n`iter_arg` must be used and registered in the same stage.\n\nThe single-block `condition` region dictates the condition under which the\npipeline should execute. It has a `register` terminator, and the\npipeline initiates new iterations while the registered value is `true : i1`.\nIt may access SSA values dominating the pipeline, as well as `iter_args`,\nwhich are block arguments. The body of the block may only contain\n\u201ccombinational\u201d operations, which are currently defined to be simple\narithmetic, comparisons, and selects from the `Standard` dialect.\n\nThe single-block `stages` region wraps `loopschedule.pipeline.stage`\noperations. It has a `loopschedule.terminator` terminator, which can\nboth return results from the pipeline and register `iter_args`. Stages may\naccess SSA values dominating the pipeline, as well as `iter_args`, which are\nblock arguments.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `II` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n| `tripCount` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `iterArgs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `loopschedule.pipeline.stage` (::circt::loopschedule::LoopSchedulePipelineStageOp)\n\n*LoopSchedule dialect pipeline stage.*\n\nSyntax:\n\n```\noperation ::= `loopschedule.pipeline.stage` `start` `=` $start (`when` $when^)? $body (`:` qualified(type($results))^)? attr-dict\n```\n\nThis operation has a single-block region which dictates the operations that\nmay occur concurrently.\n\nIt has a `start` attribute, which indicates the start cycle for this stage.\n\nIt may have an optional `when` predicate, which supports conditional\nexecution for each stage. This is in addition to the `condition` region that\ncontrols the execution of the whole pipeline. A stage with a `when`\npredicate should only execute when the predicate is `true : i1`, and push a\nbubble through the pipeline otherwise.\n\nIt has a `register` terminator, which passes the concurrently\ncomputed values forward to the next stage.\n\nAny stage may access `iter_args`. If a stage accesses an `iter_arg` after\nthe stage in which it is defined, it is up to lowering passes to preserve\nthis value until the last stage that needs it.\n\nOther than `iter_args`, stages may only access SSA values dominating the\npipeline or SSA values computed by any previous stage. This ensures the\nstages capture the coarse-grained schedule of the pipeline and how values\nfeed forward and backward.\n\nTraits: `HasParent<LoopSchedulePipelineOp>`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `start` | ::mlir::IntegerAttr | 64-bit signed integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `when` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `loopschedule.register` (::circt::loopschedule::LoopScheduleRegisterOp)\n\n*LoopSchedule dialect loop register.*\n\nSyntax:\n\n```\noperation ::= `loopschedule.register` $operands (`:` qualified(type($operands))^)? attr-dict\n```\n\nThe `loopschedule.register` terminates a pipeline stage and\n\u201cregisters\u201d the values specified as operands. These values become the\nresults of the stage.\n\nTraits: `HasParent<LoopSchedulePipelineOp, LoopSchedulePipelineStageOp>`, `Terminator`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operands` | variadic of any type |\n\n### `loopschedule.terminator` (::circt::loopschedule::LoopScheduleTerminatorOp)\n\n*LoopSchedule dialect terminator.*\n\nSyntax:\n\n```\noperation ::= `loopschedule.terminator` `iter_args` `(` $iter_args `)` `,`\n              `results` `(` $results `)` `:`\n              functional-type($iter_args, $results) attr-dict\n```\n\nThe `loopschedule.terminator` operation represents the terminator of\na `loopschedule.pipeline`.\n\nThe `results` section accepts a variadic list of values which become the\npipeline\u2019s return values. These must be results of a stage, and their types\nmust match the pipeline\u2019s return types. The results need not be defined in\nthe final stage, and it is up to lowering passes to preserve these values\nuntil the final stage is complete.\n\nThe `iter_args` section accepts a variadic list of values which become the\nnext iteration\u2019s `iter_args`. These may be the results of any stage, and\ntheir types must match the pipeline\u2019s `iter_args` types.\n\nTraits: `AttrSizedOperandSegments`, `HasParent<LoopSchedulePipelineOp>`, `Terminator`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `iter_args` | variadic of any type |\n| `results` | variadic of any type |\n\n'loopschedule' Dialect Docs\n---------------------------\n\n* [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n\n [Prev - `kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/ \"`kanagawa` Dialect Rationale\")\n[Next - LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/ \"LoopSchedule Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/index.md"
  },
  {
    "role": "user",
    "content": "LoopSchedule Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nLoopSchedule Dialect Rationale\n==============================\n\nThis document describes various design points of the `loopschedule` dialect, why it is\nthe way it is, and current status. This follows in the spirit of other\n[MLIR\nRationale docs](https://mlir.llvm.org/docs/Rationale/).\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\nThe `loopschedule` dialect provides a collection of ops to represent software-like loops\nafter scheduling. There are currently two main kinds of loops that can be represented:\npipelined and sequential. Pipelined loops allow multiple iterations of the loop to be\nin-flight at a time and have an associated initiation interval (`II`) to specify the number\nof cycles between the start of successive loop iterations. In contrast, sequential loops\nare guaranteed to only have one iteration in-flight at any given time.\n\nA primary goal of the `loopschedule` dialect, as opposed to many other High-Level Synthesis\n(HLS) representations, is to maintain the structure of loops after scheduling. As such, the\n`loopschedule` ops are inspired by the `scf` and `affine` dialect ops.\n\nPipelined Loops\u00a0[\u00b6](#pipelined-loops)\n-------------------------------------\n\nPipelined loops are represented with the `loopschedule.pipeline` op. A `pipeline`\nloop resembles a `while` loop in the `scf` dialect, but the body must contain only\n`loopschedule.pipeline.stage` and `loopschedule.terminator` ops. To have a better\nunderstanding of how `loopschedule.pipeline` works, we will look at the following\nexample:\n\n```\nfunc.func @test1(%arg0: memref<10xi32>) -> i32 {\n  %c0 = arith.constant 0 : index\n  %c1 = arith.constant 1 : index\n  %c10 = arith.constant 10 : index\n  %c0_i32 = arith.constant 0 : i32\n  %0 = loopschedule.pipeline II = 1 iter_args(%arg1 = %c0, %arg2 = %c0_i32) : (index, i32) -> i32 {\n    %1 = arith.cmpi ult, %arg1, %c10 : index\n    loopschedule.register %1 : i1\n  } do {\n    %1:2 = loopschedule.pipeline.stage start = 0 {\n      %3 = arith.addi %arg1, %c1 : index\n      %4 = memref.load %arg0[%arg1] : memref<10xi32>\n      loopschedule.register %3, %4 : index, i32\n    } : index, i32\n    %2 = loopschedule.pipeline.stage start = 1 {\n      %3 = arith.addi %1#1, %arg2 : i32\n      pipeline.register %3 : i32\n    } : i32\n    loopschedule.terminator iter_args(%1#0, %2), results(%2) : (index, i32) -> i32\n  }\n  return %0 : i32\n}\n```\n\nA `pipeline` op first defines the initial values for the `iter_args`. `iter_args` are values that will\nbe passed back to the first stage after the last stage of the pipeline. The pipeline also defines a\nspecific, static `II`. Each pipeline stage in the `do` block represents a series of ops run in parallel.\n\nValues are registered at the end of a stage and passed out as results for future pipeline stages to\nuse. Each pipeline stage must have a defined start time, which is the number of cycles between the\nstart of the pipeline and when the first valid data will be available as input to that stage.\n\nFinally, the terminator is called with the `iter_args` for the next iteration and the result values\nthat will be returned when the pipeline completes. Even though the terminator is located at the\nend of the loop body, its values are passed back to a previous stage whenever needed. We do not\nneed to wait for an entire iteration to finish before `iter_args` become valid for the next iteration.\n\nMulti-cycle and pipelined ops can also be supported in `pipeline` loops. In the following example,\nassume the multiply op is bound to a 3-stage pipelined multiplier:\n\n```\nfunc.func @test1(%arg0: memref<10xi32>, %arg1: memref<10xi32>) {\n  %c0 = arith.constant 0 : index\n  %c1 = arith.constant 1 : index\n  %c10 = arith.constant 10 : index\n  %c1_i32 = arith.constant 1 : i32\n  loopschedule.pipeline II = 1 iter_args(%arg2 = %c0) : (index, i32) -> () {\n    %1 = arith.cmpi ult, %arg1, %c10 : index\n    loopschedule.register %1 : i1\n  } do {\n    %1:2 = loopschedule.pipeline.stage start = 0 {\n      %3 = arith.addi %arg1, %c1 : index\n      %4 = memref.load %arg0[%arg2] : memref<10xi32>\n      loopschedule.register %3, %4 : index, i32\n    } : index, i32\n    %2:2 = loopschedule.pipeline.stage start = 1 {\n      %3 = arith.muli %1#1, %c1_i32 : i32\n      pipeline.register %3, %1#0 : i32\n    } : i32\n    loopschedule.pipeline.stage start = 4 {\n      memref.store %2#0, %arg0[%2#1] : i32\n      pipeline.register\n    } : i32\n    loopschedule.terminator iter_args(%1#0), results() : (index, i32) -> ()\n  }\n  return\n}\n```\n\nHere, the `II` is still 1 because new values can be introduced to the multiplier every cycle. The last\nstage is delayed by 3 cycles because of the 3 cycle latency of the multiplier. The `pipeline` op is\ncurrently tightly coupled to the lowering implementation used, as the latency of operators is not\nrepresented in the IR, but rather an implicit assumption made when lowering later. The scheduling\nproblem is constructed with these implicit operator latencies in mind. This coupling can be addressed\nin the future with a proper operator library to maintain explicit operator latencies in the IR.\n\nStatus\u00a0[\u00b6](#status)\n-------------------\n\nAdded pipeline loop representation, more documentation and rationale to come as ops are added.\n\n [Prev - 'loopschedule' Dialect](https://circt.llvm.org/docs/Dialects/LoopSchedule/ \"'loopschedule' Dialect\")\n[Next - 'msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/ \"'msft' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect-](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/MSFT/index.md"
  },
  {
    "role": "user",
    "content": "'msft' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'msft' Dialect\n==============\n\n*Microsoft internal support dialect*\n\nUmbrella dialect for everything needed to support Microsoft development\nbut not thoroughly discussed. Most (if not everything) in this dialect is\na candidate for generalization and re-homing.\n\n* [Operations](#operations)\n  + [`msft.hlc.linear` (::circt::msft::LinearOp)](#msfthlclinear-circtmsftlinearop)\n  + [`msft.instance.dynamic` (::circt::msft::DynamicInstanceOp)](#msftinstancedynamic-circtmsftdynamicinstanceop)\n  + [`msft.instance.hierarchy` (::circt::msft::InstanceHierarchyOp)](#msftinstancehierarchy-circtmsftinstancehierarchyop)\n  + [`msft.instance.verb_attr` (::circt::msft::DynamicInstanceVerbatimAttrOp)](#msftinstanceverb_attr-circtmsftdynamicinstanceverbatimattrop)\n  + [`msft.output` (::circt::msft::OutputOp)](#msftoutput-circtmsftoutputop)\n  + [`msft.pd.location` (::circt::msft::PDPhysLocationOp)](#msftpdlocation-circtmsftpdphyslocationop)\n  + [`msft.pd.multicycle` (::circt::msft::PDMulticycleOp)](#msftpdmulticycle-circtmsftpdmulticycleop)\n  + [`msft.pd.physregion` (::circt::msft::PDPhysRegionOp)](#msftpdphysregion-circtmsftpdphysregionop)\n  + [`msft.pd.reg_location` (::circt::msft::PDRegPhysLocationOp)](#msftpdreg_location-circtmsftpdregphyslocationop)\n  + [`msft.pe.output` (::circt::msft::PEOutputOp)](#msftpeoutput-circtmsftpeoutputop)\n  + [`msft.physical_region` (::circt::msft::DeclPhysicalRegionOp)](#msftphysical_region-circtmsftdeclphysicalregionop)\n  + [`msft.systolic.array` (::circt::msft::SystolicArrayOp)](#msftsystolicarray-circtmsftsystolicarrayop)\n* [Attributes](#attributes-8)\n  + [LocationVectorAttr](#locationvectorattr)\n  + [PhysLocationAttr](#physlocationattr)\n  + [PhysicalBoundsAttr](#physicalboundsattr)\n* [Enums](#enums)\n  + [PrimitiveType](#primitivetype)\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `msft.hlc.linear` (::circt::msft::LinearOp)\u00a0[\u00b6](#msfthlclinear-circtmsftlinearop)\n\n*Model of a linear datapath which can be arbitrarily pipelined*\n\nSyntax:\n\n```\noperation ::= `msft.hlc.linear` `clock` $clock attr-dict `:` type($outs) $datapath\n```\n\nDefines a feed-forward datapath which can be scheduled into a pipeline.\nDue to the feed-forwardness, the inner region is NOT a graph region.\nInternally, only combinational operations (`comb`, `msft`, `hw`) are allowed.\n\nExample:\n\n```\nmsft.module @foo(%in0 : i32, %in1 : i32, %in2 : i32, %clk : i1) -> (out: i32) -> {\n  %0 = msft.hlc.linear(%a = %in0, %b = %in1, %c = %in2) clock %clk (i32, i32, i32) -> (i32) {\n    %0 = comb.mul %a, %b : i32\n    %1 = comb.add %0, %c : i32\n    msft.output %1 : i32\n  }\n}\n```\n\nTraits: `SingleBlockImplicitTerminator<OutputOp>`, `SingleBlock`\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `clock` | A type for clock-carrying wires |\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| `outs` | variadic of any type |\n\n### `msft.instance.dynamic` (::circt::msft::DynamicInstanceOp)\u00a0[\u00b6](#msftinstancedynamic-circtmsftdynamicinstanceop)\n\n*A module instance in the instance hierarchy*\n\nSyntax:\n\n```\noperation ::= `msft.instance.dynamic` custom<ImplicitInnerRef>($instanceRef) $body attr-dict\n```\n\nRepresents an instance (as in instance in the instance hierarchy) referred\nto henceforth as a dynamic instance. Specified with a path through the\ninstance hierarchy (which in the future will be replaced with an AppID).\nLowers to a `hw.hierpath` but unlike a global ref, does not require all of\nthe ops participating in the hierpath to contain a back pointer attribute.\nAllows users to efficiently add placements to a large number of dynamic\ninstances which happen to map to a small number of static instances by\nbulk-adding the necessary `hw.hierpath` attributes.\n\nDuring the lowering, moves the operations in the body to the top level and\ngives them the symbol of the hierpath which was created to replace the\ndynamic instance.\n\nTraits: `HasParent<circt::msft::InstanceHierarchyOp, circt::msft::DynamicInstanceOp>`, `NoTerminator`\n\n#### Attributes:\u00a0[\u00b6](#attributes)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `instanceRef` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n\n### `msft.instance.hierarchy` (::circt::msft::InstanceHierarchyOp)\u00a0[\u00b6](#msftinstancehierarchy-circtmsftinstancehierarchyop)\n\n*The root of an instance hierarchy*\n\nSyntax:\n\n```\noperation ::= `msft.instance.hierarchy` $topModuleRef ($instName^)? $body attr-dict\n```\n\nModels the \u201croot\u201d / \u201ctop\u201d of an instance hierarchy. `DynamicInstanceOp`s\nmust be contained by this op. Specifies the top module and (optionally) an\n\u201cinstance\u201d name in the case where there are multiple instances of a\nparticular module in a design. (As is often the case where one isn\u2019t\nproducing the design\u2019s \u201ctop\u201d module but a subdesign.)\n\nTraits: `HasParent<mlir::ModuleOp>`, `NoTerminator`\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `topModuleRef` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `instName` | ::mlir::StringAttr | string attribute |\n\n### `msft.instance.verb_attr` (::circt::msft::DynamicInstanceVerbatimAttrOp)\u00a0[\u00b6](#msftinstanceverb_attr-circtmsftdynamicinstanceverbatimattrop)\n\n*Specify an arbitrary attribute attached to a dynamic instance*\n\nSyntax:\n\n```\noperation ::= `msft.instance.verb_attr` ($ref^)? `name` `:` $name `value` `:` $value (`path` `:` $subPath^)? attr-dict\n```\n\nAllows a user to specify a custom attribute name and value which is attached\nto a dynamic instance.\n\nFor Quartus tcl, translates to:\nset\\_instance\\_assignment -name $name $value -to $parent|<instance\\_path>\n\nInterfaces: `DynInstDataOpInterface`, `UnaryDynInstDataOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-2)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `value` | ::mlir::StringAttr | string attribute |\n| `subPath` | ::mlir::StringAttr | string attribute |\n| `ref` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n### `msft.output` (::circt::msft::OutputOp)\u00a0[\u00b6](#msftoutput-circtmsftoutputop)\n\n*Termination operation*\n\nSyntax:\n\n```\noperation ::= `msft.output` attr-dict ($operands^ `:` qualified(type($operands)))?\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ReturnLike`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `operands` | variadic of any type |\n\n### `msft.pd.location` (::circt::msft::PDPhysLocationOp)\u00a0[\u00b6](#msftpdlocation-circtmsftpdphyslocationop)\n\n*Specify a location for an instance*\n\nSyntax:\n\n```\noperation ::= `msft.pd.location` ($ref^)? custom<PhysLoc>($loc) (`path` `:` $subPath^)? attr-dict\n```\n\nUsed to specify a specific location on an FPGA to place a dynamic instance.\nSupports specifying the location of a subpath for extern modules and device\nprimitives. Intended to live as a child of `instance.dynamic` initially\nwithout the `ref` field. The dynamic instance lowering will fill in `ref`\nwith the symol of the `hw.hierpath` op corresponding to the lowered dynamic\ninstance.\n\nInterfaces: `DynInstDataOpInterface`, `UnaryDynInstDataOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-3)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `loc` | ::circt::msft::PhysLocationAttr | Descibes a physical location on a device |\n| `subPath` | ::mlir::StringAttr | string attribute |\n| `ref` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n### `msft.pd.multicycle` (::circt::msft::PDMulticycleOp)\u00a0[\u00b6](#msftpdmulticycle-circtmsftpdmulticycleop)\n\n*Specify a multicycle constraint*\n\nSyntax:\n\n```\noperation ::= `msft.pd.multicycle` $cycles $source `->` $dest attr-dict\n```\n\nSpecifies a multicycle constraint in between two registers.\n`source` and `dest` symbols reference `HierPathOp` symbols denoting the\nexact registers in the instance hierarchy to which the constraint applies.\n\nInterfaces: `DynInstDataOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-4)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `source` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `dest` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `cycles` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 1 |\n\n### `msft.pd.physregion` (::circt::msft::PDPhysRegionOp)\u00a0[\u00b6](#msftpdphysregion-circtmsftpdphysregionop)\n\n*Specify a physical region for an instance*\n\nSyntax:\n\n```\noperation ::= `msft.pd.physregion` ($ref^)? $physRegionRef (`path` `:` $subPath^)? attr-dict\n```\n\nAnnotate a particular entity within an op with the region of the devices\non an FPGA to which it should mapped. The physRegionRef must refer to a\nDeclPhysicalRegion operation.\n\nInterfaces: `DynInstDataOpInterface`, `UnaryDynInstDataOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-5)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `physRegionRef` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `subPath` | ::mlir::StringAttr | string attribute |\n| `ref` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n### `msft.pd.reg_location` (::circt::msft::PDRegPhysLocationOp)\u00a0[\u00b6](#msftpdreg_location-circtmsftpdregphyslocationop)\n\n*Specify register locations*\n\nSyntax:\n\n```\noperation ::= `msft.pd.reg_location` (`ref` $ref^)? custom<ListOptionalRegLocList>($locs) attr-dict\n```\n\nA version of \u201cPDPhysLocationOp\u201d specialized for registers, which have one\nlocation per bit.\n\nInterfaces: `DynInstDataOpInterface`, `UnaryDynInstDataOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-6)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `locs` | ::circt::msft::LocationVectorAttr | Vector of optional locations corresponding to bits in a type |\n| `ref` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n### `msft.pe.output` (::circt::msft::PEOutputOp)\u00a0[\u00b6](#msftpeoutput-circtmsftpeoutputop)\n\n*Set the outputs from a PE block*\n\nSyntax:\n\n```\noperation ::= `msft.pe.output` $output attr-dict `:` type($output)\n```\n\nTraits: `Terminator`\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `output` | any type |\n\n### `msft.physical_region` (::circt::msft::DeclPhysicalRegionOp)\u00a0[\u00b6](#msftphysical_region-circtmsftdeclphysicalregionop)\n\nSyntax:\n\n```\noperation ::= `msft.physical_region` $sym_name `,` $bounds attr-dict\n```\n\nTraits: `HasParent<mlir::ModuleOp>`\n\nInterfaces: `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-7)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `bounds` | ::mlir::ArrayAttr | array of PhysicalBounds |\n\n### `msft.systolic.array` (::circt::msft::SystolicArrayOp)\u00a0[\u00b6](#msftsystolicarray-circtmsftsystolicarrayop)\n\n*Model of a row/column broadcast systolic array*\n\nNote: the PE region is NOT a graph region. This was intentional since\nsystolic arrays are entirely feed-forward.\n\nTraits: `SingleBlockImplicitTerminator<PEOutputOp>`, `SingleBlock`\n\n#### Operands:\u00a0[\u00b6](#operands-3)\n\n| Operand | Description |\n| --- | --- |\n| `rowInputs` | an ArrayType |\n| `colInputs` | an ArrayType |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `peOutputs` | an array of arrays |\n\nAttributes\u00a0[\u00b6](#attributes-8)\n-----------------------------\n\n### LocationVectorAttr\u00a0[\u00b6](#locationvectorattr)\n\n*Vector of optional locations corresponding to bits in a type*\n\n#### Parameters:\u00a0[\u00b6](#parameters)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| type | `::mlir::TypeAttr` |  |\n| locs | `::llvm::ArrayRef<::circt::msft::PhysLocationAttr>` |  |\n\n### PhysLocationAttr\u00a0[\u00b6](#physlocationattr)\n\n*Descibes a physical location on a device*\n\nAnnotate a particular entity within an op with the location of the device\non an FPGA to which it should mapped. The coordinates in this attribute\nare absolute locations on the device, so if there are two instances of a\nmodule with this annotation incorrect results will be generated. How to\nsolve this is a more general, open problem.\n\n#### Parameters:\u00a0[\u00b6](#parameters-1)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| primitiveType | `PrimitiveTypeAttr` |  |\n| x | `uint64_t` |  |\n| y | `uint64_t` |  |\n| num | `uint64_t` |  |\n\n### PhysicalBoundsAttr\u00a0[\u00b6](#physicalboundsattr)\n\n*Describes a rectangle bounding a physical region on a device*\n\nDescribes a rectangular bound within a device. The lower and upper bounds\nmust be specified for both the X and Y axis. The bounds are inclusive.\n\n#### Parameters:\u00a0[\u00b6](#parameters-2)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| xMin | `uint64_t` |  |\n| xMax | `uint64_t` |  |\n| yMin | `uint64_t` |  |\n| yMax | `uint64_t` |  |\n\nEnums\u00a0[\u00b6](#enums)\n-----------------\n\n### PrimitiveType\u00a0[\u00b6](#primitivetype)\n\n*Type of device at physical location*\n\n#### Cases:\u00a0[\u00b6](#cases)\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| M20K | `1` | M20K |\n| DSP | `2` | DSP |\n| FF | `3` | FF |\n\n [Prev - LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/ \"LoopSchedule Dialect Rationale\")\n[Next - 'om' Dialect](https://circt.llvm.org/docs/Dialects/OM/ \"'om' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/OM/index.md"
  },
  {
    "role": "user",
    "content": "'om' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'om' Dialect\n============\n\n*The Object Model dialect captures design intent from various domains in an\nobject model.*\n\nFor more information about the Object Model dialect, see the\n[Object Model Dialect Rationale](/docs/Dialects/OM/RationaleOM/).\n\n* [Operations](#operations)\n  + [`om.any_cast` (::circt::om::AnyCastOp)](#omany_cast-circtomanycastop)\n  + [`om.basepath_create` (::circt::om::BasePathCreateOp)](#ombasepath_create-circtombasepathcreateop)\n  + [`om.class` (::circt::om::ClassOp)](#omclass-circtomclassop)\n  + [`om.class.extern` (::circt::om::ClassExternOp)](#omclassextern-circtomclassexternop)\n  + [`om.class.fields` (::circt::om::ClassFieldsOp)](#omclassfields-circtomclassfieldsop)\n  + [`om.constant` (::circt::om::ConstantOp)](#omconstant-circtomconstantop)\n  + [`om.frozenbasepath_create` (::circt::om::FrozenBasePathCreateOp)](#omfrozenbasepath_create-circtomfrozenbasepathcreateop)\n  + [`om.frozenpath_create` (::circt::om::FrozenPathCreateOp)](#omfrozenpath_create-circtomfrozenpathcreateop)\n  + [`om.frozenpath_empty` (::circt::om::FrozenEmptyPathOp)](#omfrozenpath_empty-circtomfrozenemptypathop)\n  + [`om.integer.add` (::circt::om::IntegerAddOp)](#omintegeradd-circtomintegeraddop)\n  + [`om.integer.mul` (::circt::om::IntegerMulOp)](#omintegermul-circtomintegermulop)\n  + [`om.integer.shl` (::circt::om::IntegerShlOp)](#omintegershl-circtomintegershlop)\n  + [`om.integer.shr` (::circt::om::IntegerShrOp)](#omintegershr-circtomintegershrop)\n  + [`om.list_concat` (::circt::om::ListConcatOp)](#omlist_concat-circtomlistconcatop)\n  + [`om.list_create` (::circt::om::ListCreateOp)](#omlist_create-circtomlistcreateop)\n  + [`om.object` (::circt::om::ObjectOp)](#omobject-circtomobjectop)\n  + [`om.object.field` (::circt::om::ObjectFieldOp)](#omobjectfield-circtomobjectfieldop)\n  + [`om.path_create` (::circt::om::PathCreateOp)](#ompath_create-circtompathcreateop)\n  + [`om.path_empty` (::circt::om::EmptyPathOp)](#ompath_empty-circtomemptypathop)\n  + [`om.unknown` (::circt::om::UnknownValueOp)](#omunknown-circtomunknownvalueop)\n* [Attributes](#attributes-10)\n  + [IntegerAttr](#integerattr)\n  + [ListAttr](#listattr)\n  + [PathAttr](#pathattr)\n  + [SymbolRefAttr](#symbolrefattr)\n  + [ReferenceAttr](#referenceattr)\n* [Types](#types)\n  + [BasePathType](#basepathtype)\n  + [ClassType](#classtype)\n  + [FrozenBasePathType](#frozenbasepathtype)\n  + [FrozenPathType](#frozenpathtype)\n  + [ListType](#listtype)\n  + [AnyType](#anytype)\n  + [OMIntegerType](#omintegertype)\n  + [PathType](#pathtype)\n  + [ReferenceType](#referencetype)\n  + [StringType](#stringtype)\n  + [SymbolRefType](#symbolreftype)\n* [Enums](#enums)\n  + [TargetKind](#targetkind)\n\nOperations\n----------\n\n### `om.any_cast` (::circt::om::AnyCastOp)\n\n*Cast any value to any type.*\n\nSyntax:\n\n```\noperation ::= `om.any_cast` $input attr-dict `:` functional-type($input, $result)\n```\n\nCasts any value to AnyType. This is useful for situations where a value of\nAnyType is needed, but a value of some concrete type is known.\n\nIn the evaluator, this is a noop, and the value of concrete type is used.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A type that represents any valid OM type. |\n\n### `om.basepath_create` (::circt::om::BasePathCreateOp)\n\n*Produce a base path value*\n\nSyntax:\n\n```\noperation ::= `om.basepath_create` $basePath $target attr-dict\n```\n\nProduces a value which represents a fragment of a hierarchical path to a\ntarget. Given a base path, extend it with the name of a module instance, to\nproduce a new base path. The instance is identified via an NLA. Once the\nfinal verilog name of the instance is known, this op can be converted into\na FrozenBasePathOp.\n\nExample:\n\n```\nhw.module @Foo() -> () {\n  hw.inst \"bar\" sym @bar @Bar() -> ()\n}\nhw.hierpath @Path [@Foo::@bar]\nom.class @OM(%basepath: !om.basepath) {\n  %0 = om.basepath_create %base @Path\n}\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `target` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `basePath` | A fragment of a path to a hardware component |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A fragment of a path to a hardware component |\n\n### `om.class` (::circt::om::ClassOp)\n\nTraits: `IsolatedFromAbove`, `SingleBlockImplicitTerminator<ClassFieldsOp>`, `SingleBlock`\n\nInterfaces: `ClassLike`, `OpAsmOpInterface`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `formalParamNames` | ::mlir::ArrayAttr | string array attribute |\n| `fieldNames` | ::mlir::ArrayAttr | array attribute |\n| `fieldTypes` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n### `om.class.extern` (::circt::om::ClassExternOp)\n\nTraits: `IsolatedFromAbove`, `NoTerminator`\n\nInterfaces: `ClassLike`, `OpAsmOpInterface`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `formalParamNames` | ::mlir::ArrayAttr | string array attribute |\n| `fieldNames` | ::mlir::ArrayAttr | array attribute |\n| `fieldTypes` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n### `om.class.fields` (::circt::om::ClassFieldsOp)\n\nSyntax:\n\n```\noperation ::= `om.class.fields` attr-dict ($fields^ `:` qualified(type($fields)))?\n              custom<FieldLocs>($field_locs)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<ClassOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `field_locs` | ::mlir::ArrayAttr | location array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `fields` | variadic of any type |\n\n### `om.constant` (::circt::om::ConstantOp)\n\nSyntax:\n\n```\noperation ::= `om.constant` $value attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::TypedAttr | TypedAttr instance |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `om.frozenbasepath_create` (::circt::om::FrozenBasePathCreateOp)\n\n*Produce a frozen base path value*\n\nSyntax:\n\n```\noperation ::= `om.frozenbasepath_create` $basePath custom<BasePathString>($path) attr-dict\n```\n\nProduces a value which represents a fragment of a hierarchical path to a\ntarget.\n\nExample:\n\n```\nom.class @OM(%basepath: !om.basepath)\n  %0 = om.frozenbasepath_create %basepath \"Foo/bar:Bar/baz\"\n}\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `path` | ::circt::om::PathAttr | An attribute that represents an instance path |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `basePath` | A frozen fragment of a path to a hardware component |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A frozen fragment of a path to a hardware component |\n\n### `om.frozenpath_create` (::circt::om::FrozenPathCreateOp)\n\n*Produce a frozen path value*\n\nSyntax:\n\n```\noperation ::= `om.frozenpath_create` $targetKind $basePath custom<PathString>($path, $module, $ref, $field)\n              attr-dict\n```\n\nProduces a value which represents a hierarchical path to a hardware\ncomponent from a base path to a target.\n\nExample:\n\n```\nom.class @OM(%basepath: !om.basepath)\n  %0 = om.frozenpath_create reference %base \"Foo/bar:Bar>w.a\"\n}\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `targetKind` | ::circt::om::TargetKindAttr | object model target kind |\n| `path` | ::circt::om::PathAttr | An attribute that represents an instance path |\n| `module` | ::mlir::StringAttr | string attribute |\n| `ref` | ::mlir::StringAttr | string attribute |\n| `field` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `basePath` | A frozen fragment of a path to a hardware component |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A frozen path to a hardware component |\n\n### `om.frozenpath_empty` (::circt::om::FrozenEmptyPathOp)\n\n*Produce a frozen path value to nothing*\n\nSyntax:\n\n```\noperation ::= `om.frozenpath_empty` attr-dict\n```\n\nProduces a value which represents a hierarchical path to nothing.\n\nExample:\n\n```\nom.class @OM()\n  %0 = om.frozenpath_empty\n}\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A frozen path to a hardware component |\n\n### `om.integer.add` (::circt::om::IntegerAddOp)\n\n*Add two OMIntegerType values*\n\nSyntax:\n\n```\noperation ::= `om.integer.add` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nPerform arbitrary precision signed integer addition of two OMIntegerType\nvalues.\n\nExample:\n\n```\n%2 = om.integer.add %0, %1 : !om.integer\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `IntegerBinaryArithmeticOp`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | A type that represents an arbitrary width integer. |\n| `rhs` | A type that represents an arbitrary width integer. |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A type that represents an arbitrary width integer. |\n\n### `om.integer.mul` (::circt::om::IntegerMulOp)\n\n*Multiply two OMIntegerType values*\n\nSyntax:\n\n```\noperation ::= `om.integer.mul` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nPerform arbitrary prevision signed integer multiplication of two\nOMIntegerType values.\n\nExample:\n\n```\n%2 = om.integer.mul %0, %1 : !om.integer\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `IntegerBinaryArithmeticOp`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | A type that represents an arbitrary width integer. |\n| `rhs` | A type that represents an arbitrary width integer. |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A type that represents an arbitrary width integer. |\n\n### `om.integer.shl` (::circt::om::IntegerShlOp)\n\n*Shift an OMIntegerType value left by an OMIntegerType value*\n\nSyntax:\n\n```\noperation ::= `om.integer.shl` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nPerform arbitrary precision signed integer arithmetic shift left of the lhs\nOMIntegerType value by the rhs OMIntegerType value. The rhs value must be\nnon-negative.\n\nExample:\n\n```\n%2 = om.integer.shl %0, %1 : !om.integer\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `IntegerBinaryArithmeticOp`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | A type that represents an arbitrary width integer. |\n| `rhs` | A type that represents an arbitrary width integer. |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A type that represents an arbitrary width integer. |\n\n### `om.integer.shr` (::circt::om::IntegerShrOp)\n\n*Shift an OMIntegerType value right by an OMIntegerType value*\n\nSyntax:\n\n```\noperation ::= `om.integer.shr` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nPerform arbitrary precision signed integer arithmetic shift right of the lhs\nOMIntegerType value by the rhs OMIntegerType value. The rhs value must be\nnon-negative.\n\nExample:\n\n```\n%2 = om.integer.shr %0, %1 : !om.integer\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `IntegerBinaryArithmeticOp`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | A type that represents an arbitrary width integer. |\n| `rhs` | A type that represents an arbitrary width integer. |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A type that represents an arbitrary width integer. |\n\n### `om.list_concat` (::circt::om::ListConcatOp)\n\n*Concatenate multiple lists to produce a new list*\n\nSyntax:\n\n```\noperation ::= `om.list_concat` $subLists attr-dict `:` type($result)\n```\n\nProduces a value of list type by concatenating the provided lists.\n\nExample:\n\n```\n%3 = om.list_concat %0, %1, %2 : !om.list<string>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `subLists` | variadic of A type that represents a list. |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A type that represents a list. |\n\n### `om.list_create` (::circt::om::ListCreateOp)\n\n*Create a list of values*\n\nCreates a list from a sequence of inputs.\n\n```\n%list = om.list_create %a, %b, %c : !om.ref\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A type that represents a list. |\n\n### `om.object` (::circt::om::ObjectOp)\n\nSyntax:\n\n```\noperation ::= `om.object` $className `(` $actualParams `)`  attr-dict `:`\n              functional-type($actualParams, $result)\n```\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `className` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `actualParams` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A type that represents a reference to a Class. |\n\n### `om.object.field` (::circt::om::ObjectFieldOp)\n\nSyntax:\n\n```\noperation ::= `om.object.field` $object `,` $fieldPath attr-dict `:` functional-type($object, $result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldPath` | ::mlir::ArrayAttr | flat symbol ref array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `object` | A type that represents a reference to a Class. |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `om.path_create` (::circt::om::PathCreateOp)\n\n*Produce a path value*\n\nSyntax:\n\n```\noperation ::= `om.path_create` $targetKind $basePath $target attr-dict\n```\n\nProduces a value which represents a hierarchical path to a hardware\ntarget.\nfrom a base path to a target.\n\nExample:\n\n```\nhw.module @Foo() -> () {\n  %wire = hw.wire sym @w: !i1\n}\nhw.hierpath @Path [@Foo::@w]\nom.class @OM(%basepath: !om.basepath)\n  %0 = om.path_create reference %basepath @Path\n}\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `targetKind` | ::circt::om::TargetKindAttr | object model target kind |\n| `target` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `basePath` | A fragment of a path to a hardware component |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A path to a hardware component |\n\n### `om.path_empty` (::circt::om::EmptyPathOp)\n\n*Produce a path value to nothing*\n\nSyntax:\n\n```\noperation ::= `om.path_empty` attr-dict\n```\n\nProduces a value which represents a hierarchical path to nothing.\n\nExample:\n\n```\nom.class @OM()\n  %0 = om.path_empty\n}\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A path to a hardware component |\n\n### `om.unknown` (::circt::om::UnknownValueOp)\n\n*An operation with an unknown value used to tie-off connections*\n\nSyntax:\n\n```\noperation ::= `om.unknown` attr-dict `:` type($result)\n```\n\nAn operation that is used to tie-off connections to objects for which we do\nnot care about the value being used.\n\nThis is used in situations where a class exists and is instantiated, but the\ninstantiator has no reasonable value that it can or should drive.\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\nAttributes\n----------\n\n### IntegerAttr\n\n*An attribute that represents an arbitrary integer*\n\nSyntax:\n\n```\n#om.integer<\n  mlir::IntegerAttr   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `mlir::IntegerAttr` |  |\n\n### ListAttr\n\n*An attribute that represents a list*\n\nSyntax:\n\n```\n#om.list<\n  mlir::Type,   # elementType\n  mlir::ArrayAttr   # elements\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `mlir::Type` |  |\n| elements | `mlir::ArrayAttr` |  |\n\n### PathAttr\n\n*An attribute that represents an instance path*\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| path | `::llvm::ArrayRef<::circt::om::PathElement>` |  |\n\n### SymbolRefAttr\n\n*An attribute that wraps a FlatSymbolRefAttr type*\n\nSyntax:\n\n```\n#om.sym_ref<\n  mlir::FlatSymbolRefAttr   # ref\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| ref | `mlir::FlatSymbolRefAttr` |  |\n\n### ReferenceAttr\n\n*An attribute that wraps a #hw.innerNameRef with !om.ref type*\n\nSyntax:\n\n```\n#om.ref<\n  circt::hw::InnerRefAttr   # innerRef\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| innerRef | `circt::hw::InnerRefAttr` |  |\n\nTypes\n-----\n\n### BasePathType\n\n*A fragment of a path to a hardware component*\n\nSyntax: `!om.basepath`\n\n### ClassType\n\n*A type that represents a reference to a Class.*\n\nSyntax:\n\n```\n!om.class.type<\n  mlir::FlatSymbolRefAttr   # className\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| className | `mlir::FlatSymbolRefAttr` |  |\n\n### FrozenBasePathType\n\n*A frozen fragment of a path to a hardware component*\n\nSyntax: `!om.frozenbasepath`\n\n### FrozenPathType\n\n*A frozen path to a hardware component*\n\nSyntax: `!om.frozenpath`\n\n### ListType\n\n*A type that represents a list.*\n\nSyntax:\n\n```\n!om.list<\n  mlir::Type   # elementType\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `mlir::Type` |  |\n\n### AnyType\n\n*A type that represents any valid OM type.*\n\nSyntax: `!om.any`\n\n### OMIntegerType\n\n*A type that represents an arbitrary width integer.*\n\nSyntax: `!om.integer`\n\n### PathType\n\n*A path to a hardware component*\n\nSyntax: `!om.path`\n\n### ReferenceType\n\n*A type that represents a reference to a hardware entity.*\n\nSyntax: `!om.ref`\n\n### StringType\n\n*A type that represents a string.*\n\nSyntax: `!om.string`\n\n### SymbolRefType\n\n*A type that represents a reference to a flat symbol reference.*\n\nSyntax: `!om.sym_ref`\n\nEnums\n-----\n\n### TargetKind\n\n*Object model target kind*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| DontTouch | `0` | dont\\_touch |\n| Instance | `1` | instance |\n| MemberInstance | `2` | member\\_instance |\n| MemberReference | `3` | member\\_reference |\n| Reference | `4` | reference |\n\n'om' Dialect Docs\n-----------------\n\n* [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n\n [Prev - 'msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/ \"'msft' Dialect\")\n[Next - Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/ \"Object Model Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/OM/RationaleOM/index.md"
  },
  {
    "role": "user",
    "content": "Object Model Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nObject Model Dialect Rationale\n==============================\n\nThis document describes various design points of the `om` dialect. This follows\nin the spirit of other\n[MLIR Rationale docs](https://mlir.llvm.org/docs/Rationale/).\n\nMotivation\u00a0[\u00b6](#motivation)\n---------------------------\n\nThe goal of the `om` dialect is to develop an IR suitable for domain modeling. It\nintends to accomplish this by providing constructs for capturing an\n[Object Model](https://en.wikipedia.org/wiki/Object_model) (OM). Domain modeling\nin this context means capturing design intent and supporting tooling related to\nthe creation of CPUs and SoCs. Anything other than RTL level design entry falls\nunder this broad categorization, and must be intimately tied to RTL level design\nentry in a stable way.\n\nThis includes modeling domains such as:\n\n* Physical hierarchies\n* Power specifications\n* Clocks and clock domains\n* Bus interfaces\n* Software bringup\n* And much more\u2026\n\nThis dialect encompasses a very generic compiler IR capable of representing\nconcepts from these varied domains. This is not to say that we should never\ndevelop domain-specific compiler IRs for such domains. To the contrary, it is\nexpected that over time we will continuously re-evaluate the uses of the `om`\ndialect, and graduate well-understood models into domain-specific IRs through\nfurther dialects.\n\nDomain models should support tooling built around the design with well-defined\nand type safe APIs. This includes tools generating collateral such as:\n\n* Synthesis constraints\n* IP-XACT\n* DTS\n* And much more\u2026\n\nBackground\u00a0[\u00b6](#background)\n---------------------------\n\nLots of discussions and prior art have informed the design of the `om` dialect.\n\n### Ontologies\u00a0[\u00b6](#ontologies)\n\nDomain modeling is intimately tied to the philosophical topic of\n[ontologies](https://en.wikipedia.org/wiki/Ontology_%28information_science%29). The\n`om` dialect should be able to support an ontology of interest as it evolves.\nThis requires data structures that derive their power from simplicity. The\ndialect attempts to provide a few, orthogonal structures that can be composed to\nflexibly support a variety of domain modeling needs in powerful ways.\n\n### Domain Models APIs\u00a0[\u00b6](#domain-models-apis)\n\nThe domain models should not exist in a vacuum. They must be queried via\nwell-defined APIs to be of use to the various tools that require them. The design\nof the data structures should simultaneously capture the domain model and support\nquerying it in a natural way.\n\n### Inspiration from Modern Languages\u00a0[\u00b6](#inspiration-from-modern-languages)\n\nWhile many modern languages have influenced this design, the simplest analogy\nmight be in terms of Java classes. The `om` dialect constructs are similar to\nhow Java defines classes, with constructors and public data members, but without\ngeneric data types.\n\nClass constructors and public data member separate how Objects are created from\nhow they are used. The removal of generic data types requires the domain model\nto be monomorphized.\n\nThe design for Classes also draws on OCaml and C++.\n\nCore Constructs\u00a0[\u00b6](#core-constructs)\n-------------------------------------\n\n### Classes\u00a0[\u00b6](#classes)\n\nClass definitions have a name, a formal parameter list, and a body.\n\nThe formal parameter list provides a name and a type for each parameter that\nmust be supplied to instantiate the Class. In the IR, formal parameters become\nblock arguments, much like function formal parameters in software compilers.\nAfter Classes are defined, they can be instantiated as Objects in the IR by\nsupplying actual parameters for each declared formal parameter.\n\nThe body provides a way to describe both the publicly exported Fields of the\nClass, as well as its internal implementation.\n\nThe list of formal parameters describes what is needed to create a Class, and\nthe list of Fields describes how a Class can be used. They need not be the same,\nalthough for simple Classes, like Scala case classes, they may be. Together, the\nformal parameters and Fields describe the public API of a Class.\n\nOne or more Classes may be entrypoints into the domain model, providing\ndifferent top-level views into the graph. Such Classes have no formal\nparameters, and define their entrypoint to the domain model in terms of the\nFields they expose, which may be instantiated Objects or other primitives. One\nway to think of this is as an alternative to top-level Object instances that are\nnot inside any Class; such Objects can always be made Fields of a new top-level\nClass with no actual parameters.\n\nThe internal implementation is responsible for assigning values to the Fields,\nand is defined in terms of a small expression grammar including:\n\n* Instantiations of Classes to create Objects by passing expressions as actual\n  parameters\n* Accessing Fields on instantiated Objects\n* References to formal parameters\n* Primitive values like integers, strings, and symbols\n* Container values like lists\n* Expressions involving primitive and container values\n\nThis modeling of Classes might be most similar to Java classes, which define\npublic constructors and members. The proposed modeling of Classes is restricted\nto data members, and there is no such things as a method for Classes.\n\n### Fields\u00a0[\u00b6](#fields)\n\nFields are how arbitrary data can be exposed by each Object, according to the\ntypes defined in the Class the Object is instantiating. Fields are namespaced by\nthe class or interface they are defined in. Fields are name-value pairs, where\nthe name is given in the Class definition and the value is any expression in the\nsame small expression grammar described under Classes.\n\nWhere the expression assigned to each Field comes from is an internal detail\nthat cannot be accessed via Objects of a Class. Only the Field\u2019s value can be\naccessed, by name, externally.\n\nThe type system for Fields is left open and extensible: any Type representable\nin MLIR is allowed. This includes:\n\n* Builtin MLIR types like integer, float, symbol references, etc.\n* Core CIRCT types like HW inner reference\n* Types defined by the domain model via Classes\n* Container types like lists\n* Other new types defined for domain modeling\n\n### Objects\u00a0[\u00b6](#objects)\n\nObjects represent a specific entity from the ontology that is being captured in\nthe domain model. They have a very small list of required attributes, which\nallows the platform to reason about all Objects in a uniform way. As such,\naddition of new attributes should be reviewed and debated carefully.\n\nThe initial list of required attributes for all Objects is:\n\n* Class definition name: the name of the Class this Object is instantiating\n\nAn Object instantiation must also supply a list of actual parameters that match\nthe Class\u2019s formal parameters. These actual parameters can be any expression in\nthe same small expression grammar used to assign values to Fields of Classes.\nObject instances are values just like other expressions, and can be assigned to\nnamed Fields in a Class or passed as actual parameters in other Object\ninstantiations.\n\nThe type of an Object is governed by its Class, and a new custom type is added\nto support a reference to a Class in the type system. When Objects are passed as\nactual parameters to other Object instantiations, they are passed by reference.\n\nFields defined by Classes can be accessed from concrete Object instances. Field\naccesses accept an instance of an Object, and a list of Fields to refer to\nwithin the Object and potential children Objects. Object Field accesses are\nvalues just like other expressions, and can be assigned to named Fields in a\nClass or passed as actual parameters in Object instantiations.\n\n### Expressions\u00a0[\u00b6](#expressions)\n\nThe small expression grammar described under Classes includes expressions\ninvolving primitive and container values. This sections describes the rationale\nfor such expressions.\n\nIn order for a Class to effectively capture parts of a domain model, it may be\nnecessary for the Class to represent computation in terms of its formal\nparameters.\n\nFor example, a Class might represent a device that is attached to a bus, and\naccessible at some address. If that address is implemented as an offset relative\nto some base address, the Class could have an input integer as a formal\nparameter representing the base address, a Field representing the device\naddress, and internally add some constant offset to the base address before\nassigning the resulting value into the Field.\n\nAs another example, a Class might internally instantiate Objects of some other\nClasses, access Fields of those Objects, create a container holding the values\nof those fields, and assign the container to a Field. Using container\nconstruction expressions, this can be represented directly in the Class,\nallowing it to abstract over the Objects it creates internally.\n\nAlternatives Considered\u00a0[\u00b6](#alternatives-considered)\n-----------------------------------------------------\n\n### Other Libraries and Tools for Domain Modeling\u00a0[\u00b6](#other-libraries-and-tools-for-domain-modeling)\n\nMany powerful libraries and tools exist for building domain models in a variety\nof programming languages. It would be possible to implement the goals using any\nsuch system, but this misses the opportunity to continue leveraging MLIR based\ntooling. These other systems may be powerful, but so is MLIR, and integrating new\nsystems comes with a cost. With MLIR, the infrastructure is already in place to\nachieve the goal of creating modular libraries in a common framework.\n\n### Specific IR for Domain Modeling\u00a0[\u00b6](#specific-ir-for-domain-modeling)\n\nMLIR has excellent support for flexibly defining IRs that model different\ndomains. Why not use this power to model domains directly in the IR using the\nappropriate abstractions?\n\nOperations could be defined for bus interfaces, address maps, and all the other\ndomain models. This would enable very precise modeling, verification,\ndocumentation, etc. to all be captured in the IR. We could build up a library of\nall the domain models we care about.\n\nThe problem with this approach is it puts the burden of domain modeling on\ncompiler engineers. Any new property or domain model will require new IR\ndefinitions. This puts compiler engineers on the critical path of all domain\nmodel related tasks, which is not scalable.\n\nThere is a potential future world where it becomes tractable to define specific\nIRs without getting a compiler engineer involved. Tools like\n[IRDL](https://pldi22.sigplan.org/details/pldi-2022-pldi/33/IRDL-An-IR-Definition-Language-for-SSA-Compilers)\nare being built right now, which could allow developers to conveniently express\ndomain-specific IRs in an ergonomic way from a programming language of their\nchoosing. But this is still very research oriented, and may not be ready for\nproduction in the near term.\n\nIn the meantime, defining a few core abstractions that let the compiler reason\nabout the domain models in a limited but useful way is sufficient to enable many\nuse-cases without putting compiler engineers on the critical path.\n\nHowever, as mentioned in the initial motivation, we also want to be diligent\nabout reviewing the uses of the generic model, and promoting well-defined\nmodeling into domain-specific IRs once they are ready to be hardened and little\nchurn in the modeling is expected.\n\n### Generic IR with Objects\u00a0[\u00b6](#generic-ir-with-objects)\n\nThe first `om` dialect proposal simply had Containers, Properties on Containers,\nand references between Containers. This was a Smalltalk-style \u201ceverything is an\nobject\u201d system, where the only way to interact with an object would be through\nits Properties and References (as opposed to messages in Smalltalk).\n\nSuch a system is extremely simple, yet powerful. However, this does not lend\nitself to all of our stated goals. This leads to a dynamically typed system,\nwhere the compiler has little static knowledge. This is actually somewhat akin to\nthe current Object Model JSON design. We want to keep the simplicity and power,\nbut bring a more statically typed approach to bear.\n\n### Generic IR with Objects and Protocols\u00a0[\u00b6](#generic-ir-with-objects-and-protocols)\n\nThe second `om` dialect proposal split Containers into two concepts: Objects and\nProtocols. Objects had Properties, and Protocols defined a set of Properties that\nan Object must have. This started to bring more static information to the system,\nwhere multiple Objects could be reasoned about in terms of Protocols.\n\nHowever, this was still insufficient. The design point of having Objects\nimplement Protocols was a step in the right direction, but only a step. The type\nsystem gained slightly more static information, but was still only defined in\nterms of loose collections of Objects.\n\n### Generic IR with Objects, Structs, and Traits\u00a0[\u00b6](#generic-ir-with-objects-structs-and-traits)\n\nThe third `om` dialect proposal split Protocols into two concepts: Structs and\nTraits. The name and design was inspired by Rust. Structs defined Fields that\ninstances of Structs would have. This separation between definition and instance\nwas another crucial step in the right direction. The type system was defined in\nterms of Structs, inheritance, and Traits that Structs implement. Objects were\ntyped in terms of the Struct they were instantiating.\n\nHowever, there was still a key ingredient missing. Struct definitions were a\nsimple list of flat Fields, and Object instantiations simply provided concrete\nvalues for each field. The missing ingredient was a separation between what was\nneeded to instantiate a Struct and what was exposed as Fields of a Struct.\n\nThis addition led to the current design of the `om` dialect. Modulo some\nrenaming, the key difference was that Struct definitions were given a formal\nparameter list, and Struct bodies were updated to admit a small grammar of\nexpressions to compute the Struct\u2019s various Fields.\n\n [Prev - 'om' Dialect](https://circt.llvm.org/docs/Dialects/OM/ \"'om' Dialect\")\n[Next - 'pipeline' Dialect](https://circt.llvm.org/docs/Dialects/Pipeline/ \"'pipeline' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect-](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Pipeline/index.md"
  },
  {
    "role": "user",
    "content": "'pipeline' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'pipeline' Dialect\n==================\n\n* [Operations](#operations)\n  + [`pipeline.latency` (::circt::pipeline::LatencyOp)](#pipelinelatency-circtpipelinelatencyop)\n  + [`pipeline.latency.return` (::circt::pipeline::LatencyReturnOp)](#pipelinelatencyreturn-circtpipelinelatencyreturnop)\n  + [`pipeline.return` (::circt::pipeline::ReturnOp)](#pipelinereturn-circtpipelinereturnop)\n  + [`pipeline.scheduled` (::circt::pipeline::ScheduledPipelineOp)](#pipelinescheduled-circtpipelinescheduledpipelineop)\n  + [`pipeline.src` (::circt::pipeline::SourceOp)](#pipelinesrc-circtpipelinesourceop)\n  + [`pipeline.stage` (::circt::pipeline::StageOp)](#pipelinestage-circtpipelinestageop)\n  + [`pipeline.unscheduled` (::circt::pipeline::UnscheduledPipelineOp)](#pipelineunscheduled-circtpipelineunscheduledpipelineop)\n\nOperations\n----------\n\n### `pipeline.latency` (::circt::pipeline::LatencyOp)\n\n*Pipeline dialect latency operation.*\n\nSyntax:\n\n```\noperation ::= `pipeline.latency` $latency `->` `(` type($results) `)` $body attr-dict\n```\n\nThe `pipeline.latency` operation represents an operation for wrapping\nmulti-cycle operations. The operation declares a single block\nwherein any operation may be placed within. The operation is not\n`IsolatedFromAbove` meaning that the operation can reference values\ndefined outside of the operation (subject to the materialization\nphase of the parent pipeline).\n\nTraits: `HasOnlyGraphRegion`, `HasParent<UnscheduledPipelineOp, ScheduledPipelineOp>`, `SingleBlockImplicitTerminator<LatencyReturnOp>`, `SingleBlock`\n\nInterfaces: `RegionKindInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `latency` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 1 |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `pipeline.latency.return` (::circt::pipeline::LatencyReturnOp)\n\n*Pipeline latency return operation.*\n\nSyntax:\n\n```\noperation ::= `pipeline.latency.return` ($inputs^)? attr-dict (`:` type($inputs)^)?\n```\n\nThe `pipeline.latency.return` operation represents a terminator of a\n`pipeline.latency` operation.\n\nTraits: `HasParent<LatencyOp>`, `Terminator`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n### `pipeline.return` (::circt::pipeline::ReturnOp)\n\n*Pipeline dialect return.*\n\nSyntax:\n\n```\noperation ::= `pipeline.return` ($inputs^)? attr-dict (`:` type($inputs)^)?\n```\n\nThe \u201creturn\u201d operation represents a terminator of a `pipeline.pipeline`.\n\nTraits: `HasParent<UnscheduledPipelineOp, ScheduledPipelineOp>`, `Terminator`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n### `pipeline.scheduled` (::circt::pipeline::ScheduledPipelineOp)\n\n*Scheduled pipeline operation*\n\nThe `pipeline.scheduled` operation represents a scheduled pipeline.\nThe pipeline contains a single block representing a graph region.\n\nA `pipeline.scheduled` operation can exist in multiple phases, mainly\npertaining to when registers have been materialized (made explicit).\nFor an in-depth explanation, please refer to the Pipeline dialect rationale.\n\nA `pipeline.scheduled` supports a `stall` input. This signal is intended to\nconnect to all stages within the pipeline, and is used to stall the entirety\nof the pipeline. It is lowering defined how stages choose to use this signal,\nalthough in the common case, a `stall` signal would typically connect to\nthe clock-enable input of the stage-separating registers.\n\nThe `go` input is used to start the pipeline. This value is fed through\nthe stages as the current stage valid/next stage enable signal.\nNote: the op is currently only designed for pipelines with II=1. For\npipelines with II>1, a user must themselves maintain state about when\nthe pipeline is ready to accept new inputs. We plan to add support for\nhead-of-pipeline backpressure in the future.\n\nAny value defined outside the pipeline is considered an external input. An\nexternal input will *not* be registered.\n\nThe pipeline may optionally be provided with an array of bits `stallability`\nwhich is used to determine which stages are stallable.\n\n* If not provided and the pipeline has a stall signal, all stages are stallable.\n* If provided, and the pipeline has a stall signal, the number of bits must\n  match the number of stages in the pipeline. Each bit represents a stage,\n  in the order of which the stages appear wrt. the `pipeline.stage` operations.\n  A bit set to 1 indicates that the stage is stallable, and 0 indicates that\n  the stage is not stallable.\n\nThe exit (non-registered) stage of a pipeline cannot be non-stallable, and\nwill always follow the stallability of the parent pipeline.\n\nFor more information about non-stallable stages, and how these are lowered,\nplease refer to the Pipeline dialect rationale.\n\nTraits: `AttrSizedOperandSegments`\n\nInterfaces: `OpAsmOpInterface`, `RegionKindInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `inputNames` | ::mlir::ArrayAttr | string array attribute |\n| `outputNames` | ::mlir::ArrayAttr | string array attribute |\n| `stallability` | ::mlir::ArrayAttr | 1-bit boolean array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n| `stall` | 1-bit signless integer |\n| `clock` | A type for clock-carrying wires |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `dataOutputs` | variadic of any type |\n| `done` | 1-bit signless integer |\n\n### `pipeline.src` (::circt::pipeline::SourceOp)\n\n*Pipeline source operation*\n\nSyntax:\n\n```\noperation ::= `pipeline.src` $input `:` type($input) attr-dict\n```\n\nThe `pipeline.src` operation represents a source operation in a scheduled,\nnon-register materialized pipeline.\nIt is used as a canonicalization barrier to prevent cross-block canonicalization\nof operations that are not allowed to be moved or mutated across pipeline\nstages (i.e. MLIR blocks).\n\nTo facilitate this, the operation is *not* marked as `Pure`.\n\nTraits: `HasParent<ScheduledPipelineOp>`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | any type |\n\n### `pipeline.stage` (::circt::pipeline::StageOp)\n\n*Pipeline stage terminator.*\n\nSyntax:\n\n```\noperation ::= `pipeline.stage` $nextStage\n              custom<StageRegisters>($registers, type($registers), $clockGates, $clockGatesPerRegister, $registerNames)\n              custom<Passthroughs>($passthroughs, type($passthroughs), $passthroughNames)\n              attr-dict\n```\n\nThe `pipeline.stage` operation represents a stage terminator. It is used\nto communicate:\n\n1. which stage (block) to transition to next\n2. which registers to build at this stage boundary\n3. which values to pass through to the next stage without registering\n4. An optional hierarchy of boolean values to be used for clock gates for\n   each register.\n\n* The implicit \u2018!stalled\u2019 gate will always be the first signal in the\n  hierarchy. Further signals are added to the hierarchy from left to\n  right.\n\nExample:\n\n```\npipeline.stage ^bb1 regs(%a : i32 gated by [%foo, %bar], %b : i1) pass(%c : i32)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `AttrSizedOperandSegments`, `HasParent<ScheduledPipelineOp>`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `clockGatesPerRegister` | ::mlir::ArrayAttr | 64-bit integer array attribute |\n| `registerNames` | ::mlir::ArrayAttr | string array attribute |\n| `passthroughNames` | ::mlir::ArrayAttr | string array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `registers` | variadic of any type |\n| `passthroughs` | variadic of any type |\n| `clockGates` | variadic of 1-bit signless integer |\n\n#### Successors:\n\n| Successor | Description |\n| --- | --- |\n| `nextStage` | any successor |\n\n### `pipeline.unscheduled` (::circt::pipeline::UnscheduledPipelineOp)\n\n*Unscheduled pipeline operation*\n\nThe \u201cpipeline.unscheduled\u201d operation represents a pipeline that has not yet\nbeen scheduled. It contains a single block representing a graph region of\noperations to-be-scheduled into a pipeline.\nMainly serves as a container and entrypoint for scheduling.\n\nThe interface of a `pipeline.unscheduled` is similar to that of a\n`pipeline.scheduled`. Please refer to this op for further documentation\nabout the interface signals.\n\nTraits: `AttrSizedOperandSegments`, `HasOnlyGraphRegion`, `SingleBlockImplicitTerminator<ReturnOp>`, `SingleBlock`\n\nInterfaces: `OpAsmOpInterface`, `RegionKindInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `inputNames` | ::mlir::ArrayAttr | string array attribute |\n| `outputNames` | ::mlir::ArrayAttr | string array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n| `stall` | 1-bit signless integer |\n| `clock` | A type for clock-carrying wires |\n| `reset` | 1-bit signless integer |\n| `go` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `dataOutputs` | variadic of any type |\n| `done` | 1-bit signless integer |\n\n'pipeline' Dialect Docs\n-----------------------\n\n* [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n\n [Prev - Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/ \"Object Model Dialect Rationale\")\n[Next - Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/ \"Pipeline Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/index.md"
  },
  {
    "role": "user",
    "content": "Pipeline Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nPipeline Dialect Rationale\n==========================\n\nThis document describes various design points of the `pipeline` dialect, why it is\nthe way it is, and current status. This follows in the spirit of other\n[MLIR\nRationale docs](https://mlir.llvm.org/docs/Rationale/).\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\nPipeline Phases\u00a0[\u00b6](#pipeline-phases)\n-------------------------------------\n\nA `pipeline.pipeline` operation can be used in a sequence of phases, each\nof which incrementally transforms the pipeline from being unscheduled towards\nbeing an RTL representation of a pipeline. Each phase is mutually exlusive,\nmeaning that the \u201cphase-defining\u201d operations\n(`pipeline.ss, pipeline.ss.reg, pipeline.stage`) are not allowed to co-exist.\n\n### Phase 1: Unscheduled\u00a0[\u00b6](#phase-1-unscheduled)\n\nThe highest-level phase that a pipeline may be in is the unscheduled phase.\nIn this case, the body of the pipeline simply consists of a feed-forward set of\noperations representing a dataflow graph.\n\n```\n%out = pipeline.unscheduled(%arg0, %arg1, %go) clock %clk reset %rst : (i32, i32, i1) -> (i32) {\n  ^bb0(%a0 : i32, %a1: i32, %g : i1):\n    %add0 = comb.add %a0, %a1 : i32\n    %add1 = comb.add %add0, %a0 : i32\n    %add2 = comb.add %add1, %add0 : i32\n    pipeline.return %add2 valid %s1_valid : i32\n}\n```\n\n### Phase 2: Scheduled\u00a0[\u00b6](#phase-2-scheduled)\n\nUsing e.g. the `pipeline-schedule-linear` pass, a pipeline may be scheduled wrt.\nan operator library denoting the latency of each operation. The result of a scheduling\nproblem is the movement of operations to specific blocks.\nEach block represents a pipeline stage, with `pipeline.stage` operations being\nstage-terminating operations that determine the order of stages.\n\nAt this level, the semantics of the pipeline are that **any SSA def-use edge that\ncrosses a stage is a pipeline register**. To prevent cross-block canonicalization\nto occur post-scheduling, these def-use edges must be expressed using the\n`pipeline.src` operation, which is used to refer a value from within the basic\nblock that uses it, but which is defined in *any* prior, dominating stage (block).  \nGiven these relaxed semantics, this level of abstraction is suitable for pipeline\nretiming. Operations may be moved from one stage to another, or new blocks may be\ninserted between existing blocks, without changing the semantics of the pipeline.\nThe only requirement is that def-use edges wrt. the order of stages are preserved.\nFor expressing semantics about multi-cycle latencies of SSA, please refer to the\n`multicycle operations` segment below.\n\n```\n%out = pipeline.scheduled(%arg0, %arg1, %go) clock %clk reset %rst : (i32, i32, i1) -> (i32) {\n^bb0(%a0 : i32, %a1: i32, %go : i1):\n  %add0 = comb.add %a0, %a1 : i32\n  pipeline.stage ^bb1 enable %go\n\n^bb1:\n  // %add0, %a0 is referenced in this stage via. dominance, w/ pipeline.src\n  // preventing cross-block canonicalization.\n  %add0_bb1 = pipeline.src %add0 : i32\n  %a0_bb1 = pipeline.src %a0 : i32\n  %add1 = comb.add %add0_bb1, %a0_bb1 : i32\n  pipeline.stage ^bb2 enable %go\n\n^bb2:\n  %add0_bb2 = pipeline.src %add0 : i32\n  %add1_bb2 = pipeline.src %add1 : i32\n  %add2 = comb.add %add1_bb2, %add0_bb2 : i32 // %add0 crosses multiple stages.\n  pipeline.return %add2 enable %go : i32   // %go crosses multiple stages\n}\n```\n\n### Phase 3: Register materialized\u00a0[\u00b6](#phase-3-register-materialized)\n\nOnce the prior phase has been completed, pipeline registers must be materialized.  \nThis amounts to a dataflow analysis to check the phase 2 property of def-use edges\nacross pipeline stages, performed by the `pipeline-explicit-regs` pass.\n\nThe result of this pass is the addition of block arguments to each block representing\na pipeline stage, block arguments which represent stage inputs. It is the\n`pipeline.stage` operation which determines which values are registered and which\nare passed through directly. The block arguments to each stage should thus \u201cjust\u201d\nbe seen as wires feeding into the stage.\nIn case a value was marked as multicycle, a value is passed through the `pass` list\nin the stage terminating `pipeline.stage` operation. This indicates that the value\nis to be passed through to the target stage without being registered.  \nAt this level, an invariant of the pipeline is that **any SSA value used within\na stage must be defined within the stage**, wherein that definition may be either\na block argument or as a result of another operation in the stage.  \nThe order of block arguments to a stage is, that register inputs from the\npredecessor stage come first, followed by pass-through values. A verifier will\ncheck that the signature of a stage block matches the predecessor `pipeline.stage`\noperation.\n\n```\n%0 = pipeline.scheduled(%arg0, %arg1, %go) clock %clk reset %rst : (i32, i32, i1) -> i32 {\n^bb0(%a0: i32, %a1: i32, %go: i1):\n  %1 = comb.add %a0, %a1 : i32\n  pipeline.stage ^bb1 regs (%1, %a0, %go) pass () enable %go\n\n^bb1(%1_s0 : i32, %a0_s0 : i32, %go_s0 : i1):\n  %2 = comb.add %1_s0, %a0_s0 : i32\n  pipeline.stage ^bb2 regs (%2, %1_s0, %go_s0) pass () enable %go_s0\n\n^bb2(%2_s1 : i32, %1_s1 : i32, %go_s1 : i1):\n  %3 = comb.add %2_s1, %1_s1 : i32 // %1 from the entry stage is chained through both stage 1 and 2.\n  pipeline.return %3 valid %go_s1 : i32 // and likewise with %go\n}\n```\n\nA note on constants\u00a0[\u00b6](#a-note-on-constants)\n---------------------------------------------\n\nConstants (defined as all operations which the `OpTrait::ConstantLike` trait) are\nspecial cases in the pipeline dialect. These are allowed to be used anywhere\nwithin the pipeline, and are not subject to the SSA def-use edge restrictions\ndescribed above. By doing so, we allow for constant canonicalizers to run,\nwhich may apply regardless of where a constant is used within the pipeline.  \nThe result of this is that constant-like operations will be moved to the\nentry stage of the pipeline.  \nIn the `pipeline-to-hw` pass, in case the user selects to perform `outline`d\nlowering, constants will be **copied** into the stages which reference them.\n\nMulticycle operations\u00a0[\u00b6](#multicycle-operations)\n-------------------------------------------------\n\nOftentimes, we may have operations which take multiple cycles to complete within\na pipeline. Support for this is provided by the `pipeline.latency` operation.\nThe main purpose of this operation is to provide a way to inform the\nregister materialization pass to pass values through stages *without* registering them.\n\nCurrently, all return values have an identical latency. This is an\narbitrary restriction, and may be lifted in the future if needed.\n\nAs an example pipeline:\n\n```\n^bb1:\n...\n%out = pipeline.latency 2 -> (i32) {\n  %dl1 = seq.compreg %in : i32\n  %dl2 = seq.compreg %dl1 : i32\n  pipeline.latency.return %dl2 : i32\n}\npipeline.stage ^bb2\n\n^bb2:\n// It is illegal to reference %out here\npipeline.stage ^bb3\n\n\n^bb3:\n// It is legal to reference %out here\npipeline.stage ^bb4\n\n^bb4:\n// It is legal to reference %out here. This will also imply a register\n// between stage bb3 and bb4.\n%out_bb4 = pipeline.src %out : i32\nfoo.bar %out_bb4 : i32\n```\n\nwhich will register materialize to:\n\n```\n^bb1:\n...\n%out = pipeline.latency 2 -> (i32) {\n  %dl1 = seq.compreg %in : i32\n  %dl2 = seq.compreg %dl1 : i32\n  pipeline.latency.return %dl2 : i32\n}\npipeline.stage ^bb2 pass(%out : i32)    // %out is passed through\n\n^bb2(%out_s2 : i32):\npipeline.stage ^bb3 pass(%out_s2 : i32) // %out is passed through\n\n\n^bb3(%out_s3 : i32):\npipeline.stage ^bb4 regs(%out_s3 : i32) // %out is registered\n\n^bb4(%out_s4 : i32):\nfoo.bar %out_s4 : i32\n```\n\nNon-stallable Pipeline Stages\u00a0[\u00b6](#non-stallable-pipeline-stages)\n-----------------------------------------------------------------\n\n**Note:** the following is only valid for pipelines with a stall signal.\n\nAn option of the Pipeline abstraction presented in this dialect is the ability\nto have *non-stallable stages* (NS). NS stages are used wherever a pipeline\naccess resources that are not able to stop on a dime, and thus require a fixed\namount of cycles to complete.\n\nNon-stallable stages are marked as an attribute of the pipeline operations,\nwherein a bitvector is provided (by the user) to indicate which stage(s) are\nnon-stallable.\n\nTo see how non-stallable stages are implemented, consider the following. For\nevery stage, we define two signals - `S_{N,en}` is the signal that indicates\nthat the stage currently has valid contents (i.e. not a bubble). `S_{N,valid}`\nis the signal that is used as a clock-enable for the output registers of a\nstage.\n\nStages can be grouped into three distinct types based on how their valid signal\nis defined: stallable stages, non-stallable stages and runoff stages.\n\n![](includes/img/Pipeline/stage_control.png \"Stage control\")\n\n1. Stallable stages are any stages which appear **before** the first\n   non-stallable stage in the pipeline.\n2. Non-stallable stages are the stages explicitly marked as non-stallable by the\n   user.\n3. Runoff stages and stages that appear **after** (and by extension, **between**\n   non-stallable stages). Runoff stages consider their own enablement wrt. the\n   stall signal, as well as the enablement of the **last non-stallable\n   register** (LNS) wrt. the runoff stage\u2019s position in the pipeline.\n\nThe purpose of the runoff stages is to ensure that they are able to pass through\nas many pipeline cycles as there are upstream non-stallable stages, such that\nthe contents of the non-stallable stages is not discarded.  \nAn important implication of this is that pipelines with non-stallable stages\n**must** be connected to some buffer mechanism that is able to hold as many\npipeline output value cycles as there are non-stallable stages in the pipeline.\n\nAs an example, the following 6 stage pipeline will have the following valid\nsignals: ![](includes/img/Pipeline/ns_ex1.png \"Stage control\")\n\n### Example 1:\u00a0[\u00b6](#example-1)\n\nIn this example, we have two NS stages followed by three runoff stages:\n\n![](includes/img/Pipeline/ns_ex2.png \"Stage control\")\n\nIn this example we see that, as expected, two cycles are output from the\npipeline after the stall signal goes high, corresponding to the two NS stages.\n\n### Example 2:\u00a0[\u00b6](#example-2)\n\nIn this example, we have two NS stages, then one runoff stage, then one NS\nstage, and finally one runoff stage:\n\n![](includes/img/Pipeline/ns_ex3.png \"Stage control\")\n\nIn this example we see that, as expected, three cycles are output from the\npipeline after the stall signal goes high, corresponding to the three NS stages.\n\n [Prev - 'pipeline' Dialect](https://circt.llvm.org/docs/Dialects/Pipeline/ \"'pipeline' Dialect\")\n[Next - 'rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/ \"'rtgtest' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect-](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/RTGTest/index.md"
  },
  {
    "role": "user",
    "content": "'rtgtest' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'rtgtest' Dialect\n=================\n\n*Types and operations for random test generation testing*\n\nThis dialect defines the `rtgtest` dialect, which provides a set of\noperation definitions to test the RTG dialect.\n\n* [Operations](#operations)\n  + [`rtgtest.constant_test` (::circt::rtgtest::ConstantTestOp)](#rtgtestconstant_test-circtrtgtestconstanttestop)\n  + [`rtgtest.get_hartid` (::circt::rtgtest::GetHartIdOp)](#rtgtestget_hartid-circtrtgtestgethartidop)\n  + [`rtgtest.implicit_constraint_op` (::circt::rtgtest::ImplicitConstraintTestOp)](#rtgtestimplicit_constraint_op-circtrtgtestimplicitconstrainttestop)\n  + [`rtgtest.rv32i.add` (::circt::rtgtest::ADD)](#rtgtestrv32iadd-circtrtgtestadd)\n  + [`rtgtest.rv32i.addi` (::circt::rtgtest::ADDI)](#rtgtestrv32iaddi-circtrtgtestaddi)\n  + [`rtgtest.rv32i.and` (::circt::rtgtest::AND)](#rtgtestrv32iand-circtrtgtestand)\n  + [`rtgtest.rv32i.andi` (::circt::rtgtest::ANDI)](#rtgtestrv32iandi-circtrtgtestandi)\n  + [`rtgtest.rv32i.auipc` (::circt::rtgtest::AUIPC)](#rtgtestrv32iauipc-circtrtgtestauipc)\n  + [`rtgtest.rv32i.beq` (::circt::rtgtest::BEQ)](#rtgtestrv32ibeq-circtrtgtestbeq)\n  + [`rtgtest.rv32i.bge` (::circt::rtgtest::BGE)](#rtgtestrv32ibge-circtrtgtestbge)\n  + [`rtgtest.rv32i.bgeu` (::circt::rtgtest::BGEU)](#rtgtestrv32ibgeu-circtrtgtestbgeu)\n  + [`rtgtest.rv32i.blt` (::circt::rtgtest::BLT)](#rtgtestrv32iblt-circtrtgtestblt)\n  + [`rtgtest.rv32i.bltu` (::circt::rtgtest::BLTU)](#rtgtestrv32ibltu-circtrtgtestbltu)\n  + [`rtgtest.rv32i.bne` (::circt::rtgtest::BNE)](#rtgtestrv32ibne-circtrtgtestbne)\n  + [`rtgtest.rv32i.ebreak` (::circt::rtgtest::EBREAKOp)](#rtgtestrv32iebreak-circtrtgtestebreakop)\n  + [`rtgtest.rv32i.ecall` (::circt::rtgtest::ECALLOp)](#rtgtestrv32iecall-circtrtgtestecallop)\n  + [`rtgtest.rv32i.jal` (::circt::rtgtest::JAL)](#rtgtestrv32ijal-circtrtgtestjal)\n  + [`rtgtest.rv32i.jalr` (::circt::rtgtest::JALROp)](#rtgtestrv32ijalr-circtrtgtestjalrop)\n  + [`rtgtest.rv32i.la` (::circt::rtgtest::LA)](#rtgtestrv32ila-circtrtgtestla)\n  + [`rtgtest.rv32i.lb` (::circt::rtgtest::LBOp)](#rtgtestrv32ilb-circtrtgtestlbop)\n  + [`rtgtest.rv32i.lbu` (::circt::rtgtest::LBUOp)](#rtgtestrv32ilbu-circtrtgtestlbuop)\n  + [`rtgtest.rv32i.lh` (::circt::rtgtest::LHOp)](#rtgtestrv32ilh-circtrtgtestlhop)\n  + [`rtgtest.rv32i.lhu` (::circt::rtgtest::LHUOp)](#rtgtestrv32ilhu-circtrtgtestlhuop)\n  + [`rtgtest.rv32i.lui` (::circt::rtgtest::LUI)](#rtgtestrv32ilui-circtrtgtestlui)\n  + [`rtgtest.rv32i.lw` (::circt::rtgtest::LWOp)](#rtgtestrv32ilw-circtrtgtestlwop)\n  + [`rtgtest.rv32i.or` (::circt::rtgtest::OR)](#rtgtestrv32ior-circtrtgtestor)\n  + [`rtgtest.rv32i.ori` (::circt::rtgtest::ORI)](#rtgtestrv32iori-circtrtgtestori)\n  + [`rtgtest.rv32i.sb` (::circt::rtgtest::SB)](#rtgtestrv32isb-circtrtgtestsb)\n  + [`rtgtest.rv32i.sh` (::circt::rtgtest::SH)](#rtgtestrv32ish-circtrtgtestsh)\n  + [`rtgtest.rv32i.sll` (::circt::rtgtest::SLL)](#rtgtestrv32isll-circtrtgtestsll)\n  + [`rtgtest.rv32i.slli` (::circt::rtgtest::SLLI)](#rtgtestrv32islli-circtrtgtestslli)\n  + [`rtgtest.rv32i.slt` (::circt::rtgtest::SLT)](#rtgtestrv32islt-circtrtgtestslt)\n  + [`rtgtest.rv32i.slti` (::circt::rtgtest::SLTI)](#rtgtestrv32islti-circtrtgtestslti)\n  + [`rtgtest.rv32i.sltiu` (::circt::rtgtest::SLTIU)](#rtgtestrv32isltiu-circtrtgtestsltiu)\n  + [`rtgtest.rv32i.sltu` (::circt::rtgtest::SLTU)](#rtgtestrv32isltu-circtrtgtestsltu)\n  + [`rtgtest.rv32i.sra` (::circt::rtgtest::SRA)](#rtgtestrv32isra-circtrtgtestsra)\n  + [`rtgtest.rv32i.srai` (::circt::rtgtest::SRAI)](#rtgtestrv32israi-circtrtgtestsrai)\n  + [`rtgtest.rv32i.srl` (::circt::rtgtest::SRL)](#rtgtestrv32isrl-circtrtgtestsrl)\n  + [`rtgtest.rv32i.srli` (::circt::rtgtest::SRLI)](#rtgtestrv32isrli-circtrtgtestsrli)\n  + [`rtgtest.rv32i.sub` (::circt::rtgtest::SUB)](#rtgtestrv32isub-circtrtgtestsub)\n  + [`rtgtest.rv32i.sw` (::circt::rtgtest::SW)](#rtgtestrv32isw-circtrtgtestsw)\n  + [`rtgtest.rv32i.xor` (::circt::rtgtest::XOR)](#rtgtestrv32ixor-circtrtgtestxor)\n  + [`rtgtest.rv32i.xori` (::circt::rtgtest::XORI)](#rtgtestrv32ixori-circtrtgtestxori)\n* [Attributes](#attributes-2)\n  + [CPUAttr](#cpuattr)\n  + [RegA0Attr](#rega0attr)\n  + [RegA1Attr](#rega1attr)\n  + [RegA2Attr](#rega2attr)\n  + [RegA3Attr](#rega3attr)\n  + [RegA4Attr](#rega4attr)\n  + [RegA5Attr](#rega5attr)\n  + [RegA6Attr](#rega6attr)\n  + [RegA7Attr](#rega7attr)\n  + [RegF0Attr](#regf0attr)\n  + [RegGpAttr](#reggpattr)\n  + [RegRaAttr](#regraattr)\n  + [RegS0Attr](#regs0attr)\n  + [RegS1Attr](#regs1attr)\n  + [RegS2Attr](#regs2attr)\n  + [RegS3Attr](#regs3attr)\n  + [RegS4Attr](#regs4attr)\n  + [RegS5Attr](#regs5attr)\n  + [RegS6Attr](#regs6attr)\n  + [RegS7Attr](#regs7attr)\n  + [RegS8Attr](#regs8attr)\n  + [RegS9Attr](#regs9attr)\n  + [RegS10Attr](#regs10attr)\n  + [RegS11Attr](#regs11attr)\n  + [RegSpAttr](#regspattr)\n  + [RegT0Attr](#regt0attr)\n  + [RegT1Attr](#regt1attr)\n  + [RegT2Attr](#regt2attr)\n  + [RegT3Attr](#regt3attr)\n  + [RegT4Attr](#regt4attr)\n  + [RegT5Attr](#regt5attr)\n  + [RegT6Attr](#regt6attr)\n  + [RegTpAttr](#regtpattr)\n  + [RegZeroAttr](#regzeroattr)\n* [Types](#types)\n  + [CPUType](#cputype)\n  + [FloatRegisterType](#floatregistertype)\n  + [IntegerRegisterType](#integerregistertype)\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `rtgtest.constant_test` (::circt::rtgtest::ConstantTestOp)\u00a0[\u00b6](#rtgtestconstant_test-circtrtgtestconstanttestop)\n\nSyntax:\n\n```\noperation ::= `rtgtest.constant_test` type($result) attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::Attribute | any attribute |\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `rtgtest.get_hartid` (::circt::rtgtest::GetHartIdOp)\u00a0[\u00b6](#rtgtestget_hartid-circtrtgtestgethartidop)\n\nSyntax:\n\n```\noperation ::= `rtgtest.get_hartid` $cpu attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `cpu` | handle to a specific CPU |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `hartid` | index |\n\n### `rtgtest.implicit_constraint_op` (::circt::rtgtest::ImplicitConstraintTestOp)\u00a0[\u00b6](#rtgtestimplicit_constraint_op-circtrtgtestimplicitconstrainttestop)\n\nSyntax:\n\n```\noperation ::= `rtgtest.implicit_constraint_op` (`implicit_constraint` $implicitConstraint^)? attr-dict\n```\n\nInterfaces: `ImplicitConstraintOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `implicitConstraint` | ::mlir::UnitAttr | unit attribute |\n\n### `rtgtest.rv32i.add` (::circt::rtgtest::ADD)\u00a0[\u00b6](#rtgtestrv32iadd-circtrtgtestadd)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.add` $rd `,` $rs1 `,` $rs2 attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n\n### `rtgtest.rv32i.addi` (::circt::rtgtest::ADDI)\u00a0[\u00b6](#rtgtestrv32iaddi-circtrtgtestaddi)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.addi` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.and` (::circt::rtgtest::AND)\u00a0[\u00b6](#rtgtestrv32iand-circtrtgtestand)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.and` $rd `,` $rs1 `,` $rs2 attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-3)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n\n### `rtgtest.rv32i.andi` (::circt::rtgtest::ANDI)\u00a0[\u00b6](#rtgtestrv32iandi-circtrtgtestandi)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.andi` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-4)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.auipc` (::circt::rtgtest::AUIPC)\u00a0[\u00b6](#rtgtestrv32iauipc-circtrtgtestauipc)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.auipc` $rd `,` $imm `:` type($imm) attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-5)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `imm` | a 32-bit immediate or a reference to a label |\n\n### `rtgtest.rv32i.beq` (::circt::rtgtest::BEQ)\u00a0[\u00b6](#rtgtestrv32ibeq-circtrtgtestbeq)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.beq` $rs1 `,` $rs2 `,` $imm `:` qualified(type($imm)) attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-6)\n\n| Operand | Description |\n| --- | --- |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n| `imm` | a 13-bit immediate or a reference to a label |\n\n### `rtgtest.rv32i.bge` (::circt::rtgtest::BGE)\u00a0[\u00b6](#rtgtestrv32ibge-circtrtgtestbge)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.bge` $rs1 `,` $rs2 `,` $imm `:` qualified(type($imm)) attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-7)\n\n| Operand | Description |\n| --- | --- |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n| `imm` | a 13-bit immediate or a reference to a label |\n\n### `rtgtest.rv32i.bgeu` (::circt::rtgtest::BGEU)\u00a0[\u00b6](#rtgtestrv32ibgeu-circtrtgtestbgeu)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.bgeu` $rs1 `,` $rs2 `,` $imm `:` qualified(type($imm)) attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-8)\n\n| Operand | Description |\n| --- | --- |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n| `imm` | a 13-bit immediate or a reference to a label |\n\n### `rtgtest.rv32i.blt` (::circt::rtgtest::BLT)\u00a0[\u00b6](#rtgtestrv32iblt-circtrtgtestblt)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.blt` $rs1 `,` $rs2 `,` $imm `:` qualified(type($imm)) attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-9)\n\n| Operand | Description |\n| --- | --- |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n| `imm` | a 13-bit immediate or a reference to a label |\n\n### `rtgtest.rv32i.bltu` (::circt::rtgtest::BLTU)\u00a0[\u00b6](#rtgtestrv32ibltu-circtrtgtestbltu)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.bltu` $rs1 `,` $rs2 `,` $imm `:` qualified(type($imm)) attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-10)\n\n| Operand | Description |\n| --- | --- |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n| `imm` | a 13-bit immediate or a reference to a label |\n\n### `rtgtest.rv32i.bne` (::circt::rtgtest::BNE)\u00a0[\u00b6](#rtgtestrv32ibne-circtrtgtestbne)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.bne` $rs1 `,` $rs2 `,` $imm `:` qualified(type($imm)) attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-11)\n\n| Operand | Description |\n| --- | --- |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n| `imm` | a 13-bit immediate or a reference to a label |\n\n### `rtgtest.rv32i.ebreak` (::circt::rtgtest::EBREAKOp)\u00a0[\u00b6](#rtgtestrv32iebreak-circtrtgtestebreakop)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.ebreak` attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n### `rtgtest.rv32i.ecall` (::circt::rtgtest::ECALLOp)\u00a0[\u00b6](#rtgtestrv32iecall-circtrtgtestecallop)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.ecall` attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n### `rtgtest.rv32i.jal` (::circt::rtgtest::JAL)\u00a0[\u00b6](#rtgtestrv32ijal-circtrtgtestjal)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.jal` $rd `,` $imm `:` type($imm) attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-12)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `imm` | a 21-bit immediate or a reference to a label |\n\n### `rtgtest.rv32i.jalr` (::circt::rtgtest::JALROp)\u00a0[\u00b6](#rtgtestrv32ijalr-circtrtgtestjalrop)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.jalr` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-13)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.la` (::circt::rtgtest::LA)\u00a0[\u00b6](#rtgtestrv32ila-circtrtgtestla)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.la` $rd `,` $mem `:` type($mem) attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-14)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `mem` | handle to a memory or an ISA immediate or a reference to a label |\n\n### `rtgtest.rv32i.lb` (::circt::rtgtest::LBOp)\u00a0[\u00b6](#rtgtestrv32ilb-circtrtgtestlbop)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.lb` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-15)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.lbu` (::circt::rtgtest::LBUOp)\u00a0[\u00b6](#rtgtestrv32ilbu-circtrtgtestlbuop)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.lbu` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-16)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.lh` (::circt::rtgtest::LHOp)\u00a0[\u00b6](#rtgtestrv32ilh-circtrtgtestlhop)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.lh` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-17)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.lhu` (::circt::rtgtest::LHUOp)\u00a0[\u00b6](#rtgtestrv32ilhu-circtrtgtestlhuop)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.lhu` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-18)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.lui` (::circt::rtgtest::LUI)\u00a0[\u00b6](#rtgtestrv32ilui-circtrtgtestlui)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.lui` $rd `,` $imm `:` type($imm) attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-19)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `imm` | a 32-bit immediate or a reference to a label |\n\n### `rtgtest.rv32i.lw` (::circt::rtgtest::LWOp)\u00a0[\u00b6](#rtgtestrv32ilw-circtrtgtestlwop)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.lw` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-20)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.or` (::circt::rtgtest::OR)\u00a0[\u00b6](#rtgtestrv32ior-circtrtgtestor)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.or` $rd `,` $rs1 `,` $rs2 attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-21)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n\n### `rtgtest.rv32i.ori` (::circt::rtgtest::ORI)\u00a0[\u00b6](#rtgtestrv32iori-circtrtgtestori)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.ori` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-22)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.sb` (::circt::rtgtest::SB)\u00a0[\u00b6](#rtgtestrv32isb-circtrtgtestsb)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.sb` $rs1 `,` $rs2 `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-23)\n\n| Operand | Description |\n| --- | --- |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.sh` (::circt::rtgtest::SH)\u00a0[\u00b6](#rtgtestrv32ish-circtrtgtestsh)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.sh` $rs1 `,` $rs2 `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-24)\n\n| Operand | Description |\n| --- | --- |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.sll` (::circt::rtgtest::SLL)\u00a0[\u00b6](#rtgtestrv32isll-circtrtgtestsll)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.sll` $rd `,` $rs1 `,` $rs2 attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-25)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n\n### `rtgtest.rv32i.slli` (::circt::rtgtest::SLLI)\u00a0[\u00b6](#rtgtestrv32islli-circtrtgtestslli)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.slli` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-26)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 5-bit immediate |\n\n### `rtgtest.rv32i.slt` (::circt::rtgtest::SLT)\u00a0[\u00b6](#rtgtestrv32islt-circtrtgtestslt)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.slt` $rd `,` $rs1 `,` $rs2 attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-27)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n\n### `rtgtest.rv32i.slti` (::circt::rtgtest::SLTI)\u00a0[\u00b6](#rtgtestrv32islti-circtrtgtestslti)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.slti` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-28)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.sltiu` (::circt::rtgtest::SLTIU)\u00a0[\u00b6](#rtgtestrv32isltiu-circtrtgtestsltiu)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.sltiu` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-29)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.sltu` (::circt::rtgtest::SLTU)\u00a0[\u00b6](#rtgtestrv32isltu-circtrtgtestsltu)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.sltu` $rd `,` $rs1 `,` $rs2 attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-30)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n\n### `rtgtest.rv32i.sra` (::circt::rtgtest::SRA)\u00a0[\u00b6](#rtgtestrv32isra-circtrtgtestsra)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.sra` $rd `,` $rs1 `,` $rs2 attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-31)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n\n### `rtgtest.rv32i.srai` (::circt::rtgtest::SRAI)\u00a0[\u00b6](#rtgtestrv32israi-circtrtgtestsrai)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.srai` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-32)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 5-bit immediate |\n\n### `rtgtest.rv32i.srl` (::circt::rtgtest::SRL)\u00a0[\u00b6](#rtgtestrv32isrl-circtrtgtestsrl)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.srl` $rd `,` $rs1 `,` $rs2 attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-33)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n\n### `rtgtest.rv32i.srli` (::circt::rtgtest::SRLI)\u00a0[\u00b6](#rtgtestrv32isrli-circtrtgtestsrli)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.srli` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-34)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 5-bit immediate |\n\n### `rtgtest.rv32i.sub` (::circt::rtgtest::SUB)\u00a0[\u00b6](#rtgtestrv32isub-circtrtgtestsub)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.sub` $rd `,` $rs1 `,` $rs2 attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-35)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n\n### `rtgtest.rv32i.sw` (::circt::rtgtest::SW)\u00a0[\u00b6](#rtgtestrv32isw-circtrtgtestsw)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.sw` $rs1 `,` $rs2 `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-36)\n\n| Operand | Description |\n| --- | --- |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\n### `rtgtest.rv32i.xor` (::circt::rtgtest::XOR)\u00a0[\u00b6](#rtgtestrv32ixor-circtrtgtestxor)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.xor` $rd `,` $rs1 `,` $rs2 attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-37)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs1` | represents an integer register |\n| `rs2` | represents an integer register |\n\n### `rtgtest.rv32i.xori` (::circt::rtgtest::XORI)\u00a0[\u00b6](#rtgtestrv32ixori-circtrtgtestxori)\n\nSyntax:\n\n```\noperation ::= `rtgtest.rv32i.xori` $rd `,` $rs `,` $imm attr-dict\n```\n\nTraits: `InstructionOpAdaptorTrait`\n\nInterfaces: `InstructionOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-38)\n\n| Operand | Description |\n| --- | --- |\n| `rd` | represents an integer register |\n| `rs` | represents an integer register |\n| `imm` | a 12-bit immediate |\n\nAttributes\u00a0[\u00b6](#attributes-2)\n-----------------------------\n\n### CPUAttr\u00a0[\u00b6](#cpuattr)\n\n*This attribute represents a CPU referred to by the core ID*\n\nSyntax:\n\n```\n#rtgtest.cpu<\n  size_t   # id\n>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| id | `size_t` |  |\n\n### RegA0Attr\u00a0[\u00b6](#rega0attr)\n\nSyntax: `#rtgtest.a0`\n\n### RegA1Attr\u00a0[\u00b6](#rega1attr)\n\nSyntax: `#rtgtest.a1`\n\n### RegA2Attr\u00a0[\u00b6](#rega2attr)\n\nSyntax: `#rtgtest.a2`\n\n### RegA3Attr\u00a0[\u00b6](#rega3attr)\n\nSyntax: `#rtgtest.a3`\n\n### RegA4Attr\u00a0[\u00b6](#rega4attr)\n\nSyntax: `#rtgtest.a4`\n\n### RegA5Attr\u00a0[\u00b6](#rega5attr)\n\nSyntax: `#rtgtest.a5`\n\n### RegA6Attr\u00a0[\u00b6](#rega6attr)\n\nSyntax: `#rtgtest.a6`\n\n### RegA7Attr\u00a0[\u00b6](#rega7attr)\n\nSyntax: `#rtgtest.a7`\n\n### RegF0Attr\u00a0[\u00b6](#regf0attr)\n\nSyntax: `#rtgtest.f0`\n\n### RegGpAttr\u00a0[\u00b6](#reggpattr)\n\nSyntax: `#rtgtest.gp`\n\n### RegRaAttr\u00a0[\u00b6](#regraattr)\n\nSyntax: `#rtgtest.ra`\n\n### RegS0Attr\u00a0[\u00b6](#regs0attr)\n\nSyntax: `#rtgtest.s0`\n\n### RegS1Attr\u00a0[\u00b6](#regs1attr)\n\nSyntax: `#rtgtest.s1`\n\n### RegS2Attr\u00a0[\u00b6](#regs2attr)\n\nSyntax: `#rtgtest.s2`\n\n### RegS3Attr\u00a0[\u00b6](#regs3attr)\n\nSyntax: `#rtgtest.s3`\n\n### RegS4Attr\u00a0[\u00b6](#regs4attr)\n\nSyntax: `#rtgtest.s4`\n\n### RegS5Attr\u00a0[\u00b6](#regs5attr)\n\nSyntax: `#rtgtest.s5`\n\n### RegS6Attr\u00a0[\u00b6](#regs6attr)\n\nSyntax: `#rtgtest.s6`\n\n### RegS7Attr\u00a0[\u00b6](#regs7attr)\n\nSyntax: `#rtgtest.s7`\n\n### RegS8Attr\u00a0[\u00b6](#regs8attr)\n\nSyntax: `#rtgtest.s8`\n\n### RegS9Attr\u00a0[\u00b6](#regs9attr)\n\nSyntax: `#rtgtest.s9`\n\n### RegS10Attr\u00a0[\u00b6](#regs10attr)\n\nSyntax: `#rtgtest.s10`\n\n### RegS11Attr\u00a0[\u00b6](#regs11attr)\n\nSyntax: `#rtgtest.s11`\n\n### RegSpAttr\u00a0[\u00b6](#regspattr)\n\nSyntax: `#rtgtest.sp`\n\n### RegT0Attr\u00a0[\u00b6](#regt0attr)\n\nSyntax: `#rtgtest.t0`\n\n### RegT1Attr\u00a0[\u00b6](#regt1attr)\n\nSyntax: `#rtgtest.t1`\n\n### RegT2Attr\u00a0[\u00b6](#regt2attr)\n\nSyntax: `#rtgtest.t2`\n\n### RegT3Attr\u00a0[\u00b6](#regt3attr)\n\nSyntax: `#rtgtest.t3`\n\n### RegT4Attr\u00a0[\u00b6](#regt4attr)\n\nSyntax: `#rtgtest.t4`\n\n### RegT5Attr\u00a0[\u00b6](#regt5attr)\n\nSyntax: `#rtgtest.t5`\n\n### RegT6Attr\u00a0[\u00b6](#regt6attr)\n\nSyntax: `#rtgtest.t6`\n\n### RegTpAttr\u00a0[\u00b6](#regtpattr)\n\nSyntax: `#rtgtest.tp`\n\n### RegZeroAttr\u00a0[\u00b6](#regzeroattr)\n\nSyntax: `#rtgtest.zero`\n\nTypes\u00a0[\u00b6](#types)\n-----------------\n\n### CPUType\u00a0[\u00b6](#cputype)\n\n*Handle to a specific CPU*\n\nSyntax: `!rtgtest.cpu`\n\nThis type implements a specific context resource to test RTG operations\ntaking context resources as operands (such as `on_context`) and other things\nrequiring a concrete instance of a `ContextResourceTypeInterface`.\n\n### FloatRegisterType\u00a0[\u00b6](#floatregistertype)\n\n*Represents a floating-point register*\n\nSyntax: `!rtgtest.freg`\n\n### IntegerRegisterType\u00a0[\u00b6](#integerregistertype)\n\n*Represents an integer register*\n\nSyntax: `!rtgtest.ireg`\n\n [Prev - Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/ \"Pipeline Dialect Rationale\")\n[Next - 'seq' Dialect](https://circt.llvm.org/docs/Dialects/Seq/ \"'seq' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Seq/index.md"
  },
  {
    "role": "user",
    "content": "'seq' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'seq' Dialect\n=============\n\n*Types and operations for seq dialect*\n\nThe `seq` dialect is intended to model digital sequential logic.\n\n* [Operations](#operations)\n  + [`seq.clock_div` (::circt::seq::ClockDividerOp)](#seqclock_div-circtseqclockdividerop)\n  + [`seq.clock_gate` (::circt::seq::ClockGateOp)](#seqclock_gate-circtseqclockgateop)\n  + [`seq.clock_inv` (::circt::seq::ClockInverterOp)](#seqclock_inv-circtseqclockinverterop)\n  + [`seq.clock_mux` (::circt::seq::ClockMuxOp)](#seqclock_mux-circtseqclockmuxop)\n  + [`seq.compreg` (::circt::seq::CompRegOp)](#seqcompreg-circtseqcompregop)\n  + [`seq.compreg.ce` (::circt::seq::CompRegClockEnabledOp)](#seqcompregce-circtseqcompregclockenabledop)\n  + [`seq.const_clock` (::circt::seq::ConstClockOp)](#seqconst_clock-circtseqconstclockop)\n  + [`seq.fifo` (::circt::seq::FIFOOp)](#seqfifo-circtseqfifoop)\n  + [`seq.firmem` (::circt::seq::FirMemOp)](#seqfirmem-circtseqfirmemop)\n  + [`seq.firmem.read_port` (::circt::seq::FirMemReadOp)](#seqfirmemread_port-circtseqfirmemreadop)\n  + [`seq.firmem.read_write_port` (::circt::seq::FirMemReadWriteOp)](#seqfirmemread_write_port-circtseqfirmemreadwriteop)\n  + [`seq.firmem.write_port` (::circt::seq::FirMemWriteOp)](#seqfirmemwrite_port-circtseqfirmemwriteop)\n  + [`seq.firreg` (::circt::seq::FirRegOp)](#seqfirreg-circtseqfirregop)\n  + [`seq.from_clock` (::circt::seq::FromClockOp)](#seqfrom_clock-circtseqfromclockop)\n  + [`seq.from_immutable` (::circt::seq::FromImmutableOp)](#seqfrom_immutable-circtseqfromimmutableop)\n  + [`seq.hlmem` (::circt::seq::HLMemOp)](#seqhlmem-circtseqhlmemop)\n  + [`seq.initial` (::circt::seq::InitialOp)](#seqinitial-circtseqinitialop)\n  + [`seq.read` (::circt::seq::ReadPortOp)](#seqread-circtseqreadportop)\n  + [`seq.shiftreg` (::circt::seq::ShiftRegOp)](#seqshiftreg-circtseqshiftregop)\n  + [`seq.to_clock` (::circt::seq::ToClockOp)](#seqto_clock-circtseqtoclockop)\n  + [`seq.write` (::circt::seq::WritePortOp)](#seqwrite-circtseqwriteportop)\n  + [`seq.yield` (::circt::seq::YieldOp)](#seqyield-circtseqyieldop)\n* [Attributes](#attributes-12)\n  + [ClockConstAttr](#clockconstattr)\n  + [FirMemInitAttr](#firmeminitattr)\n* [Type constraints](#type-constraints)\n  + [an ImmutableType](#an-immutabletype)\n* [Types](#types)\n  + [ClockType](#clocktype)\n  + [FirMemType](#firmemtype)\n  + [HLMemType](#hlmemtype)\n  + [ImmutableType](#immutabletype)\n* [Enums](#enums)\n  + [ClockConst](#clockconst)\n  + [RUW](#ruw)\n  + [WUW](#wuw)\n\nOperations\n----------\n\n### `seq.clock_div` (::circt::seq::ClockDividerOp)\n\n*Produces a clock divided by a power of two*\n\nSyntax:\n\n```\noperation ::= `seq.clock_div` $input `by` $pow2 attr-dict\n```\n\nThe output clock is phase-aligned to the input clock.\n\n```\n%div_clock = seq.clock_div %clock by 1\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `pow2` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | A type for clock-carrying wires |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | A type for clock-carrying wires |\n\n### `seq.clock_gate` (::circt::seq::ClockGateOp)\n\n*Safely gates a clock with an enable signal*\n\nSyntax:\n\n```\noperation ::= `seq.clock_gate` $input `,` $enable (`,` $test_enable^)? (`sym` $inner_sym^)? attr-dict\n```\n\nThe `seq.clock_gate` enables and disables a clock safely, without glitches,\nbased on a boolean enable value. If the enable operand is 1, the output\nclock produced by the clock gate is identical to the input clock. If the\nenable operand is 0, the output clock is a constant zero.\n\nThe `enable` operand is sampled at the rising edge of the input clock; any\nchanges on the enable before or after that edge are ignored and do not\naffect the output clock.\n\nThe `test_enable` operand is optional and if present is OR\u2019d together with\nthe `enable` operand to determine whether the output clock is gated or not.\n\nThe op can be referred to using an inner symbol. Upon translation, the\nsymbol will target the instance to the external module it lowers to.\n\n```\n%gatedClock = seq.clock_gate %clock, %enable\n%gatedClock = seq.clock_gate %clock, %enable, %test_enable\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `InnerSymbolOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | A type for clock-carrying wires |\n| `enable` | 1-bit signless integer |\n| `test_enable` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | A type for clock-carrying wires |\n\n### `seq.clock_inv` (::circt::seq::ClockInverterOp)\n\n*Inverts the clock signal*\n\nSyntax:\n\n```\noperation ::= `seq.clock_inv` $input attr-dict\n```\n\nNote that the compiler can optimize inverters away, preventing their\nuse as part of explicit clock buffers.\n\n```\n%inv_clock = seq.clock_inv %clock\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | A type for clock-carrying wires |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | A type for clock-carrying wires |\n\n### `seq.clock_mux` (::circt::seq::ClockMuxOp)\n\n*Safely selects a clock based on a condition*\n\nSyntax:\n\n```\noperation ::= `seq.clock_mux` $cond `,` $trueClock `,` $falseClock attr-dict\n```\n\nThe `seq.clock_mux` op selects a clock from two options. If `cond` is\ntrue, the first clock operand is selected to drive downstream logic.\nOtherwise, the second clock is used.\n\n```\n%clock = seq.clock_mux %cond, %trueClock, %falseClock\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `cond` | 1-bit signless integer |\n| `trueClock` | A type for clock-carrying wires |\n| `falseClock` | A type for clock-carrying wires |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A type for clock-carrying wires |\n\n### `seq.compreg` (::circt::seq::CompRegOp)\n\n*Register a value, storing it for one cycle*\n\nSyntax:\n\n```\noperation ::= `seq.compreg` (`sym` $inner_sym^)? `` custom<ImplicitSSAName>($name) $input `,` $clk\n              (`reset` $reset^ `,` $resetValue)?\n              (`initial` $initialValue^)? attr-dict `:` type($data)\n              custom<OptionalTypeMatch>(ref(type($data)), ref($resetValue), type($resetValue))\n              custom<OptionalImmutableTypeMatch>(ref(type($data)), ref($initialValue), type($initialValue))\n```\n\nSee the Seq dialect rationale for a longer description\n\nTraits: `AlwaysSpeculatableImplTrait`, `AttrSizedOperandSegments`\n\nInterfaces: `Clocked`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `InnerSymbolOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `OpAsmOpInterface`, `Resettable`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | any type |\n| `clk` | A type for clock-carrying wires |\n| `reset` | 1-bit signless integer |\n| `resetValue` | any type |\n| `initialValue` | an ImmutableType |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `data` | any type |\n\n### `seq.compreg.ce` (::circt::seq::CompRegClockEnabledOp)\n\n*When enabled, register a value*\n\nSyntax:\n\n```\noperation ::= `seq.compreg.ce` (`sym` $inner_sym^)? `` custom<ImplicitSSAName>($name) $input `,` $clk `,` $clockEnable\n              (`reset` $reset^ `,` $resetValue)?\n              (`initial` $initialValue^)? attr-dict `:` type($data)\n              custom<OptionalTypeMatch>(ref(type($data)), ref($resetValue), type($resetValue))\n              custom<OptionalImmutableTypeMatch>(ref(type($data)), ref($initialValue), type($initialValue))\n```\n\nSee the Seq dialect rationale for a longer description\n\nTraits: `AlwaysSpeculatableImplTrait`, `AttrSizedOperandSegments`\n\nInterfaces: `Clocked`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `InnerSymbolOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `OpAsmOpInterface`, `Resettable`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | any type |\n| `clk` | A type for clock-carrying wires |\n| `clockEnable` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `resetValue` | any type |\n| `initialValue` | an ImmutableType |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `data` | any type |\n\n### `seq.const_clock` (::circt::seq::ConstClockOp)\n\n*Produce constant clock value*\n\nSyntax:\n\n```\noperation ::= `seq.const_clock` $value attr-dict\n```\n\nThe constant operation produces a constant clock value.\n\n```\n  %clock = seq.const_clock low\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::circt::seq::ClockConstAttr | clock constant |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | A type for clock-carrying wires |\n\n### `seq.fifo` (::circt::seq::FIFOOp)\n\n*A high-level FIFO operation*\n\nSyntax:\n\n```\noperation ::= `seq.fifo` `depth` $depth\n              (`rd_latency` $rdLatency^)?\n              custom<FIFOAFThreshold>($almostFullThreshold, type($almostFull))\n              custom<FIFOAEThreshold>($almostEmptyThreshold, type($almostEmpty))\n              `in` $input `rdEn` $rdEn `wrEn` $wrEn `clk` $clk `rst` $rst attr-dict `:` type($input)\n```\n\nThis operation represents a high-level abstraction of a FIFO. Access to the\nFIFO is structural, and thus may be composed with other core RTL dialect\noperations.\nThe fifo operation is configurable with the following parameters:\n\n1. Depth (cycles)\n2. Read latency (cycles) is the number of cycles it takes for a read to\n   return data after the read enable signal is asserted.\n3. Almost full/empty thresholds (optional). If not provided, these will\n   be asserted when the FIFO is full/empty.\n\nLike `seq.hlmem` there are no guarantees that all possible fifo configuration\nare able to be lowered. Available lowering passes will pattern match on the\nrequested fifo configuration and attempt to provide a legal lowering.\n\nTraits: `AttrSizedResultSegments`\n\nInterfaces: `OpAsmOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `depth` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n| `rdLatency` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 0 |\n| `almostFullThreshold` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 0 |\n| `almostEmptyThreshold` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 0 |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | any type |\n| `rdEn` | 1-bit signless integer |\n| `wrEn` | 1-bit signless integer |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | any type |\n| `full` | 1-bit signless integer |\n| `empty` | 1-bit signless integer |\n| `almostFull` | 1-bit signless integer |\n| `almostEmpty` | 1-bit signless integer |\n\n### `seq.firmem` (::circt::seq::FirMemOp)\n\n*A FIRRTL-flavored memory*\n\nSyntax:\n\n```\noperation ::= `seq.firmem` (`sym` $inner_sym^)? `` custom<ImplicitSSAName>($name)\n              $readLatency `,` $writeLatency `,` $ruw `,` $wuw\n              attr-dict `:` type($memory)\n```\n\nThe `seq.firmem` op represents memories lowered from the FIRRTL dialect. It\nis used to capture some of the peculiarities of what FIRRTL expects from\nmemories, while still representing them at the HW dialect level.\n\nA `seq.firmem` declares the memory and captures the memory-level parameters\nsuch as width and depth or how read/write collisions are resolved. The read,\nwrite, and read-write ports are expressed as separate operations that take\nthe declared memory as an operand.\n\nInterfaces: `InnerSymbolOpInterface`, `MemoryEffectOpInterface (MemoryEffectOpInterface)`, `OpAsmOpInterface`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `readLatency` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `writeLatency` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `ruw` | circt::seq::RUWAttr | Read-Under-Write Behavior |\n| `wuw` | circt::seq::WUWAttr | Write-Under-Write Behavior |\n| `name` | ::mlir::StringAttr | string attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `init` | ::circt::seq::FirMemInitAttr | Memory initialization information |\n| `prefix` | ::mlir::StringAttr | string attribute |\n| `output_file` | ::mlir::Attribute | any attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `memory` | A FIRRTL-flavored memory |\n\n### `seq.firmem.read_port` (::circt::seq::FirMemReadOp)\n\n*A memory read port*\n\nSyntax:\n\n```\noperation ::= `seq.firmem.read_port` $memory `[` $address `]` `,` `clock` $clk\n              (`enable` $enable^)?\n              attr-dict `:` type($memory)\n```\n\nThe `seq.firmem.read_port` op represents a read port on a `seq.firmem`\nmemory. It takes the memory as an operand, together with the address to\nbe read, the clock on which the read is synchronized, and an optional\nenable. Omitting the enable operand has the same effect as passing a\nconstant `true` to it.\n\nInterfaces: `Clocked`, `InferTypeOpInterface`, `MemoryEffectOpInterface (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `memory` | A FIRRTL-flavored memory |\n| `address` | signless integer |\n| `clk` | A type for clock-carrying wires |\n| `enable` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `data` | signless integer |\n\n### `seq.firmem.read_write_port` (::circt::seq::FirMemReadWriteOp)\n\n*A memory read-write port*\n\nSyntax:\n\n```\noperation ::= `seq.firmem.read_write_port` $memory `[` $address `]` `=` $writeData `if` $mode `,` `clock` $clk\n              (`enable` $enable^)? (`mask` $mask^)?\n              attr-dict `:` type($memory) (`,` type($mask)^)?\n```\n\nThe `seq.firmem.read_write_port` op represents a read-write port on a\n`seq.firmem` memory. It takes the memory as an operand, together with the\naddress and data to be written, a mode operand indicating whether the port\nshould perform a read (`mode=0`) or a write (`mode=1`), the clock on which\nthe read and write is synchronized, an optional enable, and and optional\nwrite mask. Omitting the enable operand has the same effect as passing a\nconstant `true` to it. Omitting the write mask operand has the same effect\nas passing an all-ones value to it. A write mask operand can only be present\nif the `seq.firmem` specifies a mask width; otherwise it must be omitted.\n\nTraits: `AttrSizedOperandSegments`\n\nInterfaces: `Clocked`, `InferTypeOpInterface`, `MemoryEffectOpInterface (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource, MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `memory` | A FIRRTL-flavored memory |\n| `address` | signless integer |\n| `clk` | A type for clock-carrying wires |\n| `enable` | 1-bit signless integer |\n| `writeData` | signless integer |\n| `mode` | 1-bit signless integer |\n| `mask` | signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `readData` | signless integer |\n\n### `seq.firmem.write_port` (::circt::seq::FirMemWriteOp)\n\n*A memory write port*\n\nSyntax:\n\n```\noperation ::= `seq.firmem.write_port` $memory `[` $address `]` `=` $data `,` `clock` $clk\n              (`enable` $enable^)? (`mask` $mask^)?\n              attr-dict `:` type($memory) (`,` type($mask)^)?\n```\n\nThe `seq.firmem.write_port` op represents a write port on a `seq.firmem`\nmemory. It takes the memory as an operand, together with the address and\ndata to be written, the clock on which the write is synchronized, an\noptional enable, and and optional write mask. Omitting the enable operand\nhas the same effect as passing a constant `true` to it. Omitting the write\nmask operand has the same effect as passing an all-ones value to it. A write\nmask operand can only be present if the `seq.firmem` specifies a mask width;\notherwise it must be omitted.\n\nTraits: `AttrSizedOperandSegments`\n\nInterfaces: `Clocked`, `MemoryEffectOpInterface (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `memory` | A FIRRTL-flavored memory |\n| `address` | signless integer |\n| `clk` | A type for clock-carrying wires |\n| `enable` | 1-bit signless integer |\n| `data` | signless integer |\n| `mask` | signless integer |\n\n### `seq.firreg` (::circt::seq::FirRegOp)\n\n*Register with preset and sync or async reset*\n\n`firreg` represents registers originating from FIRRTL after the lowering\nof the IR to HW. The register is used as an intermediary in the process\nof lowering to SystemVerilog to facilitate optimisation at the HW level,\ncompactly representing a register with a single operation instead of\ncomposing it from register definitions, always blocks and if statements.\n\nThe `data` output of the register accesses the value it stores. On the\nrising edge of the `clk` input, the register takes a new value provided\nby the `next` signal. Optionally, the register can also be provided with\na synchronous or an asynchronous `reset` signal and `resetValue`, as shown\nin the example below.\n\n```\n%name = seq.firreg %next clock %clk [ sym @sym ]\n    [ reset (sync|async) %reset, %value ]\n    [ preset value ] : type\n```\n\nImplicitly, all registers are pre-set to a randomized value.\n\nA register implementing a counter starting at 0 from reset can be defined\nas follows:\n\n```\n%zero = hw.constant 0 : i32\n%reg = seq.firreg %next clock %clk reset sync %reset, %zero : i32\n%one = hw.constant 1 : i32\n%next = comb.add %reg, %one : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameVariadicOperandSize`\n\nInterfaces: `Clocked`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `InnerSymbolOpInterface`, `MemoryEffectOpInterface (MemoryEffectOpInterface)`, `NoMemoryEffect (MemoryEffectOpInterface)`, `OpAsmOpInterface`, `Resettable`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource, MemoryEffects::Read on ::mlir::SideEffects::DefaultResource, MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}`, `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `preset` | ::mlir::IntegerAttr | arbitrary integer attribute |\n| `isAsync` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `next` | any type |\n| `clk` | A type for clock-carrying wires |\n| `reset` | 1-bit signless integer |\n| `resetValue` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `data` | any type |\n\n### `seq.from_clock` (::circt::seq::FromClockOp)\n\n*Cast from a clock type to a wire type*\n\nSyntax:\n\n```\noperation ::= `seq.from_clock` $input attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | A type for clock-carrying wires |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | 1-bit signless integer |\n\n### `seq.from_immutable` (::circt::seq::FromImmutableOp)\n\n*Cast from an immutable type to a wire type*\n\nSyntax:\n\n```\noperation ::= `seq.from_immutable` $input attr-dict `:` functional-type(operands, results)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an ImmutableType |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | any type |\n\n### `seq.hlmem` (::circt::seq::HLMemOp)\n\n*Instantiate a high-level memory.*\n\nSyntax:\n\n```\noperation ::= `seq.hlmem` $name $clk `,` $rst attr-dict `:` type($handle)\n```\n\nSee the Seq dialect rationale for a longer description\n\nInterfaces: `Clocked`, `OpAsmOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clk` | A type for clock-carrying wires |\n| `rst` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `handle` | Multi-dimensional memory type |\n\n### `seq.initial` (::circt::seq::InitialOp)\n\n*Operation that produces values for initialization*\n\nSyntax:\n\n```\noperation ::= `seq.initial` `(` $inputs `)` $body attr-dict `:` functional-type($inputs, results)\n```\n\n`seq.initial` op creates values wrapped types with !seq.immutable.\nSee the Seq dialect rationale for a longer description.\n\nTraits: `IsolatedFromAbove`, `RecursiveMemoryEffects`, `RecursivelySpeculatableImplTrait`, `SingleBlockImplicitTerminator<YieldOp>`, `SingleBlock`\n\nInterfaces: `ConditionallySpeculatable`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of an ImmutableType |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| \u00abunnamed\u00bb | variadic of an ImmutableType |\n\n### `seq.read` (::circt::seq::ReadPortOp)\n\n*Structural read access to a seq.hlmem, with an optional read enable signal.*\n\nTraits: `AttrSizedOperandSegments`\n\nInterfaces: `OpAsmOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `latency` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `memory` | Multi-dimensional memory type |\n| `addresses` | variadic of a signless integer bitvector |\n| `rdEn` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `readData` | any type |\n\n### `seq.shiftreg` (::circt::seq::ShiftRegOp)\n\n*Shift register*\n\nSyntax:\n\n```\noperation ::= `seq.shiftreg` `[` $numElements `]`\n              (`sym` $inner_sym^)? `` custom<ImplicitSSAName>($name) $input `,` $clk `,` $clockEnable\n              (`reset` $reset^ `,` $resetValue)?\n              (`powerOn` $powerOnValue^)? attr-dict `:` type($data)\n              custom<OptionalTypeMatch>(ref(type($data)), ref($resetValue), type($resetValue))\n              custom<OptionalTypeMatch>(ref(type($data)), ref($powerOnValue), type($powerOnValue))\n```\n\nThe `seq.shiftreg` op represents a shift register. It takes the input\nvalue and shifts it every cycle when `clockEnable` is asserted.\nThe `reset` and `resetValue` operands are optional and if present, every\nentry in the shift register will be initialized to `resetValue` upon\nassertion of the reset signal. Exact reset behavior (sync/async) is\nimplementation defined.\n\nTraits: `AlwaysSpeculatableImplTrait`, `AttrSizedOperandSegments`\n\nInterfaces: `Clocked`, `ConditionallySpeculatable`, `InferTypeOpInterface`, `InnerSymbolOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `OpAsmOpInterface`, `Resettable`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `numElements` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 1 |\n| `name` | ::mlir::StringAttr | string attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | any type |\n| `clk` | A type for clock-carrying wires |\n| `clockEnable` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n| `resetValue` | any type |\n| `powerOnValue` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `data` | any type |\n\n### `seq.to_clock` (::circt::seq::ToClockOp)\n\n*Cast from a wire type to a clock type*\n\nSyntax:\n\n```\noperation ::= `seq.to_clock` $input attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit signless integer |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `output` | A type for clock-carrying wires |\n\n### `seq.write` (::circt::seq::WritePortOp)\n\n*Structural write access to a seq.hlmem*\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `latency` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `memory` | Multi-dimensional memory type |\n| `addresses` | variadic of a signless integer bitvector |\n| `inData` | any type |\n| `wrEn` | 1-bit signless integer |\n\n### `seq.yield` (::circt::seq::YieldOp)\n\n*Yield values*\n\nSyntax:\n\n```\noperation ::= `seq.yield` attr-dict ($operands^ `:` type($operands))?\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<InitialOp>`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operands` | variadic of any type |\n\nAttributes\n----------\n\n### ClockConstAttr\n\n*Clock constant*\n\nSyntax:\n\n```\n#seq.clock_constant<\n  circt::seq::ClockConst   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `circt::seq::ClockConst` | an enum of type ClockConst |\n\n### FirMemInitAttr\n\n*Memory initialization information*\n\nSyntax:\n\n```\n#seq.firmem.init<\n  mlir::StringAttr,   # filename\n  bool,   # isBinary\n  bool   # isInline\n>\n```\n\nThis attribute captures what the initial contents of a memory should be.\nAt the moment this is modeled primarily with simulation in mind, where the\nmemory contents are pre-loaded from a file at simulation startup.\n\nThe `filename` specifies a file on disk that contains the initial contents\nfor this memory. If `isBinary` is set, the file is interpreted as a binary\nfile, otherwise it is treated as hexadecimal. This is modeled after the\n`$readmemh` and `$readmemb` SystemVerilog functions. If `isInline` is set,\nthe initialization is emitted directly in the memory model; otherwise it is\nsplit out into a separate module that can be bound in.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| filename | `mlir::StringAttr` |  |\n| isBinary | `bool` |  |\n| isInline | `bool` |  |\n\nType constraints\n----------------\n\n### an ImmutableType\n\nTypes\n-----\n\n### ClockType\n\n*A type for clock-carrying wires*\n\nSyntax: `!seq.clock`\n\nThe `!seq.clock` type represents signals which can be used to drive the\nclock input of sequential operations.\n\n### FirMemType\n\n*A FIRRTL-flavored memory*\n\nSyntax:\n\n```\n!seq.firmem<\n  uint64_t,   # depth\n  uint32_t,   # width\n  std::optional<uint32_t>   # maskWidth\n>\n```\n\nThe `!seq.firmem` type represents a FIRRTL-flavored memory declared by a\n`seq.firmem` operation. It captures the parameters of the memory that are\nrelevant to the read, write, and read-write ports, such as width and depth.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| depth | `uint64_t` |  |\n| width | `uint32_t` |  |\n| maskWidth | `std::optional<uint32_t>` |  |\n\n### HLMemType\n\n*Multi-dimensional memory type*\n\nSyntax:\n\n```\nhlmem-type ::== `hlmem` `<` dim-list element-type `>`\n```\n\nThe HLMemType represents the type of an addressable memory structure. The\ntype is inherently multidimensional. Dimensions must be known integer values.\n\nNote: unidimensional memories are represented as <1x{element type}> -\n<{element type}> is illegal.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| shape | `::llvm::ArrayRef<int64_t>` |  |\n| elementType | `Type` |  |\n\n### ImmutableType\n\n*Value type that is immutable after initialization*\n\nSyntax:\n\n```\n!seq.immutable<\n  ::mlir::Type   # innerType\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| innerType | `::mlir::Type` |  |\n\nEnums\n-----\n\n### ClockConst\n\n*Clock constant*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Low | `0` | low |\n| High | `1` | high |\n\n### RUW\n\n*Read-Under-Write Behavior*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Undefined | `0` | undefined |\n| Old | `1` | old |\n| New | `2` | new |\n\n### WUW\n\n*Write-Under-Write Behavior*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Undefined | `0` | undefined |\n| PortOrder | `1` | port\\_order |\n\n'seq' Dialect Docs\n------------------\n\n* [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n\n [Prev - 'rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/ \"'rtgtest' Dialect\")\n[Next - Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/ \"Seq(uential) Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Seq/RationaleSeq/index.md"
  },
  {
    "role": "user",
    "content": "Seq(uential) Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nSeq(uential) Dialect Rationale\n==============================\n\nThis document describes various design points of the `seq` dialect, why it is\nthe way it is, and current status. This follows in the spirit of other\n[MLIR\nRationale docs](https://mlir.llvm.org/docs/Rationale/).\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\nDigital logic is generally split into two categories: combinational and\nsequential. CIRCT contains a `comb` dialect to model the basic combinational\noperations and the (future) `seq` dialect which is discussed here. The\nintention of the `seq` dialect is to provide a set of stateful constructs\nwhich can be used to model sequential logic, independent of the output method\n(e.g. SystemVerilog).\n\nDefinitions\u00a0[\u00b6](#definitions)\n-----------------------------\n\nFor the sake of precision, we use the following definitions:\n\n* Physical devices:\n  + **Unclocked Latch:** A memory element which is only sensitive to the\n    levels of its inputs. Has no clock. Example: SR Latch.\n  + Clocked (gated) **latch:** A latch wherein the inputs are gated by a\n    clock. Transparent the entire time the clock is high. Generally referred to\n    as a \u201clatch\u201d. Examples: \u201cgated SR latch\u201d, \u201cD latch\u201d.\n  + Edge-triggered **flip-flop:** An edge-sensitive memory element. Captures\n    the input value on one or both clock edges. Variants: posedge FF, negedge\n    FF, \u201cedge-sensitive\u201d FF (captures the input value on both edges),\n    resettable FF.\n* Abstract models:\n  + **Register:** A synchronous, resettable memory element. Can be\n    implemented using any of the above \u201ccircuit level\u201d elements.\n\nThe computational register operation\u00a0[\u00b6](#the-computational-register-operation)\n-------------------------------------------------------------------------------\n\nThe `seq.compreg` op models an abstract notion of a \u201cregister\u201d, independent\nof its implementation (e.g. latch, D flip-flop). This specific register op is\nintended to support \u201ccomputation support\u201d or \u201creset-agnostic code\u201d and thus\nit cannot be used to model all the behaviors of a SystemVerilog register.\n(E.g. FSM and pipeline registers.) It is intended to be \u2019lowered\u2019 to a\nspecific implementation, which may be an `sv.always_ff` block, a device\nprimitive instantiation, or even a feedback loop in all `comb` logic.\n\nOur intention is to allow analysis and optimization of sequential logic\nwithout having to reason about implementation-specific behavior. This makes\nit somewhat distinct from the SystemVerilog register wherein one has to\naccount for details like reset behavior and implementation (latch vs.\nflip-flop).\n\n`CompReg` has four operands:\n\n* **input**: The value to be captured at \u2018clock\u2019. Generally called \u2019d\u2019.\n  Accepts any type, results in the same type. Does not support any notion of\n  addressing, meaning that this operation sets / reads the entire value.\n* **clock**: Capture \u2018value\u2019 on the positive edge of this signal.\n* **reset**: Signal to set the state to \u2018resetValue\u2019. Optional.\n* **resetValue**: A value which the state is set to upon reset. Required iff\n  \u2018reset\u2019 is present.\n* **initialValue**: An initial value for registers. This represents a system power-on value in FPGA.\n* **name**: A name for the register, defaults to `\"\"`. Inferred from the textual\n  SSA value name, or passed explicitly in builder APIs. The name will be passed to\n  the `sv.reg` during lowering.\n* **innerSym**: An optional symbol to refer to the register. The symbol will be\n  passed to the `sv.reg` during lowering if present.\n\n```\n%q = seq.compreg %input, %clk [ reset %reset, %resetValue ] [initial %initial] : $type(input)\n```\n\nUpon initialization, the state is defined to be uninitialized.\n\n### Variant: `seq.compreg.ce`\u00a0[\u00b6](#variant-seqcompregce)\n\nThis op is a version of compreg with the addition of a clock enable signal.\nHaving the clock enable explicit (instead of a mux feeding it) is convenient for\nmapping to SV behavioral and will be (in the future) easier to map to device\nprimitives or standard cells.\n\n### Rationale\u00a0[\u00b6](#rationale)\n\nSeveral design decisions were made in defining this op. Mostly, they were\nmade to simplify it while still providing the common case. Providing support\nfor all flavors of registers is an anti-goal of this op. If an omitted\nfeature is needed, it can be added or (if not common or precludes\noptimization) another op could be added.\n\n* Logical features:\n\n  + Inclusion of optional \u2018reset\u2019 signal: This operand makes lowering to an\n    efficient implementation of reset easier. Omission of it would require some\n    (potentially complex) analysis to find the reset mux if required\n  + Inclusion of \u2018resetValue\u2019: if we have a \u2018reset\u2019 signal, we need to\n    include a value.\n* Timing / clocking:\n\n  + Omission of \u2019negedge\u2019 event on \u2018clock\u2019: this is easily modeled by\n    inverting the clock value.\n  + Omission of \u2018dual edge\u2019 event on \u2018clock\u2019: this is not expected to be\n    terribly common.\n  + Omission of edge conditions on \u2018reset\u2019: Since this op specifically\n    targets \u201creset-agnostic code\u201d, the reset style shouldn\u2019t affect logical\n    correctness. It should, therefore, be determined by a lowering pass.\n\nThe FIRRTL register operation [Provisional]\u00a0[\u00b6](#the-firrtl-register-operation-provisional)\n-------------------------------------------------------------------------------------------\n\nThe `seq.firreg` carries all the information required to represent a FIRRTL\nregister and lower it to SystemVerilog.\n\n`FirReg` has the following operands:\n\n* **input**: Value to set the register to on the positive edge of the clock\n  signal.\n* **clk**: Clock signal driving the register.\n* **name**: A name for the register, passed directly to the `sv.reg`.\n* **inner\\_sym**: A optional symbol for the register, passed directly to the\n  `sv.reg`. Is a symbol is not specified and the register is randomised, one is\n  created during the lowering to SV. Registers without symbols can be removed\n  from the design.\n* **reset**: Signal to trigger the reset.\n* **resetValue**: A value which is set upon reset. Must be a constant if the\n  reset is asynchronous.\n* **isAsync**: Optional boolean flag indicating whether the reset is\n  asynchronous.\n* **preset**: Optional attribute specifying a preset value. If no preset\n  attribute is present, the register is random-initialized.\n\n```\n%reg = seq.firreg %input clock %clk [ sym @sym ]\n    [ reset (sync|async) %reset, %value ]\n    [ preset value ] : $type(input)\n```\n\nExamples of registers:\n\n```\n%reg_no_reset = seq.firreg %input clock %clk sym @sym : i32\n\n%reg_sync_reset_rand  = seq.firreg %input clock %clk sym @sym\n    reset sync %reset, %value : i64\n\n%reg_async_reset = seq.firreg %input clock %clk sym @sym\n    reset async %reset, %value : i1f\n\n%reg_preset = seq.firreg %next clock %clock preset 123 : i32\n```\n\nA register without a reset lowers directly to an always block:\n\n```\nalways @(posedge clk) begin\n  a <= [%input]\nend\n```\n\nIn the presence of a reset, an if statement and an always block with the\nproper triggers are emitted:\n\n```\nalways @(posedge clk or [posedge reset]) begin\n  if ([%reset])\n    a <= [%resetValue]\n  else\n    a <= [%input]\nend\n```\n\nAdditionally, `sv` operations are also included to provide the register with\na randomized preset value or an explicit preset constant.\nSince items assigned in an `always_ff` block cannot be initialised in an\n`initial` block, this register lowers to `always`.\n\n```\n`ifndef SYNTHESIS\n  `ifdef RANDOMIZE_REG_INIT\n    reg [31:0] _RANDOM;\n  `endif\n  initial begin\n    `INIT_RANDOM_PROLOG_\n    `ifdef RANDOMIZE_REG_INIT\n      _RANDOM = {`RANDOM};\n      a = _RANDOM;\n    `endif\n  end\n`endif\n```\n\nRegisters expect the logic assignment to them to be in SSA form.\nFor example, a strict connect to a field of a structure:\n\n```\n%field = firrtl.subfield %a[field]\nfirrtl.matchingconnect %field, %value\n```\n\nIs converted into a `hw.struct_inject` operation:\n\n```\n%reg = seq.firreg %value clock %clk sym @sym : i32\n%value = hw.struct_inject %reg[\"x\"], %value\n```\n\nIn order to avoid generating unnecessary assignments, the lowering of the\nregister to `sv` eliminates the SSA form and emits a single parallel assignment\nto the field (`reg.x = value`).\n\n### Rationale\u00a0[\u00b6](#rationale-1)\n\nA register specific for FIRRTL is desired as it has a specific lowering while\nalso requiring a preset value and asynchronous resets.\nThe lowering must also be compatible with the reference FIRRTL lowering, which\nmight diverge from the lowering of the computation register.\n\n### Future considerations\u00a0[\u00b6](#future-considerations)\n\n* Enable signal: if this proves difficult to detect (or non-performant if we\n  do not detect and generate the SystemVerilog correctly), we can build it into\n  the compreg op.\n* Reset style and clock style: how should we model posedge vs negedge clocks?\n  Async vs sync resets? There are some reasonable options here: attributes on\n  this op or `clock` and `reset` types which are parameterized with that\n  information.\n* Initial value: this register is uninitialized. Using an uninitialized value\n  results in undefined behavior. We will add an `initialValue` attribute if\n  this proves insufficient.\n\nThe High-Level Memory Abstraction\u00a0[\u00b6](#the-high-level-memory-abstraction)\n-------------------------------------------------------------------------\n\nThe `seq.hlmem` (high-level memory operation) intends to capture the semantics\nof a memory which eventually map to some form on-chip resources - whether being\nFPGA or ASIC-based.\nThe abstraction aims to abstract away the physical implementation details of the\nmemory, and instead focus on the external interface and access semantics of the\nmemory. this, in turn, facilitates analysis and transformation (e.g. memory\nmerging, read/write conflicts, etc.) and may serve as a target for other\nhigh-level abstractions.\n\nThe high-level memory abstraction is split into two parts:\n\n* Memory *allocation* is defined by the `seq.hlmem` operation. This operation\n  defines the internal memory structure. For now, this strictly pertains to the\n  layout of the memory (dimensionality) and element type.\n* Memory *access* is defined by separate port operations which reference the\n  allocated memory. Port access operations are defined at the same level of\n  abstraction as the core RTL dialects and contain no notion of control\n  flow. As such, for e.g. a write port with a non-zero latency, the encapsulating\n  IR must already have accounted for this latency.\n  The behavior of conflicting writes is defined by the lowering. Generally speaking, it should be considered as undefined.\n\nExample usage:\n\n```\n  %myMemory = seq.hlmem @myMemory %clk : <4xi32>\n  %c0_i2 = hw.constant 0 : i2\n  %c1_i1 = hw.constant 1 : i1\n  %c42_i32 = hw.constant 42 : i32\n  %myMemory_rdata = seq.read %myMemory[%c0_i2] rden %c1_i1 { latency = 0} : !seq.hlmem<4xi32>\n  seq.write %myMemory[%c0_i2] %c42_i32 wren %c1_i1 { latency = 1 } : !seq.hlmem<4xi32>\n```\n\nLowering the op is intended to be performed by matching on the `seq.hlmem`,\ncollecting the port ops which access the memory, and based on this\nperform a lowering to an appropriate memory structure. This memory\ncould either be behavioral (able to support any combination of memory allocation\nand port accesses) or specialized (e.g. specifically target FPGA resources,\ncall a memory compiler, \u2026 which may only be possible for a subset of\nallocation and access combinations).\n\n### Rationale\u00a0[\u00b6](#rationale-2)\n\nThe high-level memory abstraction, as presented here, represents a useful\nalbeit limited abstraction when considering the complexity of instantiating\nmemory resources in both FPGAs and ASICs.\n\nThe scope of what the `hlmem` operations can represent is large. Examples\nbeing: multidimensional memories, arbitrary # of read/write ports, and mixed\nport latencies (all of which could occur together).  \nIn reality, it will only be a limited subset of the possible combinations of\nthese operations which can be lowered reasonably to an FPGA or ASIC implementation.  \nHowever, by allowing for such complexity, we ensure that we have a unified IR\nwhich can represent such varying levels of complexity, thus ensuring maximum\nreusability of analysis and transformation passes.\n\n### Future considerations\u00a0[\u00b6](#future-considerations-1)\n\n#### **Port refinements**\u00a0[\u00b6](#port-refinements)\n\nThe main design decision of `seq.hlmem` is the choice of abstracting away\nthe structural details of a port into separate ops of which we currently\nonly provide rudimentary read- and write ops.\nExample future ports could be:\n\n* **Asymmetric port widths**\n  Specified as a new `seq.asym_read` port which defines a read data width\n  of some fraction of the native data size.\n\n  ```\n  %rdata = seq.asym_read %rp[%addr] : !seq.hlmem<4xi32> -> i16\n  ```\n\n  which would then put different typing requirements on the `%addr` signal.\n  Given the halfing of the word size, the expected address type would then\n  be `ceil(log2(4)) << 1 = i3`\n* **Byte-enable write ports**\n  Specified as a new `seq.write_be` port with an additional byte enable\n  signal.\n\n  ```\n  %wdata = seq.write_be %wp[%addr] %wdata, %be : i32, i4 -> !seq.hlmem<4xi32>\n  ```\n* **Debug ports**\n  Could be specified as either an additional read port, or (if further\n  specialization is needed) attached to the memory symbol.\n\n  ```\n  %mem = seq.debug @myMemory : !seq.hlmem<4xi32>\n  ```\n\nThe FIFO operation\u00a0[\u00b6](#the-fifo-operation)\n-------------------------------------------\n\nThe `seq.fifo` operation intends to capture the semantics of a FIFO which\neventually map to some form of on-chip resources. By having a FIFO abstraction,\nwe provide an abstraction that can be targeted for target-specialized implementations,\nas well as default behavioral lowerings (based on `seq.hlmem`).\n\nThe FIFO interface consists of:\n\n* **Inputs**:\n  + clock, reset\n  + input data\n  + read/write enable\n* **Outputs**:\n  + output data\n  + full, empty flags\n  + optional almost full, almost empty flags\n\nThe fifo operation is configurable with the following parameters:\n\n1. Depth (cycles)\n2. Differing in- and output widths\n3. Almost empty/full thresholds (optional)\n\nLike `seq.hlmem` there are no guarantees that all possible fifo configuration\nare able to be lowered. Available lowering passes will pattern match on the\nrequested fifo configuration and attempt to provide a legal lowering.\n\nState Initialization\u00a0[\u00b6](#state-initialization)\n-----------------------------------------------\n\nWhile ASICs might not have explicit initial values, they are crucial for simulation\nand FPGA implementation. FPGA designs often require constant initial values, while\nsimulation allows for more complex initialization using expressions like function calls\n`$random`, `$readmem`, and `$fopen`.\n\nIn order to represent various kinds of initialization, `seq.initial` op and `!seq.immutable` type\nare introduced. The `seq.initial` operation produces values with types wrapped in `!seq.immutable`.\nThe `!seq.immutable` type wrapper prevents initial values from depending on time-variant values.\nStateful operations typically require corresponding initial values with the `!seq.immutable` type.\nThis ensures that the initial state of the operation is well-defined and independent of time-variant factors.\n\nExample Input:\n\n```\n%r_init, %u_init = seq.initial {\n  %rand = sv.macro.ref.se @RANDOM() : () -> i32\n  %c0_i32 = hw.constant 0 : i32\n  seq.yield %rand, %c0_i32 : i32, i32\n} : !seq.immutable<i32>, !seq.immutable<i32>\n\n%r = seq.compreg %i, %clk initial %r_init : i32\n%u = seq.compreg %i, %clk initial %u_init : i32\n```\n\nOutput Verilog:\n\n```\nreg [31:0] r;\ninitial\n  r = `RANDOM;\nreg [31:0] u = 32'h0;\n```\n\n [Prev - 'seq' Dialect](https://circt.llvm.org/docs/Dialects/Seq/ \"'seq' Dialect\")\n[Next - 'ssp' Dialect](https://circt.llvm.org/docs/Dialects/SSP/ \"'ssp' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect-](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/SSP/index.md"
  },
  {
    "role": "user",
    "content": "'ssp' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'ssp' Dialect\n=============\n\n*Static scheduling problem instances and solutions.*\n\nA dialect to abstractly represent instances and solutions of\n[static\nscheduling problems](https://circt.llvm.org/docs/Scheduling/), intended as\nan import/export format for testing, benchmarking, and rapid prototyping of\nproblem definitions and algorithm implementations. See the\n[rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/) for more\ninformation.\n\n* [Operations](#operations)\n  + [`ssp.graph` (::circt::ssp::DependenceGraphOp)](#sspgraph-circtsspdependencegraphop)\n  + [`ssp.instance` (::circt::ssp::InstanceOp)](#sspinstance-circtsspinstanceop)\n  + [`ssp.library` (::circt::ssp::OperatorLibraryOp)](#ssplibrary-circtsspoperatorlibraryop)\n  + [`ssp.operation` (::circt::ssp::OperationOp)](#sspoperation-circtsspoperationop)\n  + [`ssp.operator_type` (::circt::ssp::OperatorTypeOp)](#sspoperator_type-circtsspoperatortypeop)\n  + [`ssp.resource` (::circt::ssp::ResourceLibraryOp)](#sspresource-circtsspresourcelibraryop)\n  + [`ssp.resource_type` (::circt::ssp::ResourceTypeOp)](#sspresource_type-circtsspresourcetypeop)\n* [Attributes](#attributes-6)\n  + [DependenceAttr](#dependenceattr)\n  + [DistanceAttr](#distanceattr)\n  + [IncomingDelayAttr](#incomingdelayattr)\n  + [InitiationIntervalAttr](#initiationintervalattr)\n  + [LatencyAttr](#latencyattr)\n  + [LimitAttr](#limitattr)\n  + [LinkedOperatorTypeAttr](#linkedoperatortypeattr)\n  + [LinkedResourceTypesAttr](#linkedresourcetypesattr)\n  + [OutgoingDelayAttr](#outgoingdelayattr)\n  + [StartTimeInCycleAttr](#starttimeincycleattr)\n  + [StartTimeAttr](#starttimeattr)\n\nOperations\n----------\n\n### `ssp.graph` (::circt::ssp::DependenceGraphOp)\n\n*Container for (scheduling) operations.*\n\nSyntax:\n\n```\noperation ::= `ssp.graph` $body attr-dict\n```\n\nThe dependence graph is spanned by `OperationOp`s (vertices) and a\ncombination of MLIR value uses and symbol references (edges).\n\nTraits: `HasOnlyGraphRegion`, `HasParent<InstanceOp>`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\nInterfaces: `OpAsmOpInterface`\n\n### `ssp.instance` (::circt::ssp::InstanceOp)\n\n*Instance of a static scheduling problem.*\n\nSyntax:\n\n```\noperation ::= `ssp.instance` ($sym_name^)? `of` $problemName custom<SSPProperties>($sspProperties) $body attr-dict\n```\n\nThis operation represents an instance of a static scheduling problem,\ncomprised of an operator library (`OperatorLibraryOp`, a container for\n`OperatorTypeOp`s), an resource library (`ResourceLibraryOp`, a container\nfor `ResourceTypeOp`s), and the dependence graph (`DependenceGraphOp`, a\ncontainer for `OperationOp`s). The instance and its components (operations,\noperator types, resource types and dependences) can carry properties,\ni.e. special MLIR attributes inheriting from the TableGen classes in\n`PropertyBase.td`. The `ssp` dialect provides attribute definitions (and\nshort-form pretty-printing) for CIRCT\u2019s built-in scheduling problems.\n\n**Example**\n\n```\nssp.instance @canis14_fig2 of \"ModuloProblem\" [II<3>] {\n  library {\n    operator_type @Memory [latency<1>]\n    operator_type @Add [latency<1>]\n  }\n  resource {\n    resource_type @ReadPort [limit<1>]\n    resource_type @WritePort [limit<1>]\n  }\n  graph {\n    %0 = operation<@Memory> @load_A(@store_A [dist<1>]) uses[@ReadPort] [t<2>]\n    %1 = operation<@Memory> @load_B() uses[@ReadPort] [t<0>]\n    %2 = operation<@Add> @add(%0, %1) [t<3>]  // no `resource_type` needed\n    operation<@Memory> @store_A(%2) uses[@WritePort] [t<4>]\n  }\n}\n```\n\nTraits: `IsolatedFromAbove`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\nInterfaces: `OpAsmOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `problemName` | ::mlir::StringAttr | string attribute |\n| `sspProperties` | ::mlir::ArrayAttr | array attribute |\n\n### `ssp.library` (::circt::ssp::OperatorLibraryOp)\n\n*Container for operator types.*\n\nSyntax:\n\n```\noperation ::= `ssp.library` ($sym_name^)? $body attr-dict\n```\n\nThe operator library abstracts the characteristics of the target\narchitecture/IR (onto which the source graph is scheduled), represented by\nthe individual `OperatorTypeOp`s. This operation may be used outside of an\n`InstanceOp`.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\nInterfaces: `OpAsmOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `ssp.operation` (::circt::ssp::OperationOp)\n\n*Vertex and incoming edges in the dependence graph.*\n\nThis MLIR operation represents an operation (in the terminology of CIRCT\u2019s\nscheduling infra) in a scheduling problem, or in other words, a vertex in\nthe surrounding instance\u2019s dependence graph. In addition, it also encodes\nthe operation\u2019s incoming dependences. In order to faithfully reproduce the\ninternal modeling in the scheduling infrastructure, these dependence edges\nare either encoded as MLIR operands (def-use dependences) or symbol\nreferences (auxiliary dependences). To that end, `OperationOp`s can\noptionally be named, and accept/produce an arbitrary number of\noperands/results. The operation and the incoming dependences can carry\nproperties.\n\nThe `linkedOperatorType` and `linkedResourceType` property in the root\n`Problem` class are central to the problem models, because it links operations\nto their properties in the target IR. Therefore, the referenced operator/resource\ntype symbol is parsed/printed right after the operation keyword in the custom\nassembly syntax. Flat symbol references are resolved by name in the surrounding\ninstance\u2019s operator/resource library. Nested references can point to arbitrary\noperator/resource libraries.\n\n**Examples**\n\n```\n// unnamed, only def-use dependences\n%2 = operation<@Add>(%0, %1)\n\n// unnamed, multiple results\n%5:2 = operation<@Div>(%3, %4) // multiple results\n\n// named, mix of def-use and auxiliary dependences\noperation<@MemAccess> @store_A(%2, @store_B, @load_A) uses[@MemPort]\n\n// dependence properties\noperation<@Barrier>(%2 [dist<1>], %5#1, @store_A [dist<3>])\n\n// operator type in stand-alone library\n%7 = operation<@MathLib::@Sqrt>(%6)\n```\n\nTraits: `HasParent<DependenceGraphOp>`\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `dependences` | ::mlir::ArrayAttr | dependence array attribute |\n| `sspProperties` | ::mlir::ArrayAttr | array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operands` | variadic of none type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of none type |\n\n### `ssp.operator_type` (::circt::ssp::OperatorTypeOp)\n\n*Element of the target architecture/IR.*\n\nSyntax:\n\n```\noperation ::= `ssp.operator_type` $sym_name custom<SSPProperties>($sspProperties) attr-dict\n```\n\nThis operation represents an operator type, which can be augmented with a\nset of problem-specific properties, and is identified through a unique name.\n\n**Example**\n\n```\noperator_type @MemPort [latency<1>]\n```\n\nTraits: `HasParent<OperatorLibraryOp>`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `sspProperties` | ::mlir::ArrayAttr | array attribute |\n\n### `ssp.resource` (::circt::ssp::ResourceLibraryOp)\n\n*Container for resource types.*\n\nSyntax:\n\n```\noperation ::= `ssp.resource` ($sym_name^)? $body attr-dict\n```\n\nThe resource library represents different kinds of resource of desired\nusage on the target architecture/IR. Each resource will be represented by\nthe individual `ResourceTypeOp`s. An `OperationOp` can be associated with\nzero, one, or multiple resources. This operation may be used outside of\nan `InstanceOp` so different problems can share the same resource constraints.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\nInterfaces: `OpAsmOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `ssp.resource_type` (::circt::ssp::ResourceTypeOp)\n\n*Resource of desired usage on the target architecture/IR.*\n\nSyntax:\n\n```\noperation ::= `ssp.resource_type` $sym_name custom<SSPProperties>($sspProperties) attr-dict\n```\n\nThis resource represents a resource type, which can be augmented with a\nset of problem-specific properties, and is identified through a unique name.\n\n**Example**\n\n```\nresource_type @MemPort [limit<1>]\n```\n\nTraits: `HasParent<ResourceLibraryOp>`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `sspProperties` | ::mlir::ArrayAttr | array attribute |\n\nAttributes\n----------\n\n### DependenceAttr\n\n*Internal representation of dependence edges.*\n\nSyntax:\n\n```\n#ssp.dependence<\n  unsigned,   # operandIdx\n  ::mlir::FlatSymbolRefAttr,   # sourceRef\n  ::mlir::ArrayAttr   # properties\n>\n```\n\nAn attribute to uniformly model def-use and auxiliary\n[dependences](https://circt.llvm.org/docs/Scheduling/#components) as well as\nto attach\n[properties](https://circt.llvm.org/docs/Scheduling/#properties)\nto them. This attribute is an implementation detail of the `ssp.OperationOp`\nand as such is supposed to be hidden by the custom parser/printer.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| operandIdx | `unsigned` |  |\n| sourceRef | `::mlir::FlatSymbolRefAttr` |  |\n| properties | `::mlir::ArrayAttr` |  |\n\n### DistanceAttr\n\n*Models the `Distance` property in `::circt::scheduling::CyclicProblem`.*\n\nSyntax:\n\n```\n#ssp.dist<\n  unsigned   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `unsigned` |  |\n\n### IncomingDelayAttr\n\n*Models the `IncomingDelay` property in `::circt::scheduling::ChainingProblem`.*\n\nSyntax:\n\n```\n#ssp.incDelay<\n  ::mlir::FloatAttr   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `::mlir::FloatAttr` |  |\n\n### InitiationIntervalAttr\n\n*Models the `InitiationInterval` property in `::circt::scheduling::CyclicProblem`.*\n\nSyntax:\n\n```\n#ssp.II<\n  unsigned   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `unsigned` |  |\n\n### LatencyAttr\n\n*Models the `Latency` property in `::circt::scheduling::Problem`.*\n\nSyntax:\n\n```\n#ssp.latency<\n  unsigned   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `unsigned` |  |\n\n### LimitAttr\n\n*Models the `Limit` property in `::circt::scheduling::SharedOperatorsProblem`.*\n\nSyntax:\n\n```\n#ssp.limit<\n  unsigned   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `unsigned` |  |\n\n### LinkedOperatorTypeAttr\n\n*Models the `LinkedOperatorType` property in `::circt::scheduling::Problem`.*\n\nSyntax:\n\n```\n#ssp.opr<\n  ::mlir::SymbolRefAttr   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `::mlir::SymbolRefAttr` |  |\n\n### LinkedResourceTypesAttr\n\n*Models the `LinkedResourceTypes` property in `::circt::scheduling::Problem`.*\n\nSyntax:\n\n```\n#ssp.rsrcs<\n  ::mlir::ArrayAttr   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `::mlir::ArrayAttr` |  |\n\n### OutgoingDelayAttr\n\n*Models the `OutgoingDelay` property in `::circt::scheduling::ChainingProblem`.*\n\nSyntax:\n\n```\n#ssp.outDelay<\n  ::mlir::FloatAttr   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `::mlir::FloatAttr` |  |\n\n### StartTimeInCycleAttr\n\n*Models the `StartTimeInCycle` property in `::circt::scheduling::ChainingProblem`.*\n\nSyntax:\n\n```\n#ssp.z<\n  ::mlir::FloatAttr   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `::mlir::FloatAttr` |  |\n\n### StartTimeAttr\n\n*Models the `StartTime` property in `::circt::scheduling::Problem`.*\n\nSyntax:\n\n```\n#ssp.t<\n  unsigned   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `unsigned` |  |\n\n'ssp' Dialect Docs\n------------------\n\n* [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n\n [Prev - Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/ \"Seq(uential) Dialect Rationale\")\n[Next - SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/ \"SSP Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/SSP/RationaleSSP/index.md"
  },
  {
    "role": "user",
    "content": "SSP Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nSSP Dialect Rationale\n=====================\n\nThis document describes various design points of the SSP dialect, why they are\nthe way they are, and current status. This follows in the spirit of other\n[MLIR\nRationale docs](https://mlir.llvm.org/docs/Rationale/).\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\nCIRCT\u2019s\n[scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/) is\nlightweight and dialect-agnostic, in order to fit into any lowering flow with a\nneed for static scheduling. However, it lacks an import/export format for\nstoring and exchanging problem instances. The SSP (\"**S**tatic **S**cheduling\n**P**roblems\") dialect fills that role by defining an IR that captures problem\ninstances\n\n* in full fidelity,\n* in a concise syntax,\n* and independent of any other \u201chost\u201d dialect.\n\nThe SSP dialect\u2019s main use-cases are\n[testing](#testing),\n[benchmarking](#benchmarking) and\n[rapid-prototyping](#rapid-prototyping). It is\nstrictly a companion to the existing scheduling infrastructure, and clients (HLS\nflows etc.) are advised to use the C++ APIs directly.\n\n### Testing\u00a0[\u00b6](#testing)\n\nIn order to test the scheduling infrastructure\u2019s problem definitions (in\nparticular, their input checkers/solution verifiers) and algorithm\nimplementations, a \u201chost\u201d IR to store problem instances is needed. To that end,\nthe test-cases started out with a mix of standard and unregistered operations,\nand heavy use of generic attributes, as shown in the following example (note\nespecially the index-based specification of auxiliary dependences):\n\n```\nfunc.func @canis14_fig2() attributes {\n  problemInitiationInterval = 3,\n  auxdeps = [ [3,0,1], [3,4] ],\n  operatortypes = [\n    { name = \"mem_port\", latency = 1, limit = 1 },\n    { name = \"add\", latency = 1 }\n  ] } {\n  %0 = \"dummy.load_A\"() { opr = \"mem_port\", problemStartTime = 2 } : () -> i32\n  %1 = \"dummy.load_B\"() { opr = \"mem_port\", problemStartTime = 0 } : () -> i32\n  %2 = arith.addi %0, %1 { opr = \"add\", problemStartTime = 3 } : i32\n  \"dummy.store_A\"(%2) { opr = \"mem_port\", problemStartTime = 4 } : (i32) -> ()\n  return { problemStartTime = 5 }\n}\n```\n\nHere is the same test-case encoded in the SSP dialect:\n\n```\nssp.instance \"canis14_fig2\" of \"ModuloProblem\" [II<3>] {\n  library {\n    operator_type @MemPort [latency<1>, limit<1>]\n    operator_type @Add [latency<1>]\n    operator_type @Implicit [latency<0>]\n  }\n  graph {\n    %0 = operation<@MemPort>(@store_A [dist<1>]) [t<2>]\n    %1 = operation<@MemPort>() [t<0>]\n    %2 = operation<@Add>(%0, %1) [t<3>]\n    operation<@MemPort> @store_A(%2) [t<4>]\n    operation<@Implicit>(@store_A) [t<5>]\n  }\n}\n```\n\nEmitting an SSP dump is also useful to test that an conversion pass correctly\nconstructs the scheduling problem, e.g. checking that it contains a memory\ndependence to another operation:\n\n```\n// CHECK: operation<@{{.*}}>(%0, @[[store_1]])\n%5 = affine.load %0[0] : memref<1xi32>\n...\n// CHECK: operation<@{{.*}}> @[[store_1:.*]](%7, %0)\naffine.store %7, %0[0] : memref<1xi32>\n```\n\n### Benchmarking\u00a0[\u00b6](#benchmarking)\n\nScheduling is a hard combinatorial optimization problem that can be solved by a\nvariety of approaches, ranging from fast heuristics to exact formulations in\nmathematical frameworks such as integer linear programs capable of computing\nprovably optimal solutions. It is therefore important to evaluate scheduler\nimplementations beyond just functional correctness testing, i.e. to assess the\nscheduler\u2019s runtime and scalability, as well as the solution quality, on sets of\nrepresentative benchmark instances.\n\nWith the SSP dialect, such instances can be saved directly from synthesis flows\nusing CIRCT\u2019s scheduling infrastructure, or emitted in the textual MLIR format\nby third-party tools. As the SSP IR is self-contained, it would even be viable\nto store problem instances originating from out-of-tree or proprietary flows, as\ntheir source and target IRs would not be required to load and schedule a problem\ninstance in a benchmark harness.\n\n### Rapid prototyping\u00a0[\u00b6](#rapid-prototyping)\n\nThe SSP dialect also provides a path towards automatically generated Python\nbindings for the scheduling infrastructure, which will ease the prototyping of\nnew scheduling clients and problem definitions.\n\n### Q&A\u00a0[\u00b6](#qa)\n\n* **Q:** Do I have to do a dialect conversion to and from this dialect to\n  schedule something?\n\n  No, use the C++ API, i.e. the problem classes and scheduler entrypoints in\n  `circt::scheduling`, directly! This dialect is a one-way street in terms of\n  dialect conversion, and only intended to load and store problem instances for\n  the use-cases listed above.\n* **Q:** Why don\u2019t you use something like Cap\u2019nProto to (de)serialize the\n  problem instances?\n\n  Textual MLIR is reasonably easy to write by hand, which is important for\n  test-cases, and we need MLIR operations anyways, because the scheduling\n  infrastructure builds on top of the MLIR def-use graph to represent its\n  dependence graphs.\n* **Q:** `OperationOp` doesn\u2019t seem like a great name.\n\n  No, you\u2019re right. However, the SSP dialect uses the same terminology as the\n  scheduling infrastructure, so any changes would have to originate there.\n\nRationale for selected design points\u00a0[\u00b6](#rationale-for-selected-design-points)\n-------------------------------------------------------------------------------\n\n### Use of container-like operations instead of regions in `InstanceOp`\u00a0[\u00b6](#use-of-container-like-operations-instead-of-regions-in-instanceop)\n\nThis dialect defines the `OperatorLibraryOp` and `DependenceGraphOp` to serve as\nthe first and second operation in an `InstanceOp`\u2019s region. The alternative of\nusing two regions on the `InstanceOp` is not applicable, because the\n`InstanceOp` then needs to provide a symbol table, but the upstream\n`SymbolTable` trait enforces single-region ops. Lastly, we also considered using\na single graph region to hold both `OperatorTypeOp`s and `OperationOp`s, but\ndiscarded that design because it cannot be safely roundtripped via a\n`circt::scheduling::Problem` (internally, registered operator types and\noperations are separate lists).\n\n### Stand-alone use of the `OperatorLibraryOp`\u00a0[\u00b6](#stand-alone-use-of-the-operatorlibraryop)\n\nThe `OperatorLibraryOp` can be named and used outside of an `InstanceOp`. This\nis useful to share operator type definitions across multiple instances. In\naddition, until CIRCT gains better infrastructure to manage predefined hardware\nmodules and their properties, such a stand-alone `OperatorLibraryOp` can also\nact as an interim solution to represent operator libraries for scheduling\nclients.\n\n### Use of SSA operands *and* symbol references to encode dependences\u00a0[\u00b6](#use-of-ssa-operands-_and_-symbol-references-to-encode-dependences)\n\nThis is required to faithfully reproduce the internal modeling in the scheduling\ninfrastructure, which distinguishes def-use (result to operand, tied to MLIR SSA\ngraph) and auxiliary (op to op, stored explicitly) dependences\n(\n[example](https://circt.llvm.org/docs/Scheduling/#constructing-a-problem-instance)).\nTo represent the former, the `OperationOp` produces an arbitrary number of\n`NoneType`-typed results, and accepts an arbitrary number of operands, thus\nspanning a def-use graph. Auxiliary dependences are encoded as symbol uses,\nwhich reference the name of the dependence\u2019s source `OperationOp`. Modeling\nthese dependences with symbols rather than SSA operands is a necessity because\nthe scheduling infrastructure implicitly considers *all* def-use edges between\nregistered operations. Hence, auxiliary dependences, hypothetically encoded as\nSSA operands, would be counted twice.\n\n### No attribute interface for scheduling properties\u00a0[\u00b6](#no-attribute-interface-for-scheduling-properties)\n\nProperties are represented by dialect attributes inheriting from the base\nclasses in `PropertyBase.td`, which include `extraClassDeclaration`s for\n`setInProblem(...)` and `getFromProblem(...)` methods that directly interact\nwith the C++ problem class. In order to get/set a certain property, a reference\nto the concrete class is required, e.g.: a `CyclicProblem &` if we want to set a\ndependence\u2019s `distance` property.\n\nA more obvious design would be to make these methods part of an attribute\ninterface. However, then the methods could only accept a `Problem &`, which\ncannot be statically downcasted to the concrete class due to the use of virtual\nmultiple inheritance in the problem class hierarchy. If the inheritance model\nwere to change in the scheduling infrastructure, the use of attribute interfaces\nshould be reconsidered.\n\nImport/export\u00a0[\u00b6](#importexport)\n--------------------------------\n\nThe `circt/Dialect/SSP/Utilities.h` header defines methods to convert between\n`ssp.InstanceOp`s and `circt::scheduling::Problem` instances. These utilities\nuse template parameters for the problem class and the property attribute\nclasses, allowing client code to load/save an instance of a certain problem\nclass with the given properties (but ignoring others). Incompatible properties\n(e.g. `distance` on a base `Problem`, or `initiationInterval` on an operation)\nwill be caught at compile time as errors in the template instantiation. Note\nthat convenience versions that simply load/save all properties known in the\ngiven problem class are provided as well.\n\nExtensibility\u00a0[\u00b6](#extensibility)\n---------------------------------\n\nA key feature of the scheduling infrastructure is its extensibility. New problem\ndefinitions in out-of-tree projects have to define attributes inheriting from\nthe property base classes in one of their own dialects. Due to the heavy use of\ntemplates in the import/export utilities, these additional attributes are\nsupported uniformly alongside the built-in property attributes. The only\ndifference is that the SSP dialect provides short-form pretty printing for its\nown properties, whereas externally-defined properties fall back to the generic\ndialect attribute syntax.\n\n [Prev - 'ssp' Dialect](https://circt.llvm.org/docs/Dialects/SSP/ \"'ssp' Dialect\")\n[Next - 'sv' Dialect](https://circt.llvm.org/docs/Dialects/SV/ \"'sv' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect-](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/SV/index.md"
  },
  {
    "role": "user",
    "content": "'sv' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'sv' Dialect\n============\n\n*Types and operations for SV dialect*\n\nThis dialect defines the `sv` dialect, which represents various\nSystemVerilog-specific constructs in an AST-like representation.\n\n* [Operations](#operations)\n  + [`sv.alias` (::circt::sv::AliasOp)](#svalias-circtsvaliasop)\n  + [`sv.always` (::circt::sv::AlwaysOp)](#svalways-circtsvalwaysop)\n  + [`sv.alwayscomb` (::circt::sv::AlwaysCombOp)](#svalwayscomb-circtsvalwayscombop)\n  + [`sv.alwaysff` (::circt::sv::AlwaysFFOp)](#svalwaysff-circtsvalwaysffop)\n  + [`sv.array_index_inout` (::circt::sv::ArrayIndexInOutOp)](#svarray_index_inout-circtsvarrayindexinoutop)\n  + [`sv.assert` (::circt::sv::AssertOp)](#svassert-circtsvassertop)\n  + [`sv.assert.concurrent` (::circt::sv::AssertConcurrentOp)](#svassertconcurrent-circtsvassertconcurrentop)\n  + [`sv.assert_property` (::circt::sv::AssertPropertyOp)](#svassert_property-circtsvassertpropertyop)\n  + [`sv.assign` (::circt::sv::AssignOp)](#svassign-circtsvassignop)\n  + [`sv.assume` (::circt::sv::AssumeOp)](#svassume-circtsvassumeop)\n  + [`sv.assume.concurrent` (::circt::sv::AssumeConcurrentOp)](#svassumeconcurrent-circtsvassumeconcurrentop)\n  + [`sv.assume_property` (::circt::sv::AssumePropertyOp)](#svassume_property-circtsvassumepropertyop)\n  + [`sv.bind` (::circt::sv::BindOp)](#svbind-circtsvbindop)\n  + [`sv.bind.interface` (::circt::sv::BindInterfaceOp)](#svbindinterface-circtsvbindinterfaceop)\n  + [`sv.bpassign` (::circt::sv::BPAssignOp)](#svbpassign-circtsvbpassignop)\n  + [`sv.case` (::circt::sv::CaseOp)](#svcase-circtsvcaseop)\n  + [`sv.constantStr` (::circt::sv::ConstantStrOp)](#svconstantstr-circtsvconstantstrop)\n  + [`sv.constantX` (::circt::sv::ConstantXOp)](#svconstantx-circtsvconstantxop)\n  + [`sv.constantZ` (::circt::sv::ConstantZOp)](#svconstantz-circtsvconstantzop)\n  + [`sv.cover` (::circt::sv::CoverOp)](#svcover-circtsvcoverop)\n  + [`sv.cover.concurrent` (::circt::sv::CoverConcurrentOp)](#svcoverconcurrent-circtsvcoverconcurrentop)\n  + [`sv.cover_property` (::circt::sv::CoverPropertyOp)](#svcover_property-circtsvcoverpropertyop)\n  + [`sv.error` (::circt::sv::ErrorOp)](#sverror-circtsverrorop)\n  + [`sv.exit` (::circt::sv::ExitOp)](#svexit-circtsvexitop)\n  + [`sv.fatal` (::circt::sv::FatalOp)](#svfatal-circtsvfatalop)\n  + [`sv.fflush` (::circt::sv::FFlushOp)](#svfflush-circtsvfflushop)\n  + [`sv.finish` (::circt::sv::FinishOp)](#svfinish-circtsvfinishop)\n  + [`sv.for` (::circt::sv::ForOp)](#svfor-circtsvforop)\n  + [`sv.force` (::circt::sv::ForceOp)](#svforce-circtsvforceop)\n  + [`sv.func` (::circt::sv::FuncOp)](#svfunc-circtsvfuncop)\n  + [`sv.func.call` (::circt::sv::FuncCallOp)](#svfunccall-circtsvfunccallop)\n  + [`sv.func.call.procedural` (::circt::sv::FuncCallProceduralOp)](#svfunccallprocedural-circtsvfunccallproceduralop)\n  + [`sv.func.dpi.import` (::circt::sv::FuncDPIImportOp)](#svfuncdpiimport-circtsvfuncdpiimportop)\n  + [`sv.fwrite` (::circt::sv::FWriteOp)](#svfwrite-circtsvfwriteop)\n  + [`sv.generate` (::circt::sv::GenerateOp)](#svgenerate-circtsvgenerateop)\n  + [`sv.generate.case` (::circt::sv::GenerateCaseOp)](#svgeneratecase-circtsvgeneratecaseop)\n  + [`sv.if` (::circt::sv::IfOp)](#svif-circtsvifop)\n  + [`sv.ifdef` (::circt::sv::IfDefOp)](#svifdef-circtsvifdefop)\n  + [`sv.ifdef.procedural` (::circt::sv::IfDefProceduralOp)](#svifdefprocedural-circtsvifdefproceduralop)\n  + [`sv.include` (::circt::sv::IncludeOp)](#svinclude-circtsvincludeop)\n  + [`sv.indexed_part_select` (::circt::sv::IndexedPartSelectOp)](#svindexed_part_select-circtsvindexedpartselectop)\n  + [`sv.indexed_part_select_inout` (::circt::sv::IndexedPartSelectInOutOp)](#svindexed_part_select_inout-circtsvindexedpartselectinoutop)\n  + [`sv.info` (::circt::sv::InfoOp)](#svinfo-circtsvinfoop)\n  + [`sv.initial` (::circt::sv::InitialOp)](#svinitial-circtsvinitialop)\n  + [`sv.interface` (::circt::sv::InterfaceOp)](#svinterface-circtsvinterfaceop)\n  + [`sv.interface.instance` (::circt::sv::InterfaceInstanceOp)](#svinterfaceinstance-circtsvinterfaceinstanceop)\n  + [`sv.interface.modport` (::circt::sv::InterfaceModportOp)](#svinterfacemodport-circtsvinterfacemodportop)\n  + [`sv.interface.signal` (::circt::sv::InterfaceSignalOp)](#svinterfacesignal-circtsvinterfacesignalop)\n  + [`sv.interface.signal.assign` (::circt::sv::AssignInterfaceSignalOp)](#svinterfacesignalassign-circtsvassigninterfacesignalop)\n  + [`sv.interface.signal.read` (::circt::sv::ReadInterfaceSignalOp)](#svinterfacesignalread-circtsvreadinterfacesignalop)\n  + [`sv.localparam` (::circt::sv::LocalParamOp)](#svlocalparam-circtsvlocalparamop)\n  + [`sv.logic` (::circt::sv::LogicOp)](#svlogic-circtsvlogicop)\n  + [`sv.macro.decl` (::circt::sv::MacroDeclOp)](#svmacrodecl-circtsvmacrodeclop)\n  + [`sv.macro.def` (::circt::sv::MacroDefOp)](#svmacrodef-circtsvmacrodefop)\n  + [`sv.macro.error` (::circt::sv::MacroErrorOp)](#svmacroerror-circtsvmacroerrorop)\n  + [`sv.macro.ref` (::circt::sv::MacroRefOp)](#svmacroref-circtsvmacrorefop)\n  + [`sv.macro.ref.expr` (::circt::sv::MacroRefExprOp)](#svmacrorefexpr-circtsvmacrorefexprop)\n  + [`sv.macro.ref.expr.se` (::circt::sv::MacroRefExprSEOp)](#svmacrorefexprse-circtsvmacrorefexprseop)\n  + [`sv.modport.get` (::circt::sv::GetModportOp)](#svmodportget-circtsvgetmodportop)\n  + [`sv.nonstandard.deposit` (::circt::sv::DepositOp)](#svnonstandarddeposit-circtsvdepositop)\n  + [`sv.ordered` (::circt::sv::OrderedOutputOp)](#svordered-circtsvorderedoutputop)\n  + [`sv.passign` (::circt::sv::PAssignOp)](#svpassign-circtsvpassignop)\n  + [`sv.read_inout` (::circt::sv::ReadInOutOp)](#svread_inout-circtsvreadinoutop)\n  + [`sv.readmem` (::circt::sv::ReadMemOp)](#svreadmem-circtsvreadmemop)\n  + [`sv.reg` (::circt::sv::RegOp)](#svreg-circtsvregop)\n  + [`sv.release` (::circt::sv::ReleaseOp)](#svrelease-circtsvreleaseop)\n  + [`sv.reserve_names` (::circt::sv::ReserveNamesOp)](#svreserve_names-circtsvreservenamesop)\n  + [`sv.return` (::circt::sv::ReturnOp)](#svreturn-circtsvreturnop)\n  + [`sv.sformatf` (::circt::sv::SFormatFOp)](#svsformatf-circtsvsformatfop)\n  + [`sv.stop` (::circt::sv::StopOp)](#svstop-circtsvstopop)\n  + [`sv.struct_field_inout` (::circt::sv::StructFieldInOutOp)](#svstruct_field_inout-circtsvstructfieldinoutop)\n  + [`sv.system` (::circt::sv::SystemFunctionOp)](#svsystem-circtsvsystemfunctionop)\n  + [`sv.system.sampled` (::circt::sv::SampledOp)](#svsystemsampled-circtsvsampledop)\n  + [`sv.system.stime` (::circt::sv::STimeOp)](#svsystemstime-circtsvstimeop)\n  + [`sv.system.time` (::circt::sv::TimeOp)](#svsystemtime-circtsvtimeop)\n  + [`sv.unpacked_array_create` (::circt::sv::UnpackedArrayCreateOp)](#svunpacked_array_create-circtsvunpackedarraycreateop)\n  + [`sv.unpacked_open_array_cast` (::circt::sv::UnpackedOpenArrayCastOp)](#svunpacked_open_array_cast-circtsvunpackedopenarraycastop)\n  + [`sv.verbatim` (::circt::sv::VerbatimOp)](#svverbatim-circtsvverbatimop)\n  + [`sv.verbatim.expr` (::circt::sv::VerbatimExprOp)](#svverbatimexpr-circtsvverbatimexprop)\n  + [`sv.verbatim.expr.se` (::circt::sv::VerbatimExprSEOp)](#svverbatimexprse-circtsvverbatimexprseop)\n  + [`sv.verbatim.module` (::circt::sv::SVVerbatimModuleOp)](#svverbatimmodule-circtsvsvverbatimmoduleop)\n  + [`sv.verbatim.source` (::circt::sv::SVVerbatimSourceOp)](#svverbatimsource-circtsvsvverbatimsourceop)\n  + [`sv.warning` (::circt::sv::WarningOp)](#svwarning-circtsvwarningop)\n  + [`sv.wire` (::circt::sv::WireOp)](#svwire-circtsvwireop)\n  + [`sv.xmr` (::circt::sv::XMROp)](#svxmr-circtsvxmrop)\n  + [`sv.xmr.ref` (::circt::sv::XMRRefOp)](#svxmrref-circtsvxmrrefop)\n* [Attributes](#attributes-63)\n  + [CaseExprPatternAttr](#caseexprpatternattr)\n  + [IncludeStyleAttr](#includestyleattr)\n  + [MacroIdentAttr](#macroidentattr)\n  + [ModportDirectionAttr](#modportdirectionattr)\n  + [ModportStructAttr](#modportstructattr)\n  + [SVAttributeAttr](#svattributeattr)\n  + [ValidationQualifierTypeEnumAttr](#validationqualifiertypeenumattr)\n* [Type constraints](#type-constraints)\n  + [an Unpacked Open ArrayType](#an-unpacked-open-arraytype)\n* [Types](#types)\n  + [InterfaceType](#interfacetype)\n  + [ModportType](#modporttype)\n  + [UnpackedOpenArrayType](#unpackedopenarraytype)\n* [Enums](#enums)\n  + [CaseStmtType](#casestmttype)\n  + [DeferAssert](#deferassert)\n  + [EventControl](#eventcontrol)\n  + [IncludeStyle](#includestyle)\n  + [MemBaseTypeAttr](#membasetypeattr)\n  + [ModportDirection](#modportdirection)\n  + [ResetType](#resettype)\n  + [ValidationQualifierTypeEnum](#validationqualifiertypeenum)\n\nOperations\n----------\n\n### `sv.alias` (::circt::sv::AliasOp)\n\n*SystemVerilog \u2018alias\u2019 statement*\n\nSyntax:\n\n```\noperation ::= `sv.alias` $aliases attr-dict `:` qualified(type($aliases))\n```\n\nAn alias statement declares multiple names for the same physical net, or\nbits within a net. Aliases always have at least two operands.\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `aliases` | variadic of InOutType |\n\n### `sv.always` (::circt::sv::AlwaysOp)\n\n*\u2018always @\u2019 block*\n\nSyntax:\n\n```\noperation ::= `sv.always` custom<EventList>($events, $clocks) $body attr-dict\n```\n\nSee SV Spec 9.2, and 9.4.2.2.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `NonProceduralOp`, `ProceduralRegion`, `RecursiveMemoryEffects`, `RecursivelySpeculatableImplTrait`, `SingleBlock`\n\nInterfaces: `ConditionallySpeculatable`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `events` | ::mlir::ArrayAttr | events |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clocks` | variadic of 1-bit signless integer |\n\n### `sv.alwayscomb` (::circt::sv::AlwaysCombOp)\n\n*\u2018alwayscomb block*\n\nSyntax:\n\n```\noperation ::= `sv.alwayscomb` $body attr-dict\n```\n\nSee SV Spec 9.2, and 9.2.2.2.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `NonProceduralOp`, `ProceduralRegion`, `RecursiveMemoryEffects`, `RecursivelySpeculatableImplTrait`, `SingleBlock`\n\nInterfaces: `ConditionallySpeculatable`\n\n### `sv.alwaysff` (::circt::sv::AlwaysFFOp)\n\n*\u2018alwaysff @\u2019 block with optional reset*\n\nSyntax:\n\n```\noperation ::= `sv.alwaysff` `(` $clockEdge $clock `)` $bodyBlk\n              ( `(` $resetStyle `:` $resetEdge^ $reset `)` $resetBlk )? attr-dict\n```\n\nalwaysff blocks represent always\\_ff verilog nodes, which enforce inference\nof registers. This block takes a clock signal and edge sensitivity and\nreset type. If the reset type is anything but \u2019noreset\u2019, the block takes a\nreset signal, reset sensitivity, and reset block. Appropriate if conditions\nare generated in the output code based on the reset type. A negative-edge,\nasynchronous reset will check the inverse of the reset condition\n(if (!reset) begin resetblock end) to match the sensitivity.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `NonProceduralOp`, `ProceduralRegion`, `RecursiveMemoryEffects`, `RecursivelySpeculatableImplTrait`, `SingleBlock`\n\nInterfaces: `ConditionallySpeculatable`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `clockEdge` | circt::sv::EventControlAttr | edge control trigger |\n| `resetStyle` | ::circt::sv::ResetTypeAttr | reset type |\n| `resetEdge` | circt::sv::EventControlAttr | edge control trigger |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n\n### `sv.array_index_inout` (::circt::sv::ArrayIndexInOutOp)\n\n*Index an inout memory to produce an inout element*\n\nSyntax:\n\n```\noperation ::= `sv.array_index_inout` $input`[`$index`]` attr-dict `:` qualified(type($input)) `,` qualified(type($index))\n```\n\nSee SV Spec 11.5.2.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an inout type with array element |\n| `index` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | InOutType |\n\n### `sv.assert` (::circt::sv::AssertOp)\n\n*Immediate assertion statement*\n\nSyntax:\n\n```\noperation ::= `sv.assert` $expression `,` $defer\n              (`label` $label^)?\n              (`message` $message^ (`(` $substitutions^ `)` `:`\n              qualified(type($substitutions)))?)? attr-dict\n```\n\nSpecify that a Boolean expression is always true. This can be used to both\ndocument the behavior of the design and to test that the design behaves as\nexpected. See Section 16.3 of the SystemVerilog 2017 specification.\n\nTraits: `ProceduralOp`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `defer` | circt::sv::DeferAssertAttr | assertion deferring mode |\n| `label` | ::mlir::StringAttr | string attribute |\n| `message` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `expression` | 1-bit signless integer |\n| `substitutions` | variadic of any type |\n\n### `sv.assert.concurrent` (::circt::sv::AssertConcurrentOp)\n\n*Concurrent assertion statement, i.e., assert property*\n\nSyntax:\n\n```\noperation ::= `sv.assert.concurrent` $event $clock `,` $property\n              (`label` $label^)?\n              (`message` $message^ (`(` $substitutions^ `)` `:`\n              qualified(type($substitutions)))?)? attr-dict\n```\n\nSpecify that a property of the hardware design is true whenever the property\nis evaluated. This can be used to both document the behavior of the design\nand to test that the design behaves as expected. See section 16.5 of the\nSystemVerilog 2017 specification.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `event` | circt::sv::EventControlAttr | edge control trigger |\n| `label` | ::mlir::StringAttr | string attribute |\n| `message` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | 1-bit signless integer |\n| `property` | 1-bit signless integer |\n| `substitutions` | variadic of any type |\n\n### `sv.assert_property` (::circt::sv::AssertPropertyOp)\n\n*Property assertion \u2013 can be disabled and clocked*\n\nSyntax:\n\n```\noperation ::= `sv.assert_property` $property (`on` $event^)? ($clock^)? (`disable_iff` $disable^)?\n              (`label` $label^)? attr-dict `:` type($property)\n```\n\nAssert that a given SVA-style property holds. This is only checked when\nthe disable signal is low and a clock event occurs. This is analogous to\nthe verif.assert operation, but with a flipped enable polarity.\n\nTraits: `AttrSizedOperandSegments`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `event` | circt::sv::EventControlAttr | edge control trigger |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `clock` | 1-bit signless integer |\n| `disable` | 1-bit signless integer |\n\n### `sv.assign` (::circt::sv::AssignOp)\n\n*Continuous assignment*\n\nSyntax:\n\n```\noperation ::= `sv.assign` $dest `,` $src attr-dict `:` qualified(type($src))\n```\n\nA SystemVerilog assignment statement \u2018x = y;\u2019.\nThese occur in module scope. See SV Spec 10.3.2.\n\nTraits: `NonProceduralOp`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | InOutType |\n| `src` | a valid inout element |\n\n### `sv.assume` (::circt::sv::AssumeOp)\n\n*Immediate assume statement*\n\nSyntax:\n\n```\noperation ::= `sv.assume` $expression `,` $defer\n              (`label` $label^)?\n              (`message` $message^ (`(` $substitutions^ `)` `:`\n              qualified(type($substitutions)))?)? attr-dict\n```\n\nSpecify that a Boolean expression is assumed to always be true. This can\neither be used as an assertion-like check that the expression is, in fact,\nalways true or to bound legal input values during testing. See Section 16.3\nof the SystemVerilog 2017 specification.\n\nTraits: `ProceduralOp`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `defer` | circt::sv::DeferAssertAttr | assertion deferring mode |\n| `label` | ::mlir::StringAttr | string attribute |\n| `message` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `expression` | 1-bit signless integer |\n| `substitutions` | variadic of any type |\n\n### `sv.assume.concurrent` (::circt::sv::AssumeConcurrentOp)\n\n*Concurrent assume statement, i.e., assume property*\n\nSyntax:\n\n```\noperation ::= `sv.assume.concurrent` $event $clock `,` $property\n              (`label` $label^)?\n              (`message` $message^ (`(` $substitutions^ `)` `:`\n              qualified(type($substitutions)))?)? attr-dict\n```\n\nSpecify that a property is assumed to be true whenever the property is\nevaluated. This can be used to both document the behavior of the design and\nto test that the design behaves as expected. See section 16.5 of the\nSystemVerilog 2017 specification.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `event` | circt::sv::EventControlAttr | edge control trigger |\n| `label` | ::mlir::StringAttr | string attribute |\n| `message` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | 1-bit signless integer |\n| `property` | 1-bit signless integer |\n| `substitutions` | variadic of any type |\n\n### `sv.assume_property` (::circt::sv::AssumePropertyOp)\n\n*Property assumption \u2013 can be disabled and clocked*\n\nSyntax:\n\n```\noperation ::= `sv.assume_property` $property (`on` $event^)? ($clock^)? (`disable_iff` $disable^)?\n              (`label` $label^)? attr-dict `:` type($property)\n```\n\nAssume that a given SVA-style property holds. This is only considered when\nthe disable signal is low and a clock event occurs. This is analogous to\nthe verif.assume operation, but with a flipped enable polarity.\n\nTraits: `AttrSizedOperandSegments`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `event` | circt::sv::EventControlAttr | edge control trigger |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `clock` | 1-bit signless integer |\n| `disable` | 1-bit signless integer |\n\n### `sv.bind` (::circt::sv::BindOp)\n\n*Indirect instantiation statement*\n\nSyntax:\n\n```\noperation ::= `sv.bind` $instance attr-dict\n```\n\nIndirectly instantiate a module from the context of another module. BindOp\npairs with a `hw.instance` (identified by a `boundInstance` symbol) which\ntracks all information except the emission point for the bind. BindOp also\ntracks the `instanceModule` symbol for the `hw.module` that contains the\n`hw.instance` to accelerate symbol lookup.\n\nSee 23.11 of SV 2017 spec for more information about bind.\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `instance` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n\n### `sv.bind.interface` (::circt::sv::BindInterfaceOp)\n\n*Indirectly instantiate an interface*\n\nSyntax:\n\n```\noperation ::= `sv.bind.interface` $instance attr-dict\n```\n\nIndirectly instantiate an interface in the context of another module. This\noperation must pair with a `sv.interface.instance`.\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `instance` | ::circt::hw::InnerRefAttr | Refer to a name inside a module |\n\n### `sv.bpassign` (::circt::sv::BPAssignOp)\n\n*Blocking procedural assignment*\n\nSyntax:\n\n```\noperation ::= `sv.bpassign` $dest `,` $src  attr-dict `:` qualified(type($src))\n```\n\nA SystemVerilog blocking procedural assignment statement \u2018x = y;\u2019. These\noccur in initial, always, task, and function blocks. The statement is\nexecuted before any following statements are. See SV Spec 10.4.1.\n\nTraits: `ProceduralOp`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | InOutType |\n| `src` | a valid inout element |\n\n### `sv.case` (::circt::sv::CaseOp)\n\n*\u2018case (cond)\u2019 block*\n\nSee SystemVerilog 2017 12.5.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `ProceduralOp`, `ProceduralRegion`, `SingleBlock`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `caseStyle` | ::CaseStmtTypeAttr | case type |\n| `casePatterns` | ::mlir::ArrayAttr | array attribute |\n| `validationQualifier` | ::circt::sv::ValidationQualifierTypeEnumAttr | validation qualifier type |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `cond` | any type |\n| `caseValues` | variadic of any type |\n\n### `sv.constantStr` (::circt::sv::ConstantStrOp)\n\n*A constant of string value*\n\nSyntax:\n\n```\noperation ::= `sv.constantStr` $str attr-dict\n```\n\nThis operation produces a constant string literal.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `str` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a HW string |\n\n### `sv.constantX` (::circt::sv::ConstantXOp)\n\n*A constant of value \u2018x\u2019*\n\nSyntax:\n\n```\noperation ::= `sv.constantX` attr-dict `:` qualified(type($result))\n```\n\nThis operation produces a constant value of \u2018x\u2019. This \u2018x\u2019 follows the\nSystem Verilog rules for \u2018x\u2019 propagation.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a known primitive element |\n\n### `sv.constantZ` (::circt::sv::ConstantZOp)\n\n*A constant of value \u2018z\u2019*\n\nSyntax:\n\n```\noperation ::= `sv.constantZ` attr-dict `:` qualified(type($result))\n```\n\nThis operation produces a constant value of \u2018z\u2019. This \u2018z\u2019 follows the\nSystem Verilog rules for \u2018z\u2019 propagation.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a known primitive element |\n\n### `sv.cover` (::circt::sv::CoverOp)\n\n*Immediate cover statement*\n\nSyntax:\n\n```\noperation ::= `sv.cover` $expression `,` $defer\n              (`label` $label^)?\n              (`message` $message^ (`(` $substitutions^ `)` `:`\n              qualified(type($substitutions)))?)? attr-dict\n```\n\nSpecify that a Boolean expression should be monitored for coverage, i.e., a\nsimulator will watch if it occurs and how many times it occurs. See section\n16.3 of the SystemVerilog 2017 specification.\n\nTraits: `ProceduralOp`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `defer` | circt::sv::DeferAssertAttr | assertion deferring mode |\n| `label` | ::mlir::StringAttr | string attribute |\n| `message` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `expression` | 1-bit signless integer |\n| `substitutions` | variadic of any type |\n\n### `sv.cover.concurrent` (::circt::sv::CoverConcurrentOp)\n\n*Concurrent cover statement, i.e., cover property*\n\nSyntax:\n\n```\noperation ::= `sv.cover.concurrent` $event $clock `,` $property\n              (`label` $label^)?\n              (`message` $message^ (`(` $substitutions^ `)` `:`\n              qualified(type($substitutions)))?)? attr-dict\n```\n\nSpecify that a specific property should be monitored for coverage, i.e., a\nsimulation will watch if it occurrs and how many times it occurs. See\nsection 16.5 of the SystemVerilog 2017 specification.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `event` | circt::sv::EventControlAttr | edge control trigger |\n| `label` | ::mlir::StringAttr | string attribute |\n| `message` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `clock` | 1-bit signless integer |\n| `property` | 1-bit signless integer |\n| `substitutions` | variadic of any type |\n\n### `sv.cover_property` (::circt::sv::CoverPropertyOp)\n\n*Property cover point \u2013 can be disabled and clocked*\n\nSyntax:\n\n```\noperation ::= `sv.cover_property` $property (`on` $event^)? ($clock^)? (`disable_iff` $disable^)?\n              (`label` $label^)? attr-dict `:` type($property)\n```\n\nCover when a given SVA-style property holds. This is only checked when\nthe disable signal is low and a clock event occurs. This is analogous to\nthe verif.cover operation, but with a flipped enable polarity.\n\nTraits: `AttrSizedOperandSegments`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `event` | circt::sv::EventControlAttr | edge control trigger |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `clock` | 1-bit signless integer |\n| `disable` | 1-bit signless integer |\n\n### `sv.error` (::circt::sv::ErrorOp)\n\n*`$error` severity message task*\n\nSyntax:\n\n```\noperation ::= `sv.error` ($message^ (`(` $substitutions^ `)` `:` qualified(type($substitutions)))?)?\n              attr-dict\n```\n\nThis system task indicates a run-time error.\n\nIf present, the optional message is printed with any additional operands\ninterpolated into the message string.\n\nTraits: `ProceduralOp`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `message` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `substitutions` | variadic of any type |\n\n### `sv.exit` (::circt::sv::ExitOp)\n\n*`$exit` system task*\n\nSyntax:\n\n```\noperation ::= `sv.exit` attr-dict\n```\n\nWaits for all `program` blocks to complete and then makes an implicit call\nto `$finish` with default verbosity (level 1) to conclude the simulation.\n\nTraits: `ProceduralOp`\n\n### `sv.fatal` (::circt::sv::FatalOp)\n\n*`$fatal` severity message task*\n\nSyntax:\n\n```\noperation ::= `sv.fatal` $verbosity\n              (`,` $message^ (`(` $substitutions^ `)` `:`\n              qualified(type($substitutions)))?)? attr-dict\n```\n\nGenerates a run-time fatal error which terminates the simulation with an\nerror code. Makes an implicit call to `$finish`, forwarding the `verbosity`\noperand. If present, the optional message is printed with any additional\noperands interpolated into the message string.\n\nTraits: `ProceduralOp`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `verbosity` | ::mlir::IntegerAttr | 8-bit signless integer attribute whose minimum value is 0 whose maximum value is 2 |\n| `message` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `substitutions` | variadic of any type |\n\n### `sv.fflush` (::circt::sv::FFlushOp)\n\n*\u2019$fflush\u2019 statement*\n\nSyntax:\n\n```\noperation ::= `sv.fflush` (`fd` $fd^)? attr-dict\n```\n\nThe $fflush system task flushes the output buffer of the specified file\ndescriptor. If no file descriptor is specified, all open files are flushed.\n\nSee IEEE 1800-2023 Section 21.3.6.\n\nTraits: `ProceduralOp`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `fd` | 32-bit signless integer |\n\n### `sv.finish` (::circt::sv::FinishOp)\n\n*`$finish` system task*\n\nSyntax:\n\n```\noperation ::= `sv.finish` $verbosity attr-dict\n```\n\nStops the simulation and exits/terminates the simulator process. In practice\nmost GUI-based simulators will show a prompt to the user offering them an\nopportunity to not close the simulator altogether.\n\nOther tasks such as `$exit` or `$fatal` implicitly call this system task.\n\nThe optional `verbosity` parameter controls how much diagnostic information\nis printed when the system task is executed (see section 20.2 of IEEE\n1800-2017):\n\n* `0`: Prints nothing\n* `1`: Prints simulation time and location (default)\n* `2`: Prints simulation time, location, and statistics about the memory and\n  CPU time used in simulation\n\nTraits: `ProceduralOp`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `verbosity` | ::mlir::IntegerAttr | 8-bit signless integer attribute whose minimum value is 0 whose maximum value is 2 |\n\n### `sv.for` (::circt::sv::ForOp)\n\n*System verilog for loop*\n\nThe `sv.for` operation in System Verilog defines a for statement that requires\nthree SSA operands: `lowerBounds`, `upperBound`, and `step`. It functions\nsimilarly to `scf.for`, where the loop iterates the induction variable from\n`lowerBound` to `upperBound` with a step size of `step`, i.e:\n\n```\n for (logic ... indVar = lowerBound; indVar < upperBound; indVar += step) begin\n end\n```\n\nIt\u2019s important to note that since we are using a bit precise type instead of a Verilog\n`integer` type, users must be cautious about potential overflow. For example, if\nyou wish to iterate over all 2-bit values, you must use a 3-bit value as the\ninduction variable type.\n\nTraits: `NoTerminator`, `ProceduralOp`, `ProceduralRegion`, `SingleBlock`\n\nInterfaces: `OpAsmOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inductionVarName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `lowerBound` | a signless integer bitvector |\n| `upperBound` | a signless integer bitvector |\n| `step` | a signless integer bitvector |\n\n### `sv.force` (::circt::sv::ForceOp)\n\n*Force procedural statement*\n\nSyntax:\n\n```\noperation ::= `sv.force` $dest `,` $src  attr-dict `:` qualified(type($src))\n```\n\nA SystemVerilog force procedural statement \u2018force x = y;\u2019. These\noccur in initial, always, task, and function blocks.\nA force statement shall override a procedural assignment until\na release statement is executed on the variable.\nThe left-hand side of the assignment can be a variable, a net,\na constant bit-select of a vector net, a part-select of a vector\nnet or a concatenation. It cannot be a memory word or a bit-select\nor part-select of a vector variable. See SV Spec 10.6.2.\n\nTraits: `ProceduralOp`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | InOutType |\n| `src` | a valid inout element |\n\n### `sv.func` (::circt::sv::FuncOp)\n\n*A SystemVerilog function*\n\n`sv.func` represents SystemVerilog function in IEEE 1800-2017 section 13.4\n\u201cFunctions\u201d. Similar to HW module, it\u2019s allowed to mix the order of input\nand output arguments. `sv.func` can be used for both function\ndeclaration and definition, i.e. a function without a body\nregion is a declaration.\n\nIn SV there are two representations for function results,\n\u201coutput argument\u201d and \u201creturn value\u201d. Currently an output argument\nis considered as as a return value if it\u2019s is the last argument\nand has a special attribute `sv.func.explicitly_returned`.\n\nTraits: `HasParent<mlir::ModuleOp>`, `IsolatedFromAbove`, `ProceduralRegion`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallableOpInterface`, `Emittable`, `FunctionOpInterface`, `HWEmittableModuleLike`, `HWModuleLike`, `InstanceGraphModuleOpInterface`, `OpAsmOpInterface`, `PortList`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `module_type` | ::mlir::TypeAttr | type attribute of a module |\n| `per_argument_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `input_locs` | ::mlir::ArrayAttr | location array attribute |\n| `result_locs` | ::mlir::ArrayAttr | location array attribute |\n| `verilogName` | ::mlir::StringAttr | string attribute |\n\n### `sv.func.call` (::circt::sv::FuncCallOp)\n\n*Function call in a non-procedural region*\n\nSyntax:\n\n```\noperation ::= `sv.func.call` $callee `(` $inputs `)` attr-dict `:` functional-type($inputs, results)\n```\n\nThis op represents a function call in a non-procedural region.\nA function call in a non-procedural region must have a return\nvalue and no output argument.\n\nTraits: `NonProceduralOp`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `callee` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| \u00abunnamed\u00bb | variadic of any type |\n\n### `sv.func.call.procedural` (::circt::sv::FuncCallProceduralOp)\n\n*Function call in a procedural region*\n\nSyntax:\n\n```\noperation ::= `sv.func.call.procedural` $callee `(` $inputs `)` attr-dict `:` functional-type($inputs, results)\n```\n\nTraits: `ProceduralOp`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `callee` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| \u00abunnamed\u00bb | variadic of any type |\n\n### `sv.func.dpi.import` (::circt::sv::FuncDPIImportOp)\n\n*DPI import statement*\n\nSyntax:\n\n```\noperation ::= `sv.func.dpi.import` (`linkage` $linkage_name^)? $callee attr-dict\n```\n\n`sv.func.dpi.import` represents DPI function import statement defined in\nIEEE 1800-2017 section 35.4.\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `callee` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `linkage_name` | ::mlir::StringAttr | string attribute |\n\n### `sv.fwrite` (::circt::sv::FWriteOp)\n\n*\u2019$fwrite\u2019 statement*\n\nSyntax:\n\n```\noperation ::= `sv.fwrite` $fd `,` $format_string attr-dict (`(` $substitutions^ `)` `:`\n              qualified(type($substitutions)))?\n```\n\nTraits: `ProceduralOp`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `format_string` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `fd` | 32-bit signless integer |\n| `substitutions` | variadic of any type |\n\n### `sv.generate` (::circt::sv::GenerateOp)\n\n*A generate block*\n\nSyntax:\n\n```\noperation ::= `sv.generate` $sym_name attr-dict `:` $body\n```\n\nSee SystemVerilog 2017 27.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n\n### `sv.generate.case` (::circt::sv::GenerateCaseOp)\n\n*A \u2018case\u2019 statement inside of a generate block*\n\nSyntax:\n\n```\noperation ::= `sv.generate.case` $cond attr-dict ` ` `[`\n              custom<CaseRegions>($casePatterns, $caseNames, $caseRegions)\n              `]`\n```\n\nSee SystemVerilog 2017 27.5.\n\nTraits: `HasParent<GenerateOp>`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `cond` | ::mlir::TypedAttr | TypedAttr instance |\n| `casePatterns` | ::mlir::ArrayAttr | case pattern array |\n| `caseNames` | ::mlir::ArrayAttr | string array attribute |\n\n### `sv.if` (::circt::sv::IfOp)\n\n*\u2018if (cond)\u2019 block*\n\nSyntax:\n\n```\noperation ::= `sv.if` $cond $thenRegion (`else` $elseRegion^)? attr-dict\n```\n\nTraits: `NoRegionArguments`, `NoTerminator`, `ProceduralOp`, `ProceduralRegion`, `SingleBlock`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `cond` | 1-bit signless integer |\n\n### `sv.ifdef` (::circt::sv::IfDefOp)\n\n*\u2018ifdef MACRO\u2019 block*\n\nSyntax:\n\n```\noperation ::= `sv.ifdef` $cond $thenRegion (`else` $elseRegion^)? attr-dict\n```\n\nThis operation is an #ifdef block, which has a \u201cthen\u201d and \u201celse\u201d region.\nThis operation is for non-procedural regions and its body is non-procedural.\n\nTraits: `HasOnlyGraphRegion`, `NoRegionArguments`, `NoTerminator`, `NonProceduralOp`, `SingleBlock`\n\nInterfaces: `RegionKindInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `cond` | ::circt::sv::MacroIdentAttr | Macro identifier |\n\n### `sv.ifdef.procedural` (::circt::sv::IfDefProceduralOp)\n\n*\u2018ifdef MACRO\u2019 block for procedural regions*\n\nSyntax:\n\n```\noperation ::= `sv.ifdef.procedural` $cond $thenRegion (`else` $elseRegion^)? attr-dict\n```\n\nThis operation is an #ifdef block, which has a \u201cthen\u201d and \u201celse\u201d region.\nThis operation is for procedural regions and its body is procedural.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `ProceduralOp`, `ProceduralRegion`, `SingleBlock`\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `cond` | ::circt::sv::MacroIdentAttr | Macro identifier |\n\n### `sv.include` (::circt::sv::IncludeOp)\n\n*Preprocessor `include directive*\n\nSyntax:\n\n```\noperation ::= `sv.include` $style $target attr-dict\n```\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `style` | ::circt::sv::IncludeStyleAttr | Double-quoted local include, or angle bracketed system include |\n| `target` | ::mlir::StringAttr | string attribute |\n\n### `sv.indexed_part_select` (::circt::sv::IndexedPartSelectOp)\n\n*Read several contiguous bits of an int type.This is an indexed part-select operator.The base is an integer expression and the width is an integer constant. The bits start from base and the number of bits selected is equal to width. If $decrement is true, then part select decrements starting from $base.See SV Spec 11.5.1.*\n\nSyntax:\n\n```\noperation ::= `sv.indexed_part_select` $input`[`$base (`decrement` $decrement^)?`:` $width`]` attr-dict `:` qualified(type($input)) `,` qualified(type($base))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `width` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `decrement` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a signless integer bitvector |\n| `base` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `sv.indexed_part_select_inout` (::circt::sv::IndexedPartSelectInOutOp)\n\n*Address several contiguous bits of an inout type (e.g. a wire or inout port). This is an indexed part-select operator.The base is an integer expression and the width is an integer constant. The bits start from base and the number of bits selected is equal to width. If $decrement is true, then part select decrements starting from $base.See SV Spec 11.5.1.*\n\nSyntax:\n\n```\noperation ::= `sv.indexed_part_select_inout` $input`[`$base (`decrement` $decrement^)?`:` $width`]` attr-dict `:` qualified(type($input)) `,` qualified(type($base))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `width` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `decrement` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | InOutType |\n| `base` | a signless integer bitvector |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | InOutType |\n\n### `sv.info` (::circt::sv::InfoOp)\n\n*`$info` severity message task*\n\nSyntax:\n\n```\noperation ::= `sv.info` ($message^ (`(` $substitutions^ `)` `:` qualified(type($substitutions)))?)?\n              attr-dict\n```\n\nThis system task indicates a message with no specific severity.\n\nIf present, the optional message is printed with any additional operands\ninterpolated into the message string.\n\nTraits: `ProceduralOp`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `message` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `substitutions` | variadic of any type |\n\n### `sv.initial` (::circt::sv::InitialOp)\n\n*\u2018initial\u2019 block*\n\nSyntax:\n\n```\noperation ::= `sv.initial` $body attr-dict\n```\n\nSee SV Spec 9.2.1.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `NonProceduralOp`, `ProceduralRegion`, `RecursiveMemoryEffects`, `RecursivelySpeculatableImplTrait`, `SingleBlock`\n\nInterfaces: `ConditionallySpeculatable`\n\n### `sv.interface` (::circt::sv::InterfaceOp)\n\n*Operation to define a SystemVerilog interface*\n\nSyntax:\n\n```\noperation ::= `sv.interface` $sym_name attr-dict-with-keyword $body\n```\n\nThis operation defines a named interface. Its name is a symbol that can\nbe looked up when declared inside a SymbolTable operation. This operation is\nalso a SymbolTable itself, so the symbols in its region can be looked up.\n\nExample:\n\n```\nsv.interface @myinterface {\n  sv.interface.signal @data : i32\n  sv.interface.modport @input_port (input @data)\n  sv.interface.modport @output_port (output @data)\n}\n```\n\nTraits: `NoTerminator`, `SingleBlock`, `SymbolTable`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `comment` | ::mlir::StringAttr | string attribute |\n\n### `sv.interface.instance` (::circt::sv::InterfaceInstanceOp)\n\n*Instantiate an interface*\n\nSyntax:\n\n```\noperation ::= `sv.interface.instance` (`sym` $inner_sym^)? `` custom<ImplicitSSAName>($name) attr-dict\n              `:` qualified(type($result))\n```\n\nUse this to declare an instance of an interface:\n\n```\n%iface = sv.interface.instance : !sv.interface<@handshake_example>\n```\n\nInterfaces: `HasCustomSSAName`, `InnerSymbolOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n| `doNotPrint` | ::mlir::UnitAttr | unit attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | SystemVerilog interface type pointing to an InterfaceOp |\n\n### `sv.interface.modport` (::circt::sv::InterfaceModportOp)\n\n*Operation to define a SystemVerilog modport for interfaces*\n\nSyntax:\n\n```\noperation ::= `sv.interface.modport` attr-dict $sym_name custom<ModportStructs>($ports)\n```\n\nThis operation defines a named modport within an interface. Its name is a\nsymbol that can be looked up inside its parent interface. There is an array\nof structs that contains two fields: an enum to indicate the direction of\nthe signal in the modport, and a symbol reference to refer to the signal.\n\nExample:\n\n```\nsv.interface.modport @input_port (input @data)\nsv.interface.modport @output_port (output @data)\n```\n\nTraits: `HasParent<InterfaceOp>`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `ports` | ::mlir::ArrayAttr | array of modport structs |\n\n### `sv.interface.signal` (::circt::sv::InterfaceSignalOp)\n\n*Operation to define a SystemVerilog signal for interfaces*\n\nSyntax:\n\n```\noperation ::= `sv.interface.signal` attr-dict $sym_name `:` $type\n```\n\nThis operation defines a named signal within an interface. Its type is\nspecified in an attribute, and currently supports IntegerTypes.\n\nExample:\n\n```\nsv.interface.signal @data : i32\n```\n\nTraits: `HasParent<InterfaceOp>`\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `type` | ::mlir::TypeAttr | Any SV/HW type |\n\n### `sv.interface.signal.assign` (::circt::sv::AssignInterfaceSignalOp)\n\n*Assign an interfaces signal to some other signal.*\n\nSyntax:\n\n```\noperation ::= `sv.interface.signal.assign` $iface `(` custom<IfaceTypeAndSignal>(type($iface), $signalName) `)`\n              `=` $rhs attr-dict `:` qualified(type($rhs))\n```\n\nUse this to continuously assign a signal inside an interface to a\nvalue or other signal.\n\n```\n  sv.interface.signal.assign %iface(@handshake_example::@data)\n    = %zero32 : i32\n```\n\nWould result in the following SystemVerilog:\n\n```\n  assign iface.data = zero32;\n```\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `signalName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `iface` | SystemVerilog interface type pointing to an InterfaceOp |\n| `rhs` | any type |\n\n### `sv.interface.signal.read` (::circt::sv::ReadInterfaceSignalOp)\n\n*Access the data in an interface\u2019s signal.*\n\nSyntax:\n\n```\noperation ::= `sv.interface.signal.read` $iface `(` custom<IfaceTypeAndSignal>(type($iface), $signalName) `)`\n              attr-dict `:` qualified(type($signalData))\n```\n\nThis is an expression to access a signal inside of an interface.\n\n```\n  %ifaceData = sv.interface.signal.read %iface\n      (@handshake_example::@data) : i32\n```\n\nCould result in the following SystemVerilog:\n\n```\n  wire [31:0] ifaceData = iface.data;\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `signalName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `iface` | SystemVerilog interface type pointing to an InterfaceOp |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `signalData` | any type |\n\n### `sv.localparam` (::circt::sv::LocalParamOp)\n\n*Declare a localparam*\n\nSyntax:\n\n```\noperation ::= `sv.localparam` `` custom<ImplicitSSAName>($name) attr-dict `:` qualified(type($result))\n```\n\nThe localparam operation produces a `localparam` declaration. See SV spec\n6.20.4 p125.\n\nTraits: `AlwaysSpeculatableImplTrait`, `FirstAttrDerivedResultType`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::Attribute | any attribute |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a known primitive element |\n\n### `sv.logic` (::circt::sv::LogicOp)\n\n*Define a logic*\n\nSyntax:\n\n```\noperation ::= `sv.logic` (`sym` $inner_sym^)? `` custom<ImplicitSSAName>($name) attr-dict\n              `:` qualified(type($result))\n```\n\nDeclare a SystemVerilog Variable Declaration of \u2019logic\u2019 type.\nSee SV Spec 6.8, pp100.\n\nInterfaces: `InnerSymbolOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | InOutType |\n\n### `sv.macro.decl` (::circt::sv::MacroDeclOp)\n\n*System verilog macro declaration*\n\nSyntax:\n\n```\noperation ::= `sv.macro.decl` $sym_name (`[` $verilogName^ `]`)? (`(` $args^ `)`)?  attr-dict\n```\n\nThe `sv.macro.def` declares a macro in System Verilog. This is a\ndeclaration; the body of the macro, which produces a verilog macro\ndefinition is created with a `macro.def` operation.\n\nLacking args will be a macro without \u201c()\u201d. An empty args will be an empty \u201c()\u201d.\n\nThe verilog name is the spelling of the macro when emitting verilog.\n\nInterfaces: `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `args` | ::mlir::ArrayAttr | string array attribute |\n| `verilogName` | ::mlir::StringAttr | string attribute |\n\n### `sv.macro.def` (::circt::sv::MacroDefOp)\n\n*System verilog macro definition*\n\nSyntax:\n\n```\noperation ::= `sv.macro.def` $macroName $format_string (`(` $symbols^ `)`)? attr-dict\n```\n\nThe `sv.macro.def` defines a macro in System Verilog which optionally takes\na body.\n\nThis is modeled similarly to verbatim in that the contents of the macro are\nopaque (plain string). Given the general power of macros, this op does not\ntry to capture a return type.\n\nThis operation produces a definition for the macro declaration referenced by\n`sym_name`. Argument lists are picked up from that operation.\n\nsv.macro.def allows operand substitutions with {{0}} syntax.\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `macroName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `format_string` | ::mlir::StringAttr | string attribute |\n| `symbols` | ::mlir::ArrayAttr | name reference array attribute |\n\n### `sv.macro.error` (::circt::sv::MacroErrorOp)\n\n*Produce a compilation error using the preprocessor*\n\nSyntax:\n\n```\noperation ::= `sv.macro.error` ($message^)? attr-dict\n```\n\nThe `sv.macro.error` op represents a static error in System Verilog. Since\nSystem Verilog lacks an error preprocessor directive, this is emitted as a\nreference to an undefined macro definition.\n\nWe reserve the macro prefix \\_ERROR for emitting static assertions.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `message` | ::mlir::StringAttr | string attribute |\n\n### `sv.macro.ref` (::circt::sv::MacroRefOp)\n\n*Statement to refer to a SystemVerilog macro*\n\nSyntax:\n\n```\noperation ::= `sv.macro.ref` $macroName (`(` $inputs^ `)` `:` type($inputs))? attr-dict\n```\n\nThis operation represent a statement by referencing a named macro.\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `macroName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n### `sv.macro.ref.expr` (::circt::sv::MacroRefExprOp)\n\n*Expression to refer to a SystemVerilog macro*\n\nSyntax:\n\n```\noperation ::= `sv.macro.ref.expr` $macroName `(` $inputs `)` attr-dict `:` functional-type($inputs, $result)\n```\n\nThis operation produces a value by referencing a named macro.\n\nPresently, it is assumed that the referenced macro is a constant with no\nside effects. This expression is subject to CSE. It can be duplicated\nand emitted inline by the Verilog emitter.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `macroName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a known primitive element or InOutType |\n\n### `sv.macro.ref.expr.se` (::circt::sv::MacroRefExprSEOp)\n\n*Expression to refer to a SystemVerilog macro*\n\nSyntax:\n\n```\noperation ::= `sv.macro.ref.expr.se` $macroName `(` $inputs `)` attr-dict `:` functional-type($inputs, $result)\n```\n\nThis operation produces a value by referencing a named macro.\n\nPresently, it is assumed that the referenced macro is not constant and has\nside effects. This expression is not subject to CSE. It can not be\nduplicated, but can be emitted inline by the Verilog emitter.\n\nInterfaces: `HasCustomSSAName`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `macroName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a known primitive element or InOutType |\n\n### `sv.modport.get` (::circt::sv::GetModportOp)\n\n*Get a modport out of an interface instance*\n\nSyntax:\n\n```\noperation ::= `sv.modport.get` $iface $field attr-dict `:` qualified(type($iface)) `->` qualified(type($result))\n```\n\nUse this to extract a modport view to an instantiated interface. For\nexample, to get the \u2018dataflow\\_in\u2019 modport on the \u2018handshake\\_example\u2019\ninterface:\n\n```\n%ifaceModport = sv.modport.get @dataflow_in %iface :\n  !sv.interface<@handshake_example> ->\n  !sv.modport<@handshake_example::@dataflow_in>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `field` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `iface` | SystemVerilog interface type pointing to an InterfaceOp |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | SystemVerilog type pointing to an InterfaceModportOp |\n\n### `sv.nonstandard.deposit` (::circt::sv::DepositOp)\n\n*`$deposit` system task*\n\nSyntax:\n\n```\noperation ::= `sv.nonstandard.deposit` $dest `,` $src  attr-dict `:` qualified(type($src))\n```\n\nThis system task sets the value of a net or variable, but doesn\u2019t hold it.\nThis is a common simulation vendor extension.\n\nTraits: `ProceduralOp`, `VendorExtension`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | InOutType |\n| `src` | a valid inout element |\n\n### `sv.ordered` (::circt::sv::OrderedOutputOp)\n\n*A sub-graph region which guarantees to output statements in-order*\n\nSyntax:\n\n```\noperation ::= `sv.ordered` $body attr-dict\n```\n\nThis operation groups operations into a region whose purpose is to force\nverilog emission to be statement-by-statement, in-order. This allows\nside-effecting operations, or macro expansions which applie to subsequent\noperations to be properly sequenced.\nThis operation is for non-procedural regions and its body is non-procedural.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `NonProceduralOp`, `SingleBlock`\n\n### `sv.passign` (::circt::sv::PAssignOp)\n\n*Nonblocking procedural assignment*\n\nSyntax:\n\n```\noperation ::= `sv.passign` $dest `,` $src  attr-dict `:` qualified(type($src))\n```\n\nA SystemVerilog nonblocking procedural assignment statement \u2018x <= y;\u2019.\nThese occur in initial, always, task, and function blocks. The statement\ncan be scheduled without blocking procedural flow. See SV Spec 10.4.2.\n\nTraits: `ProceduralOp`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | InOutType |\n| `src` | a valid inout element |\n\n### `sv.read_inout` (::circt::sv::ReadInOutOp)\n\n*Get the value of from something of inout type (e.g. a wire or inout port) as the value itself.*\n\nSyntax:\n\n```\noperation ::= `sv.read_inout` $input attr-dict `:` qualified(type($input))\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | InOutType |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a known primitive element |\n\n### `sv.readmem` (::circt::sv::ReadMemOp)\n\n*Load a memory from a file in either binary or hex format*\n\nSyntax:\n\n```\noperation ::= `sv.readmem` $dest `,` $filename `,` $base attr-dict `:` qualified(type($dest))\n```\n\nLoad a memory from a file using either `$readmemh` or `$readmemb` based on\nan attribute.\n\nSee Section 21.4 of IEEE 1800-2017 for more information.\n\nTraits: `ProceduralOp`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `filename` | ::mlir::StringAttr | string attribute |\n| `base` | ::MemBaseTypeAttrAttr | the numeric base of a memory file |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | InOutType |\n\n### `sv.reg` (::circt::sv::RegOp)\n\n*Define a new `reg` in SystemVerilog*\n\nSyntax:\n\n```\noperation ::= `sv.reg` (`init` $init^)? (`sym` $inner_sym^)? `` custom<ImplicitSSAName>($name) attr-dict\n              `:` qualified(type($result))\n              custom<ImplicitInitType>(ref(type($result)),ref($init), type($init))\n```\n\nDeclare a SystemVerilog Variable Declaration of \u2018reg\u2019 type.\nSee SV Spec 6.8, pp100.\n\nInterfaces: `InnerSymbolOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `init` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | InOutType |\n\n### `sv.release` (::circt::sv::ReleaseOp)\n\n*Release procedural statement*\n\nSyntax:\n\n```\noperation ::= `sv.release` $dest attr-dict `:` qualified(type($dest))\n```\n\nRelease is used in conjunction with force. When released,\nthen if the variable does not currently have an active assign\nprocedural continuous assignment, the variable shall not immediately\nchange value. The variable shall maintain its current value until\nthe next procedural assignment or procedural continuous assignment\nto the variable. Releasing a variable that currently has an\nactive assign procedural continuous assignment shall immediately\nreestablish that assignment. See SV Spec 10.6.2.\n\nTraits: `ProceduralOp`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | InOutType |\n\n### `sv.reserve_names` (::circt::sv::ReserveNamesOp)\n\n*Disallow a set of names to be used during emission*\n\nSyntax:\n\n```\noperation ::= `sv.reserve_names` $reservedNames attr-dict\n```\n\nTraits: `HasParent<mlir::ModuleOp>`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `reservedNames` | ::mlir::ArrayAttr | string array attribute |\n\n### `sv.return` (::circt::sv::ReturnOp)\n\n*Function return operation*\n\nSyntax:\n\n```\noperation ::= `sv.return` attr-dict ($operands^ `:` type($operands))?\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<FuncOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `operands` | variadic of any type |\n\n### `sv.sformatf` (::circt::sv::SFormatFOp)\n\n*\u2019$sformatf\u2019 task*\n\nSyntax:\n\n```\noperation ::= `sv.sformatf` $format_string attr-dict (`(` $substitutions^ `)` `:` qualified(type($substitutions)))?\n```\n\nThis operations represents `$sformatf` task that produces a string from\na format string and substitutions.\n\nSee section 21.3.3 of 1800-2023 for more details.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `format_string` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `substitutions` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a HW string |\n\n### `sv.stop` (::circt::sv::StopOp)\n\n*`$stop` system task*\n\nSyntax:\n\n```\noperation ::= `sv.stop` $verbosity attr-dict\n```\n\nCauses the simulation to be suspended. Does not terminate the simulator.\n\nThe optional `verbosity` parameter controls how much diagnostic information\nis printed when the system task is executed (see section 20.2 of IEEE\n1800-2017):\n\n* `0`: Prints nothing\n* `1`: Prints simulation time and location (default)\n* `2`: Prints simulation time, location, and statistics about the memory and\n  CPU time used in simulation\n\nTraits: `ProceduralOp`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `verbosity` | ::mlir::IntegerAttr | 8-bit signless integer attribute whose minimum value is 0 whose maximum value is 2 |\n\n### `sv.struct_field_inout` (::circt::sv::StructFieldInOutOp)\n\n*Create an subfield inout memory to produce an inout element.*\n\nSyntax:\n\n```\noperation ::= `sv.struct_field_inout` $input `[` $field `]` attr-dict `:` qualified(type($input))\n```\n\nSee SV Spec 7.2.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `field` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an inout type with struct field |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | InOutType |\n\n### `sv.system` (::circt::sv::SystemFunctionOp)\n\n*Simple SV System Function calls*\n\nSyntax:\n\n```\noperation ::= `sv.system` $fnName `(` $args `)` attr-dict `:` functional-type($args, $out)\n```\n\nThis operation calls the indicated system verilog system function. This\nsupports functions which take normal expression arguments.\n\nSee section 20 of the 2012 SV spec.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fnName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `args` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `out` | any type |\n\n### `sv.system.sampled` (::circt::sv::SampledOp)\n\n*`$sampled` system function to sample a value*\n\nSyntax:\n\n```\noperation ::= `sv.system.sampled` $expression attr-dict `:` qualified(type($expression))\n```\n\nSample a value using System Verilog sampling semantics (see Section 16.5.1\nof the SV 2017 specification for more information).\n\nA use of `$sampled` is to safely read the value of a net/variable in a\nconcurrent assertion action block such that the value will be the same as\nthe value used when the assertion is triggered. See Section 16.9.3 of the\nSV 2017 specification for more information.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `expression` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `sampledValue` | any type |\n\n### `sv.system.stime` (::circt::sv::STimeOp)\n\n*`$time` system function*\n\nSyntax:\n\n```\noperation ::= `sv.system.stime` attr-dict `:` type($result)\n```\n\nReturn a 32-bit integer value representing the time at which the function\nwas called.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 32-bit signless integer |\n\n### `sv.system.time` (::circt::sv::TimeOp)\n\n*`$time` system function*\n\nSyntax:\n\n```\noperation ::= `sv.system.time` attr-dict `:` type($result)\n```\n\nReturn a 64-bit integer value representing the time at which the function\nwas called.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit signless integer |\n\n### `sv.unpacked_array_create` (::circt::sv::UnpackedArrayCreateOp)\n\n*Create an unpacked array*\n\nSyntax:\n\n```\noperation ::= `sv.unpacked_array_create` $inputs attr-dict `:` functional-type($inputs, $result)\n```\n\nCreates an unpacked array from a variable set of values. One or more values must be\nlisted.\n\nSee the HW-SV rationale document for details on operand ordering.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a type without inout |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | an Unpacked ArrayType |\n\n### `sv.unpacked_open_array_cast` (::circt::sv::UnpackedOpenArrayCastOp)\n\n*Cast an unpacked array into an unpacked open array*\n\nSyntax:\n\n```\noperation ::= `sv.unpacked_open_array_cast` $input attr-dict `:` functional-type($input, $result)\n```\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | an Unpacked ArrayType |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | an Unpacked Open ArrayType |\n\n### `sv.verbatim` (::circt::sv::VerbatimOp)\n\n*Verbatim opaque text emitted inline.*\n\nSyntax:\n\n```\noperation ::= `sv.verbatim` $format_string (`(` $substitutions^ `)` `:`\n              qualified(type($substitutions)))? attr-dict\n```\n\nThis operation produces opaque text inline in the SystemVerilog output.\n\nsv.verbatim allows operand substitutions with {{0}} syntax.\n\nInterfaces: `InnerRefUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `format_string` | ::mlir::StringAttr | string attribute |\n| `symbols` | ::mlir::ArrayAttr | name reference array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `substitutions` | variadic of any type |\n\n### `sv.verbatim.expr` (::circt::sv::VerbatimExprOp)\n\n*Expression that expands to a value given SystemVerilog text*\n\nSyntax:\n\n```\noperation ::= `sv.verbatim.expr` $format_string (`(` $substitutions^ `)`)?\n              `:` functional-type($substitutions, $result) attr-dict\n```\n\nThis operation produces a typed value expressed by a string of\nSystemVerilog. This can be used to access macros and other values that are\nonly sensible as Verilog text.\n\nThe text string is expected to have the highest precedence, so you should\ninclude parentheses in the string if it isn\u2019t a single token. This is also\nassumed to not have side effects (use sv.verbatim.expr.se) if you need them.\n\nsv.verbatim.expr allows operand substitutions with {{0}} syntax.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `HasCustomSSAName`, `InnerRefUserOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `format_string` | ::mlir::StringAttr | string attribute |\n| `symbols` | ::mlir::ArrayAttr | name reference array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `substitutions` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a known primitive element or InOutType |\n\n### `sv.verbatim.expr.se` (::circt::sv::VerbatimExprSEOp)\n\n*Expression that expands to a value given SystemVerilog text*\n\nSyntax:\n\n```\noperation ::= `sv.verbatim.expr.se` $format_string (`(` $substitutions^ `)`)?\n              `:` functional-type($substitutions, $result) attr-dict\n```\n\nThis operation produces a typed value expressed by a string of\nSystemVerilog. This can be used to access macros and other values that are\nonly sensible as Verilog text.\n\nThe text string is expected to have the highest precedence, so you should\ninclude parentheses in the string if it isn\u2019t a single token. This is\nallowed to have side effects.\n\nsv.verbatim.se.expr allows operand substitutions with {{0}} syntax.\n\nInterfaces: `HasCustomSSAName`, `InnerRefUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `format_string` | ::mlir::StringAttr | string attribute |\n| `symbols` | ::mlir::ArrayAttr | name reference array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `substitutions` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | a known primitive element or InOutType |\n\n### `sv.verbatim.module` (::circt::sv::SVVerbatimModuleOp)\n\n*Verbatim verilog module*\n\nThe \u201csv.verbatim.module\u201d operation represents a the module interface of a\nverbatim verilog module. It references an \u201csv.verbatim.source\u201d operation\nthat contains the actual verilog source code.\n\nTraits: `HasParent<mlir::ModuleOp>`\n\nInterfaces: `HWModuleLike`, `InstanceGraphModuleOpInterface`, `PortList`, `SymbolUserOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `module_type` | ::mlir::TypeAttr | type attribute of a module |\n| `per_port_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `port_locs` | ::mlir::ArrayAttr | location array attribute |\n| `parameters` | ::mlir::ArrayAttr | parameter array attribute |\n| `source` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `verilogName` | ::mlir::StringAttr | string attribute |\n\n### `sv.verbatim.source` (::circt::sv::SVVerbatimSourceOp)\n\n*Verbatim verilog source*\n\nThe \u201csv.verbatim.source\u201d operation represents verbatim verilog definition for\na module which may have parameters. Concrete parametrizations and their ports\nare represented by a `hw.module.extern`.\n\nTraits: `HasParent<mlir::ModuleOp>`\n\nInterfaces: `SymbolUserOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `content` | ::mlir::StringAttr | string attribute |\n| `output_file` | ::circt::hw::OutputFileAttr | Output file attribute |\n| `parameters` | ::mlir::ArrayAttr | parameter array attribute |\n| `additional_files` | ::mlir::ArrayAttr | symbol ref array attribute |\n| `verilogName` | ::mlir::StringAttr | string attribute |\n\n### `sv.warning` (::circt::sv::WarningOp)\n\n*`$warning` severity message task*\n\nSyntax:\n\n```\noperation ::= `sv.warning` ($message^ (`(` $substitutions^ `)` `:` qualified(type($substitutions)))?)?\n              attr-dict\n```\n\nThis system task indicates a run-time warning.\n\nIf present, the optional message is printed with any additional operands\ninterpolated into the message string.\n\nTraits: `ProceduralOp`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `message` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `substitutions` | variadic of any type |\n\n### `sv.wire` (::circt::sv::WireOp)\n\n*Define a new wire*\n\nSyntax:\n\n```\noperation ::= `sv.wire` (`sym` $inner_sym^)? `` custom<ImplicitSSAName>($name) attr-dict\n              `:` qualified(type($result))\n```\n\nDeclare a SystemVerilog Net Declaration of \u2018wire\u2019 type.\nSee SV Spec 6.7, pp97.\n\nTraits: `NonProceduralOp`\n\nInterfaces: `InnerSymbolOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `inner_sym` | ::circt::hw::InnerSymAttr | Inner symbol definition |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | InOutType |\n\n### `sv.xmr` (::circt::sv::XMROp)\n\n*Encode a reference to a non-local net.*\n\nSyntax:\n\n```\noperation ::= `sv.xmr` (`isRooted` $isRooted^)? custom<XMRPath>($path, $terminal) attr-dict `:` qualified(type($result))\n```\n\nThis represents a non-local hierarchical name to a net, sometimes called a\ncross-module reference. A hierarchical name may be absolute, when prefixed\nwith \u2018$root\u2019, in which case it is resolved from the set of top-level modules\n(any non-instantiated modules). Non-absolute paths are resolved by\nattempting resolution of the path locally, then recursively up the instance\ngraph. See SV Spec 23.6, pp721.\n\nIt is impossible to completely resolve a hierarchical name without making a\nclosed-world assumption in the compiler. We therefore don\u2019t try to link\nhierarchical names to what they resolve to at compile time. A frontend\ngenerating this op should ensure that any instance or object in the intended\npath has public visibility so paths are not invalidated.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `isRooted` | ::mlir::UnitAttr | unit attribute |\n| `path` | ::mlir::ArrayAttr | string array attribute |\n| `terminal` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | InOutType |\n\n### `sv.xmr.ref` (::circt::sv::XMRRefOp)\n\n*Encode a reference to something with a hw.hierpath.*\n\nSyntax:\n\n```\noperation ::= `sv.xmr.ref` $ref ( $verbatimSuffix^ )? attr-dict `:` qualified(type($result))\n```\n\nThis represents a hierarchical path, but using something which the compiler\ncan understand. In contrast to the XMROp (which models pure Verilog\nhierarchical paths which may not map to anything knowable in the circuit),\nthis op uses a `hw.hierpath` to refer to something which exists in the\ncircuit.\n\nGenerally, this operation is always preferred for situations where\nhierarchical paths cannot be known statically and may change.\n\n`verbatimSuffix` should only be populated when the final operation on the\npath is an instance of an external module.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `ref` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `verbatimSuffix` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | InOutType |\n\nAttributes\n----------\n\n### CaseExprPatternAttr\n\n*Represents a case expression pattern*\n\nSyntax: `#sv.expr`\n\n### IncludeStyleAttr\n\n*Double-quoted local include, or angle bracketed system include*\n\nSyntax:\n\n```\n#sv.include_style<\n  ::IncludeStyle   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `::IncludeStyle` | an enum of type IncludeStyle |\n\n### MacroIdentAttr\n\n*Macro identifier*\n\nSyntax:\n\n```\n#sv.macro.ident<\n  ::mlir::FlatSymbolRefAttr   # ident\n>\n```\n\nRepresents a reference to a macro identifier.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| ident | `::mlir::FlatSymbolRefAttr` |  |\n\n### ModportDirectionAttr\n\n*Defines direction in a modport*\n\nSyntax:\n\n```\n#sv.modport_direction<\n  ::circt::sv::ModportDirection   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `::circt::sv::ModportDirection` | an enum of type ModportDirection |\n\n### ModportStructAttr\n\nSyntax:\n\n```\n#sv.mod_port<\n  ::circt::sv::ModportDirectionAttr,   # direction\n  mlir::FlatSymbolRefAttr   # signal\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| direction | `::circt::sv::ModportDirectionAttr` |  |\n| signal | `mlir::FlatSymbolRefAttr` |  |\n\n### SVAttributeAttr\n\n*A Verilog Attribute*\n\nThis attribute is used to encode a Verilog *attribute*. A Verilog attribute\n(not to be confused with an LLVM or MLIR attribute) is a syntactic mechanism\nfor adding metadata to specific declarations, statements, and expressions in\nthe Verilog language. *There are no \u201cstandard\u201d attributes*. Specific tools\ndefine and handle their own attributes.\n\nVerilog attributes have a mandatory name and an optional constant\nexpression. This is encoded as a key (name) value (expression) pair.\nMultiple attributes may be specified, either with multiple separate\nattributes or by comman-separating name\u2013expression pairs.\n\nCurrently, SV attributes don\u2019t block most optimizations; therefore, users should\nnot expect that sv attributes always appear in the output verilog.\nHowever, we must block optimizations that updating ops in-place\nsince it is mostly invalid to transfer SV attributes one to another.\n\nFor more information, refer to Section 5.12 of the SystemVerilog (1800-2017)\nspecification.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| name | `::mlir::StringAttr` |  |\n| expression | `::mlir::StringAttr` |  |\n| emitAsComment | `mlir::BoolAttr` |  |\n\n### ValidationQualifierTypeEnumAttr\n\n*Validation qualifier type*\n\nSyntax:\n\n```\n#sv.validation_qualifier<\n  ::circt::sv::ValidationQualifierTypeEnum   # value\n>\n```\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| value | `::circt::sv::ValidationQualifierTypeEnum` | an enum of type ValidationQualifierTypeEnum |\n\nType constraints\n----------------\n\n### an Unpacked Open ArrayType\n\nTypes\n-----\n\n### InterfaceType\n\n*SystemVerilog interface type pointing to an InterfaceOp*\n\nSyntax:\n\n```\n!sv.interface<\n  ::mlir::FlatSymbolRefAttr   # interface\n>\n```\n\nA MLIR type for the SV dialect\u2019s `InterfaceOp` to allow instances in any\ndialect with an open type system. Points at the InterfaceOp which defines\nthe SystemVerilog interface.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| interface | `::mlir::FlatSymbolRefAttr` |  |\n\n### ModportType\n\n*SystemVerilog type pointing to an InterfaceModportOp*\n\nSyntax:\n\n```\n!sv.modport<\n  ::mlir::SymbolRefAttr   # modport\n>\n```\n\nA MLIR type for the SV dialect\u2019s `InterfaceModportOp` to allow\ninteractions with any open type system dialect. Points at the\nInterfaceModportOp which defines the SystemVerilog interface\u2019s modport.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| modport | `::mlir::SymbolRefAttr` |  |\n\n### UnpackedOpenArrayType\n\n*SystemVerilog unpacked \u2018open\u2019 array*\n\nSyntax:\n\n```\n!sv.open_uarray<\n  ::mlir::Type   # elementType\n>\n```\n\nThis type represents unpacked \u2018open\u2019 array. Open array is a special type that can be\nused as formal arguments of DPI import statements.\n\nSee SystemVerilog Spec 35.5.6.1.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `::mlir::Type` |  |\n\nEnums\n-----\n\n### CaseStmtType\n\n*Case type*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| CaseStmt | `0` | case |\n| CaseXStmt | `1` | casex |\n| CaseZStmt | `2` | casez |\n\n### DeferAssert\n\n*Assertion deferring mode*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Immediate | `0` | immediate |\n| Observed | `1` | observed |\n| Final | `2` | final |\n\n### EventControl\n\n*Edge control trigger*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| AtPosEdge | `0` | posedge |\n| AtNegEdge | `1` | negedge |\n| AtEdge | `2` | edge |\n\n### IncludeStyle\n\n*Double-quoted local include, or angle bracketed system include*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Local | `0` | local |\n| System | `1` | system |\n\n### MemBaseTypeAttr\n\n*The numeric base of a memory file*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| MemBaseBin | `0` | MemBaseBin |\n| MemBaseHex | `1` | MemBaseHex |\n\n### ModportDirection\n\n*Defines direction in a modport*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| input | `0` | input |\n| output | `1` | output |\n| inout | `2` | inout |\n\n### ResetType\n\n*Reset type*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| NoReset | `0` | noreset |\n| SyncReset | `1` | syncreset |\n| AsyncReset | `2` | asyncreset |\n\n### ValidationQualifierTypeEnum\n\n*Validation qualifier type*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| ValidationQualifierPlain | `0` | plain |\n| ValidationQualifierUnique | `1` | unique |\n| ValidationQualifierUnique0 | `2` | unique0 |\n| ValidationQualifierPriority | `3` | priority |\n\n'sv' Dialect Docs\n-----------------\n\n* [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n\n [Prev - SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/ \"SSP Dialect Rationale\")\n[Next - SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/ \"SV Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/SV/RationaleSV/index.md"
  },
  {
    "role": "user",
    "content": "SV Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nSV Dialect Rationale\n====================\n\nThis document describes various design points of the `sv` dialect, a common\ndialect that is typically used in conjunction with the `hw` and `comb` dialects.\nPlease see the\n[HW Dialect Rationale](/docs/Dialects/HW/RationaleHW/) for high level insight\non how these work together. This follows in the spirit of\nother\n[MLIR Rationale docs](https://mlir.llvm.org/docs/Rationale/).\n\n* [SV Dialect Rationale](#sv-dialect-rationale)\n  + [Introduction to the `sv` dialect](#introduction-to-the-sv-dialect)\n  + [`sv` Type System](#sv-type-system)\n  + [Overview of `sv` dialect operations](#overview-of-sv-dialect-operations)\n  + [Statements](#statements)\n  + [Declarations](#declarations)\n  + [Expressions](#expressions)\n    - [Verbatim op](#verbatim-op)\n  + [Cost Model](#cost-model)\n  + [SV Dialect Attributes](#sv-dialect-attributes)\n\nIntroduction to the `sv` dialect\u00a0[\u00b6](#introduction-to-the-sv-dialect)\n---------------------------------------------------------------------\n\nThe `sv` dialect is one of the dialects that can be mixed into the HW dialect,\nproviding access to a range of syntactic and behavioral constructs in\nSystemVerilog. The driving focus of this dialect is to provide simple and\npredictable access to these features: it is not focused primarily on being easy\nto analyze and transform.\n\nThe `sv` dialect is designed to build on top of the `hw` dialect and is often\nused in conjunction with the `comb` or other dialects, so it does not have its\nown operations for combinational logic, modules, or other common functionality.\n\n`sv` Type System\u00a0[\u00b6](#sv-type-system)\n-------------------------------------\n\nLike the HW dialect, the SV dialect is designed to tolerate unknown types where\npossible, allowing other dialects to mix in with it. In addition to these\nexternal types, and the types used by the HW dialect, the SV dialect defines\ntypes for SystemVerilog interfaces.\n\nTODO: Describe interface types, modports, etc.\n\nOverview of `sv` dialect operations\u00a0[\u00b6](#overview-of-sv-dialect-operations)\n---------------------------------------------------------------------------\n\nBecause the SV dialect aims to align with the textual nature of SystemVerilog,\nmany of the constructs in the SV dialect have an \u201cAST\u201d style of representation.\nThe major classes of operations you\u2019ll find are:\n\n1. Statements like `sv.if`, `sv.ifdef`, `sv.always` and `sv.initial` that\n   expose primary task-like operations and the behavioral model.\n2. Procedural assignment operators, including the `sv.bpassign` and `sv.passign`\n   operators that expose the blocking (`x = y`) and non-blocking (`x <= y`)\n   procedural operators.\n3. Directives like `sv.finish` and `sv.alias` and behavioral functions like\n   `sv.fwrite`.\n4. Access to verification constructs with `sv.assert`, `sv.assume`, and\n   `sv.cover`.\n5. Escape hatches that allow direct integration of textual expressions\n   (`sv.verbatim.expr`) and full statements (`sv.verbatim`).\n\nThese operations are designed to directly model the syntax of the SystemVerilog\nlanguage and to be easily printable by the ExportVerilog pass. While there are\nstill many things in SystemVerilog that we cannot currently express in the SV\ndialect, this design makes it easy to incrementally build out new capabilities\nover time.\n\nStatements\u00a0[\u00b6](#statements)\n---------------------------\n\nTODO.\n\nDeclarations\u00a0[\u00b6](#declarations)\n-------------------------------\n\nTODO: Describe `sv.wire`, `sv.reg`,\n\nExpressions\u00a0[\u00b6](#expressions)\n-----------------------------\n\nTODO: Describe `sv.read_inout` and `sv.array_index_inout`.\n\n### Indexed Part Select\u00a0[\u00b6](#indexed-part-select)\n\nUnlike Bit-selects which extract a particular bit from integer types,\npart-select can extract several contiguous bits in a vector net, vector reg,\ninteger variable, or time variables.\n\n`SystemVerilog` supports two types of part-selects, a `constant part-select`\nand an `indexed part-select`.\nSV dialect has two ops named `sv.part_select` and `sv.part_select_inout`,\nthat is lowered to the `indexed part-select` operation.\nThe `sv.part_select` is defined on `Integer` type input and\n`sv.part_select_inout` is defined on `inout` type.\n\nPart select consists of 3 arguments, the input value,\na `width` and a `base` and an optional boolean attribute `decrement`.\nThe `width` shall be a compile-time constant expression.\nThe `base` can be a runtime integer expression.\n\nThe operation selects bits starting at the `base` and ascending\nor descending the bit range. The number of bits selected is equal to the\n`width` expression. The bit addressing is always ascending starting from the\n`base`, unless the `decrement` attribute is specified.\n\nPart-selects that address a range of bits that are completely out of the\naddress bounds of the net, reg, integer, or time, or when the part-select\nis x or z, shall yield the value x when read, and shall have no effect on\nthe data stored when written.\n\nPart-selects that are partially out of range shall when read return x for\nthe bits that are out of range, and when written shall only affect the bits\nthat are in range.\n\nIn this example, bits starting from `%c2` and of width `1` are addressed.\nHence `%0` is of width `1`.\n\n```\n%0 = sv.part_select_inout %combWire[%c2 : 1] : !hw.inout<i10>, i3, !hw.inout<i1>\n```\n\n### Verbatim op\u00a0[\u00b6](#verbatim-op)\n\nThe verbatim operation produces a typed value expressed by a string of\nSystemVerilog. This can be used to access macros and other values that are\nonly sensible as Verilog text. There are three kinds of verbatim operations:\n\n1. VerbatimOp(`sv.verbatim`), the statement form\n2. VerbatimExprOp(`sv.verbatim.expr`), the expression form.\n3. VerbatimExprSEOp(`sv.verbatim.expr.se`), the effectful expression form.\n\nFor the verbatim expression form, the text string is assumed to have the\nhighest precedence - include parentheses in the text if it isn\u2019t a single token.\n`sv.verbatim.expr` is assumed to not have side effects (is `NoSideEffect` in\nMLIR terminology), whereas `sv.verbatim.expr.se` may have side effects.\n\nVerbatim allows operand substitutions with \u2018{{0}}\u2019 syntax.\nFor macro substitution, optional operands and symbols can be added after the\nstring. Verbatim ops may also include an array of symbol references.\nThe indexing begins at 0, and if the index is greater than the\nnumber of operands, then it is used to index into the symbols array.\nIt is invalid to have macro indices greater than the total number\nof operands and symbols.\nExample,\n\n```\nsv.verbatim \"MACRO({{0}}, {{1}} reg={{4}}, {{3}})\" \n            (%add, %xor) : i8, i8\n            {symRefs = [@reg1, @Module1, @instance1]}\n```\n\nSubstitions also allow format specifier after a \u2018:\u2019. The meaning of said options\ndepends on the operand type or the operation pointed to by the symbol. So far,\nthe following format specifiers are supported:\n\n* Symbol referring to a `hw.hierpath`: the separation string for joining names\n  in the path. Defaults to \u201c.\u201d.\n\nExample:\n\n```\nhw.hierpath @instref_1 [@TopModule::@foo, @FooModule::@bar, @BarModule::@leaf]\nsv.verbatim \"hierpath {{0:|}}\" {symbols = [@instref_1]}\n// Produces: \"hierpath foo|bar|leaf\"\n```\n\nCost Model\u00a0[\u00b6](#cost-model)\n---------------------------\n\nThe SV dialect is primarily designed for human consumption, not machines. As\nsuch, transformations should aim to reduce redundancy, eliminate useless\nconstructs (e.g. eliminate empty ifdef and if blocks), etc.\n\nSV Dialect attributes\u00a0[\u00b6](#sv-dialect-attributes)\n-------------------------------------------------\n\n### `sv.namehint`\u00a0[\u00b6](#svnamehint)\n\nTODO.\n\n### `sv.attribute` and `sv.attributes`\u00a0[\u00b6](#svattribute-and-svattributes)\n\n`sv.attribute` is used to encode Verilog *attribute* that annotates metadata\nto verilog constructs. See more detail in the `sv.attribute` definition.\nWe encode SV attributes into attr-dict with the key `sv.attributes`.\nThe item of `sv.attributes` must be an ArrayAttr whose elements are `sv.attribute`.\nCurrently, SV attributes don\u2019t block most optimizations; therefore, users\nshould not expect that sv attributes always appear in the output verilog.\nHowever, in the future, we might have to re-consider blocking every optimization\nfor operations with SV attributes.\n\nExample,\n\n```\n%0 = sv.wire { sv.attributes = [#sv.attribute<\"foo\">,\n                                   #sv.attribute<\"bar\"=\"baz\">]}\n\n==>\n(* foo, bar = baz *)\nwire GEN;\n```\n\n [Prev - 'sv' Dialect](https://circt.llvm.org/docs/Dialects/SV/ \"'sv' Dialect\")\n[Next - 'synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/ \"'synth' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect-](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Synth/index.md"
  },
  {
    "role": "user",
    "content": "'synth' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'synth' Dialect\n===============\n\n*Synthesis dialect for logic synthesis operations*\n\nThe Synth dialect provides operations and types for logic synthesis,\nincluding meta operations for synthesis decisions, logic representations\nlike AIG and MIG, and synthesis pipeline infrastructure.\n\n* [Operations](#operations)\n  + [`synth.aig.and_inv` (::circt::synth::aig::AndInverterOp)](#synthaigand_inv-circtsynthaigandinverterop)\n  + [`synth.mig.maj_inv` (::circt::synth::mig::MajorityInverterOp)](#synthmigmaj_inv-circtsynthmigmajorityinverterop)\n\nOperations\n----------\n\n### `synth.aig.and_inv` (::circt::synth::aig::AndInverterOp)\n\n*AIG dialect AND operation*\n\nSyntax:\n\n```\noperation ::= `synth.aig.and_inv` custom<VariadicInvertibleOperands>($inputs, type($result), $inverted, attr-dict)\n```\n\nThe `synth.aig.and_inv` operation represents an And-Inverter in the AIG dialect.\nUnlike `comb.and`, operands can be inverted respectively.\n\nExample:\n\n```\n  %r1 = synth.aig.and_inv %a, %b: i3\n  %r2 = synth.aig.and_inv not %a, %b, not %c : i3\n  %r3 = synth.aig.and_inv not %a : i3\n```\n\nTraditionally, an And-Node in AIG has two operands. However, `synth.aig.and_inv`\nextends this concept by allowing variadic operands and non-i1 integer types.\nAlthough the final stage of the synthesis pipeline requires lowering\neverything to i1-binary operands, it\u2019s more efficient to progressively lower\nthe variadic multibit operations.\n\nVariadic operands have demonstrated their utility in low-level optimizations\nwithin the `comb` dialect. Furthermore, in synthesis, it\u2019s common practice\nto re-balance the logic path. Variadic operands enable the compiler to\nselect more efficient solutions without the need to traverse binary trees\nmultiple times.\n\nThe ability to represent multibit operations during synthesis is crucial for\nscalability. This approach enables a form of vectorization, allowing for\nbatch processing of logic synthesis when multibit operations are constructed\nin a similar manner.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inverted` | ::mlir::DenseBoolArrayAttr | i1 dense array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `synth.mig.maj_inv` (::circt::synth::mig::MajorityInverterOp)\n\n*Majority-Inverter operation*\n\nSyntax:\n\n```\noperation ::= `synth.mig.maj_inv` custom<VariadicInvertibleOperands>($inputs, type($result), $inverted,\n              attr-dict)\n```\n\nThe `synth.mig.maj_inv` operation represents a Majority-Inverter in the\nSynth dialect. This is used to represent majority inverter graph in\nsynthesis. This operation computes the majority function of its inputs,\nwhere operands can be inverted respectively.\n\nThe majority function returns 1 when more than half of the inputs are 1,\nand 0 otherwise. For three inputs, it\u2019s equivalent to:\n(a & b) | (a & c) | (b & c).\n\nExample:\n\n```\n  %r1 = synth.mig.maj_inv %a, %b, %c : i1\n  %r2 = synth.mig.maj_inv not %a, %b, not %c : i1\n  %r3 = synth.mig.maj_inv %a, %b, %c, %d, %e : i3\n```\n\nThe number of inputs must be odd to avoid ties.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inverted` | ::mlir::DenseBoolArrayAttr | i1 dense array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n'synth' Dialect Docs\n--------------------\n\n* ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n* [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n\n [Prev - SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/ \"SV Dialect Rationale\")\n[Next - 'synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/ \"'synth' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [Talks and Related Publications](https://circt.llvm.org/talks/)\n      * [Getting Started](https://circt.llvm.org/getting_started/)\n      * [Code Documentation-](https://circt.llvm.org/docs/)\n        + [Tools+](https://circt.llvm.org/docs/Tools/)\n        + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n        + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n          - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n          - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n          - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n          - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n            * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n          - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n            * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n          - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n            * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n          - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n            * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n          - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n            * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n            * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n            * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n            * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n            * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n          - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n            * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n            * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n            * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n          - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n            * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n          - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n            * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n          - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n            * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n          - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n            * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n          - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n            * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n          - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n            * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n          - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n          - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n            * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n          - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n            * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n          - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n          - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n            * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n          - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n            * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n          - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n            * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n          - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n            * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n            * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n          - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n            * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n          - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n          - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n            * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n          - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n          - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n          - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n          - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n          - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n          - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n          - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n        + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n        + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n        + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n        + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n        + [Passes](https://circt.llvm.org/docs/Passes/)\n        + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n          - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n          - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n        + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n        + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n        + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n        + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Synth/RationaleSynth/index.md"
  },
  {
    "role": "user",
    "content": "'synth' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'synth' Dialect\n===============\n\nThis document outlines the rationale of the Synth dialect, a dialect for logic synthesis which includes boolean operations specifically designed for logic synthesis such as and-inverter and majority-inverter.\n\n* [Rationale](#rationale)\n  + [Logic Representations: AIG and MIG](#logic-representations-aig-and-mig)\n  + [Why use the Synth dialect instead of the `comb` dialect?](#why-use-the-synth-dialect-instead-of-the-comb-dialect)\n\nRationale\u00a0[\u00b6](#rationale)\n-------------------------\n\n### Logic Representations: AIG and MIG\u00a0[\u00b6](#logic-representations-aig-and-mig)\n\nAIG (And-Inverter Graph) and MIG (Majority-Inverter Graph) have emerged as fundamental representations in logic synthesis. AIG represents Boolean functions using only AND gates with optional input inversions, providing a canonical and efficient representation that has been the foundation of synthesis tools like ABC for decades. Recent research trends have explored MIG as an alternative representation using majority gates (3-input gates that output the majority value) with optional input inversions, which can represent some functions more compactly than AIG and enables novel optimization strategies, particularly for arithmetic circuits and emerging computing paradigms.\n\nCIRCT synthesis pipeline is designed to support both AIG and MIG, and can be extended to support other representations in the future.\n\n### Why use the Synth dialect instead of the `comb` dialect?\u00a0[\u00b6](#why-use-the-synth-dialect-instead-of-the-comb-dialect)\n\nAnd-Inverter Graphs have proven to be a scalable approach for logic synthesis, serving as the underlying data structure for ABC, one of the most performant open-source logic synthesis tools.\n\nWhile it\u2019s technically possible to represent `synth.aig.and_inv` using a combination of `comb.and`, `comb.xor`, and `hw.constant`, the ability to represent everything with `synth.aig.and_inv` offers significant advantages. This unified representation simplifies complex analyses such as path retiming and area analysis, as well as logic mappings. Moreover, it allows for direct application of existing AIG research results and tools, further enhancing its utility in the synthesis process.\n\n [Prev - 'synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/ \"'synth' Dialect\")\n[Next - Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/ \"Synth Longest Path Analysis\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect-](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/index.md"
  },
  {
    "role": "user",
    "content": "Synth Longest Path Analysis - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nSynth Longest Path Analysis\n===========================\n\nThis document describes the longest path analysis for the Synth dialect, which calculates the maximum delay through combinational paths in a circuit where Synth primitive operations are considered to have a unit delay.\n\n* [Overview](#overview)\n* [Design](#design)\n* [Implementation Details](#implementation-details)\n  + [Data Structures](#data-structures)\n  + [Algorithm](#algorithm)\n* [Usage](#usage)\n  + [Analysis Interface](#analysis-interface)\n\nOverview\u00a0[\u00b6](#overview)\n-----------------------\n\nThe longest path analysis is a static analysis that computes the maximum delay from inputs to outputs in a circuit. It is particularly useful for:\n\n1. Identifying critical paths in a design\n2. Estimating circuit performance\n3. Guiding optimization passes to focus on high-delay paths\n\nThe analysis treats each primitive logic operation as having a unit delay (1), and calculates the maximum delay through all possible paths in the circuit.\n\nDesign\u00a0[\u00b6](#design)\n-------------------\n\nThe longest path analysis is by nature very expensive analysis:\n\n* Dataflow must be tracked in a bit-sensitive manner\n* The analysis must handle module instances and hierarchies\n* The dataflow graph can be very large, especially for multi core designs with deep hierarchies and wide datapaths\n* The analysis must provide debuggable information if requested.\n\nTo make the analysis tractable, we use several techniques:\n\n* Redundant Path Elimination: If a path is closed under specific hierarchical context, it\u2019s not necessary to propagate it its parents.\n* Graph Parallelism: The analysis is designed to be executed in parallel across the instance graph. Each module is analyzed independently, and the results are combined across the hierarchy.\n* Early pruning of paths: Paths that are known to be not part of the longest paths are pruned early.\n\nImplementation Details\u00a0[\u00b6](#implementation-details)\n---------------------------------------------------\n\n### Data Structures\u00a0[\u00b6](#data-structures)\n\nThe analysis uses several key data structures:\n\n* **Object**: Represents a specific bit of a value at a specific instance path\n* **OpenPath**: Represents an open path from a fan-in with an associated delay\n* **DataflowPath**: Represents a complete path from a fanout to a fanin\n* **DebugPoint**: Provides debug information for a point in the path\n\n### Algorithm\u00a0[\u00b6](#algorithm)\n\nThe analysis works by:\n\n1. Traverse instance graph in post-order\n2. Walk operations, and start tracing from fanOuts (FFs and module outputs)\n3. Following combinational paths through logic operations\n4. Computing the maximum delay to each point in the circuit\n5. Recording the paths with their associated delays\n6. 1-5 are parallelly executed across all modules in the design\n\nFor each operation, the analysis:\n\n* Computes the delay as the maximum of input delays plus the operation\u2019s delay\n* Records the path information including the source, sink, and intermediate points\n* Handles multi-bit values by analyzing each bit position separately\n\nUsage\u00a0[\u00b6](#usage)\n-----------------\n\n### Analysis Interface\u00a0[\u00b6](#analysis-interface)\n\nThe `LongestPathAnalysis` class provides the following key methods:\n\n#### Core Query Methods\u00a0[\u00b6](#core-query-methods)\n\n* `getResults(Value, size_t, SmallVectorImpl<DataflowPath>&)`: Gets all paths to the given value and bit position.\n* `getAverageMaxDelay(Value)`: Returns the average of maximum delays across all bits of a value\n* `isAnalysisAvailable(StringAttr)`: Checks if analysis is available for a module\n\n#### Path Query Methods\u00a0[\u00b6](#path-query-methods)\n\n* `getInternalPaths(StringAttr, SmallVectorImpl<DataflowPath>&, bool elaboratePaths = false)`: Gets all closed paths (register-to-register) in a module\n* `getOpenPathsFromInputPortsToInternal(StringAttr, SmallVectorImpl<DataflowPath>&)`: Gets open paths from module input ports to internal sequential elements\n* `getOpenPathsFromInternalToOutputPorts(StringAttr, SmallVectorImpl<DataflowPath>&)`: Gets open paths from internal sequential elements to module output ports\n* `getAllPaths(StringAttr, SmallVectorImpl<DataflowPath>&, bool elaboratePaths = false)`: Convenience method that combines all path types\n\n#### Hierarchical Path Support\u00a0[\u00b6](#hierarchical-path-support)\n\nThe analysis now supports hierarchical path elaboration through the `elaboratePaths` parameter. When enabled, paths include full hierarchical instance information across module boundaries, providing complete visibility into timing paths in hierarchical designs.\n\n [Prev - 'synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/ \"'synth' Dialect\")\n[Next - 'systemc' Dialect](https://circt.llvm.org/docs/Dialects/SystemC/ \"'systemc' Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect-](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/SystemC/index.md"
  },
  {
    "role": "user",
    "content": "'systemc' Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\n'systemc' Dialect\n=================\n\n*Types and operations for the SystemC dialect*\n\nThis dialect defines the `systemc` dialect, which represents various\nconstructs of the SystemC library (IEEE 1666-2011) useful for emission.\n\n* [Operations](#operations)\n  + [`systemc.convert` (::circt::systemc::ConvertOp)](#systemcconvert-circtsystemcconvertop)\n  + [`systemc.cpp.assign` (::circt::systemc::AssignOp)](#systemccppassign-circtsystemcassignop)\n  + [`systemc.cpp.call` (::circt::systemc::CallOp)](#systemccppcall-circtsystemccallop)\n  + [`systemc.cpp.call_indirect` (::circt::systemc::CallIndirectOp)](#systemccppcall_indirect-circtsystemccallindirectop)\n  + [`systemc.cpp.delete` (::circt::systemc::DeleteOp)](#systemccppdelete-circtsystemcdeleteop)\n  + [`systemc.cpp.destructor` (::circt::systemc::DestructorOp)](#systemccppdestructor-circtsystemcdestructorop)\n  + [`systemc.cpp.func` (::circt::systemc::FuncOp)](#systemccppfunc-circtsystemcfuncop)\n  + [`systemc.cpp.member_access` (::circt::systemc::MemberAccessOp)](#systemccppmember_access-circtsystemcmemberaccessop)\n  + [`systemc.cpp.new` (::circt::systemc::NewOp)](#systemccppnew-circtsystemcnewop)\n  + [`systemc.cpp.return` (::circt::systemc::ReturnOp)](#systemccppreturn-circtsystemcreturnop)\n  + [`systemc.cpp.variable` (::circt::systemc::VariableOp)](#systemccppvariable-circtsystemcvariableop)\n  + [`systemc.ctor` (::circt::systemc::CtorOp)](#systemcctor-circtsystemcctorop)\n  + [`systemc.func` (::circt::systemc::SCFuncOp)](#systemcfunc-circtsystemcscfuncop)\n  + [`systemc.instance.bind_port` (::circt::systemc::BindPortOp)](#systemcinstancebind_port-circtsystemcbindportop)\n  + [`systemc.instance.decl` (::circt::systemc::InstanceDeclOp)](#systemcinstancedecl-circtsystemcinstancedeclop)\n  + [`systemc.interop.verilated` (::circt::systemc::InteropVerilatedOp)](#systemcinteropverilated-circtsystemcinteropverilatedop)\n  + [`systemc.method` (::circt::systemc::MethodOp)](#systemcmethod-circtsystemcmethodop)\n  + [`systemc.module` (::circt::systemc::SCModuleOp)](#systemcmodule-circtsystemcscmoduleop)\n  + [`systemc.sensitive` (::circt::systemc::SensitiveOp)](#systemcsensitive-circtsystemcsensitiveop)\n  + [`systemc.signal` (::circt::systemc::SignalOp)](#systemcsignal-circtsystemcsignalop)\n  + [`systemc.signal.read` (::circt::systemc::SignalReadOp)](#systemcsignalread-circtsystemcsignalreadop)\n  + [`systemc.signal.write` (::circt::systemc::SignalWriteOp)](#systemcsignalwrite-circtsystemcsignalwriteop)\n  + [`systemc.thread` (::circt::systemc::ThreadOp)](#systemcthread-circtsystemcthreadop)\n* [Type constraints](#type-constraints)\n  + [a SystemC sc\\_bigint type](#a-systemc-sc_bigintw-type)\n  + [a SystemC sc\\_biguint type](#a-systemc-sc_biguintw-type)\n  + [a SystemC sc\\_bv\\_base type](#a-systemc-sc_bv_base-type)\n  + [a SystemC sc\\_bv type](#a-systemc-sc_bvw-type)\n  + [a SystemC sc\\_int\\_base type](#a-systemc-sc_int_base-type)\n  + [a SystemC sc\\_int type](#a-systemc-sc_intw-type)\n  + [a SystemC sc\\_lv\\_base type](#a-systemc-sc_lv_base-type)\n  + [a SystemC sc\\_lv type](#a-systemc-sc_lvw-type)\n  + [FunctionType with no inputs and results](#functiontype-with-no-inputs-and-results)\n  + [a SystemC sc\\_signed type](#a-systemc-sc_signed-type)\n  + [a SystemC sc\\_uint\\_base type](#a-systemc-sc_uint_base-type)\n  + [a SystemC sc\\_uint type](#a-systemc-sc_uintw-type)\n  + [a SystemC sc\\_unsigned type](#a-systemc-sc_unsigned-type)\n  + [a SystemC sc\\_value\\_base type](#a-systemc-sc_value_base-type)\n* [Types](#types)\n  + [InOutType](#inouttype)\n  + [InputType](#inputtype)\n  + [LogicType](#logictype)\n  + [ModuleType](#moduletype)\n  + [OutputType](#outputtype)\n  + [SignalType](#signaltype)\n* [Enums](#enums)\n  + [MemberAccessKind](#memberaccesskind)\n\nOperations\n----------\n\n### `systemc.convert` (::circt::systemc::ConvertOp)\n\n*Converts between various integer and bit vector types.*\n\nSyntax:\n\n```\noperation ::= `systemc.convert` $input attr-dict `:` functional-type($input, $result)\n```\n\nAllows conversions between the various integer and bit vector types in\nSystemC, including MLIRs signless integers that are used to represent the\nprimitive C integer types, according to the explicit and implicit\nconstructors, implicit access operators and explicit conversion member\nfunctions defined in the respective data type class in the SystemC spec\n(refer to the description of the supported types and the spec chapters\nlisted there for more information).\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | integer or a SystemC sc\\_value\\_base type or signless integer or a SystemC sc\\_bv\\_base type or a SystemC sc\\_bv type or a SystemC sc\\_lv\\_base type or a SystemC sc\\_lv type or a SystemC sc\\_logic type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | integer or a SystemC sc\\_value\\_base type or signless integer or a SystemC sc\\_bv\\_base type or a SystemC sc\\_bv type or a SystemC sc\\_lv\\_base type or a SystemC sc\\_lv type or a SystemC sc\\_logic type |\n\n### `systemc.cpp.assign` (::circt::systemc::AssignOp)\n\n*A C++ assignment.*\n\nSyntax:\n\n```\noperation ::= `systemc.cpp.assign` $dest `=` $source attr-dict `:` type($dest)\n```\n\nAssigns one SSA value to another. Note that there is no notion of lvalues\nand rvalues. This means that one can assign to a value that is the result\nof, e.g., an addition, which is not allowed in C++. It is the responsibility\nof the user and the implementor of a lowering pass that creates this\noperation to make sure that the operands are valid according to C++\nsemantics. Rationale for that: implementing these constraints would add\nquite some complexity, but still does not guarantee that the assignment\nis valid because we also make use of non-verifyable verbatim types, etc.\n\nTraits: `SameTypeOperands`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | any type |\n| `source` | any type |\n\n### `systemc.cpp.call` (::circt::systemc::CallOp)\n\n*Call operation*\n\nSyntax:\n\n```\noperation ::= `systemc.cpp.call` $callee `(` $callee_operands `)` attr-dict `:`\n              functional-type($callee_operands, $results)\n```\n\nThe `systemc.cpp.call` operation represents a direct call to a function that\nis within the same symbol scope as the call. The operands and result types\nof the call must match the specified function type. The callee is encoded as\na symbol reference attribute named \u201ccallee\u201d.\n\nExample:\n\n```\n%2 = systemc.cpp.call @my_add(%0, %1) : (i32, i32) -> i32\n```\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `callee` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `callee_operands` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `systemc.cpp.call_indirect` (::circt::systemc::CallIndirectOp)\n\n*Indirect call operation*\n\nSyntax:\n\n```\noperation ::= `systemc.cpp.call_indirect` $callee `(` $callee_operands `)` attr-dict `:` type($callee)\n```\n\nThe `systemc.cpp.call_indirect` operation represents an indirect call to a\nvalue of function type. The operands and result types of the call must match\nthe specified function type.\n\nExample:\n\n```\n%func = systemc.cpp.member_access %object dot \"func\" : () -> i32\n%result = systemc.cpp.call_indirect %func() : () -> i32\n```\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `callee` | function type |\n| `callee_operands` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `systemc.cpp.delete` (::circt::systemc::DeleteOp)\n\n*A C++ delete expression.*\n\nSyntax:\n\n```\noperation ::= `systemc.cpp.delete` $pointer attr-dict `:` qualified(type($pointer))\n```\n\nDestroys objects previously allocated by the new expression and releases\nthe allocated memory.\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `pointer` | EmitC pointer type |\n\n### `systemc.cpp.destructor` (::circt::systemc::DestructorOp)\n\n*A C++ destructor definition.*\n\nSyntax:\n\n```\noperation ::= `systemc.cpp.destructor` attr-dict-with-keyword $body\n```\n\nThis operation models a C++ destructor of a class or struct. It is not an\noperation modelling some abstract SystemC construct, but still required to\nsupport more complex functionality such as having a pointer to an external\nobject inside a SystemC module, e.g., for interoperability purposes.\n\nTraits: `HasParent<SCModuleOp>`, `NoTerminator`, `SingleBlock`\n\n### `systemc.cpp.func` (::circt::systemc::FuncOp)\n\n*An operation with a name containing a single `SSACFG` region*\n\nOperations within the function cannot implicitly capture values defined\noutside of the function, i.e. Functions are `IsolatedFromAbove`. All\nexternal references must use function arguments or attributes that establish\na symbolic connection (e.g. symbols referenced by name via a string\nattribute like SymbolRefAttr). An external function declaration (used when\nreferring to a function declared in some other module) has no body. While\nthe MLIR textual form provides a nice inline syntax for function arguments,\nthey are internally represented as \u201cblock arguments\u201d to the first block in\nthe region.\n\nArgument names are stored in a \u2018argNames\u2019 attribute, but used directly as\nthe SSA value\u2019s names. They are verified to be unique and can be used to\nprint them, e.g., as C function argument names.\n\nOnly dialect attribute names may be specified in the attribute dictionaries\nfor function arguments, results, or the function itself.\n\nExample:\n\n```\n// External function definitions.\nsystemc.cpp.func @abort()\nsystemc.cpp.func externC @scribble(i32, i64) -> i64\n\n// A function that returns its argument twice:\nsystemc.cpp.func @count(%argumentName: i64) -> (i64, i64) {\n  return %argumentName, %argumentName: i64, i64\n}\n\n// A function with an attribute\nsystemc.cpp.func @exampleFnAttr() attributes {dialectName.attrName = false}\n```\n\nTraits: `AutomaticAllocationScope`, `IsolatedFromAbove`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallableOpInterface`, `FunctionOpInterface`, `OpAsmOpInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `function_type` | ::mlir::TypeAttr | type attribute of function type |\n| `arg_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `res_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `argNames` | ::mlir::ArrayAttr | string array attribute |\n| `externC` | ::mlir::UnitAttr | unit attribute |\n| `sym_visibility` | ::mlir::StringAttr | string attribute |\n\n### `systemc.cpp.member_access` (::circt::systemc::MemberAccessOp)\n\n*A C++ member access expression.*\n\nSyntax:\n\n```\noperation ::= `systemc.cpp.member_access` $object $accessKind $memberName attr-dict `:`\n              functional-type($object, $result)\n```\n\nRepresents the C++ member access operators `.` and `->`.\nThe member name is passed as a plain string and is not checked for validity.\nAdditional qualifications (`A::E1`) or template disambiguation\n(`template E1`) can be manually added to this plain member name string for\nemission.\nThe type of the object and result cannot be verified as it is allowed to use\nvarbatim types such as `emitc.opaque`.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `memberName` | ::mlir::StringAttr | string attribute |\n| `accessKind` | ::MemberAccessKindAttr | C++ member access kind |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `object` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `systemc.cpp.new` (::circt::systemc::NewOp)\n\n*A C++ \u2019new\u2019 expression.*\n\nSyntax:\n\n```\noperation ::= `systemc.cpp.new` `(` $args `)` attr-dict `:` functional-type($args, $result)\n```\n\nCreates and initializes C++ objects using dynamic storage.\nNote that the types of the constructor arguments are not verified in any way\nw.r.t. the result\u2019s type because it is allowed to use an opaque type for the\npointee.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `args` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | EmitC pointer type |\n\n### `systemc.cpp.return` (::circt::systemc::ReturnOp)\n\n*Function return operation*\n\nSyntax:\n\n```\noperation ::= `systemc.cpp.return` attr-dict ($returnValues^ `:` type($returnValues))?\n```\n\nThe `systemc.cpp.return` operation represents a return operation within a\nfunction. The operand number and types must match the signature of the\nfunction that contains the operation.\n\nExample:\n\n```\nsystemc.cpp.func @foo() : i32 {\n  ...\n  systemc.cpp.return %0 : i32\n}\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<systemc::FuncOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `returnValues` | variadic of any type |\n\n### `systemc.cpp.variable` (::circt::systemc::VariableOp)\n\n*Declare a C++ variable with optional initialization value.*\n\nDeclares a variable according to C++ semantics. If an initialization value\nis present, the variable will be assigned that value at the declaration,\ne.g, `int varname = 0;`.\n\nInterfaces: `HasCustomSSAName`, `SystemCNameDeclOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `init` | any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `variable` | any type |\n\n### `systemc.ctor` (::circt::systemc::CtorOp)\n\n*A constructor definition.*\n\nSyntax:\n\n```\noperation ::= `systemc.ctor` attr-dict-with-keyword $body\n```\n\nRepresents the SC\\_CTOR macro as described in IEEE 1666-2011 \u00a75.2.7.\nThe name of the module being constructed does not have to be passed\nto this operation, but is automatically added during emission.\n\nTraits: `HasParent<SCModuleOp>`, `NoTerminator`, `SingleBlock`\n\n### `systemc.func` (::circt::systemc::SCFuncOp)\n\n*A (void)->void member function of a SC\\_MODULE.*\n\nSyntax:\n\n```\noperation ::= `systemc.func` `` custom<ImplicitSSAName>($name) attr-dict-with-keyword $body\n```\n\nThis operation does not represent a specific SystemC construct, but a\nregular C++ member function with no arguments and a void return type.\nThese are used to implement module-internal logic and are registered to the\nmodule using the SC\\_METHOD, SC\\_THREAD, and SC\\_CTHREAD macros.\n\nTraits: `HasParent<SCModuleOp>`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `HasCustomSSAName`, `InferTypeOpInterface`, `SystemCNameDeclOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `handle` | FunctionType with no inputs and results |\n\n### `systemc.instance.bind_port` (::circt::systemc::BindPortOp)\n\n*Binds a port of a module instance to a channel.*\n\nThe ports of a submodule have to be bound to channels in a module further\nup in the instance hierarchy (as opposed to `sc_export` where the channel\nhas to reside in the same module or a submodule). Therefore, a port can be\nbound to either a signal declared by the `systemc.signal` operation or to\na port with matching direction (and thus bound to a channel further up in\nthe hierarchy).\nMore information on ports can be found in IEEE 1666-2011 \u00a75.12.,\nin particular IEEE 1666-2011 \u00a75.12.7. is about port binding.\nMore information on predefined channels can be found in IEEE 1666-2011 \u00a76.\n\nTraits: `HasParent<CtorOp>`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `portId` | ::mlir::IntegerAttr | index attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `instance` | a SystemC module type |\n| `channel` | a SystemC sc\\_in type or a SystemC sc\\_inout type or a SystemC sc\\_out type or a SystemC sc\\_signal type |\n\n### `systemc.instance.decl` (::circt::systemc::InstanceDeclOp)\n\n*Declares a SystemC module instance.*\n\nSyntax:\n\n```\noperation ::= `systemc.instance.decl` custom<ImplicitSSAName>($name) $moduleName attr-dict\n              `:` qualified(type($instanceHandle))\n```\n\nDeclares an instantiation of a SystemC module inside another SystemC module\nby value. The instance handle returned by this operation can then be used\nto initialize it in the constructor and to access its fields.\nMore information can be found in IEEE 1666-2011 \u00a74.1.1.\n\nTraits: `HasParent<SCModuleOp>`\n\nInterfaces: `HasCustomSSAName`, `InstanceOpInterface`, `SymbolUserOpInterface`, `SystemCNameDeclOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `moduleName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `instanceHandle` | a SystemC module type |\n\n### `systemc.interop.verilated` (::circt::systemc::InteropVerilatedOp)\n\n*Instantiates a verilated module.*\n\nSyntax:\n\n```\noperation ::= `systemc.interop.verilated` $instanceName $moduleName\n              custom<InputPortList>($inputs, type($inputs), $inputNames) `->`\n              custom<OutputPortList>(type($results), $resultNames) attr-dict\n```\n\nInstantiates a verilated module represented by a hw.module operation\n(usually the extern variant).\n\nThis operation also encodes the interoparability layer to connect its\ncontext (i.e. the surrounding operation, input values, result values, and\ntypes) to the C++ code of the verilated module.\nWhen residing in a context that understands C++ (e.g., inside a SystemC\nmodule), this refers to the instantiation of the class, assignment of the\ninput ports, the call to the eval() function and reading the output ports.\n\nAdditionally, properties of the verilated module can be specified in\na config attribute which influences the interop layer code generation\n(not yet implemented).\n\nInterfaces: `OpAsmOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `instanceName` | ::mlir::StringAttr | string attribute |\n| `moduleName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `inputNames` | ::mlir::ArrayAttr | string array attribute |\n| `resultNames` | ::mlir::ArrayAttr | string array attribute |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `systemc.method` (::circt::systemc::MethodOp)\n\n*Represents the SystemC SC\\_METHOD macro.*\n\nSyntax:\n\n```\noperation ::= `systemc.method` $funcHandle attr-dict\n```\n\nRepresents the SC\\_METHOD macro as described in IEEE 1666-2011 \u00a75.2.9.\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `funcHandle` | FunctionType with no inputs and results |\n\n### `systemc.module` (::circt::systemc::SCModuleOp)\n\n*Define a SystemC SC\\_MODULE.*\n\nRepresents the SC\\_MODULE macro as described in IEEE 1666-2011 \u00a75.2.5.\nModels input, output and inout ports as module arguments (as opposed to\n`sc_signal`s which are modeled by a separate `systemc.signal` operation),\nbut are nonetheless emitted as regular struct fields.\n\nTraits: `HasParent<mlir::ModuleOp>`, `IsolatedFromAbove`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallableOpInterface`, `FunctionOpInterface`, `ModuleOpInterface`, `OpAsmOpInterface`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `function_type` | ::mlir::TypeAttr | type attribute of function type |\n| `arg_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `res_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `portNames` | ::mlir::ArrayAttr | string array attribute |\n\n### `systemc.sensitive` (::circt::systemc::SensitiveOp)\n\n*Describes the static sensitivity of an unspawned process.*\n\nSyntax:\n\n```\noperation ::= `systemc.sensitive` $sensitivities attr-dict ( `:` qualified(type($sensitivities))^ )?\n```\n\nThis operation allows to specify the static sensitivity of unspawned\nprocesses. An unspawned process is one created by the `SC_METHOD`,\n`SC_THREAD`, or `SC_CTHREAD` macro. The operands to this operation are\nregistered as sensitivities to the process last created (in control-flow\norder).\nEach `SC_MODULE` contains an instance of the `sc_sensitive` class to do the\nregistration. For a description of the `sc_sensitive` class refer to\nIEEE 1666-2011 \u00a75.4. For a description of the `sensitive` data member of\n`SC_MODULE` refer to IEEE 1666-2011 \u00a75.2.14.\n\nTraits: `HasParent<CtorOp>`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `sensitivities` | variadic of a SystemC sc\\_in type or a SystemC sc\\_inout type or a SystemC sc\\_out type or a SystemC sc\\_signal type |\n\n### `systemc.signal` (::circt::systemc::SignalOp)\n\n*Declares a SystemC `sc_signal<T>`.*\n\nSyntax:\n\n```\noperation ::= `systemc.signal` custom<ImplicitSSAName>($name) ( `named` $named^ )? attr-dict\n              `:` qualified(type($signal))\n```\n\nRepresents the `sc_signal` template as described in IEEE 1666-2011 \u00a76.4.\nAdding the \u2019named\u2019 attribute will lead to the signal being emitted with the\n`SC_NAMED` convenience macro. Note that this macro is not part of\nIEEE 1666-2011, but was added in version 2.3.3.\n\nTraits: `HasParent<SCModuleOp>`\n\nInterfaces: `HasCustomSSAName`, `SystemCNameDeclOpInterface`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `named` | ::mlir::UnitAttr | unit attribute |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `signal` | a SystemC sc\\_signal type |\n\n### `systemc.signal.read` (::circt::systemc::SignalReadOp)\n\n*Returns the current value of a signal or port.*\n\nSyntax:\n\n```\noperation ::= `systemc.signal.read` $input attr-dict `:` qualified(type($input))\n```\n\nRepresents the member function `const T& read() const;` and operator\n`operator const T& () const;` of class `sc_signal` as described in\nIEEE 1666-2011 \u00a76.4.7., of class `sc_in` as described in \u00a76.8.3., and\nof class `sc_inout` as decribed in \u00a76.10.3. It shall return the current\nvalue of the signal/port.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `input` | a SystemC sc\\_in type or a SystemC sc\\_inout type or a SystemC sc\\_signal type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `systemc.signal.write` (::circt::systemc::SignalWriteOp)\n\n*Writes a value to a signal or port.*\n\nSyntax:\n\n```\noperation ::= `systemc.signal.write` $dest `,` $src attr-dict `:` qualified(type($dest))\n```\n\nRepresents the member function `void write(const T&);` and several variants\nof the operator `operator=` of class `sc_signal` as described in\nIEEE 1666-2011 \u00a76.4.8., of class `sc_inout` as described in \u00a76.10.3., and of\nclass `sc_out` as decribed in \u00a76.12.3. It shall modify the value of the\nsignal/port such that it appears to have the new value (as observed using\nthe `sytemc.signal.read` operation) in the next delta cycle but not before\nthen.\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `dest` | a SystemC sc\\_out type or a SystemC sc\\_inout type or a SystemC sc\\_signal type |\n| `src` | any type |\n\n### `systemc.thread` (::circt::systemc::ThreadOp)\n\n*Represents the SystemC SC\\_THREAD macro.*\n\nSyntax:\n\n```\noperation ::= `systemc.thread` $funcHandle attr-dict\n```\n\nRepresents the SC\\_THREAD macro as described in IEEE 1666-2011 \u00a75.2.9.\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `funcHandle` | FunctionType with no inputs and results |\n\nType constraints\n----------------\n\n### a SystemC sc\\_bigint type\n\n### a SystemC sc\\_biguint type\n\n### a SystemC sc\\_bv\\_base type\n\n### a SystemC sc\\_bv type\n\n### a SystemC sc\\_int\\_base type\n\n### a SystemC sc\\_int type\n\n### a SystemC sc\\_lv\\_base type\n\n### a SystemC sc\\_lv type\n\n### FunctionType with no inputs and results\n\n### a SystemC sc\\_signed type\n\n### a SystemC sc\\_uint\\_base type\n\n### a SystemC sc\\_uint type\n\n### a SystemC sc\\_unsigned type\n\n### a SystemC sc\\_value\\_base type\n\nTypes\n-----\n\n### InOutType\n\n*A SystemC sc\\_inout type*\n\nSyntax:\n\n```\n!systemc.inout<\n  ::mlir::Type   # baseType\n>\n```\n\nRepresents the specialized SystemC port class sc\\_inout as described in\nIEEE 1666-2011 \u00a76.10.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| baseType | `::mlir::Type` |  |\n\n### InputType\n\n*A SystemC sc\\_in type*\n\nSyntax:\n\n```\n!systemc.in<\n  ::mlir::Type   # baseType\n>\n```\n\nRepresents the specialized SystemC port class sc\\_in as described in\nIEEE 1666-2011 \u00a76.8.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| baseType | `::mlir::Type` |  |\n\n### LogicType\n\n*A SystemC sc\\_logic type*\n\nSyntax: `!systemc.logic`\n\nRepresents a single bit with with a value corresponding to one of the four\nlogic states \u20180\u2019, \u20181\u2019, \u2018Z\u2019, and \u2018X\u2019 in SystemC as described in\nIEEE 1666-2011 \u00a77.9.2.\nA value of this type can be created using the \u2019emitc.constant\u2019 operation\nwith a string attribute containing \u201c0\u201d, \u201c1\u201d, \u201cX\u201d, \u201cZ\u201d, \u201cx\u201d, or \u201cz\u201d or an\ni1 attribute representing \u201ctrue\u201d or \u201cfalse\u201d. Any other value will be\ninterpreted as \u2018X\u2019 (unknown state).\n\n### ModuleType\n\n*A SystemC module type*\n\nRepresents a SystemC module instantiation. Example:\n`!systemc.module<moduleName(portName1: type1, portName2: type2)>`\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| moduleName | `mlir::StringAttr` |  |\n| ports | `::llvm::ArrayRef<::circt::systemc::ModuleType::PortInfo>` | module ports |\n\n### OutputType\n\n*A SystemC sc\\_out type*\n\nSyntax:\n\n```\n!systemc.out<\n  ::mlir::Type   # baseType\n>\n```\n\nRepresents the specialized SystemC port class sc\\_out as described in\nIEEE 1666-2011 \u00a76.12.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| baseType | `::mlir::Type` |  |\n\n### SignalType\n\n*A SystemC sc\\_signal type*\n\nSyntax:\n\n```\n!systemc.signal<\n  ::mlir::Type   # baseType\n>\n```\n\nRepresents the predefined primitive channel sc\\_signal as described in\nIEEE 1666-2011 \u00a76.4.\n\n#### Parameters:\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| baseType | `::mlir::Type` |  |\n\nEnums\n-----\n\n### MemberAccessKind\n\n*C++ member access kind*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| Dot | `0` | dot |\n| Arrow | `1` | arrow |\n\n'systemc' Dialect Docs\n----------------------\n\n* [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n\n [Prev - Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/ \"Synth Longest Path Analysis\")\n[Next - SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/ \"SystemC Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/index.md"
  },
  {
    "role": "user",
    "content": "SystemC Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nSystemC Dialect Rationale\n=========================\n\nThis document describes various design points of the SystemC dialect, why they\nare the way they are, and current status. This follows in the spirit of other\n[MLIR Rationale docs](https://mlir.llvm.org/docs/Rationale/).\n\n* [SystemC Dialect Rationale](#systemc-dialect-rationale)\n  + [Introduction](#introduction)\n  + [Lowering](#lowering)\n  + [Q&A](#qa)\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\n[SystemC](https://en.wikipedia.org/wiki/SystemC) is a library written in C++\nto allow functional modeling of systems. The included event-driven simulation\nkernel can then be used to simulate a system modeled entirely in SystemC.\nAdditionally, SystemC is a standard (IEEE Std 1666-2011) supported by several\ntools (e.g., Verilator) and can thus be used as an interface to such tools as\nwell as between multiple systems that are internally using custom\nimplementations.\n\nEnabling CIRCT to emit SystemC code provides another way (next to Verilog\nemission) to interface with the outside-world and at the same time\nprovides another way to simulate systems compiled with CIRCT.\n\nLowering\u00a0[\u00b6](#lowering)\n-----------------------\n\nIn a first step, lowering from\n[HW](https://circt.llvm.org/docs/Dialects/HW/)\nto the SystemC dialect will be implemented. A tool called ExportSystemC,\nwhich is analogous to ExportVerilog, will then take these SystemC and\n[Comb](https://circt.llvm.org/docs/Dialects/Comb/) operations to emit proper\nSystemC-C++ code that can be compiled using clang, GCC, or any other\nC++-compiler to produce the simulator binary. In the long run support for more\ndialects can be added, such as LLHD and SV.\n\nAs a simple example we take a look at the following HW module which just adds\ntwo numbers together:\n\n```\nhw.module @adder (%a: i32, %b: i32) -> (c: i32) {\n    %sum = comb.add %a, %b : i32\n    hw.output %sum : i32\n}\n```\n\nIt will then be lowered to the following SystemC IR to make code emission\neasier for ExportSystemC:\n\n```\nsystemc.module @adder(%a: i32, %b: i32) -> (%c: i32) {\n    systemc.ctor {\n        systemc.method @add\n    }\n    systemc.func @add() {\n        // c = a + b\n        %res = comb.add %a, %b : i32\n        systemc.con %c, %res : i32\n    }\n}\n```\n\nExportSystemC will then emit the following C++ code to be compiled by clang or\nanother C++-compiler:\n\n```\n#ifndef ADDER_H\n#define ADDER_H\n\n#include <systemc.h>\n\nSC_MODULE(adder) {\n    sc_in<sc_uint<32>> a;\n    sc_in<sc_uint<32>> b;\n    sc_out<sc_uint<32>> c;\n\n    SC_CTOR(adder) {\n        SC_METHOD(add);\n    }\n\n    void add() {\n        c = a + b;\n    }\n};\n\n#endif // ADDER_H\n```\n\nQ&A\u00a0[\u00b6](#qa)\n------------\n\n**Q: Why implement a custom module operation rather than using `hw.module`?**\n\nIn SystemC we want to model module outputs as arguments such that the SSA value\nis already defined from the beginning which we can then assign to and reference.\n\n**Q: Why implement a custom func operation rather than using `func.func`?**\n\nAn important difference compared to the `func.func` operation is that it\nrepresents a member function (method) of a SystemC module, i.e., a C++ struct.\nThis leads to some implementation differences:\n\n* Not isolated from above: we need to be able to access module fields such as\n  the modules inputs, outputs, and signals\n* Verified to have no arguments and void return type: this is a restriction\n  from SystemC for the function to be passed to SC\\_METHOD, etc. This could\n  also be achieved with `func.func`, but would require us to write the verifier\n  in `systemc.module` instead.\n* Region with only a single basic block (structured control flow) and no\n  terminator: using structured control-flow leads to easier code emission\n\n**Q: How much of C++ does the SystemC dialect aim to model?**\n\nAs much as necessary, as little as possible. Completely capturing C++ in a\ndialect would be a huge undertaking and way too much to \u2018just\u2019 achieve SystemC\nemission. At the same time, it is not possible to not model any C++ at all,\nbecause when only modeling SystemC specific constructs, the gap for\nExportSystemC to bridge would be too big (we want the printer to be as simple\nas possible).\n\n**Q: Why does `systemc.module` have a graph region rather than a SSACFG region?**\n\nIt contains a single graph region to allow flexible positioning of the fields,\nconstructor and methods to support different ordering styles (fields at top\nor bottom, methods to be registered with SC\\_METHOD positioned after the\nconstructor, etc.) without requiring any logic in ExportSystemC. Program code\nto change the emission style can thus be written as part of the lowering from\nHW, as a pre-emission transformation, or anywhere else.\n\n [Prev - 'systemc' Dialect](https://circt.llvm.org/docs/Dialects/SystemC/ \"'systemc' Dialect\")\n[Next - Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/ \"Debug Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect-](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Debug/index.md"
  },
  {
    "role": "user",
    "content": "Debug Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nDebug Dialect\n=============\n\nThis dialect provides operations and types to interleave debug information (DI)\nwith other parts of the IR.\n\n* [Rationale](#rationale)\n  + [Representations](#representations)\n* [Representing Source Language Constructs](#representing-source-language-constructs)\n* [Tracking Inlined Modules](#tracking-inlined-modules)\n* [Types](#types)\n  + [Overview](#overview)\n  + [ArrayType](#arraytype)\n  + [ScopeType](#scopetype)\n  + [StructType](#structtype)\n* [Operations](#operations)\n  + [`dbg.array` (circt::debug::ArrayOp)](#dbgarray-circtdebugarrayop)\n  + [`dbg.scope` (circt::debug::ScopeOp)](#dbgscope-circtdebugscopeop)\n  + [`dbg.struct` (circt::debug::StructOp)](#dbgstruct-circtdebugstructop)\n  + [`dbg.variable` (circt::debug::VariableOp)](#dbgvariable-circtdebugvariableop)\n\nRationale\u00a0[\u00b6](#rationale)\n-------------------------\n\nThe main goal of the debug dialect is to provide a mechanism to track the\ncorrespondence between values, types, and hierarchy of a source language and the\nIR being compiled and transformed. This allows simulators, synthesizers, and\nother debugging tools to reconstruct a source language view into the processed\nhardware and allow for easier debugging by humans.\n\nDebug information in CIRCT follows these principles:\n\n* **It is best effort:** DI is meant as a tool to aid humans in their debugging\n  effort, not a contractual obligation to retain all source language semantics\n  through the compilation pipeline. We preserve information as well as possible\n  and reasonable, but accept the fact that certain optimizations may cause\n  information to be discarded.\n* **It affects the output:** Enabling the tracking of DI is expected to block\n  certain optimizations. We undertake an effort to minimize the impact of DI on\n  the output quality, size, simulation speed, or synthesis results, but accept\n  the fact that preserving visibility and observability of source language\n  constructs may prevent certain optimizations from running.\n\n### Representations\u00a0[\u00b6](#representations)\n\nThere are two mechanisms in MLIR that lend themselves to conveying debug\ninformation:\n\n* **Attributes** attached to existing operations. This is similar to LLVM\u2019s\n  approach of tracking DI in the operation\u2019s metadata. Translated to MLIR, an\n  operation\u2019s location would be an obvious choice to do this tracking, since\n  locations are well-preserved by passes and difficult to accidentally drop.\n  MLIR currently does not support custom location attributes, which would\n  require DI attributes to be attached to a `FusedLoc` as metadata.\n* **Operations** interleaved with the rest of the IR. This makes DI a\n  first-class citizen, but also causes debug information to potentially intefere\n  with optimizations. For example, debug dialect ops introduce additional uses\n  of values that might have otherwise been deleted by DCE. However, there may be\n  alternative ways to dealing with such situations. For example, Verilog\n  emission may simply ignore operations that are only used by debug ops,\n  therefore achieving the same effect as DCE would have.\n\nThe debug dialect uses *operations* to represent debug info. This decision was\nbased on discussions with various people in the LLVM and MLIR community, where\nDI was commonly quoted as one of LLVM\u2019s weak points, with its living in metadata\nspace making it more of a second-class citizen rather than a first-class\nconcern. Since we want to represent source language types and constructs as\naccurately as possible, and we want to track if values are type-lowered,\nconstant-folded, outlined, or adjusted in some other way, using operations seems\nlike a natural choice. MLIR ops already have all the machinery needed to refer\nto values in the IR, and many passes will already do the right thing with them.\n\nRepresenting Source Language Constructs\u00a0[\u00b6](#representing-source-language-constructs)\n-------------------------------------------------------------------------------------\n\nThe `dbg.variable` op is the key mechanism to establish a mapping between\nhigh-level source language values and low-level values in the IR that are\ntransformed by the compiler. Consider the following source language pseudocode:\n\n```\nstruct Req {\n  data: i42,\n  valid: i1,\n  ready: &i1,\n}\nstruct Resp {\n  result: i42,\n  done: i1,\n}\nmodule Foo {\n  parameter Depth: uint;\n  const Width: uint = 2**Depth;\n  input req: Req;\n  output resps: Resp[2];\n  let x = req;\n}\n```\n\nA frontend for this language could generate the following debug variables as\npart of the body of module `Foo`, in order to track the structs, arrays,\nparameters, constants, and local bindings present in the source language:\n\n```\nhw.module @Foo_Width12(\n  in %req_data: i42,\n  in %req_valid: i1,\n  out req_ready: i1,\n  out resps0_result: i42,\n  out resps0_done: i1,\n  out resps1_result: i42,\n  out resps1_done: i1\n) {\n  // %req_ready = ...\n  // %resps0_result = ...\n  // %resps0_done = ...\n  // %resps1_result = ...\n  // %resps1_done = ...\n\n  // parameter Depth\n  %c12_i32 = hw.constant 12 : i32\n  dbg.variable \"Depth\", %c12_i32 : i32\n\n  // const Width\n  %c4096_i32 = hw.constant 4096 : i32\n  dbg.variable \"Width\", %c4096_i32 : i32\n\n  // input req: Req\n  %0 = dbg.struct {\"data\": %req_data, \"valid\": %req_valid, \"ready\": %req_ready} : i42, i1, i1\n  dbg.variable \"req\", %0 : !dbg.struct\n\n  // output resps: Resp[2]\n  %1 = dbg.struct {\"result\": %resps0_result, \"done\": %resps0_done} : i42, i1\n  %2 = dbg.struct {\"result\": %resps1_result, \"done\": %resps1_done} : i42, i1\n  %3 = dbg.array [%1, %2] : !dbg.struct, !dbg.struct\n  dbg.variable \"resps\", %3 : !dbg.array\n\n  // let x = req\n  dbg.variable \"x\", %0 : !dbg.struct\n\n  hw.output %req_ready, %resps0_result, %resps0_done, %resps1_result, %resps1_done : i1, i42, i1, i42, i1\n}\n```\n\nDespite the fact that the `Req` and `Resp` structs, and `Resp[2]` array were\nunrolled and lowered into separate scalar values in the IR, and the `ready: &i1`\ninput of `Req` having been turned into a `ready: i1` output, the `dbg.variable`\nop accurately tracks how the original source language values can be\nreconstructed. Note also how monomorphization has turned the `Depth` parameter\nand `Width` into constants in the IR, but the corresponding `dbg.variable` ops\nstill expose the constant values under the name `Depth` and `Width` in the debug\ninfo.\n\nTracking Inlined Modules\u00a0[\u00b6](#tracking-inlined-modules)\n-------------------------------------------------------\n\nThe `dbg.scope` op can be used to track debug information about inlined modules.\nBy default, operations such as `hw.module` in conjunction with `hw.instance`\nintroduce an implicit module scope. All debug operations within a module are\nadded to that implicit scope, unless they have an explicit `scope` operand. This\nexplicit scope operand can be used to group the DI of an inlined module.\nConsider the following modules:\n\n```\nhw.module @Foo(in %a: i42) {\n  dbg.variable \"a\", %a : i42\n  hw.instance \"bar\" @Bar(x: %a: i42)\n}\nhw.module @Bar(in %x: i42) {\n  dbg.variable \"x\", %x : i42\n  %0 = comb.mul %x, %x : i42\n  dbg.variable \"squared\", %0 : i42\n}\n```\n\nIf we inline module `Bar`, we can introduce a `dbg.scope` operation to represent\nthe original instance, and group all debug variables in `Bar` under this\nexplicit scope:\n\n```\nhw.module @Foo(in %a: i42) {\n  dbg.variable \"a\", %a : i42\n  %0 = dbg.scope \"bar\", \"Bar\"\n  dbg.variable \"x\", %a scope %0 : i42\n  %1 = comb.mul %a, %a : i42\n  dbg.variable \"squared\", %1 scope %0 : i42\n}\n```\n\nDespite the fact that the instance op no longer exists, the explicit `dbg.scope`\nop models the additional levle of hierarchy that used to exist in the input.\n\nTypes\u00a0[\u00b6](#types)\n-----------------\n\n### Overview\u00a0[\u00b6](#overview)\n\nThe debug dialect does not precisely track the type of struct and array\naggregate values. Aggregates simply return the type `!dbg.struct` and\n`!dbg.array`, respectively.\n\nExtracting and emitting the debug information of a piece of IR involves looking\nthrough debug ops to find actually emitted values that can be used to\nreconstruct the source language values. Therefore the actual structure of the\ndebug ops is important, but their return type is not instrumental. The\ndistinction between struct and array types is an arbitrary choice that can be\nchanged easily, either by collapsing them into one aggregate type, or by more\nprecisely listing field/element types and array dimensions if the need arises.\n\n### ArrayType\u00a0[\u00b6](#arraytype)\n\n*Debug array aggregate*\n\nSyntax: `!dbg.array`\n\nThe result of a `dbg.array` operation.\n\n### ScopeType\u00a0[\u00b6](#scopetype)\n\n*Debug scope*\n\nSyntax: `!dbg.scope`\n\nThe result of a `dbg.scope` operation.\n\n### StructType\u00a0[\u00b6](#structtype)\n\n*Debug struct aggregate*\n\nSyntax: `!dbg.struct`\n\nThe result of a `dbg.struct` operation.\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `dbg.array` (circt::debug::ArrayOp)\u00a0[\u00b6](#dbgarray-circtdebugarrayop)\n\n*Aggregate values into an array*\n\nCreates an array aggregate from a list of values. The first operand is\nplaced at array index 0. The last operand is placed at the highest array\nindex. The `dbg.array` operation allows for array-like source language\nvalues to be captured in the debug info. This includes arrays, or in the\ncase of SystemVerilog, packed and unpacked arrays, lists, sequences, queues,\nFIFOs, channels, and vectors.\n\nSee the rationale for examples and details.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `elements` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| `result` | debug array aggregate |\n\n### `dbg.scope` (circt::debug::ScopeOp)\u00a0[\u00b6](#dbgscope-circtdebugscopeop)\n\n*Define a scope for debug values*\n\nSyntax:\n\n```\noperation ::= `dbg.scope` $instanceName `,` $moduleName (`scope` $scope^)? attr-dict\n```\n\nCreates an additional level of hierarchy in the DI, a \u201cscope\u201d, which can be\nused to group variables and other scopes.\n\nOperations such as `hw.module` introduce an implicit scope. All debug\noperations within a module are added to that implicit scope, unless they\nhave an explicit `scope` operand. Providing an explicit scope can be used to\nrepresent inlined modules.\n\nScopes in DI do not necessarily have to correspond to levels of a module\nhierarchy. They can also be used to model things like control flow scopes,\ncall stacks, and other source-language concepts.\n\nThe `scope` operand of any debug dialect operation must be defined locally\nby a `dbg.scope` operation. It cannot be a block argument. (This is intended\nas a temporary restriction, to be lifted in the future.)\n\nInterfaces: `InferTypeOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `instanceName` | ::mlir::StringAttr | string attribute |\n| `moduleName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `scope` | debug scope |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `result` | debug scope |\n\n### `dbg.struct` (circt::debug::StructOp)\u00a0[\u00b6](#dbgstruct-circtdebugstructop)\n\n*Aggregate values into a struct*\n\nCreates a struct aggregate from a list of names and values. The `dbg.struct`\noperation allows for struct-like source language values to be captured in\nthe debug info. This includes structs, unions, bidirectional bundles,\ninterfaces, classes, and other similar structures.\n\nSee the rationale for examples and details.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `names` | ::mlir::ArrayAttr | string array attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `fields` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-2)\n\n| Result | Description |\n| --- | --- |\n| `result` | debug struct aggregate |\n\n### `dbg.variable` (circt::debug::VariableOp)\u00a0[\u00b6](#dbgvariable-circtdebugvariableop)\n\n*A named value to be captured in debug info*\n\nSyntax:\n\n```\noperation ::= `dbg.variable` $name `,` $value (`scope` $scope^)? attr-dict `:` type($value)\n```\n\nMarks a value to be tracked in DI under the given name. The `dbg.variable`\noperation is useful to represent named values in a source language. For\nexample, ports, constants, parameters, variables, nodes, or name aliases can\nall be represented as a variable. In combination with `dbg.array` and\n`dbg.struct`, complex aggregate source language values can be described and\nreconstituted from individual IR values. The `dbg.variable` operation acts\nas a tracker that follows the evolution of its assigned value throughout the\ncompiler\u2019s pass pipelines. The debug info analysis uses this op to populate\na module\u2019s scope with named source language values, and to establish how\nthese source language values can be reconstituted from the actual IR values\npresent at the end of compilation.\n\nSee the rationale for examples and details. See the `dbg.scope` operation\nfor additional details on how to use the `scope` operand.\n\n#### Attributes:\u00a0[\u00b6](#attributes-2)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-3)\n\n| Operand | Description |\n| --- | --- |\n| `value` | any type |\n| `scope` | debug scope |\n\n [Prev - SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/ \"SystemC Dialect Rationale\")\n[Next - Interop Dialect](https://circt.llvm.org/docs/Dialects/Interop/ \"Interop Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Interop/index.md"
  },
  {
    "role": "user",
    "content": "Interop Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nInterop Dialect\n===============\n\n*Provides interoperability between backends and tools*\n\nThis dialect defines the `interop` dialect which defines operations and\ninterfaces necessary to provide interoperability between backends and\nand external tools without the need of writing custom pairwise interop\nsolutions.\n\n* [Operations](#operations)\n  + [`interop.procedural.alloc` (::circt::interop::ProceduralAllocOp)](#interopproceduralalloc-circtinteropproceduralallocop)\n  + [`interop.procedural.dealloc` (::circt::interop::ProceduralDeallocOp)](#interopproceduraldealloc-circtinteropproceduraldeallocop)\n  + [`interop.procedural.init` (::circt::interop::ProceduralInitOp)](#interopproceduralinit-circtinteropproceduralinitop)\n  + [`interop.procedural.update` (::circt::interop::ProceduralUpdateOp)](#interopproceduralupdate-circtinteropproceduralupdateop)\n  + [`interop.return` (::circt::interop::ReturnOp)](#interopreturn-circtinteropreturnop)\n* [Enums](#enums)\n  + [InteropMechanism](#interopmechanism)\n\nOperations\n----------\n\n### `interop.procedural.alloc` (::circt::interop::ProceduralAllocOp)\n\n*Represents persistent state to be allocated*\n\nSyntax:\n\n```\noperation ::= `interop.procedural.alloc` $interopMechanism ( `:` qualified(type($states))^ )? attr-dict\n```\n\nThe `interop.procedural.alloc` operation returns a variadic list of values\nthat represent persistent state, i.e., state that has to persist across\nmultiple executions of the `interop.procedural.update` operation.\nFor example, it can be lowered to C++ class fields that are persistent\nacross multiple calls of a member function, or to global simulator state\nthat persists over simulation cycles, etc.\n\nAdditionally, it has an attribute that specifies the interop mechanism under\nwhich the state types are valid. This is necessary to allow bridging patterns\nto map the types to valid types in the other interop mechanism, e.g., to an\nopaque pointer, if it does not support the same types.\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `interopMechanism` | ::InteropMechanismAttr | interface through which interoperability is achieved |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `states` | variadic of any type |\n\n### `interop.procedural.dealloc` (::circt::interop::ProceduralDeallocOp)\n\n*Performs some deallocation logic before the state is released*\n\nSyntax:\n\n```\noperation ::= `interop.procedural.dealloc` $interopMechanism ( $states^ `:` qualified(type($states)) )?\n              attr-dict-with-keyword $deallocRegion\n```\n\nThe `interop.procedural.dealloc` operation shall be executed right before\nthe state requested by the `interop.procedural.alloc` operation is\nreleased. This allows the instance to do some cleanup, e.g., when the state\ntype was a pointer and the instance performed some `malloc`.\n\nStructurally the operation is the same as the `interop.procedural.update`\noperation, but without input and output values. The state is also passed\nby value.\n\nTraits: `NoTerminator`, `SingleBlock`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `interopMechanism` | ::InteropMechanismAttr | interface through which interoperability is achieved |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `states` | variadic of any type |\n\n### `interop.procedural.init` (::circt::interop::ProceduralInitOp)\n\n*Computes the initial values for the allocated state*\n\nSyntax:\n\n```\noperation ::= `interop.procedural.init` $interopMechanism ( $states^ `:` qualified(type($states)) )?\n              attr-dict-with-keyword $initRegion\n```\n\nThe `interop.procedural.init` operation takes the variadic list of states\nfrom the `interop.procedural.alloc` operation as operands and has a body\nwith a `interop.return` operation that has a variadic list of operands that\nmatches the types of the states and represent the initial values to be\nassigned to the state values.\nThe assignment will be inserted by the container-side lowering of the\ninterop operations.\nThe operation also has an interop mechanism attribute to allow bridging\npatterns to map the types to valid types in another interop mechanism\nand to wrap the operations in the body in a way to make them executable\nin the other interop mechanism, e.g., wrap them in a `extern \"C\"` function\nto make it callable from C or LLVM IR.\n\nTraits: `SingleBlock`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `interopMechanism` | ::InteropMechanismAttr | interface through which interoperability is achieved |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `states` | variadic of any type |\n\n### `interop.procedural.update` (::circt::interop::ProceduralUpdateOp)\n\n*Takes some persistent state and inputs to compute some results*\n\nSyntax:\n\n```\noperation ::= `interop.procedural.update` $interopMechanism ( ` ` `[` $states^ `]` )? ( `(` $inputs^ `)` )? `:`\n              (`[` qualified(type($states))^ `]`)? functional-type($inputs, $outputs)\n              attr-dict-with-keyword $updateRegion\n```\n\nThe `interop.procedural.update` operation has an interop mechanism attribute\nto allow bridging patterns to map the types to valid types in another\ninterop mechanism and to wrap the operations in the body in a way to make\nthem executable using the other interop mechanism.\n\nIt takes the state values returned by the `interop.procedural.alloc`as\noperands and passes them on to the body via block arguments using\npass-by-value semantics. In addition to the state values, it also takes a\nvariadic list of inputs and also passes them on to the body.\nThe `interop.return` inside the body then returns the result values after\ndoing some computation inside the body.\n\nIf the state needs to be mutated, it has to be a pointer type.\n\nTraits: `AttrSizedOperandSegments`, `SingleBlock`\n\n#### Attributes:\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `interopMechanism` | ::InteropMechanismAttr | interface through which interoperability is achieved |\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `states` | variadic of any type |\n| `inputs` | variadic of any type |\n\n#### Results:\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `interop.return` (::circt::interop::ReturnOp)\n\n*A return operation*\n\nSyntax:\n\n```\noperation ::= `interop.return` attr-dict ($returnValues^ `:` type($returnValues))?\n```\n\nThe `interop.return` operation lists the computed initial values when\ninside the `init` operation or the computed results when inside the\n`update` operation.\n\nTraits: `HasParent<ProceduralInitOp, ProceduralUpdateOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `RegionBranchTerminatorOpInterface`\n\n#### Operands:\n\n| Operand | Description |\n| --- | --- |\n| `returnValues` | variadic of any type |\n\nEnums\n-----\n\n### InteropMechanism\n\n*Interface through which interoperability is achieved*\n\n#### Cases:\n\n| Symbol | Value | String |\n| --- | --- | --- |\n| CFFI | `0` | cffi |\n| CPP | `1` | cpp |\n\nInterop Dialect Docs\n--------------------\n\n* [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n\n [Prev - Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/ \"Debug Dialect\")\n[Next - Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/ \"Interoperability Dialect Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Interop/RationaleInterop/index.md"
  },
  {
    "role": "user",
    "content": "Interoperability Dialect Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nInteroperability Dialect Rationale\n==================================\n\nThis document describes the various design points of the Interop dialect, a\ndialect that is used to represent partially lowered interoperability layers and\nthat provides common interfaces and utilities for automated interop generation.\nThis follows in the spirit of other\n[MLIR Rationale docs](https://mlir.llvm.org/docs/Rationale/).\n\n* [Interoperability Dialect Rationale](#interoperability-dialect-rationale)\n  + [Introduction](#introduction)\n  + [Procedural Interop](#procedural-interop)\n    - [Representing Partial Lowerings](#representing-partial-lowerings)\n    - [Interop Mechanisms](#interop-mechanisms)\n    - [Instance-side Lowering](#instance-side-lowering)\n    - [Container-side Lowering](#container-side-lowering)\n    - [Bridging between Interop Mechanisms](#bridging-between-interop-mechanism)\n    - [How to use this dialect](#how-to-use-this-dialect)\n    - [Design considerations](#design-considerations)\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\nThe increasing number of CIRCT-based backends as well as the usage of many\nexternal tools raises questions about interoperability and composition of\nthose tools. Are we supposed to write interop-layers between them by hand or\ncan this also be automatically generated? Can we generate interfaces to the\noutside in multiple standardized formats/languages automatically?\n\nLet\u2019s pick simulation as a concrete example. We have Verilator, CIRCT-based\nevent-driven (e.g., `llhd-sim`) and potentially non-event-driven simulators\nthat could be mixed using interop to use the faster, more constraint\none for most of the design and switch to the slower, more general one for\nparts of the design that require the generality.\nThey all provide their own interface for writing testbenches in a way that\nsuits them best. Verilator has its custom C++ interface as well as SystemC\nsupport, `llhd-sim` expects the testbench to be written in LLHD (e.g., compiled\nfrom SystemVerilog), and nobody knows what the interface of the third would look\nlike (maybe a custom C-header?). This means, if we want to simulate a design\nwith all three, we have to write the testbench three times or at least some\nlayer between the TB and the simulator interfaces. This dialect aims to solve\nthis issue by auto-generating an interface from a selection of standarized\nformats (e.g., a SystemC or SystemVerilog module) such that the testbench has\nto be written only once and switching to another simulator just means changing\none CLI argument.\nWhat if we have to use some blackbox Verilog code in the design? Is it compiled\nby a (not yet existent) SystemVerilog front-end and simulated by the CIRCT-based\nsimulators or could it also be useful to simulate the blackbox using Verilator\nand everything surrounding it using the CIRCT-based simulator? This dialect can\nprovide the latter by implementing an interop operation and one lowering per\nsimulator rather than custom pair-wise interop implementations.\n\nWe make a clear distinction between procedural and structural interop because\nit is not possible to provide direct interop between a purely structural\nlanguage and a purely procedural language. To achieve interop between them,\none has to use at least one bridging language that has (some) support for both\nas a translation layer.\n\nProcedural Interop\u00a0[\u00b6](#procedural-interop)\n-------------------------------------------\n\nThe `interop` dialect provides a few operations to represent partially lowered\nprocedural interop instances presented in the\n[next section](#representing-partial-lowerings) as well as an interface to be\nimplemented by the surrounding module and rewrite patterns to call into those\ninterface implementations presented in the section about\n[\u2018Container-side Lowering\u2019](#container-side-lowering).\nIt also provides common rewrite patterns to insert translation layers between\ndifferent interop mechanisms like textural C++, C-foreign-functions, Verilog,\netc. They are discussed in more detail in the sections\n[\u2018Interop Mechanisms\u2019](#interop-mechanisms) and\n[\u2018Bridging between Interop Mechanisms\u2019](#bridging-between-interop-mechanisms).\n\n### Representing Partial Lowerings\u00a0[\u00b6](#representing-partial-lowerings)\n\nThere are four operations to represent partially lowered procedural interop in\nthe IR:\n\n* `interop.procedural.alloc`\n* `interop.procedural.init`\n* `interop.procedural.update`\n* `interop.procedural.dealloc`\n\nThe `alloc` operation returns a variadic list of values that represent\npersistent state, i.e., state that has to persist across multiple executions\nof the `update` operation. For example, it can be lowered to C++ class fields\nthat are persistent across multiple calls of a member function, or to global\nsimulator state that persists over simulation cycles, etc.\n\nAdditionally, it has an attribute that specifies the interop mechanism under\nwhich the state types are valid (the `cpp` in the example below). This is\nnecessary to allow bridging patterns to map the types to valid types in the\nother interop mechanism, e.g., to an opaque pointer, if it does not support\nthe same types.\n\n```\n%state = interop.procedural.alloc cpp : !emitc.ptr<!emitc.opaque<\"VBar\">>\n```\n\nThe `init` operation takes the variadic list of states from the `alloc`\noperation as operands and has a body with a `return` operation that has a\nvariadic list of operands that matches the types of the states and\nrepresent the initial values to be assigned to the state values. The assignment\nwill be inserted by the container-side lowering of the interop operations.\nThe operation also has an interop mechanism attribute for the same reason as\nabove and, additionally, to wrap the operations in the body in a way to make\nthem executable in the other interop mechanism, e.g., wrap them in a\n`extern \"C\"` function to make it callable from C or LLVM IR.\n\n```\ninterop.procedural.init cpp %state : !emitc.ptr<!emitc.opaque<\"VBar\">> {\n  %0 = systemc.cpp.new() : () -> !emitc.ptr<!emitc.opaque<\"VBar\">>\n  interop.return %0 : !emitc.ptr<!emitc.opaque<\"VBar\">>\n}\n```\n\nThe `update` operation is similar to the `alloc` operation in that it has an\ninterop mechanism attribute for the same reason and takes the state values as\noperands, but also passes them on to the body via block arguments using\npass-by-value semantics. In addition to the state values, it also takes a variadic\nlist of inputs and also passes them on to the body. The `return` inside the body\nthen returns the result values after doing some computation inside the body.\nIf the state needs to be mutated, it has to be a pointer type. If we need to be\nable to change the actual state value in the future, we could return updated\nstates via the `return` operation (currently not allowed).\n\n```\n%1 = interop.procedural.update cpp [%state](%x, %x) :\n  [!emitc.ptr<!emitc.opaque<\"VBar\">>](i32, i32) -> i32 {\n^bb0(%arg0: !emitc.ptr<!emitc.opaque<\"VBar\">>, %arg1: i32, %arg2: i32):\n  interop.return %5 : i32\n}\n```\n\nThe `dealloc` operation shall be executed right before the state requested by\nthe `alloc` operation is released. This allows the instance to do some cleanup,\ne.g., when the state type was a pointer and the instance performed some\n`malloc`. Structurally the operation is the same as the `update` operation, but\nwithout input and output values. The state is also passed by value.\n\n```\ninterop.procedural.dealloc cpp %state : !emitc.ptr<!emitc.opaque<\"VBar\">> {\n^bb0(%arg0: !emitc.ptr<!emitc.opaque<\"VBar\">>):\n  systemc.cpp.delete %arg0 : !emitc.ptr<!emitc.opaque<\"VBar\">>\n  interop.return\n}\n```\n\n### Interop Mechanisms\u00a0[\u00b6](#interop-mechanisms)\n\nA variety of interop mechanisms can be supported. This allows to perform interop\non different abstraction levels and only fall back to C-foreign-functions when\nnothing else is supported.\n\nCurrently supported interop mechanisms:\n\n* CFFI: C-foreign-functions, i.e., all interop operations are lowered to C\n  functions and function calls.\n* CPP: textual C++, i.e., the interop operations are lowered to the `systemc`\n  and `emitc` dialects and printed as C++ code. In the future, more dialects\n  (such as `scf`) could be supported.\n\nAdding a new interop mechanism requires changes to the `interop` dialect. At\na minimum, the table-gen enum has to be modified and a bridging pattern has to\nbe added.\n\n### Instance-side Lowering\u00a0[\u00b6](#instance-side-lowering)\n\nThe instance-side lowering always has to happen before the container-side\nlowering since that pass should create the interop operations that will then\nbe picked up by the container-side lowering pass and properly embedded in the\ncontext of the container operation.\n\nTo illustrate how this works, consider a design represented in `hw`, `comb`, and\n`seq`. We want to simulate that design using Verilator and provide a SystemC\nwrapper (basically what Verilator itself can also do using the SystemC Output\nMode `--sc`). As a first step, the\ntop-level module has to be cloned without the region and a\n`systemc.interop.verilated` operation has to be inserted in the body to\ninstantiate the previously cloned module (here represented as the extern module\n`@Bar`) as a verilated module. The input and output ports get connected 1-1.\nThe original design is then exported through `ExportVerilog` and verilated,\nwhile our wrapper module is lowered by the instance-side lowering.\n\n```\nhw.module.extern @Bar (%a: i32, %b: i32) -> (c: i32)\n\nhw.module @Foo (%x: i32) -> (y: i32) {\n  %c = systemc.interop.verilated \"inst\" @Bar (a: %x: i32, b: %x: i32) -> (c: i32)\n  hw.output %c : i32\n}\n```\n\nAs a result, the above code example is lowered to the following code. This is\nimplemented as a pattern on the `systemc.interop.verilated` operation in the\ndialect conversion framework. Note that it is required to provide a rewrite\npattern for this lowering to enable one-shot lowering of all interop operations\nin a design during a lowering pipeline. The patterns for all instance-side\ninterop lowerings of a dialect are provided by a population function\n(e.g., `populateInstanceInteropLoweringPatterns(RewritePatternSet&)`) exposed\nin their public API. Each dialect should also provide a pass with all its\ninstance-side lowering patterns populated for partial interop lowering.\n\n```\nhw.module @Foo(%x: i32) -> (y: i32) {\n  %state = interop.procedural.alloc cpp : !emitc.ptr<!emitc.opaque<\"VBar\">>\n  interop.procedural.init cpp %state : !emitc.ptr<!emitc.opaque<\"VBar\">> {\n    %2 = systemc.cpp.new() : () -> !emitc.ptr<!emitc.opaque<\"VBar\">>\n    interop.return %2 : !emitc.ptr<!emitc.opaque<\"VBar\">>\n  }\n  %1 = interop.procedural.update cpp [%state](%x, %x) :\n    [!emitc.ptr<!emitc.opaque<\"VBar\">>](i32, i32) -> i32 {\n  ^bb0(%arg0: !emitc.ptr<!emitc.opaque<\"VBar\">>, %arg1: i32, %arg2: i32):\n    %2 = systemc.cpp.member_access %arg0 arrow \"a\" :\n      (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n    systemc.cpp.assign %2 = %arg1 : i32\n    %3 = systemc.cpp.member_access %arg0 arrow \"b\" :\n      (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n    systemc.cpp.assign %3 = %arg2 : i32\n    %4 = systemc.cpp.member_access %arg0 arrow \"eval\" :\n      (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> (() -> ())\n    systemc.cpp.call_indirect %4() : () -> ()\n    %5 = systemc.cpp.member_access %arg0 arrow \"c\" :\n      (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n    interop.return %5 : i32\n  }\n  interop.procedural.dealloc cpp %state : !emitc.ptr<!emitc.opaque<\"VBar\">> {\n  ^bb0(%arg0: !emitc.ptr<!emitc.opaque<\"VBar\">>):\n    systemc.cpp.delete %arg0 : !emitc.ptr<!emitc.opaque<\"VBar\">>\n    interop.return\n  }\n  hw.output %1 : i32\n}\n```\n\nIn this example, it is possible to do the `HWToSystemC` conversion before or\nafter the instance-side interop lowering, but that might not be the case in\nall situations.\n\n### Container-side Lowering\u00a0[\u00b6](#container-side-lowering)\n\nThe container-side interop lowering is slightly more complex than the\ninstance-side lowering, because it consists of an interface that needs to be\nimplemented by the container operations (in our example that\u2019s the\n`systemc.module` operation) and four rewrite patterns that are provided by the\ninterop dialect and call those interface implementations. Typically, the\ninterface is implemented as an external model on the container operation, thus\nthe external model and the four rewrite patterns have to be registered in the\ncontainer-side lowering pass.\n\nSimilar to the instance-side lowering, each dialect has to provide a function\nto register all external models implementing the interop interface of that\ndialect as well as a pass that has all those models, the four rewrite patterns,\nand all the bridging patterns, provided by the interop dialect, registered.\n\nThe `ProceduralContainerInteropOpInterface` provides four function that have\nto be implemented:\n\n```\nLogicalResult allocState(PatternRewriter&, ProceduralAllocOp, ProceduralAllocOpAdaptor);\nLogicalResult initState(PatternRewriter&, ProceduralInitOp, ProceduralInitOpAdaptor);\nLogicalResult updateState(PatternRewriter&, ProceduralUpdateOp, ProceduralUpdateOpAdaptor);\nLogicalResult deallocState(PatternRewriter&, ProceduralDeallocOp, ProceduralDeallocOpAdaptor);\n```\n\nThey are responsible for lowering the respective interop operation in a similar\nfashion as regular rewrite patterns.\n\nLet\u2019s take a look at how the example from the previous section is further\nlowered. After the `convert-hw-to-systemc` pass it looks like the following:\n\n```\nsystemc.module @Foo(%x: !systemc.in<!systemc.uint<32>>,\n                    %y: !systemc.out<!systemc.uint<32>>) {\n  systemc.ctor {\n    systemc.method %update\n  }\n  %update = systemc.func {\n    %0 = systemc.signal.read %x : !systemc.in<!systemc.uint<32>>\n    %state = interop.procedural.alloc cpp : !emitc.ptr<!emitc.opaque<\"VBar\">>\n    interop.procedural.init cpp %state : !emitc.ptr<!emitc.opaque<\"VBar\">> {\n      %1 = systemc.cpp.new() : () -> !emitc.ptr<!emitc.opaque<\"VBar\">>\n      interop.return %1 : !emitc.ptr<!emitc.opaque<\"VBar\">>\n    }\n    %2 = systemc.convert %0 : (!systemc.uint<32>) -> i32\n    %3 = interop.procedural.update cpp [%state](%2, %2) :\n      [!emitc.ptr<!emitc.opaque<\"VBar\">>](i32, i32) -> i32 {\n    ^bb0(%arg0: !emitc.ptr<!emitc.opaque<\"VBar\">>, %arg1: i32, %arg2: i32):\n      %4 = systemc.cpp.member_access %arg0 arrow \"a\" :\n        (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n      systemc.cpp.assign %4 = %arg1 : i32\n      %5 = systemc.cpp.member_access %arg0 arrow \"b\" :\n        (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n      systemc.cpp.assign %5 = %arg2 : i32\n      %6 = systemc.cpp.member_access %arg0 arrow \"eval\" :\n        (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> (() -> ())\n      systemc.cpp.call_indirect %6() : () -> ()\n      %7 = systemc.cpp.member_access %arg0 arrow \"c\" :\n        (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n      interop.return %7 : i32\n    }\n    interop.procedural.dealloc cpp %state : !emitc.ptr<!emitc.opaque<\"VBar\">> {\n    ^bb0(%arg0: !emitc.ptr<!emitc.opaque<\"VBar\">>):\n      systemc.cpp.delete %arg0 : !emitc.ptr<!emitc.opaque<\"VBar\">>\n      interop.return\n    }\n    %8 = systemc.convert %3 : (i32) -> !systemc.uint<32>\n    systemc.signal.write %y, %8\n  }\n}\n```\n\nNote that the `alloc`, `init`, and `dealloc` interop operations were not moved\nto the final locations yet, although, the pass could be modified to do this.\nIn the SystemC lowering, the interop interface implementation performs the\nmovement of these operation to the final location. Doing the lowering leads to\nthe following:\n\n```\nsystemc.module @Foo(%x: !systemc.in<!systemc.uint<32>>,\n                    %y: !systemc.out<!systemc.uint<32>>) {\n  %state = systemc.cpp.variable : !emitc.ptr<!emitc.opaque<\"VBar\">>\n  systemc.ctor {\n    %0 = systemc.cpp.new() : () -> !emitc.ptr<!emitc.opaque<\"VBar\">>\n    systemc.cpp.assign %state = %0 : !emitc.ptr<!emitc.opaque<\"VBar\">>\n    systemc.method %update\n  }\n  %update = systemc.func {\n    %1 = systemc.signal.read %x : !systemc.in<!systemc.uint<32>>\n    %2 = systemc.convert %1 : (!systemc.uint<32>) -> i32\n    %3 = systemc.cpp.member_access %state arrow \"a\" :\n      (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n    systemc.cpp.assign %3 = %2 : i32\n    %4 = systemc.cpp.member_access %state arrow \"b\" :\n      (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n    systemc.cpp.assign %4 = %2 : i32\n    %5 = systemc.cpp.member_access %state arrow \"eval\" :\n      (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> (() -> ())\n    systemc.cpp.call_indirect %5() : () -> ()\n    %6 = systemc.cpp.member_access %state arrow \"c\" :\n      (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n    %7 = systemc.convert %6 : (i32) -> !systemc.uint<32>\n    systemc.signal.write %y, %7\n  }\n  systemc.cpp.destructor {\n    systemc.cpp.delete %state : !emitc.ptr<!emitc.opaque<\"VBar\">>\n  }\n}\n```\n\n### Bridging between Interop Mechanisms\u00a0[\u00b6](#bridging-between-interop-mechanisms)\n\nAs we have already seen, the instance-side lowering adds an attribute to the\ninterop operations to indicate the interop mechanism that has to be supported\nto use the bodies operations and types directly. But what happens when the\ninstance annotated the operations to be textual C++, but the interface\nimplementation of the container operation only supports CFFI?\nIn that case, the dialect that lowers the instance could also provide a lowering\npattern for that particular interop mechanism (instead of registering the\nbridging patterns), or there can be patterns that convert the interop operations\nto another interop mechanism. Using the dialect conversion framework, this will\nthen allow the pass to legalize all operations in the IR by using that extra\npattern instead of failing because of an illegal operation for which no pattern\nmatches.\n\nLet\u2019s take a closer look into the CPP to CFFI bridging pattern. It will convert\nthe interop operations from earlier to CFFI compatible versions.\n\nThe `alloc` operation\n\n```\n%state = interop.procedural.alloc cpp : !emitc.ptr<!emitc.opaque<\"VBar\">>\n```\n\nis converted to a version where all types are replaced by opaque pointers:\n\n```\n%state = interop.procedural.alloc cffi : !llvm.ptr\n```\n\nFor the `update` operation\n\n```\n%1 = interop.procedural.update cpp [%state](%x, %x) :\n  [!emitc.ptr<!emitc.opaque<\"VBar\">>](i32, i32) -> i32 {\n^bb0(%arg0: !emitc.ptr<!emitc.opaque<\"VBar\">>, %arg1: i32, %arg2: i32):\n  %2 = systemc.cpp.member_access %arg0 arrow \"a\" :\n    (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n  systemc.cpp.assign %2 = %arg1 : i32\n  %3 = systemc.cpp.member_access %arg0 arrow \"b\" :\n    (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n  systemc.cpp.assign %3 = %arg2 : i32\n  %4 = systemc.cpp.member_access %arg0 arrow \"eval\" :\n    (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> (() -> ())\n  systemc.cpp.call_indirect %4() : () -> ()\n  %5 = systemc.cpp.member_access %arg0 arrow \"c\" :\n    (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n  interop.return %5 : i32\n}\n```\n\nthe state types are also converted to opaque pointers and the body is replaced\nwith a function call. The original body is moved to a function in another file\nthat will be piped through `ExportSystemC` to generate the textual C++ that\nexports it as a `extern \"C\"` function.\n\n```\nsystemc.cpp.func externC @update (%arg0: !emitc.ptr<!emitc.opaque<\"void\">>,\n                                  %arg1: i32, %arg2: i32) -> i32 {\n  %0 = emitc.cast %arg0 : !emitc.ptr<!emitc.opaque<\"void\">> to\n    !emitc.ptr<!emitc.opaque<\"VBar\">>\n  %2 = systemc.cpp.member_access %0 arrow \"a\" :\n    (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n  systemc.cpp.assign %2 = %arg1 : i32\n  %3 = systemc.cpp.member_access %0 arrow \"b\" :\n    (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n  systemc.cpp.assign %3 = %arg2 : i32\n  %4 = systemc.cpp.member_access %0 arrow \"eval\" :\n    (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> (() -> ())\n  systemc.cpp.call_indirect %4() : () -> ()\n  %5 = systemc.cpp.member_access %0 arrow \"c\" :\n    (!emitc.ptr<!emitc.opaque<\"VBar\">>) -> i32\n  interop.return %5 : i32\n}\n// ----- other file\nfunc.func @update (%arg0: !llvm.ptr, %arg1: i32, %arg2: i32) -> i32\n%1 = interop.procedural.update cffi [%state](%x, %x) :\n  [!llvm.ptr](i32, i32) -> i32 {\n^bb0(%arg0: !llvm.ptr, %arg1: i32, %arg2: i32):\n  %1 = func.call @update(%arg0, %arg1, %arg2) : (!llvm.ptr, i32, i32) -> i32\n  interop.return %1 : i32\n}\n```\n\nThe `init` and `dealloc` operations follow the same pattern as the `update`\noperation.\n\n### How to use this dialect\u00a0[\u00b6](#how-to-use-this-dialect)\n\nFirst, we need to distinguish between the different ways this dialect might want\nto be used in another dialect or downstream repository:\n\n* Use existing dialects that implement interop lowerings in a specialized\n  pipeline: this requires implementing a new pass in the downstream tool that\n  registers all the rewrite patterns and external models from the upstream\n  dialects required to make the pass succeed in that specialized environment.\n  Having a specialized pass allows to reduce the number of dependent dialect as\n  all dialects, external models, and patterns that could potentially be needed\n  have to be registered upfront in MLIR. It\u2019s also more convenient to have a\n  one-shot pass instead of a series of partial lowerings.\n* Add a new tool or IR that can be used as an instance: implement the\n  instance-side lowering pass for your dialect and expose a function to\n  populate the rewrite pattern in a provided pattern set.\n* Add a new IR that can be used as a container for other interop instances:\n  implement the container-side interop interface and a container-side lowering\n  pass that registers the implemented interface, the four container-side\n  lowering patterns and bridging patterns provided by the `interop` dialect.\n* Add a new interop mechanism: this is currently not supported and requires\n  modifications to the `interop` dialect. Adding a new mechanism requires\n  extending the `InteropMechanism` table-gen enum and adding a bridging pattern\n  to CFFI at a minimum.\n\n### Design considerations\u00a0[\u00b6](#design-considerations)\n\nThis section aims to provide explanations for certain design decisions. It will\ntake the form of a Q&A.\n\n**Why does the container-side lowering use interfaces that are called from a**\n**rewrite pattern?**\n\nGenerally speaking, switching between interfaces and rewrite patterns allows us\nto control the dependency direction between the container interop operations\nand the interop lowering pass.\nWhen using external models to describe the lowering, the pass does not need to\nknow about that interop operation, it just needs to know about the interface\nthat describes the external model. However, the interop operation needs to know\nabout the interop lowering pass.\nWhen using rewrite patterns (without any interfaces), the pattern needs to\ndepend on the interop operation and the interop lowering pass needs to depend on\nthe patterns.\nWhile this is also a design consideration, it is not the main concern here.\nNote that the lowering patterns should be provided by the operation that is\nthe closest surrounding op (in terms of regions) to the unrealized interop\noperation and that supports interop.\nTo illustrate why this approach was taken, we can take a look at some of the\nalternatives considered:\n\n* The dialect exports a function to populate a rewrite pattern that matches on\n  the container operation of that dialect. This has the disadvantage that all\n  interop casts inside that container have to be handled in that single pattern\n  and the pattern thus needs to walk the region. Another problem is that we need\n  the closest operation to perform the interop lowering and the rewrite pattern\n  driver walks top-down, thus the pattern would need to stop walking at operations\n  that also support interop, but it can only know that if it gets a list of such\n  operations or if all of the interop supporting operations implement an interface.\n* The dialect exports a function to populate a rewrite pattern that matches on\n  the interop cast operation. The disadvantage there is that we then potentially\n  have a lot of rewrite patterns matching on the same operation and we thus need\n  to specify the matching condition to only succeed when the closest interop\n  supporting operation is the one that provided the rewrite pattern. Therefore,\n  we would still need to know which operations support interop. Alternatively,\n  the pattern returns the operation it would match on and the infra tries all\n  of them and selectes the one with the closest operation returned, however,\n  that doesn\u2019t fit the dialect conversion framework very well and would be\n  rather bad performance-wise.\n* The dialect adds a trait to the operations that support interop. The interop\n  rewrite patterns could then be provided by the downstream dialect, match on\n  the unrealized interop operations, and add as a matching condition that no\n  other operation having the interop trait is closer to the unrealized interop\n  operation. This still has the disadvantage that the conversion framework has\n  to cycle through potentially many patterns matching on the same operations\n  and check quite expensive matching conditions.\n* Current implementation: The dialect implements an external model for the\n  interop operation. The lowering pass infra then provides the rewrite patterns\n  that match on the unrealized interop operations (one per op) and checks for\n  the closest parent operation that implements the interface and then calls the\n  lowering provided by the interface implementation.\n\n**Why is instance-side lowering implemented using rewrite patterns?**\n\nWe also have the option to implement the lowering patterns in an interface or\ndirectly provide a rewrite pattern with the same trade-offs as mentioned in the\nbeginning of the above question. The only advantage of the interface approach\nis the inversion of the dependencies which is not important for us since we\nimplement partial lowering passes for every dialect anyways. The pattern based\napproach is more straight-forward to implement though.\n\n**Why are those interfaces implemented as external models?**\n\nBecause the interface implementations need to implement a lowering pattern that\nmight have to create operations from a few different dialects, it needs to\ninclude all of them and link against them. This can add a big burden to some\nother user that just wants to use the dialect but is not interested in the\ninterop functionality. It also helps to avoid dependency cycles.\n\n**How are the dialects registered that a pass depends on (for which ops may be**\n**created)?**\n\nWe have partial lowering passes for each dialect. They have a complete picture\nof what operations they create in the instance- and container-side lowerings\nand can thus register exactly those. The container-side lowerings also need\nto register the dialects needed for the interop mechanism conversion patterns\nwhich are fixed by the `interop` dialect.\nWhen implementing a specialized tool one can set up a specialized one-shot\npass for interop which registers everything that can occur at that stage of\nthe pipeline.\n\n**Why have unrealized interp operations instead of lowering directly?**\n\nThey allow us to get rid of the tight coupling between the instance interop\noperations and the surrounding container interop operations. It enables\npartial lowering at various places throughout a lowering pipeline and helps\nkeeping the number of dependences on dialects in the lowering pass low.\n\n**Is there a possibility to support multiple interop mechanisms per instance**\n**operation?**\n\nWe have to distinguish the case where we know the interop mechanism statically\nat the point in time when we create the lowering pass and the case where the\nmechanism is selected dynamically in the lowering pass.\nThe first case is easy to support because one can implement multiple patterns\nthat lower the instance operation in different ways and register the one that\nfits the best.\nIn a dynamic setting, this is still possible by registering multiple patterns\nfor the same op, but the set of operations they match on needs to be disjoint\nand must not depend on any parent operations. As a result, it might be tricky\nto add a specialized lowering without copy-pasting the original lowering\npattern and restricting its match condition.\n\n**How are the bridges between interop mechanisms provided?**\n\nThey are provided by the interop dialect as rewrite patterns similar to how the\nrewrite patterns for the instance interop to interop cast conversion is provided\nby the other dialects. This has the advantage that these conversions, which\nusually follow a common pattern, have to be implemented only once.\n\n**Why are the interop operations four separate operations instead of one with**\n**three regions?**\n\nThis allows to move the code fragments for allocation and deallocation to their\nfinal location not only during the container-side lowering, but also during a\nregular transformation pass that, e.g., collects all the state that needs to be\npersistent over multiple cycles in a simulator and inserts allocation code at\nthe top-level.\n\n**Why is there a separate `interop.alloc` operation? Why not make it part of**\n**`interop.init`?**\n\nWe need to have an operation returning SSA values for the state that which can\nbe used in the other unrealized interop operations to link them together (we\nalways need to know what alloc, update, and dealloc operations belong together).\nReturning those values from the `init` operation would lead to less flexibility,\na more complicated `init` operation, and might be misleading as the body returns\nthe values that need to be assigned to the state variables by the container-side\npass, but the returned values would be the state variables.\n\n**Why is this a separate dialect?**\n\nThis dialect provides infrastructure and utilities for all dialects that want\nto implement some kind of interop. Those dialects need to depend on this one.\nThe only dialect where it could make sense to add this functionality to is HW,\nbut we don\u2019t want to bloat HW since it is the core dialect that everyone depends\non (also the dialects that don\u2019t need interop).\n\n [Prev - Interop Dialect](https://circt.llvm.org/docs/Dialects/Interop/ \"Interop Dialect\")\n[Next - LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/ \"LLHD Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect-](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/LLHD/index.md"
  },
  {
    "role": "user",
    "content": "LLHD Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nLLHD Dialect\n============\n\nThis dialect provides operations and types to interact with an event queue in an event-based simulation.\nIt describes how signals change over time in reaction to changes in other signals and physical time advancing.\nEstablished hardware description languages such as SystemVerilog and VHDL use an event queue as their programming model to describe combinational and sequential logic, as well as test harnesses and test benches.\n\n* [Rationale](#rationale)\n  + [Register Reset Values](#register-reset-values)\n* [Types](#types)\n  + [TimeType](#timetype)\n  + [RefType](#reftype)\n* [Attributes](#attributes)\n  + [InnerSymAttr](#innersymattr)\n  + [InnerSymPropertiesAttr](#innersympropertiesattr)\n  + [TimeAttr](#timeattr)\n* [Operations](#operations)\n  + [`llhd.combinational` (::circt::llhd::CombinationalOp)](#llhdcombinational-circtllhdcombinationalop)\n  + [`llhd.constant_time` (::circt::llhd::ConstantTimeOp)](#llhdconstant_time-circtllhdconstanttimeop)\n  + [`llhd.current_time` (::circt::llhd::CurrentTimeOp)](#llhdcurrent_time-circtllhdcurrenttimeop)\n  + [`llhd.delay` (::circt::llhd::DelayOp)](#llhddelay-circtllhddelayop)\n  + [`llhd.drv` (::circt::llhd::DriveOp)](#llhddrv-circtllhddriveop)\n  + [`llhd.final` (::circt::llhd::FinalOp)](#llhdfinal-circtllhdfinalop)\n  + [`llhd.get_global_signal` (::circt::llhd::GetGlobalSignalOp)](#llhdget_global_signal-circtllhdgetglobalsignalop)\n  + [`llhd.global_signal` (::circt::llhd::GlobalSignalOp)](#llhdglobal_signal-circtllhdglobalsignalop)\n  + [`llhd.halt` (::circt::llhd::HaltOp)](#llhdhalt-circtllhdhaltop)\n  + [`llhd.int_to_time` (::circt::llhd::IntToTimeOp)](#llhdint_to_time-circtllhdinttotimeop)\n  + [`llhd.output` (::circt::llhd::OutputOp)](#llhdoutput-circtllhdoutputop)\n  + [`llhd.prb` (::circt::llhd::ProbeOp)](#llhdprb-circtllhdprobeop)\n  + [`llhd.process` (::circt::llhd::ProcessOp)](#llhdprocess-circtllhdprocessop)\n  + [`llhd.sig.array_get` (::circt::llhd::SigArrayGetOp)](#llhdsigarray_get-circtllhdsigarraygetop)\n  + [`llhd.sig.array_slice` (::circt::llhd::SigArraySliceOp)](#llhdsigarray_slice-circtllhdsigarraysliceop)\n  + [`llhd.sig.extract` (::circt::llhd::SigExtractOp)](#llhdsigextract-circtllhdsigextractop)\n  + [`llhd.sig.struct_extract` (::circt::llhd::SigStructExtractOp)](#llhdsigstruct_extract-circtllhdsigstructextractop)\n  + [`llhd.sig` (::circt::llhd::SignalOp)](#llhdsig-circtllhdsignalop)\n  + [`llhd.time_to_int` (::circt::llhd::TimeToIntOp)](#llhdtime_to_int-circtllhdtimetointop)\n  + [`llhd.wait` (::circt::llhd::WaitOp)](#llhdwait-circtllhdwaitop)\n  + [`llhd.yield` (::circt::llhd::YieldOp)](#llhdyield-circtllhdyieldop)\n* [Passes](#passes)\n  + [`-llhd-combine-drives`](#-llhd-combine-drives)\n  + [`-llhd-deseq`](#-llhd-deseq)\n  + [`-llhd-hoist-signals`](#-llhd-hoist-signals)\n  + [`-llhd-inline-calls`](#-llhd-inline-calls)\n  + [`-llhd-lower-processes`](#-llhd-lower-processes)\n  + [`-llhd-mem2reg`](#-llhd-mem2reg)\n  + [`-llhd-remove-control-flow`](#-llhd-remove-control-flow)\n  + [`-llhd-sig2reg`](#-llhd-sig2reg)\n  + [`-llhd-unroll-loops`](#-llhd-unroll-loops)\n  + [`-llhd-wrap-procedural-ops`](#-llhd-wrap-procedural-ops)\n\nRationale\u00a0[\u00b6](#rationale)\n-------------------------\n\n### Register Reset Values\u00a0[\u00b6](#register-reset-values)\n\nResets are problematic since Verilog forces designers to describe them as edge-sensitive triggers.\nThis does *not* match the async resets found on almost all standard cell flip-flops, which are level-sensitive.\nTherefore a pass lowering from Verilog-style processes to a structural register such as `seq.compreg` would have to verify that the reset value is a constant in order to make the mapping from edge-sensitive Verilog description to level-sensitive standard cell valid.\n\nIn practice, designers commonly implement registers encapsulated in a Verilog module, with the reset value being provided as a module input\nport.\nThis makes determining whether the input is a constant much more difficult.\nMost commercial tools relax this constraint and simply map the edge-sensitive reset to a level-sensitive one.\nThis does not preserve the semantics of the input, which is bad.\nMost synthesis tools will then go ahead and fail during synthesis if a register\u2019s reset value does not end up being a constant value.\n\nTherefore the Deseq pass does not verify that a register\u2019s reset value is a constant.\nInstead, it applies the same transform from edge-sensitive to level-sensitive reset as most other tools.\n\nTypes\u00a0[\u00b6](#types)\n-----------------\n\n### TimeType\u00a0[\u00b6](#timetype)\n\n*Time type*\n\nSyntax: `!llhd.time`\n\nRepresents a simulation time value as a combination of a real time value in\nseconds (or any smaller SI time unit), a delta value representing\ninfinitesimal time steps, and an epsilon value representing an absolute time\nslot within a delta step (used to model SystemVerilog scheduling regions).\n\n### RefType\u00a0[\u00b6](#reftype)\n\n*A reference to a signal or variable*\n\nSyntax:\n\n```\n!llhd.ref<\n  Type   # nestedType\n>\n```\n\nRepresents a reference to a value. Signals return a reference to the\nunderlying value, which allows them to be probed or driven.\n\n#### Parameters:\u00a0[\u00b6](#parameters)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| nestedType | `Type` |  |\n\nAttributes\u00a0[\u00b6](#attributes)\n---------------------------\n\n### InnerSymAttr\u00a0[\u00b6](#innersymattr)\n\n*Inner symbol definition*\n\nDefines the properties of an inner\\_sym attribute. It specifies the symbol\nname and symbol visibility for each field ID. For any ground types,\nthere are no subfields and the field ID is 0. For aggregate types, a\nunique field ID is assigned to each field by visiting them in a\ndepth-first pre-order. The custom assembly format ensures that for ground\ntypes, only `@<sym_name>` is printed.\n\n#### Parameters:\u00a0[\u00b6](#parameters-1)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| props | `::llvm::ArrayRef<InnerSymPropertiesAttr>` |  |\n\n### InnerSymPropertiesAttr\u00a0[\u00b6](#innersympropertiesattr)\n\n#### Parameters:\u00a0[\u00b6](#parameters-2)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| name | `::mlir::StringAttr` |  |\n| fieldID | `uint64_t` |  |\n| sym\\_visibility | `::mlir::StringAttr` |  |\n\n### TimeAttr\u00a0[\u00b6](#timeattr)\n\n*Time attribute*\n\nRepresents a value of the LLHD time type.\n\nExample: `#llhd.time<0ns, 1d, 0e>`\n\n#### Parameters:\u00a0[\u00b6](#parameters-3)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| type | `llhd::TimeType` |  |\n| time | `uint64_t` |  |\n| timeUnit | `::llvm::StringRef` | SI time unit |\n| delta | `unsigned` |  |\n| epsilon | `unsigned` |  |\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `llhd.combinational` (::circt::llhd::CombinationalOp)\u00a0[\u00b6](#llhdcombinational-circtllhdcombinationalop)\n\n*A process that runs when any of its operand values change*\n\nSyntax:\n\n```\noperation ::= `llhd.combinational` (`->` type($results)^)?\n              attr-dict-with-keyword $body\n```\n\nAn `llhd.combinational` op encapsulates a region of IR that executes once at\nthe beginning of the simulation, and subsequently whenever any of the values\nused in its body change. Control flow must eventually end in an `llhd.yield`\nterminator. The process may have results, in which case the `llhd.yield`\nterminators must provide a list of values to yield for the process results.\nWhenever any of the values used in the body change, the process reexecutes\nin order to compute updated results.\n\nThis op is commonly used to embed a control-flow description of some\ncombinational logic inside the surrounding module\u2019s graph region.\n\nExample:\n\n```\nhw.module @Foo() {\n  %0, %1 = llhd.combinational -> i42, i9001 {\n    cf.cond_br %2, ^bb1(%3, %4 : i42, i9001), ^bb1(%5, %6 : i42, i9001)\n  ^bb1(%7: i42, %8: i9001):\n    llhd.yield %7, %8 : i42, i9001\n  }\n}\n```\n\nTraits: `HasParent<hw::HWModuleOp>`, `NoRegionArguments`, `ProceduralRegion`, `RecursiveMemoryEffects`\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `llhd.constant_time` (::circt::llhd::ConstantTimeOp)\u00a0[\u00b6](#llhdconstant_time-circtllhdconstanttimeop)\n\n*Introduce a new time constant.*\n\nSyntax:\n\n```\noperation ::= `llhd.constant_time` $value attr-dict\n```\n\nThe `llhd.constant_time` instruction introduces a new constant time value as\nan SSA-operator.\n\nExample:\n\n```\n%1 = llhd.constant_time #llhd.time<1ns, 2d, 3d>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | llhd::TimeAttr | time attribute |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `result` | time type |\n\n### `llhd.current_time` (::circt::llhd::CurrentTimeOp)\u00a0[\u00b6](#llhdcurrent_time-circtllhdcurrenttimeop)\n\n*Get the current simulation time*\n\nSyntax:\n\n```\noperation ::= `llhd.current_time` attr-dict\n```\n\nMaterializes the current simulation time as an SSA value. This is equivalent\nto the `$time`, `$stime`, and `$realtime` system tasks in SystemVerilog, and\nthe `now` keyword in VHDL.\n\nThis operation has a memory read side effect to avoid motion and CSE across\n`llhd.wait` operations, and other operations that may suspend execution.\n\nInterfaces: `InferTypeOpInterface`, `MemoryEffectOpInterface (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}`\n\n#### Results:\u00a0[\u00b6](#results-2)\n\n| Result | Description |\n| --- | --- |\n| `result` | time type |\n\n### `llhd.delay` (::circt::llhd::DelayOp)\u00a0[\u00b6](#llhddelay-circtllhddelayop)\n\n*Specifies value propagation delay*\n\nSyntax:\n\n```\noperation ::= `llhd.delay` $input `by` $delay attr-dict `:` type($result)\n```\n\nThis operation propagates all value changes of the input to the output after\nthe specified time delay.\nReference values are not supported (e.g., pointers, inout, etc.)\nsince the store-like operation used for those types should encode a delayed\nstore.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-2)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `delay` | llhd::TimeAttr | time attribute |\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `input` | a type without inout |\n\n#### Results:\u00a0[\u00b6](#results-3)\n\n| Result | Description |\n| --- | --- |\n| `result` | a type without inout |\n\n### `llhd.drv` (::circt::llhd::DriveOp)\u00a0[\u00b6](#llhddrv-circtllhddriveop)\n\n*Drive a value into a signal.*\n\nSyntax:\n\n```\noperation ::= `llhd.drv` $signal `,` $value `after` $time ( `if` $enable^ )? attr-dict `:`\n              type($value)\n```\n\nThe `llhd.drv` operation drives a new value onto a signal. A time\noperand also has to be passed, which specifies the frequency at which\nthe drive will be performed. An optional enable value can be passed as\nlast argument. In this case the drive will only be performed if the\nvalue is 1. In case no enable signal is passed the drive will always be\nperformed. This operation does not define any new SSA operands.\n\nExample:\n\n```\n%true = hw.constant true\n%false = hw.constant false\n%time = llhd.constant_time <1ns, 0d, 0e>\n%sig = llhd.sig %true : i1\n\nllhd.drv %sig, %false after %time : i1\nllhd.drv %sig, %false after %time if %true : i1\n```\n\nInterfaces: `DestructurableAccessorOpInterface`, `SafeMemorySlotAccessOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `signal` | a reference to a signal or variable |\n| `value` | any type |\n| `time` | time type |\n| `enable` | 1-bit signless integer |\n\n### `llhd.final` (::circt::llhd::FinalOp)\u00a0[\u00b6](#llhdfinal-circtllhdfinalop)\n\n*A process that runs at the end of simulation*\n\nSyntax:\n\n```\noperation ::= `llhd.final` attr-dict-with-keyword $body\n```\n\nAn `llhd.final` op encapsulates a region of IR that is to be executed after\nthe last time step of a simulation has completed. This can be used to\nimplement various forms of state cleanup and tear-down. Some verifications\nops may also want to check that certain final conditions hold at the end of\na simulation run.\n\nThe `llhd.wait` terminator is not allowed in `llhd.final` processes since\nthere is no later time slot for the execution to resume. Control flow must\neventually end in an `llhd.halt` terminator.\n\nExecution order between multiple `llhd.final` ops is undefined.\n\nExample:\n\n```\nhw.module @Foo() {\n  llhd.final {\n    func.call @printSimulationStatistics() : () -> ()\n    llhd.halt\n  }\n}\n```\n\nTraits: `HasParent<hw::HWModuleOp>`, `NoRegionArguments`, `ProceduralRegion`, `RecursiveMemoryEffects`\n\n### `llhd.get_global_signal` (::circt::llhd::GetGlobalSignalOp)\u00a0[\u00b6](#llhdget_global_signal-circtllhdgetglobalsignalop)\n\n*Get a reference to a global signal*\n\nSyntax:\n\n```\noperation ::= `llhd.get_global_signal` $global_name attr-dict `:` type($result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-3)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `global_name` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Results:\u00a0[\u00b6](#results-4)\n\n| Result | Description |\n| --- | --- |\n| `result` | a reference to a signal or variable |\n\n### `llhd.global_signal` (::circt::llhd::GlobalSignalOp)\u00a0[\u00b6](#llhdglobal_signal-circtllhdglobalsignalop)\n\n*A global signal declaration*\n\nSyntax:\n\n```\noperation ::= `llhd.global_signal` $sym_name attr-dict `:` $type (`init` $initRegion^)?\n```\n\nDefine a global signal identified by a symbol name. The corresponding\n`llhd.get_global_signal` operation can be used to get a `!llhd.ref` to it.\nGlobal signals behave just like normal signals.\n\nTraits: `IsolatedFromAbove`, `NoRegionArguments`, `SingleBlock`\n\nInterfaces: `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-4)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `type` | ::mlir::TypeAttr | type attribute of any type |\n\n### `llhd.halt` (::circt::llhd::HaltOp)\u00a0[\u00b6](#llhdhalt-circtllhdhaltop)\n\n*Terminate execution of a process*\n\nSyntax:\n\n```\noperation ::= `llhd.halt` ($yieldOperands^ `:` type($yieldOperands))?\n              attr-dict\n```\n\nThe `llhd.halt` terminator suspends execution of the parent process forever,\neffectively terminating it. The `yieldOperands` are yielded as the result\nvalues of the parent process.\n\nExample:\n\n```\nllhd.halt\nllhd.halt %0, %1 : i42, i9001\n```\n\nTraits: `HasParent<ProcessOp, FinalOp>`, `Terminator`\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `yieldOperands` | variadic of any type |\n\n### `llhd.int_to_time` (::circt::llhd::IntToTimeOp)\u00a0[\u00b6](#llhdint_to_time-circtllhdinttotimeop)\n\n*Convert an integer number of femtoseconds to a time*\n\nSyntax:\n\n```\noperation ::= `llhd.int_to_time` $input attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-3)\n\n| Operand | Description |\n| --- | --- |\n| `input` | 64-bit signless integer |\n\n#### Results:\u00a0[\u00b6](#results-5)\n\n| Result | Description |\n| --- | --- |\n| `result` | time type |\n\n### `llhd.output` (::circt::llhd::OutputOp)\u00a0[\u00b6](#llhdoutput-circtllhdoutputop)\n\n*Introduce a new signal and drive a value onto it.*\n\nSyntax:\n\n```\noperation ::= `llhd.output` ( $name^ )? $value `after` $time attr-dict `:` type($value)\n```\n\nThe `llhd.output` operation introduces a new signal and continuously\ndrives a the given value onto it after a given time-delay. The same\nvalue is used to initialize the signal in the same way as the \u2018init\u2019\nvalue in `llhd.sig`. An optional name can be given to the created signal.\nThis shows up, e.g., in the simulation trace.\n\nExample:\n\n```\n%value = hw.constant true\n%time = llhd.constant_time <1ns, 0d, 0e>\n%sig = llhd.output \"sigName\" %value after %time : i1\n\n// is equivalent to\n\n%value = hw.constant true\n%time = llhd.constant_time <1ns, 0d, 0e>\n%sig = llhd.sig \"sigName\" %value : i1\nllhd.drv %sig, %value after %time : i1\n```\n\nInterfaces: `InferTypeOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-5)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-4)\n\n| Operand | Description |\n| --- | --- |\n| `value` | any type |\n| `time` | time type |\n\n#### Results:\u00a0[\u00b6](#results-6)\n\n| Result | Description |\n| --- | --- |\n| `result` | a reference to a signal or variable |\n\n### `llhd.prb` (::circt::llhd::ProbeOp)\u00a0[\u00b6](#llhdprb-circtllhdprobeop)\n\n*Probe a signal.*\n\nSyntax:\n\n```\noperation ::= `llhd.prb` $signal attr-dict `:` type($result)\n```\n\nThis operation probes a signal and returns the value it\ncurrently carries as a new SSA operand. The result type is always\nthe type carried by the signal. In SSACFG regions, the operation has a read\nside effect on the signal operand. In graph regions, the operation is\nmemory-effect free.\n\nExample:\n\n```\n%true = hw.constant true\n%sig_i1 = llhd.sig %true : i1\n%prbd = llhd.prb %sig_i1 : i1\n```\n\nInterfaces: `DestructurableAccessorOpInterface`, `InferTypeOpInterface`, `MemoryEffectOpInterface`, `SafeMemorySlotAccessOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-5)\n\n| Operand | Description |\n| --- | --- |\n| `signal` | a reference to a signal or variable |\n\n#### Results:\u00a0[\u00b6](#results-7)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `llhd.process` (::circt::llhd::ProcessOp)\u00a0[\u00b6](#llhdprocess-circtllhdprocessop)\n\n*A process that runs concurrently during simulation*\n\nSyntax:\n\n```\noperation ::= `llhd.process` (`->` type($results)^)?\n              attr-dict-with-keyword $body\n```\n\nAn `llhd.process` op encapsulates a region of IR that executes concurrently\nduring simulation. Execution can be suspended using the `llhd.wait`\nterminator, which also includes a list of values that will cause the process\nexecution to resume whenever they change. The `llhd.halt` terminator can be\nused to suspend execution forever. The process may have results, in which\ncase any `llhd.wait` or `llhd.halt` terminators must provide a list of\nvalues to yield for the process results whenever execution is suspended. The\nprocess holds these result values until it is resumed and new result values\nare yielded.\n\nExample:\n\n```\nhw.module @top() {\n  %0, %1 = llhd.process -> i42, i9001 {\n    llhd.wait yield (%2, %3 : i42, i9001), ^bb1\n  ^bb1:\n    llhd.halt %4, %5 : i42, i9001\n  }\n}\n```\n\nTraits: `HasParent<hw::HWModuleOp>`, `NoRegionArguments`, `ProceduralRegion`, `RecursiveMemoryEffects`\n\n#### Results:\u00a0[\u00b6](#results-8)\n\n| Result | Description |\n| --- | --- |\n| `results` | variadic of any type |\n\n### `llhd.sig.array_get` (::circt::llhd::SigArrayGetOp)\u00a0[\u00b6](#llhdsigarray_get-circtllhdsigarraygetop)\n\n*Extract an element from a signal of an array.*\n\nSyntax:\n\n```\noperation ::= `llhd.sig.array_get` $input `[` $index `]` attr-dict `:` type($input)\n```\n\nThe `llhd.sig.array_get` operation allows to access the element of the\n`$input` operand at position `$index`. A new subsignal aliasing the element\nwill be returned.\n\nExample:\n\n```\n// Returns a !llhd.ref<i8>\n%0 = llhd.sig.array_get %arr[%index] : !llhd.ref<!hw.array<4xi8>>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `DestructurableAccessorOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SafeMemorySlotAccessOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-6)\n\n| Operand | Description |\n| --- | --- |\n| `input` | ref of an ArrayType |\n| `index` | a signless integer bitvector |\n\n#### Results:\u00a0[\u00b6](#results-9)\n\n| Result | Description |\n| --- | --- |\n| `result` | a reference to a signal or variable |\n\n### `llhd.sig.array_slice` (::circt::llhd::SigArraySliceOp)\u00a0[\u00b6](#llhdsigarray_slice-circtllhdsigarraysliceop)\n\n*Get a range of consecutive values from a signal of an array*\n\nSyntax:\n\n```\noperation ::= `llhd.sig.array_slice` $input `at` $lowIndex attr-dict `:` type($input) `->` type($result)\n```\n\nThe `llhd.sig.array_slice` operation allows to access a sub-range of the\n`$input` operand, starting at the index given by the `$lowIndex`\noperand. The resulting slice length is defined by the result type.\nReturns a signal aliasing the elements of the slice.\n\nWidth of \u2019lowIndex\u2019 is defined to be the precise number of bits required to\nindex the \u2018input\u2019 array. More precisely: for an input array of size M,\nthe width of \u2019lowIndex\u2019 is ceil(log2(M)). Lower and upper bound indexes\nwhich are larger than the size of the \u2018input\u2019 array results in undefined\nbehavior.\n\nExample:\n\n```\n%3 = llhd.sig.array_slice %input at %lowIndex :\n  (!llhd.ref<!hw.array<4xi8>>) -> !llhd.ref<!hw.array<2xi8>>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-7)\n\n| Operand | Description |\n| --- | --- |\n| `input` | ref of an ArrayType |\n| `lowIndex` | a signless integer bitvector |\n\n#### Results:\u00a0[\u00b6](#results-10)\n\n| Result | Description |\n| --- | --- |\n| `result` | ref of an ArrayType |\n\n### `llhd.sig.extract` (::circt::llhd::SigExtractOp)\u00a0[\u00b6](#llhdsigextract-circtllhdsigextractop)\n\n*Extract a range of bits from an integer signal*\n\nSyntax:\n\n```\noperation ::= `llhd.sig.extract` $input `from` $lowBit attr-dict `:` type($input) `->` type($result)\n```\n\nThe `llhd.sig.extract` operation allows to access a range of bits\nof the `$input` operand, starting at the index given by the `$lowBit`\noperand. The result length is defined by the result type.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `DestructurableAccessorOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SafeMemorySlotAccessOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-8)\n\n| Operand | Description |\n| --- | --- |\n| `input` | ref of a signless integer bitvector |\n| `lowBit` | a signless integer bitvector |\n\n#### Results:\u00a0[\u00b6](#results-11)\n\n| Result | Description |\n| --- | --- |\n| `result` | ref of a signless integer bitvector |\n\n### `llhd.sig.struct_extract` (::circt::llhd::SigStructExtractOp)\u00a0[\u00b6](#llhdsigstruct_extract-circtllhdsigstructextractop)\n\n*Extract a field from a signal of a struct.*\n\nSyntax:\n\n```\noperation ::= `llhd.sig.struct_extract` $input `[` $field `]` attr-dict `:` type($input)\n```\n\nThe `llhd.sig.struct_extract` operation allows access to the field of the\n`$input` operand given by its name via the `$field` attribute.\nA new subsignal aliasing the field will be returned.\n\nExample:\n\n```\n// Returns a !llhd.ref<i8>\n%0 = llhd.sig.struct_extract %struct[\"foo\"]\n  : !llhd.ref<!hw.struct<foo: i8, bar: i16>>\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `DestructurableAccessorOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SafeMemorySlotAccessOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-6)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `field` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-9)\n\n| Operand | Description |\n| --- | --- |\n| `input` | ref of a StructType |\n\n#### Results:\u00a0[\u00b6](#results-12)\n\n| Result | Description |\n| --- | --- |\n| `result` | ref of any type |\n\n### `llhd.sig` (::circt::llhd::SignalOp)\u00a0[\u00b6](#llhdsig-circtllhdsignalop)\n\n*Create a signal.*\n\nSyntax:\n\n```\noperation ::= `llhd.sig` `` custom<ImplicitSSAName>($name) $init attr-dict\n              `:` type($init)\n```\n\nThe `llhd.sig` instruction introduces a new signal in the IR. The input\noperand determines the initial value carried by the signal, while the\nresult type will always be a signal carrying the type of the init operand.\nA signal defines a unique name within the entity it resides in.\n\nExample:\n\n```\n%c123_i64 = hw.constant 123 : i64\n%foo = llhd.sig %c123_i64 : i64\n%0 = llhd.sig name \"foo\" %c123_i64 : i64\n```\n\nThis example creates a new signal named \u201cfoo\u201d, carrying an `i64` type with\ninitial value of 123.\n\nInterfaces: `DestructurableAllocationOpInterface`, `InferTypeOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-7)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-10)\n\n| Operand | Description |\n| --- | --- |\n| `init` | any type |\n\n#### Results:\u00a0[\u00b6](#results-13)\n\n| Result | Description |\n| --- | --- |\n| `result` | a reference to a signal or variable |\n\n### `llhd.time_to_int` (::circt::llhd::TimeToIntOp)\u00a0[\u00b6](#llhdtime_to_int-circtllhdtimetointop)\n\n*Convert a time to an integer number of femtoseconds*\n\nSyntax:\n\n```\noperation ::= `llhd.time_to_int` $input attr-dict\n```\n\nIf the time value converted to femtoseconds does not fit into an `i64`, the\nresult is undefined.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-11)\n\n| Operand | Description |\n| --- | --- |\n| `input` | time type |\n\n#### Results:\u00a0[\u00b6](#results-14)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit signless integer |\n\n### `llhd.wait` (::circt::llhd::WaitOp)\u00a0[\u00b6](#llhdwait-circtllhdwaitop)\n\n*Suspend execution of a process*\n\nSyntax:\n\n```\noperation ::= `llhd.wait` (`yield` ` ` `(` $yieldOperands^ `:` type($yieldOperands) `)` `,`)?\n              (`delay` $delay^ `,`)?\n              (`(`$observed^ `:` qualified(type($observed))`)` `,`)?\n              $dest (`(` $destOperands^ `:` qualified(type($destOperands)) `)`)?\n              attr-dict\n```\n\nThe `llhd.wait` terminator suspends execution of the parent process until\nany of the `observed` values change or a fixed `delay` has passed. Execution\nresumes at the `dest` block with the `destOperands` arguments. The\n`yieldOperands` are yielded as the result values of the parent process.\n\nExample:\n\n```\nllhd.wait ^bb1(%0, %1 : i42, i9001)\nllhd.wait yield (%0, %1 : i42, i9001), ^bb1\nllhd.wait delay %time, ^bb1\nllhd.wait (%0, %1 : i42, i9001), ^bb1\n```\n\nTraits: `AttrSizedOperandSegments`, `HasParent<ProcessOp>`, `Terminator`\n\n#### Operands:\u00a0[\u00b6](#operands-12)\n\n| Operand | Description |\n| --- | --- |\n| `yieldOperands` | variadic of any type |\n| `delay` | time type |\n| `observed` | variadic of a known primitive element |\n| `destOperands` | variadic of any type |\n\n#### Successors:\u00a0[\u00b6](#successors)\n\n| Successor | Description |\n| --- | --- |\n| `dest` | any successor |\n\n### `llhd.yield` (::circt::llhd::YieldOp)\u00a0[\u00b6](#llhdyield-circtllhdyieldop)\n\n*Yield results back from a combinational process*\n\nSyntax:\n\n```\noperation ::= `llhd.yield` ($yieldOperands^ `:` type($yieldOperands))?\n              attr-dict\n```\n\nThe `llhd.yield` terminator terminates control flow in the parent process\nand yields the `yieldOperands` as the result values of the process.\n\nExample:\n\n```\nllhd.combinational {\n  llhd.yield\n}\n%2:2 = llhd.combinational -> i42, i9001 {\n  llhd.yield %0, %1 : i42, i9001\n}\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<CombinationalOp, GlobalSignalOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-13)\n\n| Operand | Description |\n| --- | --- |\n| `yieldOperands` | variadic of any type |\n\nPasses\u00a0[\u00b6](#passes)\n-------------------\n\n### `-llhd-combine-drives`\u00a0[\u00b6](#-llhd-combine-drives)\n\n*Combine scalar drives into aggregate drives*\n\nIf individual drives cover all of an aggregate signal\u2019s fields, merge them\ninto a single drive of the whole aggregate value.\n\n### `-llhd-deseq`\u00a0[\u00b6](#-llhd-deseq)\n\n*Convert sequential processes to registers*\n\n### `-llhd-hoist-signals`\u00a0[\u00b6](#-llhd-hoist-signals)\n\n*Hoist probes and promote drives to process results*\n\n### `-llhd-inline-calls`\u00a0[\u00b6](#-llhd-inline-calls)\n\n*Inline all function calls in HW modules*\n\nInlines all `func.call` operations nested within `llhd.combinational`,\n`llhd.process`, and `llhd.final` ops within `hw.module`s. The `func.func`\ndefinitions are left untouched. After the inlining, MLIR\u2019s symbol DCE pass\nmay be used to eliminate the function definitions where possible.\n\nThis pass expects the `llhd-wrap-procedural-ops` pass to have already run.\nOtherwise call ops immediately in the module body, a graph region, cannot be\ninlined at all since the graph region cannot accommodate the function\u2019s\ncontrol flow.\n\n#### Statistics\u00a0[\u00b6](#statistics)\n\n```\ncalls-inlined : Number of call ops that were inlined\n```\n\n### `-llhd-lower-processes`\u00a0[\u00b6](#-llhd-lower-processes)\n\n*Convert process ops to combinational ops where possible*\n\n### `-llhd-mem2reg`\u00a0[\u00b6](#-llhd-mem2reg)\n\n*Promotes memory and signal slots into values.*\n\n### `-llhd-remove-control-flow`\u00a0[\u00b6](#-llhd-remove-control-flow)\n\n*Remove acyclic control flow and replace block args with muxes*\n\nRemove the control flow in `llhd.combinational` operations by merging all\nblocks into the entry block and replacing block arguments with multiplexers.\nThis requires the control flow to be acyclic, for example by unrolling all\nloops beforehand. Additionally, since this moves operations from\nconditionally executed blocks into the unconditionally executed entry block,\nall operations must be side-effect free.\n\n### `-llhd-sig2reg`\u00a0[\u00b6](#-llhd-sig2reg)\n\n*Promote LLHD signals to SSA values*\n\n### `-llhd-unroll-loops`\u00a0[\u00b6](#-llhd-unroll-loops)\n\n*Unroll control flow loops with static bounds*\n\nUnroll loops in `llhd.combinational` operations by replicating the loop body\nand replacing induction variables with constants. The loop bounds must be\nknown at compile time.\n\n### `-llhd-wrap-procedural-ops`\u00a0[\u00b6](#-llhd-wrap-procedural-ops)\n\n*Wrap procedural ops in modules to make them inlinable*\n\nOperations such as `func.call` or `scf.if` may appear in an `hw.module` body\ndirectly. They cannot be inlined into the module though, since the inlined\nfunction or result of converting the SCF ops to the CF dialect may create\ncontrol-flow operations with multiple blocks. This pass wraps such\noperations in `llhd.combinational` ops to give them an SSACFG region to\ninline into.\n\n#### Statistics\u00a0[\u00b6](#statistics-1)\n\n```\nops-wrapped : Number of procedural ops wrapped\n```\n\n [Prev - Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/ \"Interoperability Dialect Rationale\")\n[Next - LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/ \"LTL Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/LTL/index.md"
  },
  {
    "role": "user",
    "content": "LTL Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nLTL Dialect\n===========\n\nThis dialect provides operations and types to model\n[Linear Temporal Logic](https://en.wikipedia.org/wiki/Linear_temporal_logic), sequences, and properties, which are useful for hardware verification.\n\n* [Rationale](#rationale)\n  + [Sequences and Properties](#sequences-and-properties)\n* [Representing SVAs](#representing-svas)\n  + [Sequence Concatenation and Cycle Delay](#sequence-concatenation-and-cycle-delay)\n  + [Implication](#implication)\n  + [Repetition](#repetition)\n  + [Clocking](#clocking)\n  + [Disable Iff](#disable-iff)\n* [Mapping SVA to CIRCT dialects](#mapping-sva-to-circt-dialects)\n* [Representing the LTL Formalism](#representing-the-ltl-formalism)\n  + [Next / Delay](#next--delay)\n  + [Until and Eventually](#until-and-eventually)\n  + [Concatenation and Repetition](#concatenation-and-repetition)\n* [Types](#types)\n  + [Overview](#overview)\n  + [PropertyType](#propertytype)\n  + [SequenceType](#sequencetype)\n* [Operations](#operations)\n  + [`ltl.and` (circt::ltl::AndOp)](#ltland-circtltlandop)\n  + [`ltl.boolean_constant` (circt::ltl::BooleanConstantOp)](#ltlboolean_constant-circtltlbooleanconstantop)\n  + [`ltl.clock` (circt::ltl::ClockOp)](#ltlclock-circtltlclockop)\n  + [`ltl.concat` (circt::ltl::ConcatOp)](#ltlconcat-circtltlconcatop)\n  + [`ltl.delay` (circt::ltl::DelayOp)](#ltldelay-circtltldelayop)\n  + [`ltl.eventually` (circt::ltl::EventuallyOp)](#ltleventually-circtltleventuallyop)\n  + [`ltl.goto_repeat` (circt::ltl::GoToRepeatOp)](#ltlgoto_repeat-circtltlgotorepeatop)\n  + [`ltl.implication` (circt::ltl::ImplicationOp)](#ltlimplication-circtltlimplicationop)\n  + [`ltl.intersect` (circt::ltl::IntersectOp)](#ltlintersect-circtltlintersectop)\n  + [`ltl.non_consecutive_repeat` (circt::ltl::NonConsecutiveRepeatOp)](#ltlnon_consecutive_repeat-circtltlnonconsecutiverepeatop)\n  + [`ltl.not` (circt::ltl::NotOp)](#ltlnot-circtltlnotop)\n  + [`ltl.or` (circt::ltl::OrOp)](#ltlor-circtltlorop)\n  + [`ltl.past` (circt::ltl::PastOp)](#ltlpast-circtltlpastop)\n  + [`ltl.repeat` (circt::ltl::RepeatOp)](#ltlrepeat-circtltlrepeatop)\n  + [`ltl.until` (circt::ltl::UntilOp)](#ltluntil-circtltluntilop)\n\nRationale\u00a0[\u00b6](#rationale)\n-------------------------\n\nThe main goal of the `ltl` dialect is to capture the core formalism underpinning SystemVerilog Assertions (SVAs), the de facto standard for describing temporal logic sequences and properties in hardware verification. (See IEEE 1800-2017 section 16 \u201cAssertions\u201d.) We expressly try *not* to model this dialect like an AST for SVAs, but instead try to strip away all the syntactic sugar and Verilog quirks, and distill out the core foundation as an IR. Within the CIRCT project, this dialect intends to enable emission of rich temporal assertions as part of the Verilog output, but also provide a foundation for formal tools built ontop of CIRCT.\n\n### Sequences and Properties\u00a0[\u00b6](#sequences-and-properties)\n\nThe core building blocks for modeling temporal logic in the `ltl` dialect are *sequences* and *properties*. In a nutshell, sequences behave like regular expressions over time, whereas properties provide the quantifiers to express that sequences must be true under certain conditions.\n\n**Sequences** describe boolean expressions at different points in time. They can be easily verified by a finite state automaton, similar to how regular expressions and languages have an equivalent automaton that recognizes the language. For example:\n\n* The boolean `a` is a sequence. It holds if `a` is true in cycle 0 (the current cycle).\n* The boolean expression `a & b` is also a sequence. It holds if `a & b` is true in cycle 0.\n* `##1 a` checks that `a` is true in cycle 1 (the next cycle).\n* `##[1:4] a` checks that `a` is true anywhere in cycle 1, 2, 3, or 4.\n* `a ##1 b` checks that `a` holds in cycle 0 and `b` holds in cycle 1.\n* `##1 (a ##1 b)` checks that `a` holds in cycle 1 and `b` holds in cycle 2.\n* `(a ##1 b) ##5 (c ##1 d)` checks that the sequence `(a ##1 b)` holds and is followed by the sequence `(c ##1 d)` 5 or 6 cycles later. Concretely, this checks that `a` holds in cycle 0, `b` holds in cycle 1, `c` holds in cycle 6 (5 cycles after the first sequence ended in cycle 1), and `d` holds in cycle 7.\n\n**Properties** describe concrete, testable propositions or claims built from sequences. While sequences can observe and match a certain behavior in a circuit at a specific point in time, properties allow you to express that these sequences hold in every cycle, or hold at some future point in time, or that one sequence is always followed by another. For example:\n\n* `always s` checks that the sequence `s` holds in every cycle. This is often referred to as the **G** (or \u201cglobally\u201d) operator in LTL.\n* `eventually s` checks that the sequence `s` will hold at some cycle now or in the future. This is often referred to as the **F** (or \u201cfinally\u201d) operator in LTL.\n* `p until q` checks that the property `p` holds in every cycle before the first cycle `q` holds. This is often referred to as the **U** (or \u201cuntil\u201d) operator in LTL.\n* `s implies t` checks that whenever the sequence `s` is observed, it is immediately followed by sequence `t`.\n\nTraditional definitions of the LTL formalism do not make a distinction between sequences and properties. Most of their operators fall into the property category, for example, quantifiers like *globally*, *finally*, *release*, and *until*. The set of sequence operators is usually very small, since it is not necessary for academic treatment, consisting only of the *next* operator. The `ltl` dialect provides a richer set of operations to model sequences.\n\nRepresenting SVAs\u00a0[\u00b6](#representing-svas)\n-----------------------------------------\n\n### Sequence Concatenation and Cycle Delay\u00a0[\u00b6](#sequence-concatenation-and-cycle-delay)\n\nThe primary building block for sequences in SVAs is the *concatenation* expression. Concatenation is always associated with a cycle delay, which indicates how many cycles pass between the end of the LHS sequence and the start of the RHS sequence. One, two, or more sequences can be concatenated at once, and the overall concatenation can have an initial cycle delay. For example:\n\n```\na ##1 b ##1 c      // 1 cycle delay between a, b, and c\n##2 a ##1 b ##1 c  // same, plus 2 cycles of initial delay before a\n```\n\nIn the simplest form, a cycle delay can appear as a prefix of another sequence, e.g., `##1 a`. This is essentially a concatenation with only one sequence, `a`, and an initial cycle delay of the concatenation of `1`. The prefix delays map to the LTL dialect as follows:\n\n* `##N seq`. **Fixed delay.** Sequence `seq` has to match exactly `N` cycles in the future. Equivalent to `ltl.delay %seq, N, 0`.\n* `##[N:M] seq`. **Bounded range delay.** Sequence `seq` has to match anywhere between `N` and `M` cycles in the future, inclusive. Equivalent to `ltl.delay %seq, N, (M-N)`\n* `##[N:$] seq`. **Unbounded range delay.** Sequence `seq` has to match anywhere at or beyond `N` cycles in the future, after a finite amount of cycles. Equivalent to `ltl.delay %seq, N`.\n* `##[*] seq`. Shorthand for `##[0:$]`. Equivalent to `ltl.delay %seq, 0`.\n* `##[+] seq`. Shorthand for `##[1:$]`. Equivalent to `ltl.delay %seq, 1`.\n\nConcatenation of two sequences always involves a cycle delay specification in between them, e.g., `a ##1 b` where sequence `b` starts in the cycle after `a` ends. Zero-cycle delays can be specified, e.g., `a ##0 b` where `b` starts in the same cycle as `a` ends. If `a` and `b` are booleans, `a ##0 b` is equivalent to `a && b`.\n\nThe dialect separates concatenation and cycle delay into two orthogonal operations, `ltl.concat` and `ltl.delay`, respectively. The former models concatenation as `a ##0 b`, and the latter models delay as a prefix `##1 c`. The SVA concatenations with their infix delays map to the LTL dialect as follows:\n\n* `seqA ##N seqB`. **Binary concatenation.** Sequence `seqB` follows `N` cycles after `seqA`. This can be represented as `seqA ##0 (##N seqB)`, which is equivalent to\n\n  ```\n  %0 = ltl.delay %seqB, N, 0\n  ltl.concat %seqA, %0\n  ```\n* `seqA ##N seqB ##M seqC`. **Variadic concatenation.** Sequence `seqC` follows `M` cycles after `seqB`, which itself follows `N` cycles after `seqA`. This can be represented as `seqA ##0 (##N seqB) ##0 (##M seqC)`, which is equivalent to\n\n  ```\n  %0 = ltl.delay %seqB, N, 0\n  %1 = ltl.delay %seqC, M, 0\n  ltl.concat %seqA, %0, %1\n  ```\n\n  Since concatenation is associative, this is also equivalent to `seqA ##N (seqB ##M seqC)`:\n\n  ```\n  %0 = ltl.delay %seqC, M, 0\n  %1 = ltl.concat %seqB, %0\n  %2 = ltl.delay %1, N, 0\n  ltl.concat %seqA, %2\n  ```\n\n  And also `(seqA ##N seqB) ##M seqC`:\n\n  ```\n  %0 = ltl.delay %seqB, N, 0\n  %1 = ltl.concat %seqA, %0\n  %2 = ltl.delay %seqC, M, 0\n  ltl.concat %1, %2\n  ```\n* `##N seqA ##M seqB`. **Initial delay.** Sequence `seqB` follows `M` cycles afer `seqA`, which itself starts `N` cycles in the future. This is equivalent to a delay on `seqA` within the concatenation:\n\n  ```\n  %0 = ltl.delay %seqA, N, 0\n  %1 = ltl.delay %seqB, M, 0\n  ltl.concat %0, %1\n  ```\n\n  Alternatively, the delay can also be placed on the entire concatenation:\n\n  ```\n  %0 = ltl.delay %seqB, M, 0\n  %1 = ltl.concat %seqA, %0\n  ltl.delay %1, N, 0\n  ```\n* Only the fixed delay `##N` is shown here for simplicity, but the examples extend to the other delay flavors `##[N:M]`, `##[N:$]`, `##[*]`, and `##[+]`.\n\n### Implication\u00a0[\u00b6](#implication)\n\n```\nseq |-> prop\nseq |=> prop\n```\n\nThe overlapping `|->` and non-overlapping `|=>` implication operators of SVA, which only check a property after a precondition sequence matches, map to the `ltl.implication` operation. When the sequence matches in the overlapping case `|->`, the property check starts at the same time the matched sequence ended. In the non-overlapping case `|=>`, the property check starts *at the clock tick after the* end of the matched sequence, unless the matched sequence was empty, in which special rules apply. (See IEEE 1800-2017 section 16.12.7 \u201cImplication\u201d.) The non-overlapping operator can be expressed in terms of the overlapping operator:\n\n```\nseq |=> prop\n```\n\nis equivalent to\n\n```\n(seq ##1 true) |-> prop\n```\n\nThe `ltl.implication` op implements the overlapping case `|->`, such that the two SVA operator flavors map to the `ltl` dialect as follows:\n\n* `seq |-> prop`. **Overlapping implication.** Equivalent to `ltl.implication %seq, %prop`.\n* `seq |=> prop`. **Non-overlapping implication.** Equivalent to\n\n  ```\n  %true = hw.constant true\n  %0 = ltl.delay %true, 1, 0\n  %1 = ltl.concat %seq, %0\n  ltl.implication %1, %prop\n  ```\n\nAn important benefit of only modeling the overlapping `|->` implication operator is that it does not interact with a clock. The end point of the left-hand sequence is the starting point of the right-hand sequence. There is no notion of delay between the end of the left and the start of the right sequence. Compare this to the `|=>` operator in SVA, which implies that the right-hand sequence happens at \u201cstrictly the next clock tick\u201d, which requires the operator to have a notion of time and clocking. As described above, it is still possible to model this using an explicit `ltl.delay` op, which already has an established interaction with a clock.\n\n### Repetition\u00a0[\u00b6](#repetition)\n\nConsecutive repetition repeats the sequence by a number of times. For example, `s[*3]` repeats the sequence `s` three times, which is equivalent to `s ##1 s ##1 s`. This also applies when the sequence `s` matches different traces with different lengths. For example `(##[0:3] a)[*2]` is equivalent to the disjunction of all the combinations such as `a ##1 a`, `a ##1 (##3 a)`, `(##3 a) ##1 (##2 a)`. However, the repetition with unbounded range cannot be expanded to the concatenations as it produces an infinite formula.\n\nThe definition of `ltl.repeat` is similar to that of `ltl.delay`. The mapping from SVA\u2019s consecutive repetition to the LTL dialect is as follows:\n\n* `seq[*N]`. **Fixed repeat.** Repeats `N` times. Equivalent to `ltl.repeat %seq, N, 0`.\n* `seq[*N:M]`. **Bounded range repeat.** Repeats `N` to `M` times. Equivalent to `ltl.repeat %seq, N, (M-N)`.\n* `seq[*N:$]`. **Unbounded range repeat.** Repeats `N` to an indefinite finite number of times. Equivalent to `ltl.repeat %seq, N`.\n* `seq[*]`. Shorthand for `seq[*0:$]`. Equivalent to `ltl.repeat %seq, 0`.\n* `seq[+]`. Shorthand for `seq[*1:$]`. Equivalent to `ltl.repeat %seq, 1`.\n\n#### Non-Consecutive Repetition\u00a0[\u00b6](#non-consecutive-repetition)\n\nNon-consecutive repetition checks that a sequence holds a certain number of times within an arbitrary repetition of the sequence. There are two ways of expressing non-consecutive repetition, either by including the last iteration in the count or not. If the last iteration is included, then this is called a \u201cgo-to\u201d style non-consecutive repetition and can be defined using the `ltl.goto_repeat <input>, <N>, <window>` operation, e.g. `a !b b b !b !b b c` is a valid observation of `ltl.goto_repeat %b, 1, 2`, but `a !b b b !b !b b !b !b c` is not. If we omit the constraint of having the last iteration hold, then this is simply called a non-consecutive repetition, and can be defined using the `ltl.non_consecutive_repeat <input, <N>, <window>` operation, e.g. both `a !b b b !b !b b c` and `a !b b b !b !b b !b !b c` are valid observations of `ltl.non_consecutive_repeat %b, 1, 2`. The SVA mapping of these operations is as follows:\n\n* `seq[->n:m]`: **Go-To Style Repetition**, equivalent to `ltl.goto_repeat %seq, n, (m-n)`.\n* `seq[=n:m]` : **Non-Consecutive Repetition** equivalent to `ltl.non_consecutive_repeat %seq, n, (m-n)`.\n\n### Clocking\u00a0[\u00b6](#clocking)\n\nSequence and property expressions in SVAs can specify a clock with respect to which all cycle delays are expressed. (See IEEE 1800-2017 section 16.16 \u201cClock resolution\u201d.) These map to the `ltl.clock` operation.\n\n* `@(posedge clk) seqOrProp`. **Trigger on low-to-high clock edge.** Equivalent to `ltl.clock %seqOrProp, posedge %clk`.\n* `@(negedge clk) seqOrProp`. **Trigger on high-to-low clock edge.** Equivalent to `ltl.clock %seqOrProp, negedge %clk`.\n* `@(edge clk) seqOrProp`. **Trigger on any clock edge.** Equivalent to `ltl.clock %seqOrProp, edge %clk`.\n\n### Disable Iff\u00a0[\u00b6](#disable-iff)\n\nProperties in SVA can have a disable condition attached, which allows for preemptive resets to be expressed. If the disable condition is true at any time during the evaluation of a property, the property is considered disabled. (See IEEE 1800-2017 end of section 16.12 \u201cDeclaring properties\u201d.) This maps to the `ltl.disable` operation.\n\n* `disable iff (expr) prop`. **Disable condition.** Equivalent to `ltl.disable %prop if %expr`.\n\nNote that SVAs only allow for entire properties to be disabled, at the point at which they are passed to an assert, assume, or cover statement. It is explicitly forbidden to define a property with a `disable iff` clause and then using it within another property. For example, the following is forbidden:\n\n```\nproperty p0; disable iff (cond) a |-> b; endproperty\nproperty p1; eventually p0; endproperty\n```\n\nIn this example, `p1` refers to property `p0`, which is illegal in SVA since `p0` itself defines a disable condition.\n\nIn contrast, the LTL dialect explicitly allows for properties to be disabled at arbitrary points, and disabled properties to be used in other properties. Since a disabled nested property also disables the parent property, the IR can always be rewritten into a form where there is only one `disable iff` condition at the root of a property expression.\n\nMapping SVA to CIRCT dialects\u00a0[\u00b6](#mapping-sva-to-circt-dialects)\n-----------------------------------------------------------------\n\nKnowing how to map SVA constructs to CIRCT is important to allow these to expressed correctly in any front-end. Here you will find a non-exhaustive list of conversions from SVA to CIRCT dialects.\n\n* **properties**: `!ltl.property`.\n* **sequences**: `!ltl.sequence`.\n* **`disable iff (cond)`**: `ltl.disable %prop if %cond`\n* **local variables**: Not currently possible to encode.\n* **`$rose(a)`**:\n\n```\n%1 = ltl.compreg %a, %clock : i1\n%rose = comb.icmp bin ult %1, %a : i1\n```\n\n* **`$fell(a)`**:\n\n```\n%1 = ltl.compreg %a, %clock : i1\n%fell = comb.icmp bin ugt %a, %1 : i1\n```\n\n* **`$stable(a)`**:\n\n```\n%1 = ltl.compreg %a, %clock : i1\n%rose = comb.icmp bin eq %a, %1 : i1\n```\n\n* **`$past(a, n)`**:\n\n```\n%zero = hw.constant 0 : i1\n%true = hw.constant 1 : i1\n%1 = seq.shiftreg n, %a, %clk, %true, powerOn %zero : i1\n```\n\n> The following functions are not yet supported by CIRCT:\n>\n> * **`$onehot(a)`**\n> * **`$onehot0(a)`**\n> * **`$isunknown(a)`**\n> * **`$countones(a)`**\n\n* **`a ##n b`**:\n\n```\n%a_n = ltl.delay %a, n, 0 : i1\n%anb = ltl.concat %a_n, %b : !ltl.sequence\n```\n\n* **`a ##[n:m] b`**:\n\n```\n%a_n = ltl.delay %a, n, (m-n) : i1\n%anb = ltl.concat %a_n, %b : !ltl.sequence\n```\n\n* **`s [*n]`**:\n\n```\n%repsn = ltl.repeat %s, n, 0 : !ltl.sequence\n```\n\n* **`s [*n:m]`**:\n\n```\n%repsnm = ltl.repeat %s, n, (m-n) : !ltl.sequence\n```\n\n* **`s[*n:$]`**:\n\n```\n%repsninf = ltl.repeat %s, n : !ltl.sequence\n```\n\n* **`s[->n:m]`**:\n\n```\n%1 = ltl.goto_repeat %s, n, (m-n) : !ltl.sequence\n```\n\n* **`s[=n:m]`**:\n\n```\n%1 = ltl.non_consecutive_repeat %s, n, (m-n) : !ltl.sequence\n```\n\n* **`s1 ##[+] s2`**:\n\n```\n%ds1 = ltl.delay %s1, 1\n%s1s2 = ltl.concat %ds1, %s2 : !ltl.sequence\n```\n\n* **`s1 ##[*] s2`**:\n\n```\n%ds1 = ltl.delay %s1, 0\n%s1s2 = ltl.concat %ds1, %s2 : !ltl.sequence\n```\n\n* **`s1 and s2`**:\n\n```\nltl.and %s1, %s2 : !ltl.sequence\n```\n\n* **`s1 intersect s2`**:\n\n```\nltl.intersect %s1, %s2 : !ltl.sequence\n```\n\n* **`s1 or s2`**:\n\n```\nltl.or %s1, %s2 : !ltl.sequence\n```\n\n* **`not s`**:\n\n```\nltl.not %s1 : !ltl.sequence\n```\n\n* **`first_match(s)`**: Not possible to encode yet.\n* **`expr throughout s`**:\n\n```\n%repexpr = ltl.repeat %expr, 0 : !ltl.sequence\n%res = ltl.intersect %repexpr, %s : !ltl.sequence\n```\n\n* **`s1 within s2`**:\n\n```\n%c1 = hw.constant 1 : i1\n%rep1 = ltl.repeat %c1, 0 : !ltl.sequence\n%drep1 = ltl.delay %rep1, 1, 0 : !ltl.sequence\n%ds1 = ltl.delay %s1, 1, 0 : !ltl.sequence\n%evs1 = ltl.concat %drep1, %ds1, %c1 : !ltl.sequence\n%res = ltl.intersect %evs1, %s2 : !ltl.sequence\n```\n\n* **`s |-> p`**:\n\n```\n%1 = ltl.implication %s, %p : !ltl.property\n```\n\n* **`s |=> p`**:\n\n```\n%c1 = hw.constant 1 : i1\n%ds = ltl.delay %s, 1, 0 : i1\n%antecedent = ltl.concat %ds, %c1 : !ltl.sequence\n%impl = ltl.implication %antecedent, %p : !ltl.property\n```\n\n* **`p1 implies p2`**:\n\n```\n%np1 = ltl.not %p1 : !ltl:property\n%impl = ltl.or %np1, %p2 : !ltl.property\n```\n\n* **`p1 iff p2`**: equivalent to `(not (p1 or p2)) or (p1 and p2)`\n\n```\n%p1orp2 = ltl.or %p1, %p2 : !ltl.property\n%lhs = ltl.not %p1orp2 : !ltl.property\n%rhs = ltl.and %p1, %p2 : !ltl.property\n%iff = ltl.or %lhs, %rhs : !ltl.property\n```\n\n* **`s #-# p`**:\n\n```\n%np = ltl.not %p : !ltl.property\n%impl = ltl.implication %s, %np : !ltl.property\n%res = ltl.not %impl : !ltl.property\n```\n\n* **`s #=# p`**:\n\n```\n%np = ltl.not %p : !ltl.property\t\n%ds = ltl.delay %s, 1, 0 : !ltl.sequence\n%c1 = hw.constant 1 : i1\n%ant = ltl.concat %ds, c1 : !ltl.sequence \n%impl = ltl.implication %ant, %np : !ltl.property\n%res = ltl.not %impl : !ltl.property\n```\n\n* **`strong(s)`**: default for coverpoints, not supported in other cases.\n* **`weak(s)`**: default for assert and assume, not supported for cover.\n* **`nexttime p`**:\n\n```\nltl.delay %p, 1, 0 : !ltl.sequence\n```\n\n* **`nexttime[n] p`**:\n\n```\nltl.delay %p, n, 0 : !ltl.sequence\n```\n\n* **`s_nexttime p`**: not really distinguishable from the weak version in CIRCT.\n* **`s_nexttime[n] p`**: not really distinguishable from the weak version in CIRCT.\n* **`always p`**:\n\n```\nltl.repeat %p, 0 : !ltl.sequence\n```\n\n* **`always[n:m] p`**:\n\n```\nltl.repeat %p, n, m : !ltl.sequence\n```\n\n* **`s_always[n:m] p`**: not really distinguishable in CIRCT\n* **`s_eventually p`**:\n\n```\nltl.eventually %p : !ltl.property\n```\n\n* **`eventually[n:m] p`**: not yet encodable in CIRCT.\n* **`s_eventually[n:m] p`**: not yet encodable in CIRCT.\n* **`p1 until p2`**:\n\n```\n%1 = ltl.until %p1, %p2 : !ltl.sequence\n```\n\n* **`p1 s_until p2`**: not really distinguishable from the weak version in CIRCT.\n* **`p1 until_with p2`**: Equivalent to `(p1 until p2) implies (p1 and p2)`\n\n```\n%1 = ltl.until %p1, %p2 : !ltl.sequence\n%2 = ltl.and %p1, %p2 : !ltl:property\n%n1 = ltl.not %1 : !ltl.property\n%res = ltl.or %n1, %2 : !ltl.property\n```\n\n* **`p1 s_until_with p2`**: not really distinguishable from the weak version in CIRCT.\n\n> We don\u2019t yet support abort constructs but might in the future.\n>\n> * **`accept_on ( expr ) p`**\n> * **`reject_on ( expr ) p`**\n> * **`sync_accept_on ( expr ) p`**\n> * **`sync_reject_on ( expr ) p`**\n\nRepresenting the LTL Formalism\u00a0[\u00b6](#representing-the-ltl-formalism)\n-------------------------------------------------------------------\n\n### Next / Delay\u00a0[\u00b6](#next--delay)\n\nThe `ltl.delay` sequence operation represents various shorthands for the *next*/**X** operator in LTL:\n\n| Operation | LTL Formula |\n| --- | --- |\n| `ltl.delay %a, 0, 0` | a |\n| `ltl.delay %a, 1, 0` | **X**a |\n| `ltl.delay %a, 3, 0` | **XXX**a |\n| `ltl.delay %a, 0, 2` | a \u2228 **X**a \u2228 **XX**a |\n| `ltl.delay %a, 1, 2` | **X**(a \u2228 **X**a \u2228 **XX**a) |\n| `ltl.delay %a, 0` | **F**a |\n| `ltl.delay %a, 2` | **XXF**a |\n\n### Until and Eventually\u00a0[\u00b6](#until-and-eventually)\n\n`ltl.until` is *weak*, meaning the property will hold even if the trace does not contain enough clock cycles to evaluate the property. `ltl.eventually` is *strong*, where `ltl.eventually %p` means `p` must hold at some point in the trace.\n\n### Concatenation and Repetition\u00a0[\u00b6](#concatenation-and-repetition)\n\nThe `ltl.concat` sequence operation does not have a direct equivalent in LTL. It builds a longer sequence by composing multiple shorter sequences one after another. LTL has no concept of concatenation, or a *\u201cv happens after u\u201d*, where the point in time at which v starts is dependent on how long the sequence u was.\n\nFor a sequence u with a fixed length of 2, concatenation can be represented as *\"(u happens) and (v happens 2 cycles in the future)\"*, u \u2227 **XX**v. If u has a dynamic length though, for example a delay between 1 and 2, `ltl.delay %u, 1, 1` or **X**u \u2228 **XX**u in LTL, there is no fixed number of cycles by which the sequence v can be delayed to make it start after u. Instead, all different-length variants of sequence u have to be enumerated and combined with a copy of sequence v delayed by the appropriate amount: (**X**u \u2227 **XX**v) \u2228 (**XX**u \u2227 **XXX**v). This is basically saying \u201cu delayed by 1 to 2 cycles followed by v\u201d is the same as either *\u201cu delayed by 1 cycle and v delayed by 2 cycles\u201d*, or *\u201cu delayed by 2 cycles and v delayed by 3 cycles\u201d*.\n\nThe *\u201cv happens after u\u201d* relationship is crucial to express sequences efficiently, which is why the LTL dialect has the `ltl.concat` op. If sequences are thought of as regular expressions over time, for example, `a(b|cd)` or *\u201ca followed by either (b) or (c followed by d)\u201d*, the importance of having a concatenation operation as temporal connective becomes apparent. Why LTL formalisms tend to not include such an operator is unclear.\n\nAs for `ltl.repeat`, it also relies on the semantics of *v happens after u* to compose the repeated sequences. Unlike `ltl.concat`, which can be expanded by LTL operators within a finite formula size, unbounded repetition cannot be expanded by listing all cases. This means unbounded repetition imports semantics that LTL cannot describe. The LTL dialect has this operation because it is necessary and useful for regular expressions and SVA.\n\nTypes\u00a0[\u00b6](#types)\n-----------------\n\n### Overview\u00a0[\u00b6](#overview)\n\nThe `ltl` dialect operations defines two main types returned by its operations: sequences and properties. These types form a hierarchy together with the boolean type `i1`:\n\n* a boolean `i1` is also a valid sequence\n* a sequence `!ltl.sequence` is also a valid property\n\n```\ni1 <: ltl.sequence <: ltl.property\n```\n\nThe two type constraints `AnySequenceType` and `AnyPropertyType` are provided to implement this hierarchy. Operations use these constraints for their operands, such that they can properly accept `i1` as a sequence, `i1` or a sequence as a property. The return type is an explicit `!ltl.sequence` or `!ltl.property`.\n\n### PropertyType\u00a0[\u00b6](#propertytype)\n\n*LTL property type*\n\nSyntax: `!ltl.property`\n\nThe `ltl.property` type represents a verifiable property built from linear\ntemporal logic sequences and quantifiers, for example, *\u201cif you see sequence\nA, eventually you will see sequence B\u201d*.\n\nNote that this type explicitly identifies a *property*. However, a boolean\nvalue (`i1`) or a sequence (`ltl.sequence`) is also a valid property.\nOperations that accept a property as an operand will use the `AnyProperty`\nconstraint, which also accepts `ltl.sequence` and `i1`.\n\n### SequenceType\u00a0[\u00b6](#sequencetype)\n\n*LTL sequence type*\n\nSyntax: `!ltl.sequence`\n\nThe `ltl.sequence` type represents a sequence of linear temporal logic, for\nexample, *\u201cA is true two cycles after B is true\u201d*.\n\nNote that this type explicitly identifies a *sequence*. However, a boolean\nvalue (`i1`) is also a valid sequence. Operations that accept a sequence as\nan operand will use the `AnySequence` constraint, which also accepts `i1`.\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `ltl.and` (circt::ltl::AndOp)\u00a0[\u00b6](#ltland-circtltlandop)\n\n*A conjunction of booleans, sequences, or properties.*\n\nSyntax:\n\n```\noperation ::= `ltl.and` $inputs attr-dict `:` type($inputs)\n```\n\nIf any of the `$inputs` is of type `!ltl.property`, the result of the op is\nan `!ltl.property`. Otherwise it is an `!ltl.sequence`.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of 1-bit signless integer or LTL sequence type or LTL property type |\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit signless integer or LTL sequence type or LTL property type |\n\n### `ltl.boolean_constant` (circt::ltl::BooleanConstantOp)\u00a0[\u00b6](#ltlboolean_constant-circtltlbooleanconstantop)\n\n*A constant boolean property value.*\n\nSyntax:\n\n```\noperation ::= `ltl.boolean_constant` $value attr-dict\n```\n\nRepresents a constant boolean value as an LTL property. This operation\ntakes a boolean attribute and produces an `!ltl.property` result. This is\nuseful for representing constant property values in canonicalization patterns.\n\nExample:\n\n```\n%prop = ltl.boolean_constant true\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::BoolAttr | bool attribute |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `result` | LTL property type |\n\n### `ltl.clock` (circt::ltl::ClockOp)\u00a0[\u00b6](#ltlclock-circtltlclockop)\n\n*Specify the clock for a property or sequence.*\n\nSyntax:\n\n```\noperation ::= `ltl.clock` $input `,` $edge $clock attr-dict `:` type($input)\n```\n\nSpecifies the `$edge` on a given `$clock` to be the clock for an `$input`\nproperty or sequence. All cycle delays in the `$input` implicitly refer to a\nclock that advances the state to the next cycle. The `ltl.clock` operation\nprovides that clock. The clock applies to the entire property or sequence\nexpression tree below `$input`, up to any other nested `ltl.clock`\noperations.\n\nThe operation returns a property if the `$input` is a property, and a\nsequence otherwise.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `edge` | circt::ltl::ClockEdgeAttr | clock edge |\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `clock` | 1-bit signless integer |\n\n#### Results:\u00a0[\u00b6](#results-2)\n\n| Result | Description |\n| --- | --- |\n| `result` | LTL sequence type or LTL property type |\n\n### `ltl.concat` (circt::ltl::ConcatOp)\u00a0[\u00b6](#ltlconcat-circtltlconcatop)\n\n*Concatenate sequences into a longer sequence.*\n\nSyntax:\n\n```\noperation ::= `ltl.concat` $inputs attr-dict `:` type($inputs)\n```\n\nConcatenates all of the `$inputs` sequences one after another into one\nlonger sequence. The sequences are arranged such that the end time of the\nprevious sequences coincides with the start time of the next sequence. This\nmeans there is no implicit cycle of delay between the concatenated\nsequences, which may be counterintuitive.\n\nIf a sequence should follow in the cycle after another sequence finishes,\nthat cycle of delay needs to be explicit. For example, *\u201cu followed by v in\nnext cycle\u201d* (`u ##1 v` in SVA) is represented as\n`concat(u, delay(v, 1, 0))`:\n\n```\n%0 = ltl.delay %v, 1, 0 : i1\nltl.concat %u, %v : !ltl.sequence, !ltl.sequence\n```\n\nThe resulting sequence checks for `u` in the first cycle and `v` in the\nsecond, `[u, v]` in short.\n\nWithout this explicit delay, the previous sequence\u2019s end overlaps with the\nnext sequence\u2019s start. For example, consider the two sequences `u = a ##1 b`\nand `v = c ##1 d`, which check for `a` and `c` in the first, and `b` and `d`\nin the second cycle. When these two sequences are concatenated,\n`concat(u, v)`, the end time of the first sequence coincides with the start\ntime of the second. As a result, the check for `b` at the end of the first\nsequence will coincide with the check for `c` at the start of the second\nsequence: `concat(u, v) = a ##1 (b && c) ##1 d`. The resulting sequence\nchecks for `a` in the first cycle, `b` and `c` in the second, and `d` in the\nthird, `[a, (b && c), d]` in short.\n\nBy making the delay between concatenated sequences explicit, the `concat`\noperation behaves nicely in the presence of zero-length sequences. An empty,\nzero-length sequence in a concatenation behaves as if the sequence wasn\u2019t\npresent at all. Compare this to SVAs which struggle with empty sequences.\nFor example, `x ##1 y ##1 z` would become `x ##2 z` if `y` was empty.\nSimilarly, expressing zero or more repetitions of a sequence, `w ##[*]`, is\nchallenging in SVA since concatenation always implies a cycle of delay, but\ntrivial if the delay is made explicit. This is related to the handling of\nempty rules in a parser\u2019s grammar.\n\nNote that concatenating two boolean values *a* and *b* is equivalent to\ncomputing the logical AND of them. Booleans are sequences that check if the\nboolean is true in the current cycle, which means that the sequence starts\nand ends in the same cycle. Since concatenation aligns the sequences such\nthat end time of *a* and start time of *b* coincide, the resulting sequence\nchecks if *a* and *b* both are true in the current cycle, which is an AND\noperation.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of 1-bit signless integer or LTL sequence type |\n\n#### Results:\u00a0[\u00b6](#results-3)\n\n| Result | Description |\n| --- | --- |\n| `result` | LTL sequence type |\n\n### `ltl.delay` (circt::ltl::DelayOp)\u00a0[\u00b6](#ltldelay-circtltldelayop)\n\n*Delay a sequence by a number of cycles.*\n\nSyntax:\n\n```\noperation ::= `ltl.delay` $input `,` $delay (`,` $length^)? attr-dict `:` type($input)\n```\n\nDelays the `$input` sequence by the number of cycles specified by `$delay`.\nThe delay must be greater than or equal to zero. The optional `$length`\nspecifies during how many cycles after the initial delay the sequence can\nmatch. Omitting `$length` indicates an unbounded but finite delay. For\nexample:\n\n* `ltl.delay %seq, 2, 0` delays `%seq` by exactly 2 cycles. The resulting\n  sequence matches if `%seq` matches exactly 2 cycles in the future.\n* `ltl.delay %seq, 2, 2` delays `%seq` by 2, 3, or 4 cycles. The resulting\n  sequence matches if `%seq` matches 2, 3, or 4 cycles in the future.\n* `ltl.delay %seq, 2` delays `%seq` by 2 or more cycles. The number of\n  cycles is unbounded but finite, which means that `%seq` *has* to match at\n  some point, instead of effectively never occuring by being delayed an\n  infinite number of cycles.\n* `ltl.delay %seq, 0, 0` is equivalent to just `%seq`.\n\n#### Clocking\u00a0[\u00b6](#clocking-1)\n\nThe cycle delay specified on the operation refers to a clocking event. This\nevent is not directly specified by the delay operation itself. Instead, the\n[`ltl.clock`](#ltlclock-circtltlclockop) operation can be used to associate\nall delays within a sequence with a clock.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-2)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `delay` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n| `length` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-3)\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit signless integer or LTL sequence type |\n\n#### Results:\u00a0[\u00b6](#results-4)\n\n| Result | Description |\n| --- | --- |\n| `result` | LTL sequence type |\n\n### `ltl.eventually` (circt::ltl::EventuallyOp)\u00a0[\u00b6](#ltleventually-circtltleventuallyop)\n\n*Ensure that a property will hold at some time in the future.*\n\nSyntax:\n\n```\noperation ::= `ltl.eventually` $input attr-dict `:` type($input)\n```\n\nChecks that the `$input` property will hold at a future time. This operator\nis strong: it requires that the `$input` holds after a *finite* number of\ncycles. The operator does *not* hold if the `$input` can\u2019t hold in the\nfuture.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-4)\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit signless integer or LTL sequence type or LTL property type |\n\n#### Results:\u00a0[\u00b6](#results-5)\n\n| Result | Description |\n| --- | --- |\n| `result` | LTL property type |\n\n### `ltl.goto_repeat` (circt::ltl::GoToRepeatOp)\u00a0[\u00b6](#ltlgoto_repeat-circtltlgotorepeatop)\n\n*`goto`-style non-consecutively repeating sequence.*\n\nSyntax:\n\n```\noperation ::= `ltl.goto_repeat` $input `,` $base `,` $more attr-dict `:` type($input)\n```\n\nNon-consecutive repetition of the `$input` sequence. This must hold between `$base`\nand `$base + $more` times in a finite number of evaluations. The final evaluation\nin the sequence has to match. The `$base` must be greater than or equal to zero\nand the range `$more` can\u2019t be omitted. For example, a !b b b !b !b b c represents\na matching observation of `ltl.goto_repeat %b, 1, 2`, but a !b b b !b !b b !b c doesn\u2019t.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-3)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `base` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n| `more` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-5)\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit signless integer or LTL sequence type |\n\n#### Results:\u00a0[\u00b6](#results-6)\n\n| Result | Description |\n| --- | --- |\n| `result` | LTL sequence type |\n\n### `ltl.implication` (circt::ltl::ImplicationOp)\u00a0[\u00b6](#ltlimplication-circtltlimplicationop)\n\n*Only check a property after a sequence matched.*\n\nSyntax:\n\n```\noperation ::= `ltl.implication` operands attr-dict `:` type(operands)\n```\n\nPreconditions the checking of the `$consequent` property on the\n`$antecedent` sequence. In a nutshell, if the `$antecedent` sequence matches\nat a given point in time, the `$consequent` property is checked starting at\nthe point in time at which the matched sequence ends. The result property of\nthe `ltl.implication` holds if the `$consequent` holds. Conversely, if the\n`$antecedent` does *not* match at a given point in time, the result property\ntrivially holds. This is conceptually identical to the implication operator\n\u2192, but with additional temporal semantics.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-6)\n\n| Operand | Description |\n| --- | --- |\n| `antecedent` | 1-bit signless integer or LTL sequence type |\n| `consequent` | 1-bit signless integer or LTL sequence type or LTL property type |\n\n#### Results:\u00a0[\u00b6](#results-7)\n\n| Result | Description |\n| --- | --- |\n| `result` | LTL property type |\n\n### `ltl.intersect` (circt::ltl::IntersectOp)\u00a0[\u00b6](#ltlintersect-circtltlintersectop)\n\n*The intersection of booleans sequences or properties.*\n\nSyntax:\n\n```\noperation ::= `ltl.intersect` $inputs attr-dict `:` type($inputs)\n```\n\nThe intersection of two properties. This checks that both properties both hold\nand have the same start and end times. This differs from `ltl.and` which doesn\u2019t\nconsider the timings of each operand, only their results.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-7)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of 1-bit signless integer or LTL sequence type or LTL property type |\n\n#### Results:\u00a0[\u00b6](#results-8)\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit signless integer or LTL sequence type or LTL property type |\n\n### `ltl.non_consecutive_repeat` (circt::ltl::NonConsecutiveRepeatOp)\u00a0[\u00b6](#ltlnon_consecutive_repeat-circtltlnonconsecutiverepeatop)\n\n*`goto`-style non-consecutively repeating sequence.*\n\nSyntax:\n\n```\noperation ::= `ltl.non_consecutive_repeat` $input `,` $base `,` $more attr-dict `:` type($input)\n```\n\nNon-consecutive repetition of the `$input` sequence. This must hold between `$base`\nand `$base + $more` times in a finite number of evaluations. The final evaluation\nin the sequence does not have to match. The `$base` must be greater than or equal to zero\nand the range `$more` can\u2019t be omitted. For example, both a !b b b !b !b b c and\na !b b b !b !b b !b c represent matching observations of\n`ltl.non_consecutive_repeat %b, 1, 2`.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-4)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `base` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n| `more` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-8)\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit signless integer or LTL sequence type |\n\n#### Results:\u00a0[\u00b6](#results-9)\n\n| Result | Description |\n| --- | --- |\n| `result` | LTL sequence type |\n\n### `ltl.not` (circt::ltl::NotOp)\u00a0[\u00b6](#ltlnot-circtltlnotop)\n\n*A negation of a property.*\n\nSyntax:\n\n```\noperation ::= `ltl.not` $input attr-dict `:` type($input)\n```\n\nNegates the `$input` property. The resulting property evaluates to true if\n`$input` evaluates to false, and it evaluates to false if `$input` evaluates\nto true.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-9)\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit signless integer or LTL sequence type or LTL property type |\n\n#### Results:\u00a0[\u00b6](#results-10)\n\n| Result | Description |\n| --- | --- |\n| `result` | LTL property type |\n\n### `ltl.or` (circt::ltl::OrOp)\u00a0[\u00b6](#ltlor-circtltlorop)\n\n*A disjunction of booleans, sequences, or properties.*\n\nSyntax:\n\n```\noperation ::= `ltl.or` $inputs attr-dict `:` type($inputs)\n```\n\nIf any of the `$inputs` is of type `!ltl.property`, the result of the op is\nan `!ltl.property`. Otherwise it is an `!ltl.sequence`.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-10)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of 1-bit signless integer or LTL sequence type or LTL property type |\n\n#### Results:\u00a0[\u00b6](#results-11)\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit signless integer or LTL sequence type or LTL property type |\n\n### `ltl.past` (circt::ltl::PastOp)\u00a0[\u00b6](#ltlpast-circtltlpastop)\n\n*Observe the sequence $delay cycles earlier.*\n\nSyntax:\n\n```\noperation ::= `ltl.past` $input `,` $delay attr-dict `:` type($input)\n```\n\nSemantically works like `ltl.delay %seq, -$delay, 0`\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-5)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `delay` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-11)\n\n| Operand | Description |\n| --- | --- |\n| `input` | a signless integer bitvector |\n\n#### Results:\u00a0[\u00b6](#results-12)\n\n| Result | Description |\n| --- | --- |\n| `result` | a signless integer bitvector |\n\n### `ltl.repeat` (circt::ltl::RepeatOp)\u00a0[\u00b6](#ltlrepeat-circtltlrepeatop)\n\n*Repeats a sequence by a number of times.*\n\nSyntax:\n\n```\noperation ::= `ltl.repeat` $input `,` $base (`,` $more^)? attr-dict `:` type($input)\n```\n\nRepeat the `$input` sequence at least `$base` times, at most `$base` +\n`$more` times. The number must be greater than or equal to zero. Omitting\n`$more` indicates an unbounded but finite repetition. For example:\n\n* `ltl.repeat %seq, 2, 0` repeats `%seq` exactly 2 times.\n* `ltl.repeat %seq, 2, 2` repeats `%seq` 2, 3, or 4 times.\n* `ltl.repeat %seq, 2` repeats `%seq` 2 or more times. The number of times\n  is unbounded but finite.\n* `ltl.repeat %seq, 0, 0` represents an empty sequence.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-6)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `base` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n| `more` | ::mlir::IntegerAttr | 64-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-12)\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit signless integer or LTL sequence type |\n\n#### Results:\u00a0[\u00b6](#results-13)\n\n| Result | Description |\n| --- | --- |\n| `result` | LTL sequence type |\n\n### `ltl.until` (circt::ltl::UntilOp)\u00a0[\u00b6](#ltluntil-circtltluntilop)\n\n*Property always holds until another property holds.*\n\nSyntax:\n\n```\noperation ::= `ltl.until` operands attr-dict `:` type(operands)\n```\n\nChecks that the `$input` property always holds until the `$condition`\nproperty holds once. This operator is weak: the property will hold even if\n`$input` always holds and `$condition` never holds. This operator is\nnonoverlapping: `$input` does not have to hold when `$condition` holds.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-13)\n\n| Operand | Description |\n| --- | --- |\n| `input` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `condition` | 1-bit signless integer or LTL sequence type or LTL property type |\n\n#### Results:\u00a0[\u00b6](#results-14)\n\n| Result | Description |\n| --- | --- |\n| `result` | LTL property type |\n\n [Prev - LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/ \"LLHD Dialect\")\n[Next - Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/ \"Moore Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Moore/index.md"
  },
  {
    "role": "user",
    "content": "Moore Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nMoore Dialect\n=============\n\nThis dialect provides operations and types to capture a SystemVerilog design after parsing, type checking, and elaboration.\n\n* [Rationale](#rationale)\n* [Types](#types)\n  + [Simple Bit Vector Type](#simple-bit-vector-type)\n  + [Event Type](#event-type)\n  + [Default Values](#default-values)\n  + [ArrayType](#arraytype)\n  + [AssocArrayType](#assocarraytype)\n  + [ChandleType](#chandletype)\n  + [ClassHandleType](#classhandletype)\n  + [EventType](#eventtype)\n  + [FormatStringType](#formatstringtype)\n  + [IntType](#inttype)\n  + [NullType](#nulltype)\n  + [OpenArrayType](#openarraytype)\n  + [OpenUnpackedArrayType](#openunpackedarraytype)\n  + [QueueType](#queuetype)\n  + [RealType](#realtype)\n  + [RefType](#reftype)\n  + [StringType](#stringtype)\n  + [StructType](#structtype)\n  + [TimeType](#timetype)\n  + [UnionType](#uniontype)\n  + [UnpackedArrayType](#unpackedarraytype)\n  + [UnpackedStructType](#unpackedstructtype)\n  + [UnpackedUnionType](#unpackeduniontype)\n  + [VoidType](#voidtype)\n* [Operations](#operations)\n  + [`moore.ashr` (::circt::moore::AShrOp)](#mooreashr-circtmooreashrop)\n  + [`moore.builtin.acos` (::circt::moore::AcosBIOp)](#moorebuiltinacos-circtmooreacosbiop)\n  + [`moore.builtin.acosh` (::circt::moore::AcoshBIOp)](#moorebuiltinacosh-circtmooreacoshbiop)\n  + [`moore.add` (::circt::moore::AddOp)](#mooreadd-circtmooreaddop)\n  + [`moore.fadd` (::circt::moore::AddRealOp)](#moorefadd-circtmooreaddrealop)\n  + [`moore.and` (::circt::moore::AndOp)](#mooreand-circtmooreandop)\n  + [`moore.array_create` (::circt::moore::ArrayCreateOp)](#moorearray_create-circtmoorearraycreateop)\n  + [`moore.builtin.asin` (::circt::moore::AsinBIOp)](#moorebuiltinasin-circtmooreasinbiop)\n  + [`moore.builtin.asinh` (::circt::moore::AsinhBIOp)](#moorebuiltinasinh-circtmooreasinhbiop)\n  + [`moore.assert` (::circt::moore::AssertOp)](#mooreassert-circtmooreassertop)\n  + [`moore.assigned_variable` (::circt::moore::AssignedVariableOp)](#mooreassigned_variable-circtmooreassignedvariableop)\n  + [`moore.assume` (::circt::moore::AssumeOp)](#mooreassume-circtmooreassumeop)\n  + [`moore.builtin.atan` (::circt::moore::AtanBIOp)](#moorebuiltinatan-circtmooreatanbiop)\n  + [`moore.builtin.atanh` (::circt::moore::AtanhBIOp)](#moorebuiltinatanh-circtmooreatanhbiop)\n  + [`moore.builtin.bitstoreal` (::circt::moore::BitstorealBIOp)](#moorebuiltinbitstoreal-circtmoorebitstorealbiop)\n  + [`moore.builtin.bitstoshortreal` (::circt::moore::BitstoshortrealBIOp)](#moorebuiltinbitstoshortreal-circtmoorebitstoshortrealbiop)\n  + [`moore.blocking_assign` (::circt::moore::BlockingAssignOp)](#mooreblocking_assign-circtmooreblockingassignop)\n  + [`moore.bool_cast` (::circt::moore::BoolCastOp)](#moorebool_cast-circtmooreboolcastop)\n  + [`moore.case_eq` (::circt::moore::CaseEqOp)](#moorecase_eq-circtmoorecaseeqop)\n  + [`moore.case_ne` (::circt::moore::CaseNeOp)](#moorecase_ne-circtmoorecaseneop)\n  + [`moore.casexz_eq` (::circt::moore::CaseXZEqOp)](#moorecasexz_eq-circtmoorecasexzeqop)\n  + [`moore.casez_eq` (::circt::moore::CaseZEqOp)](#moorecasez_eq-circtmoorecasezeqop)\n  + [`moore.builtin.ceil` (::circt::moore::CeilBIOp)](#moorebuiltinceil-circtmooreceilbiop)\n  + [`moore.class.classdecl` (::circt::moore::ClassDeclOp)](#mooreclassclassdecl-circtmooreclassdeclop)\n  + [`moore.class.methoddecl` (::circt::moore::ClassMethodDeclOp)](#mooreclassmethoddecl-circtmooreclassmethoddeclop)\n  + [`moore.class.new` (::circt::moore::ClassNewOp)](#mooreclassnew-circtmooreclassnewop)\n  + [`moore.class.propertydecl` (::circt::moore::ClassPropertyDeclOp)](#mooreclasspropertydecl-circtmooreclasspropertydeclop)\n  + [`moore.class.property_ref` (::circt::moore::ClassPropertyRefOp)](#mooreclassproperty_ref-circtmooreclasspropertyrefop)\n  + [`moore.class.upcast` (::circt::moore::ClassUpcastOp)](#mooreclassupcast-circtmooreclassupcastop)\n  + [`moore.builtin.clog2` (::circt::moore::Clog2BIOp)](#moorebuiltinclog2-circtmooreclog2biop)\n  + [`moore.concat` (::circt::moore::ConcatOp)](#mooreconcat-circtmooreconcatop)\n  + [`moore.concat_ref` (::circt::moore::ConcatRefOp)](#mooreconcat_ref-circtmooreconcatrefop)\n  + [`moore.conditional` (::circt::moore::ConditionalOp)](#mooreconditional-circtmooreconditionalop)\n  + [`moore.constant` (::circt::moore::ConstantOp)](#mooreconstant-circtmooreconstantop)\n  + [`moore.constant_real` (::circt::moore::ConstantRealOp)](#mooreconstant_real-circtmooreconstantrealop)\n  + [`moore.constant_string` (::circt::moore::ConstantStringOp)](#mooreconstant_string-circtmooreconstantstringop)\n  + [`moore.constant_time` (::circt::moore::ConstantTimeOp)](#mooreconstant_time-circtmooreconstanttimeop)\n  + [`moore.assign` (::circt::moore::ContinuousAssignOp)](#mooreassign-circtmoorecontinuousassignop)\n  + [`moore.conversion` (::circt::moore::ConversionOp)](#mooreconversion-circtmooreconversionop)\n  + [`moore.convert_real` (::circt::moore::ConvertRealOp)](#mooreconvert_real-circtmooreconvertrealop)\n  + [`moore.builtin.cos` (::circt::moore::CosBIOp)](#moorebuiltincos-circtmoorecosbiop)\n  + [`moore.builtin.cosh` (::circt::moore::CoshBIOp)](#moorebuiltincosh-circtmoorecoshbiop)\n  + [`moore.cover` (::circt::moore::CoverOp)](#moorecover-circtmoorecoverop)\n  + [`moore.delayed_assign` (::circt::moore::DelayedContinuousAssignOp)](#mooredelayed_assign-circtmooredelayedcontinuousassignop)\n  + [`moore.delayed_nonblocking_assign` (::circt::moore::DelayedNonBlockingAssignOp)](#mooredelayed_nonblocking_assign-circtmooredelayednonblockingassignop)\n  + [`moore.detect_event` (::circt::moore::DetectEventOp)](#mooredetect_event-circtmooredetecteventop)\n  + [`moore.builtin.display` (::circt::moore::DisplayBIOp)](#moorebuiltindisplay-circtmooredisplaybiop)\n  + [`moore.fdiv` (::circt::moore::DivRealOp)](#moorefdiv-circtmooredivrealop)\n  + [`moore.divs` (::circt::moore::DivSOp)](#mooredivs-circtmooredivsop)\n  + [`moore.divu` (::circt::moore::DivUOp)](#mooredivu-circtmooredivuop)\n  + [`moore.dyn_extract` (::circt::moore::DynExtractOp)](#mooredyn_extract-circtmooredynextractop)\n  + [`moore.dyn_extract_ref` (::circt::moore::DynExtractRefOp)](#mooredyn_extract_ref-circtmooredynextractrefop)\n  + [`moore.dyn_queue_extract` (::circt::moore::DynQueueExtractOp)](#mooredyn_queue_extract-circtmooredynqueueextractop)\n  + [`moore.dyn_queue_extract_ref` (::circt::moore::DynQueueExtractRefOp)](#mooredyn_queue_extract_ref-circtmooredynqueueextractrefop)\n  + [`moore.eq` (::circt::moore::EqOp)](#mooreeq-circtmooreeqop)\n  + [`moore.feq` (::circt::moore::EqRealOp)](#moorefeq-circtmooreeqrealop)\n  + [`moore.builtin.exp` (::circt::moore::ExpBIOp)](#moorebuiltinexp-circtmooreexpbiop)\n  + [`moore.extract` (::circt::moore::ExtractOp)](#mooreextract-circtmooreextractop)\n  + [`moore.extract_ref` (::circt::moore::ExtractRefOp)](#mooreextract_ref-circtmooreextractrefop)\n  + [`moore.fge` (::circt::moore::FgeOp)](#moorefge-circtmoorefgeop)\n  + [`moore.fgt` (::circt::moore::FgtOp)](#moorefgt-circtmoorefgtop)\n  + [`moore.builtin.finish` (::circt::moore::FinishBIOp)](#moorebuiltinfinish-circtmoorefinishbiop)\n  + [`moore.builtin.finish_message` (::circt::moore::FinishMessageBIOp)](#moorebuiltinfinish_message-circtmoorefinishmessagebiop)\n  + [`moore.fle` (::circt::moore::FleOp)](#moorefle-circtmoorefleop)\n  + [`moore.builtin.floor` (::circt::moore::FloorBIOp)](#moorebuiltinfloor-circtmoorefloorbiop)\n  + [`moore.flt` (::circt::moore::FltOp)](#mooreflt-circtmoorefltop)\n  + [`moore.fmt.concat` (::circt::moore::FormatConcatOp)](#moorefmtconcat-circtmooreformatconcatop)\n  + [`moore.fmt.int` (::circt::moore::FormatIntOp)](#moorefmtint-circtmooreformatintop)\n  + [`moore.fmt.literal` (::circt::moore::FormatLiteralOp)](#moorefmtliteral-circtmooreformatliteralop)\n  + [`moore.fmt.real` (::circt::moore::FormatRealOp)](#moorefmtreal-circtmooreformatrealop)\n  + [`moore.fmt.string` (::circt::moore::FormatStringOp)](#moorefmtstring-circtmooreformatstringop)\n  + [`moore.fstring_to_string` (::circt::moore::FormatStringToStringOp)](#moorefstring_to_string-circtmooreformatstringtostringop)\n  + [`moore.get_global_variable` (::circt::moore::GetGlobalVariableOp)](#mooreget_global_variable-circtmooregetglobalvariableop)\n  + [`moore.global_variable` (::circt::moore::GlobalVariableOp)](#mooreglobal_variable-circtmooreglobalvariableop)\n  + [`moore.handle_case_eq` (::circt::moore::HandleCaseEqOp)](#moorehandle_case_eq-circtmoorehandlecaseeqop)\n  + [`moore.handle_case_ne` (::circt::moore::HandleCaseNeOp)](#moorehandle_case_ne-circtmoorehandlecaseneop)\n  + [`moore.handle_eq` (::circt::moore::HandleEqOp)](#moorehandle_eq-circtmoorehandleeqop)\n  + [`moore.handle_ne` (::circt::moore::HandleNeOp)](#moorehandle_ne-circtmoorehandleneop)\n  + [`moore.instance` (::circt::moore::InstanceOp)](#mooreinstance-circtmooreinstanceop)\n  + [`moore.int_to_logic` (::circt::moore::IntToLogicOp)](#mooreint_to_logic-circtmooreinttologicop)\n  + [`moore.int_to_string` (::circt::moore::IntToStringOp)](#mooreint_to_string-circtmooreinttostringop)\n  + [`moore.builtin.ln` (::circt::moore::LnBIOp)](#moorebuiltinln-circtmoorelnbiop)\n  + [`moore.builtin.log10` (::circt::moore::Log10BIOp)](#moorebuiltinlog10-circtmoorelog10biop)\n  + [`moore.logic_to_int` (::circt::moore::LogicToIntOp)](#moorelogic_to_int-circtmoorelogictointop)\n  + [`moore.logic_to_time` (::circt::moore::LogicToTimeOp)](#moorelogic_to_time-circtmoorelogictotimeop)\n  + [`moore.mods` (::circt::moore::ModSOp)](#mooremods-circtmooremodsop)\n  + [`moore.modu` (::circt::moore::ModUOp)](#mooremodu-circtmooremoduop)\n  + [`moore.mul` (::circt::moore::MulOp)](#mooremul-circtmooremulop)\n  + [`moore.fmul` (::circt::moore::MulRealOp)](#moorefmul-circtmooremulrealop)\n  + [`moore.ne` (::circt::moore::NeOp)](#moorene-circtmooreneop)\n  + [`moore.fne` (::circt::moore::NeRealOp)](#moorefne-circtmoorenerealop)\n  + [`moore.neg` (::circt::moore::NegOp)](#mooreneg-circtmoorenegop)\n  + [`moore.fneg` (::circt::moore::NegRealOp)](#moorefneg-circtmoorenegrealop)\n  + [`moore.net` (::circt::moore::NetOp)](#moorenet-circtmoorenetop)\n  + [`moore.nonblocking_assign` (::circt::moore::NonBlockingAssignOp)](#moorenonblocking_assign-circtmoorenonblockingassignop)\n  + [`moore.not` (::circt::moore::NotOp)](#moorenot-circtmoorenotop)\n  + [`moore.null` (::circt::moore::NullOp)](#moorenull-circtmoorenullop)\n  + [`moore.or` (::circt::moore::OrOp)](#mooreor-circtmooreorop)\n  + [`moore.output` (::circt::moore::OutputOp)](#mooreoutput-circtmooreoutputop)\n  + [`moore.packed_to_sbv` (::circt::moore::PackedToSBVOp)](#moorepacked_to_sbv-circtmoorepackedtosbvop)\n  + [`moore.fpow` (::circt::moore::PowRealOp)](#moorefpow-circtmoorepowrealop)\n  + [`moore.pows` (::circt::moore::PowSOp)](#moorepows-circtmoorepowsop)\n  + [`moore.powu` (::circt::moore::PowUOp)](#moorepowu-circtmoorepowuop)\n  + [`moore.procedure` (::circt::moore::ProcedureOp)](#mooreprocedure-circtmooreprocedureop)\n  + [`moore.pop_back` (::circt::moore::QueuePopBackOp)](#moorepop_back-circtmoorequeuepopbackop)\n  + [`moore.pop_front` (::circt::moore::QueuePopFrontOp)](#moorepop_front-circtmoorequeuepopfrontop)\n  + [`moore.push_back` (::circt::moore::QueuePushBackOp)](#moorepush_back-circtmoorequeuepushbackop)\n  + [`moore.push_front` (::circt::moore::QueuePushFrontOp)](#moorepush_front-circtmoorequeuepushfrontop)\n  + [`moore.builtin.size` (::circt::moore::QueueSizeBIOp)](#moorebuiltinsize-circtmoorequeuesizebiop)\n  + [`moore.builtin.random` (::circt::moore::RandomBIOp)](#moorebuiltinrandom-circtmoorerandombiop)\n  + [`moore.read` (::circt::moore::ReadOp)](#mooreread-circtmoorereadop)\n  + [`moore.real_to_int` (::circt::moore::RealToIntOp)](#moorereal_to_int-circtmoorerealtointop)\n  + [`moore.builtin.realtobits` (::circt::moore::RealtobitsBIOp)](#moorebuiltinrealtobits-circtmoorerealtobitsbiop)\n  + [`moore.reduce_and` (::circt::moore::ReduceAndOp)](#moorereduce_and-circtmoorereduceandop)\n  + [`moore.reduce_or` (::circt::moore::ReduceOrOp)](#moorereduce_or-circtmoorereduceorop)\n  + [`moore.reduce_xor` (::circt::moore::ReduceXorOp)](#moorereduce_xor-circtmoorereducexorop)\n  + [`moore.replicate` (::circt::moore::ReplicateOp)](#moorereplicate-circtmoorereplicateop)\n  + [`moore.return` (::circt::moore::ReturnOp)](#moorereturn-circtmoorereturnop)\n  + [`moore.sbv_to_packed` (::circt::moore::SBVToPackedOp)](#mooresbv_to_packed-circtmooresbvtopackedop)\n  + [`moore.sext` (::circt::moore::SExtOp)](#mooresext-circtmooresextop)\n  + [`moore.sint_to_real` (::circt::moore::SIntToRealOp)](#mooresint_to_real-circtmooresinttorealop)\n  + [`moore.module` (::circt::moore::SVModuleOp)](#mooremodule-circtmooresvmoduleop)\n  + [`moore.builtin.severity` (::circt::moore::SeverityBIOp)](#moorebuiltinseverity-circtmooreseveritybiop)\n  + [`moore.sge` (::circt::moore::SgeOp)](#mooresge-circtmooresgeop)\n  + [`moore.sgt` (::circt::moore::SgtOp)](#mooresgt-circtmooresgtop)\n  + [`moore.shl` (::circt::moore::ShlOp)](#mooreshl-circtmooreshlop)\n  + [`moore.builtin.shortrealtobits` (::circt::moore::ShortrealtobitsBIOp)](#moorebuiltinshortrealtobits-circtmooreshortrealtobitsbiop)\n  + [`moore.shr` (::circt::moore::ShrOp)](#mooreshr-circtmooreshrop)\n  + [`moore.builtin.sin` (::circt::moore::SinBIOp)](#moorebuiltinsin-circtmooresinbiop)\n  + [`moore.builtin.sinh` (::circt::moore::SinhBIOp)](#moorebuiltinsinh-circtmooresinhbiop)\n  + [`moore.sle` (::circt::moore::SleOp)](#mooresle-circtmooresleop)\n  + [`moore.slt` (::circt::moore::SltOp)](#mooreslt-circtmooresltop)\n  + [`moore.builtin.sqrt` (::circt::moore::SqrtBIOp)](#moorebuiltinsqrt-circtmooresqrtbiop)\n  + [`moore.builtin.stop` (::circt::moore::StopBIOp)](#moorebuiltinstop-circtmoorestopbiop)\n  + [`moore.string_cmp` (::circt::moore::StringCmpOp)](#moorestring_cmp-circtmoorestringcmpop)\n  + [`moore.string.concat` (::circt::moore::StringConcatOp)](#moorestringconcat-circtmoorestringconcatop)\n  + [`moore.string.getc` (::circt::moore::StringGetCOp)](#moorestringgetc-circtmoorestringgetcop)\n  + [`moore.string.len` (::circt::moore::StringLenOp)](#moorestringlen-circtmoorestringlenop)\n  + [`moore.string_to_int` (::circt::moore::StringToIntOp)](#moorestring_to_int-circtmoorestringtointop)\n  + [`moore.string.tolower` (::circt::moore::StringToLowerOp)](#moorestringtolower-circtmoorestringtolowerop)\n  + [`moore.string.toupper` (::circt::moore::StringToUpperOp)](#moorestringtoupper-circtmoorestringtoupperop)\n  + [`moore.struct_create` (::circt::moore::StructCreateOp)](#moorestruct_create-circtmoorestructcreateop)\n  + [`moore.struct_extract` (::circt::moore::StructExtractOp)](#moorestruct_extract-circtmoorestructextractop)\n  + [`moore.struct_extract_ref` (::circt::moore::StructExtractRefOp)](#moorestruct_extract_ref-circtmoorestructextractrefop)\n  + [`moore.struct_inject` (::circt::moore::StructInjectOp)](#moorestruct_inject-circtmoorestructinjectop)\n  + [`moore.sub` (::circt::moore::SubOp)](#mooresub-circtmooresubop)\n  + [`moore.fsub` (::circt::moore::SubRealOp)](#moorefsub-circtmooresubrealop)\n  + [`moore.builtin.tan` (::circt::moore::TanBIOp)](#moorebuiltintan-circtmooretanbiop)\n  + [`moore.builtin.tanh` (::circt::moore::TanhBIOp)](#moorebuiltintanh-circtmooretanhbiop)\n  + [`moore.builtin.time` (::circt::moore::TimeBIOp)](#moorebuiltintime-circtmooretimebiop)\n  + [`moore.time_to_logic` (::circt::moore::TimeToLogicOp)](#mooretime_to_logic-circtmooretimetologicop)\n  + [`moore.to_builtin_bool` (::circt::moore::ToBuiltinBoolOp)](#mooreto_builtin_bool-circtmooretobuiltinboolop)\n  + [`moore.to_builtin_int` (::circt::moore::ToBuiltinIntOp)](#mooreto_builtin_int-circtmooretobuiltinintop)\n  + [`moore.trunc` (::circt::moore::TruncOp)](#mooretrunc-circtmooretruncop)\n  + [`moore.uarray_cmp` (::circt::moore::UArrayCmpOp)](#mooreuarray_cmp-circtmooreuarraycmpop)\n  + [`moore.uint_to_real` (::circt::moore::UIntToRealOp)](#mooreuint_to_real-circtmooreuinttorealop)\n  + [`moore.uge` (::circt::moore::UgeOp)](#mooreuge-circtmooreugeop)\n  + [`moore.ugt` (::circt::moore::UgtOp)](#mooreugt-circtmooreugtop)\n  + [`moore.ule` (::circt::moore::UleOp)](#mooreule-circtmooreuleop)\n  + [`moore.ult` (::circt::moore::UltOp)](#mooreult-circtmooreultop)\n  + [`moore.union_create` (::circt::moore::UnionCreateOp)](#mooreunion_create-circtmooreunioncreateop)\n  + [`moore.union_extract` (::circt::moore::UnionExtractOp)](#mooreunion_extract-circtmooreunionextractop)\n  + [`moore.union_extract_ref` (::circt::moore::UnionExtractRefOp)](#mooreunion_extract_ref-circtmooreunionextractrefop)\n  + [`moore.unreachable` (::circt::moore::UnreachableOp)](#mooreunreachable-circtmooreunreachableop)\n  + [`moore.builtin.urandom` (::circt::moore::UrandomBIOp)](#moorebuiltinurandom-circtmooreurandombiop)\n  + [`moore.vtable_entry` (::circt::moore::VTableEntryOp)](#moorevtable_entry-circtmoorevtableentryop)\n  + [`moore.vtable.load_method` (::circt::moore::VTableLoadMethodOp)](#moorevtableload_method-circtmoorevtableloadmethodop)\n  + [`moore.vtable` (::circt::moore::VTableOp)](#moorevtable-circtmoorevtableop)\n  + [`moore.variable` (::circt::moore::VariableOp)](#moorevariable-circtmoorevariableop)\n  + [`moore.wait_delay` (::circt::moore::WaitDelayOp)](#moorewait_delay-circtmoorewaitdelayop)\n  + [`moore.wait_event` (::circt::moore::WaitEventOp)](#moorewait_event-circtmoorewaiteventop)\n  + [`moore.wildcard_eq` (::circt::moore::WildcardEqOp)](#moorewildcard_eq-circtmoorewildcardeqop)\n  + [`moore.wildcard_ne` (::circt::moore::WildcardNeOp)](#moorewildcard_ne-circtmoorewildcardneop)\n  + [`moore.xor` (::circt::moore::XorOp)](#moorexor-circtmoorexorop)\n  + [`moore.yield` (::circt::moore::YieldOp)](#mooreyield-circtmooreyieldop)\n  + [`moore.zext` (::circt::moore::ZExtOp)](#moorezext-circtmoorezextop)\n\nRationale\u00a0[\u00b6](#rationale)\n-------------------------\n\nThe main goal of the `moore` dialect is to provide a set of operations and types for the `ImportVerilog` conversion to translate a fully parsed, type-checked, and elaborated Slang AST into MLIR operations.\nSee IEEE 1800-2017 for more details about SystemVerilog.\nThe dialect aims to faithfully capture the full SystemVerilog types and semantics, and provide a platform for transformation passes to resolve language quirks, analyze the design at a high level, and lower it to the core dialects.\n\nIn contrast, the `sv` dialect is geared towards emission of SystemVerilog text, and is focused on providing a good lowering target to allow for emission.\nThe `moore` and `sv` dialect may eventually converge into a single dialect.\nAs we are building out the Verilog frontend capabilities of CIRCT it is valuable to have a separate ingestion dialect, such that we do not have to make disruptive changes to the load-bearing `sv` dialect used in production.\n\nTypes\u00a0[\u00b6](#types)\n-----------------\n\n### Simple Bit Vector Type\u00a0[\u00b6](#simple-bit-vector-type)\n\nThe `moore.iN` and `moore.lN` types represent a two-valued or four-valued simple bit vector of width `N`.\n\n| Verilog | Moore Dialect |\n| --- | --- |\n| `bit` | `!moore.i1` |\n| `logic` | `!moore.l1` |\n| `reg` | `!moore.l1` |\n| `byte` | `!moore.i8` |\n| `shortint` | `!moore.i16` |\n| `int` | `!moore.i32` |\n| `integer` | `!moore.l32` |\n| `longint` | `!moore.i64` |\n| `time` | `!moore.l64` |\n\n### Event Type\u00a0[\u00b6](#event-type)\n\nThe SystemVerilog `event` type is represented as a `!moore.i1` value.\nA variable `event e` is lowered to the equivalent of `bit b`.\nTriggering an event through `-> e` is lowered to the equivalent of `b = ~b`.\nWaiting on an event through `@(e)` is lowered to the equivalent of `@(b)`.\n\n### Default Values\u00a0[\u00b6](#default-values)\n\nBehavior of unconnected ports:\n\n| Port Type | Unconnected Behavior |\n| --- | --- |\n| Input (Net) | High-impedance value (\u2018Z) |\n| Input (Variable) | Default initial value |\n| Output | No effect on Simulation |\n| Inout (Net) | High-impedance value (\u2018Z) |\n| Inout (Variable) | Default initial value |\n| Ref | Cannot be left unconnected |\n| Interconnect | Cannot be left unconnected |\n| Interface | Cannot be left unconnected |\n\nUninitialized variables:\n\n| Type | Default initial value |\n| --- | --- |\n| 4-state integral | \u2018X |\n| 2-state integral | \u20180 |\n| `real`, `shortreal` | 0.0 |\n| Enumeration | Base type default initial value |\n| `string` | \"\" (empty string) |\n| `event` | New event |\n| `class` | `null` |\n| `interface class` | `null` |\n| `chandle` | `null` |\n| `virtual interface` | `null` |\n\n### ArrayType\u00a0[\u00b6](#arraytype)\n\n*A packed array type*\n\nSyntax:\n\n```\n!moore.array<\n  unsigned,   # size\n  PackedType   # elementType\n>\n```\n\nA packed array with a fixed number of elements. This type represents packed\nrange dimensions (`[a:b]`) in SystemVerilog.\n\n| Verilog | Moore Dialect |\n| --- | --- |\n| `T [3:0]` | `!moore.array<4 x T>` |\n| `T [2:4]` | `!moore.array<3 x T>` |\n\n#### Parameters:\u00a0[\u00b6](#parameters)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| size | `unsigned` |  |\n| elementType | `PackedType` |  |\n\n### AssocArrayType\u00a0[\u00b6](#assocarraytype)\n\n*An associative array type*\n\nSyntax:\n\n```\n!moore.assoc_array<\n  UnpackedType,   # elementType\n  UnpackedType   # indexType\n>\n```\n\nAn associative array. This type represents associative arrays (`[T]`) in\nSystemVerilog.\n\n| Verilog | Moore Dialect |\n| --- | --- |\n| `T foo [K]` | `!moore.assoc_array<T, K>` |\n\n#### Parameters:\u00a0[\u00b6](#parameters-1)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `UnpackedType` |  |\n| indexType | `UnpackedType` |  |\n\n### ChandleType\u00a0[\u00b6](#chandletype)\n\n*The SystemVerilog `chandle` type*\n\nSyntax: `!moore.chandle`\n\n### ClassHandleType\u00a0[\u00b6](#classhandletype)\n\n*Class object handle type, pointing to an object on the heap.*\n\nSyntax:\n\n```\n!moore.class<\n  ::mlir::SymbolRefAttr   # classSym\n>\n```\n\nThe `!moore.class<@C>` type represents a handle of a class instance of class `@C` living on the program\u2019s heap.\n\n#### Parameters:\u00a0[\u00b6](#parameters-2)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| classSym | `::mlir::SymbolRefAttr` | class symbol |\n\n### EventType\u00a0[\u00b6](#eventtype)\n\n*The SystemVerilog `event` type*\n\nSyntax: `!moore.event`\n\n### FormatStringType\u00a0[\u00b6](#formatstringtype)\n\n*A format string type*\n\nSyntax: `!moore.format_string`\n\nAn interpolated string produced by one of the string formatting operations.\nIt is used to parse format strings present in Verilog source text and\nrepresent them as a sequence of IR operations that specify the formatting of\nindividual arguments.\n\n### IntType\u00a0[\u00b6](#inttype)\n\n*A simple bit vector type*\n\nThe `!moore.iN` and `!moore.lN` types represent a two-valued or four-valued\nsimple bit vector of width `N`. The predefined SystemVerilog integer types\nmap to this as follows:\n\n| Verilog | Moore Dialect |\n| --- | --- |\n| `bit` | `!moore.i1` |\n| `logic` | `!moore.l1` |\n| `reg` | `!moore.l1` |\n| `byte` | `!moore.i8` |\n| `shortint` | `!moore.i16` |\n| `int` | `!moore.i32` |\n| `integer` | `!moore.l32` |\n| `longint` | `!moore.i64` |\n| `time` | `!moore.time` |\n\n#### Parameters:\u00a0[\u00b6](#parameters-3)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| width | `unsigned` |  |\n| domain | `Domain` |  |\n\n### NullType\u00a0[\u00b6](#nulltype)\n\n*A type that represents null literals for chandles, classhandles,\nand virtual interfaces*\n\nSyntax: `!moore.null`\n\n### OpenArrayType\u00a0[\u00b6](#openarraytype)\n\n*An open packed array type*\n\nSyntax:\n\n```\n!moore.open_array<\n  PackedType   # elementType\n>\n```\n\nA packed array with an unspecified number of elements. This type represents\nunsized/open packed arrays (`[]`) in SystemVerilog.\n\n| Verilog | Moore Dialect |\n| --- | --- |\n| `T []` | `!moore.open_array<T>` |\n\n#### Parameters:\u00a0[\u00b6](#parameters-4)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `PackedType` |  |\n\n### OpenUnpackedArrayType\u00a0[\u00b6](#openunpackedarraytype)\n\n*An open unpacked array type*\n\nSyntax:\n\n```\n!moore.open_uarray<\n  UnpackedType   # elementType\n>\n```\n\nAn unpacked array with an unspecified number of elements. This type\nrepresents unsized/open unpacked arrays (`[]`) in SystemVerilog.\n\n| Verilog | Moore Dialect |\n| --- | --- |\n| `T foo []` | `!moore.open_uarray<T>` |\n\n#### Parameters:\u00a0[\u00b6](#parameters-5)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `UnpackedType` |  |\n\n### QueueType\u00a0[\u00b6](#queuetype)\n\n*A queue type*\n\nSyntax:\n\n```\n!moore.queue<\n  UnpackedType,   # elementType\n  unsigned   # bound\n>\n```\n\nA queue with an optional upper bound on the number of elements that it can\nhold. This type represents queues (`[$]` and `[$:a]`) in SystemVerilog. A\n`bound` of 0 indicates an unbounded queue.\n\n| Verilog | Moore Dialect |\n| --- | --- |\n| `T foo [$]` | `!moore.queue<T>` |\n| `T foo [$:42]` | `!moore.queue<T, 42>` |\n\n#### Parameters:\u00a0[\u00b6](#parameters-6)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `UnpackedType` |  |\n| bound | `unsigned` |  |\n\n### RealType\u00a0[\u00b6](#realtype)\n\n*A SystemVerilog real type*\n\nThis type represents the SystemVerilog real type. We coalesce the\n`f32`, `f64`, and `realtime` types in the SystemVerilog standard to\nthis common `!moore.real` type. The standard specifies these types to be of\nat least 32, 64, and 64 bits, respectively.\n\n| Verilog | Moore Dialect |\n| --- | --- |\n| `shortreal` | `!moore.f32` |\n| `real` | `!moore.f64` |\n| `realtime` | `!moore.time` |\n\n#### Parameters:\u00a0[\u00b6](#parameters-7)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| width | `RealWidth` |  |\n\n### RefType\u00a0[\u00b6](#reftype)\n\nSyntax:\n\n```\n!moore.ref<\n  UnpackedType   # nestedType\n>\n```\n\nA wrapper is used to wrap any SystemVerilog type. It\u2019s aimed to work for\n\u2018moore.variable\u2019, \u2018moore.blocking\\_assign\u2019, and \u2018moore.read\u2019, which are\nrelated to memory, like alloca/write/read.\n\n#### Parameters:\u00a0[\u00b6](#parameters-8)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| nestedType | `UnpackedType` |  |\n\n### StringType\u00a0[\u00b6](#stringtype)\n\n*The SystemVerilog `string` type*\n\nSyntax: `!moore.string`\n\n### StructType\u00a0[\u00b6](#structtype)\n\n*A packed struct type*\n\nSyntax:\n\n```\n!moore.struct<\n  ::llvm::ArrayRef<StructLikeMember>   # members\n>\n```\n\nA packed struct. All members are guaranteed to be packed as well.\n\n#### Parameters:\u00a0[\u00b6](#parameters-9)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| members | `::llvm::ArrayRef<StructLikeMember>` |  |\n\n### TimeType\u00a0[\u00b6](#timetype)\n\n*The SystemVerilog `time` and `realtime` type*\n\nSyntax: `!moore.time`\n\nThe `!moore.time` type represents a time value. Internally, the value is\nrepresented as femtoseconds in `i64`.\n\nTime values are a problematic part of the SystemVerilog language, since they\nare multiplied by a scaling factor given by the current scope\u2019s `timeunit`\nand then mapped to an 64 bit four-valued integer for `time`, or a real for\n`realtime`. This means that a time value flowing from one module with one\ntimeunit to another module with a different timeunit will read as two\ndistinct delay values in the two modules.\n\nTo work around these issues, the Moore dialect maps all time values to\nfemtoseconds and represents them as an integer value. This allows us to have\ntime values exchanged between modules correctly, while locally casting from\nand to `integer` and `real` with the correct local scaling factor.\n\n### UnionType\u00a0[\u00b6](#uniontype)\n\n*A packed union type*\n\nSyntax:\n\n```\n!moore.union<\n  ::llvm::ArrayRef<StructLikeMember>   # members\n>\n```\n\nA packed union. All members are guaranteed to be packed as well.\n\n#### Parameters:\u00a0[\u00b6](#parameters-10)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| members | `::llvm::ArrayRef<StructLikeMember>` |  |\n\n### UnpackedArrayType\u00a0[\u00b6](#unpackedarraytype)\n\n*An unpacked array type*\n\nSyntax:\n\n```\n!moore.uarray<\n  unsigned,   # size\n  UnpackedType   # elementType\n>\n```\n\nAn unpacked array with a fixed number of elements. This type represents\nunpacked range dimensions (`[a:b]`) and unpacked array dimensions (`[a]`) in\nSystemVerilog.\n\n| Verilog | Moore Dialect |\n| --- | --- |\n| `T foo [3:0]` | `!moore.uarray<4 x T>` |\n| `T foo [2:4]` | `!moore.uarray<3 x T>` |\n| `T foo [2]` | `!moore.uarray<2 x T>` |\n\n#### Parameters:\u00a0[\u00b6](#parameters-11)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| size | `unsigned` |  |\n| elementType | `UnpackedType` |  |\n\n### UnpackedStructType\u00a0[\u00b6](#unpackedstructtype)\n\n*An unpacked struct type*\n\nSyntax:\n\n```\n!moore.ustruct<\n  ::llvm::ArrayRef<StructLikeMember>   # members\n>\n```\n\nAn unpacked struct.\n\n#### Parameters:\u00a0[\u00b6](#parameters-12)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| members | `::llvm::ArrayRef<StructLikeMember>` |  |\n\n### UnpackedUnionType\u00a0[\u00b6](#unpackeduniontype)\n\n*An unpacked union type*\n\nSyntax:\n\n```\n!moore.uunion<\n  ::llvm::ArrayRef<StructLikeMember>   # members\n>\n```\n\nAn unpacked union.\n\n#### Parameters:\u00a0[\u00b6](#parameters-13)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| members | `::llvm::ArrayRef<StructLikeMember>` |  |\n\n### VoidType\u00a0[\u00b6](#voidtype)\n\n*The SystemVerilog `void` type*\n\nSyntax: `!moore.void`\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `moore.ashr` (::circt::moore::AShrOp)\u00a0[\u00b6](#mooreashr-circtmooreashrop)\n\n*Arithmetic right shift*\n\nSyntax:\n\n```\noperation ::= `moore.ashr` $value `,` $amount attr-dict `:` type($value) `,` type($amount)\n```\n\nShifts the `value` to the left or right by `amount` number of bits. The\nresult has the same type as the input value. The amount is always treated as\nan unsigned number and has no effect on the signedness of the result. X or\nZ bits in the input value are simply shifted left or right the same way 0 or\n1 bits are. If the amount contains X or Z bits, all result bits are X.\n\n`shl` shifts bits to the left, filling in 0 for the vacated least\nsignificant bits. `shr` and `ashr` shift bits to the right; `shr` fills in\n0 for the vacated most significant bits, and `ashr` copies the input\u2019s sign\nbit into the vacated most significant bits. Note that in contrast to the SV\nspec, the `ashr` *always* fills in the sign bit regardless of the signedness\nof the input.\n\n`shl` corresponds to the `<<` and `<<<` operators. `shr` corresponds to the\n`>>` operator, and the `>>>` operator applied to an unsigned value. `ashr`\ncorresponds to the `>>>` operator applied to a signed value.\n\nSee IEEE 1800-2017 \u00a7 11.4.10 \u201cShift operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `value` | simple bit vector type |\n| `amount` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.builtin.acos` (::circt::moore::AcosBIOp)\u00a0[\u00b6](#moorebuiltinacos-circtmooreacosbiop)\n\n*Arc-cosine*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.acos` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.builtin.acosh` (::circt::moore::AcoshBIOp)\u00a0[\u00b6](#moorebuiltinacosh-circtmooreacoshbiop)\n\n*Arc-hyperbolic cosine*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.acosh` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-2)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.add` (::circt::moore::AddOp)\u00a0[\u00b6](#mooreadd-circtmooreaddop)\n\n*Addition*\n\nSyntax:\n\n```\noperation ::= `moore.add` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nAdd the operands. If any bit in the two operands is Z or X, all bits in the\nresult are X.\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-3)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-3)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.fadd` (::circt::moore::AddRealOp)\u00a0[\u00b6](#moorefadd-circtmooreaddrealop)\n\n*Addition; add two real operands.*\n\nSyntax:\n\n```\noperation ::= `moore.fadd` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d and \u00a7 11.3.1 \u201cOperators\nwith real operands\u201d\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-4)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a SystemVerilog real type |\n| `rhs` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-4)\n\n| Result | Description |\n| --- | --- |\n| `result` | a SystemVerilog real type |\n\n### `moore.and` (::circt::moore::AndOp)\u00a0[\u00b6](#mooreand-circtmooreandop)\n\n*Bitwise AND operation*\n\nSyntax:\n\n```\noperation ::= `moore.and` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nApplies the boolean AND operation to each pair of corresponding bits in the\nleft- and right-hand side operand. Corresponds to the `&` operator.\n\nSee IEEE 1800-2017 \u00a7 11.4.8 \u201cBitwise operators\u201d.\n\n|  | 0 | 1 | X | Z |\n| --- | --- | --- | --- | --- |\n| 0 | 0 | 0 | 0 | 0 |\n| 1 | 0 | 1 | X | X |\n| X | 0 | X | X | X |\n| Z | 0 | X | X | X |\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-5)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-5)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.array_create` (::circt::moore::ArrayCreateOp)\u00a0[\u00b6](#moorearray_create-circtmoorearraycreateop)\n\n*Create an array value from individual elements*\n\nSyntax:\n\n```\noperation ::= `moore.array_create` $elements attr-dict `:` type($elements) `->` type($result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-6)\n\n| Operand | Description |\n| --- | --- |\n| `elements` | variadic of unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-6)\n\n| Result | Description |\n| --- | --- |\n| `result` | packed or unpacked static array type |\n\n### `moore.builtin.asin` (::circt::moore::AsinBIOp)\u00a0[\u00b6](#moorebuiltinasin-circtmooreasinbiop)\n\n*Arc-sine*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.asin` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-7)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-7)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.builtin.asinh` (::circt::moore::AsinhBIOp)\u00a0[\u00b6](#moorebuiltinasinh-circtmooreasinhbiop)\n\n*Arc-hyperbolic sine*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.asinh` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-8)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-8)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.assert` (::circt::moore::AssertOp)\u00a0[\u00b6](#mooreassert-circtmooreassertop)\n\n*If cond is not true, an error should be thrown.*\n\nSyntax:\n\n```\noperation ::= `moore.assert` $defer $cond (`label` $label^)? attr-dict `:` type($cond)\n```\n\nTraits: `HasParent<ProcedureOp>`\n\n#### Attributes:\u00a0[\u00b6](#attributes)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `defer` | circt::moore::DeferAssertAttr | assertion deferring mode |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-9)\n\n| Operand | Description |\n| --- | --- |\n| `cond` | single bit type |\n\n### `moore.assigned_variable` (::circt::moore::AssignedVariableOp)\u00a0[\u00b6](#mooreassigned_variable-circtmooreassignedvariableop)\n\n*A variable with a unique continuously assigned value*\n\nSyntax:\n\n```\noperation ::= `moore.assigned_variable` `` custom<ImplicitSSAName>($name) $input attr-dict `:` type($input)\n```\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`, `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-10)\n\n| Operand | Description |\n| --- | --- |\n| `input` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-9)\n\n| Result | Description |\n| --- | --- |\n| `result` | unpacked type |\n\n### `moore.assume` (::circt::moore::AssumeOp)\u00a0[\u00b6](#mooreassume-circtmooreassumeop)\n\n*Verify the cond whether has the expected behavior.*\n\nSyntax:\n\n```\noperation ::= `moore.assume` $defer $cond (`label` $label^)? attr-dict `:` type($cond)\n```\n\nTraits: `HasParent<ProcedureOp>`\n\n#### Attributes:\u00a0[\u00b6](#attributes-2)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `defer` | circt::moore::DeferAssertAttr | assertion deferring mode |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-11)\n\n| Operand | Description |\n| --- | --- |\n| `cond` | single bit type |\n\n### `moore.builtin.atan` (::circt::moore::AtanBIOp)\u00a0[\u00b6](#moorebuiltinatan-circtmooreatanbiop)\n\n*Arc-tangent*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.atan` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-12)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-10)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.builtin.atanh` (::circt::moore::AtanhBIOp)\u00a0[\u00b6](#moorebuiltinatanh-circtmooreatanhbiop)\n\n*Arc-hyperbolic tangent*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.atanh` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-13)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-11)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.builtin.bitstoreal` (::circt::moore::BitstorealBIOp)\u00a0[\u00b6](#moorebuiltinbitstoreal-circtmoorebitstorealbiop)\n\n*Convert a logic vector representation to its real-valued number*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.bitstoreal` $value attr-dict`:` type($value)\n```\n\nCorresponds to the `$bitstoreal` system function. Returns a real number\ncorresponding to the real number representation of the logic vector.\nNote that this does not correspond to a cast to another type, but rather a no-op.\n\nSee IEEE 1800-2023 \u00a7 20.5 \u201cConversion functions\u201d.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-14)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit two-valued integer type |\n\n#### Results:\u00a0[\u00b6](#results-12)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.builtin.bitstoshortreal` (::circt::moore::BitstoshortrealBIOp)\u00a0[\u00b6](#moorebuiltinbitstoshortreal-circtmoorebitstoshortrealbiop)\n\n*Convert a logic vector representation to its real-valued number*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.bitstoshortreal` $value attr-dict `:` type($value)\n```\n\nCorresponds to the `$bitstoshortreal` system function. Returns a real number\ncorresponding to the real number representation of the logic vector.\nNote that this does not correspond to a cast to another type, but rather a no-op.\n\nSee IEEE 1800-2023 \u00a7 20.5 \u201cConversion functions\u201d.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-15)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 32-bit two-valued integer type |\n\n#### Results:\u00a0[\u00b6](#results-13)\n\n| Result | Description |\n| --- | --- |\n| `result` | 32-bit real type, aka. shortreal |\n\n### `moore.blocking_assign` (::circt::moore::BlockingAssignOp)\u00a0[\u00b6](#mooreblocking_assign-circtmooreblockingassignop)\n\n*Blocking procedural assignment*\n\nSyntax:\n\n```\noperation ::= `moore.blocking_assign` $dst `,` $src attr-dict `:` type($src)\n```\n\nA blocking procedural assignment in a sequential block, such as `x = y`. The\neffects of the assignment are visible to any subsequent operations in the\nblock.\n\nSee IEEE 1800-2017 \u00a7 10.4.1 \u201cBlocking procedural assignments\u201d.\n\nInterfaces: `PromotableMemOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-16)\n\n| Operand | Description |\n| --- | --- |\n| `dst` |  |\n| `src` | unpacked type |\n\n### `moore.bool_cast` (::circt::moore::BoolCastOp)\u00a0[\u00b6](#moorebool_cast-circtmooreboolcastop)\n\n*Cast a value to a single bit boolean*\n\nSyntax:\n\n```\noperation ::= `moore.bool_cast` $input attr-dict `:` type($input) `->` type($result)\n```\n\nConvert a nonzero or true value into 1, a zero or false value into 0, and\nany value containing Z or X bits into a X. This conversion is useful in\ncombination with the logical and, or, implication, equivalence, and negation\noperators.\n\nSee IEEE 1800-2017 \u00a7 11.4.7 \u201cLogical operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-17)\n\n| Operand | Description |\n| --- | --- |\n| `input` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-14)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.case_eq` (::circt::moore::CaseEqOp)\u00a0[\u00b6](#moorecase_eq-circtmoorecaseeqop)\n\n*Case equality*\n\nSyntax:\n\n```\noperation ::= `moore.case_eq` $lhs `,` $rhs attr-dict `:` type($lhs)\n```\n\nCompares the bits in the left- and right-hand side operand and returns a\nsingle bit 0 or 1 result. If all corresponding bits in the left- and\nright-hand side are equal (both 0, 1, X, or Z), the two operands are\nconsidered equal (`case_eq` returns 1, `case_ne` returns 0). If any bits are\nnot equal, the two operands are considered not equal (`case_eq` returns 0,\n`case_ne` returns 1). `case_eq` corresponds to the `===` operator and\n`case_ne` to the `!==` operator.\n\n`casez_eq` treats Z bits in either operand as wildcards and skips them\nduring the comparison. `casexz_eq` treats X and Z bits as wildcards. These\nare different from the `wildcard_eq` operation, which only considers X/Z in\nthe right-hand operand as wildcards.\n\nCase statements use this operation to perform case comparisons:\n\n* `case` statements use `case_eq`\n* `casez` statements use `casez_eq`\n* `casex` statements use `casexz_eq`\n\nSee IEEE 1800-2017 \u00a7 11.4.5 \u201cEquality operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-18)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-15)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.case_ne` (::circt::moore::CaseNeOp)\u00a0[\u00b6](#moorecase_ne-circtmoorecaseneop)\n\n*Case inequality*\n\nSyntax:\n\n```\noperation ::= `moore.case_ne` $lhs `,` $rhs attr-dict `:` type($lhs)\n```\n\nCompares the bits in the left- and right-hand side operand and returns a\nsingle bit 0 or 1 result. If all corresponding bits in the left- and\nright-hand side are equal (both 0, 1, X, or Z), the two operands are\nconsidered equal (`case_eq` returns 1, `case_ne` returns 0). If any bits are\nnot equal, the two operands are considered not equal (`case_eq` returns 0,\n`case_ne` returns 1). `case_eq` corresponds to the `===` operator and\n`case_ne` to the `!==` operator.\n\n`casez_eq` treats Z bits in either operand as wildcards and skips them\nduring the comparison. `casexz_eq` treats X and Z bits as wildcards. These\nare different from the `wildcard_eq` operation, which only considers X/Z in\nthe right-hand operand as wildcards.\n\nCase statements use this operation to perform case comparisons:\n\n* `case` statements use `case_eq`\n* `casez` statements use `casez_eq`\n* `casex` statements use `casexz_eq`\n\nSee IEEE 1800-2017 \u00a7 11.4.5 \u201cEquality operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-19)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-16)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.casexz_eq` (::circt::moore::CaseXZEqOp)\u00a0[\u00b6](#moorecasexz_eq-circtmoorecasexzeqop)\n\n*Case equality with X and Z as wildcard*\n\nSyntax:\n\n```\noperation ::= `moore.casexz_eq` $lhs `,` $rhs attr-dict `:` type($lhs)\n```\n\nCompares the bits in the left- and right-hand side operand and returns a\nsingle bit 0 or 1 result. If all corresponding bits in the left- and\nright-hand side are equal (both 0, 1, X, or Z), the two operands are\nconsidered equal (`case_eq` returns 1, `case_ne` returns 0). If any bits are\nnot equal, the two operands are considered not equal (`case_eq` returns 0,\n`case_ne` returns 1). `case_eq` corresponds to the `===` operator and\n`case_ne` to the `!==` operator.\n\n`casez_eq` treats Z bits in either operand as wildcards and skips them\nduring the comparison. `casexz_eq` treats X and Z bits as wildcards. These\nare different from the `wildcard_eq` operation, which only considers X/Z in\nthe right-hand operand as wildcards.\n\nCase statements use this operation to perform case comparisons:\n\n* `case` statements use `case_eq`\n* `casez` statements use `casez_eq`\n* `casex` statements use `casexz_eq`\n\nSee IEEE 1800-2017 \u00a7 11.4.5 \u201cEquality operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-20)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-17)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.casez_eq` (::circt::moore::CaseZEqOp)\u00a0[\u00b6](#moorecasez_eq-circtmoorecasezeqop)\n\n*Case equality with Z as wildcard*\n\nSyntax:\n\n```\noperation ::= `moore.casez_eq` $lhs `,` $rhs attr-dict `:` type($lhs)\n```\n\nCompares the bits in the left- and right-hand side operand and returns a\nsingle bit 0 or 1 result. If all corresponding bits in the left- and\nright-hand side are equal (both 0, 1, X, or Z), the two operands are\nconsidered equal (`case_eq` returns 1, `case_ne` returns 0). If any bits are\nnot equal, the two operands are considered not equal (`case_eq` returns 0,\n`case_ne` returns 1). `case_eq` corresponds to the `===` operator and\n`case_ne` to the `!==` operator.\n\n`casez_eq` treats Z bits in either operand as wildcards and skips them\nduring the comparison. `casexz_eq` treats X and Z bits as wildcards. These\nare different from the `wildcard_eq` operation, which only considers X/Z in\nthe right-hand operand as wildcards.\n\nCase statements use this operation to perform case comparisons:\n\n* `case` statements use `case_eq`\n* `casez` statements use `casez_eq`\n* `casex` statements use `casexz_eq`\n\nSee IEEE 1800-2017 \u00a7 11.4.5 \u201cEquality operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-21)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-18)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.builtin.ceil` (::circt::moore::CeilBIOp)\u00a0[\u00b6](#moorebuiltinceil-circtmooreceilbiop)\n\n*Ceiling*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.ceil` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-22)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-19)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.class.classdecl` (::circt::moore::ClassDeclOp)\u00a0[\u00b6](#mooreclassclassdecl-circtmooreclassdeclop)\n\n*Class declaration*\n\nSyntax:\n\n```\noperation ::= `moore.class.classdecl` $sym_name\n              (`extends` $base^)?\n              (`implements` $implementedInterfaces^)?\n              attr-dict-with-keyword $body\n```\n\nTraits: `IsolatedFromAbove`, `NoTerminator`, `SingleBlock`, `SymbolTable`\n\nInterfaces: `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-3)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `base` | ::mlir::SymbolRefAttr | symbol reference attribute |\n| `implementedInterfaces` | ::mlir::ArrayAttr | symbol ref array attribute |\n\n### `moore.class.methoddecl` (::circt::moore::ClassMethodDeclOp)\u00a0[\u00b6](#mooreclassmethoddecl-circtmooreclassmethoddeclop)\n\n*Declare a class method*\n\nSyntax:\n\n```\noperation ::= `moore.class.methoddecl` $sym_name (`->` $impl^)? `:` $function_type attr-dict\n```\n\nTraits: `HasParent<ClassDeclOp>`\n\nInterfaces: `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-4)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `function_type` | ::mlir::TypeAttr | type attribute of function type |\n| `impl` | ::mlir::SymbolRefAttr | symbol reference attribute |\n\n### `moore.class.new` (::circt::moore::ClassNewOp)\u00a0[\u00b6](#mooreclassnew-circtmooreclassnewop)\n\n*Allocate a new class instance*\n\nSyntax:\n\n```\noperation ::= `moore.class.new` `:` type($result) attr-dict\n```\n\nAllocates a new instance of class @C. This op does not call the constructor.\nThe result is a non-null `!moore.class.object<@C>` handle.\n\nInterfaces: `MemoryEffectOpInterface`\n\n#### Results:\u00a0[\u00b6](#results-20)\n\n| Result | Description |\n| --- | --- |\n| `result` | Class object handle type, pointing to an object on the heap. |\n\n### `moore.class.propertydecl` (::circt::moore::ClassPropertyDeclOp)\u00a0[\u00b6](#mooreclasspropertydecl-circtmooreclasspropertydeclop)\n\n*Declare a class property*\n\nSyntax:\n\n```\noperation ::= `moore.class.propertydecl` $sym_name `:` $type  attr-dict\n```\n\nDeclares a property within a class declaration.\n\nTraits: `HasParent<ClassDeclOp>`\n\nInterfaces: `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-5)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `type` | ::mlir::TypeAttr | any type attribute |\n\n### `moore.class.property_ref` (::circt::moore::ClassPropertyRefOp)\u00a0[\u00b6](#mooreclassproperty_ref-circtmooreclasspropertyrefop)\n\n*Get a !moore.ref to a class property*\n\nSyntax:\n\n```\noperation ::= `moore.class.property_ref` $instance`[`$property`]` `:` type($instance) `->` type($propertyRef) attr-dict\n```\n\nConstruct a reference to a class instance\u2019s property field. Translates\nto a fixed offset from the the class handle into its data struct.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-6)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `property` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-23)\n\n| Operand | Description |\n| --- | --- |\n| `instance` | Class object handle type, pointing to an object on the heap. |\n\n#### Results:\u00a0[\u00b6](#results-21)\n\n| Result | Description |\n| --- | --- |\n| `propertyRef` |  |\n\n### `moore.class.upcast` (::circt::moore::ClassUpcastOp)\u00a0[\u00b6](#mooreclassupcast-circtmooreclassupcastop)\n\n*Upcast a derived handle to a base handle (zero-cost)*\n\nSyntax:\n\n```\noperation ::= `moore.class.upcast` $instance `:` type($instance) `to` type($result) attr-dict\n```\n\nCasts an instance of a class to one of its base classes.\nThe created instance points to the same underlying data struct as the original\ninstance, and modifying it will modify the spawning instance\u2019s data as well.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-24)\n\n| Operand | Description |\n| --- | --- |\n| `instance` | Class object handle type, pointing to an object on the heap. |\n\n#### Results:\u00a0[\u00b6](#results-22)\n\n| Result | Description |\n| --- | --- |\n| `result` | Class object handle type, pointing to an object on the heap. |\n\n### `moore.builtin.clog2` (::circt::moore::Clog2BIOp)\u00a0[\u00b6](#moorebuiltinclog2-circtmooreclog2biop)\n\n*Compute ceil(log2(x)) of x*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.clog2` $value attr-dict `:` type($value)\n```\n\nComputes the ceiling of the base-2 logarithm of the argument. The argument\nis interpreted as unsigned. The result is 0 if the argument is 0. The result\ncorresponds to the minimum address width necessary to address a given number\nof elements, or the number of bits necessary to represent a given number of\nstates.\n\nIf any of the bits in the argument are X or Z, the result is X.\n\nSee IEEE 1800-2017 \u00a7 20.8.1 \u201cInteger math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-25)\n\n| Operand | Description |\n| --- | --- |\n| `value` | a simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-23)\n\n| Result | Description |\n| --- | --- |\n| `result` | a simple bit vector type |\n\n### `moore.concat` (::circt::moore::ConcatOp)\u00a0[\u00b6](#mooreconcat-circtmooreconcatop)\n\n*A concatenation of expressions*\n\nSyntax:\n\n```\noperation ::= `moore.concat` $values attr-dict `:` `(` type($values) `)` `->` type($result)\n```\n\nThis operation represents the SystemVerilog concatenation expression\n`{x, y, z}`. See IEEE 1800-2017 \u00a711.4.12 \u201cConcatenation operators\u201d.\n\nAll operands must be simple bit vector types.\n\nThe concatenation result is a simple bit vector type. The result is unsigned\nregardless of the sign of the operands (see concatenation-specific rules in\nIEEE 1800-2017 \u00a711.8.1 \u201cRules for expression types\u201d). The size of the result\nis the sum of the sizes of all operands. If any of the operands is\nfour-valued, the result is four-valued; otherwise it is two-valued.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-26)\n\n| Operand | Description |\n| --- | --- |\n| `values` | variadic of a simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-24)\n\n| Result | Description |\n| --- | --- |\n| `result` | a simple bit vector type |\n\n### `moore.concat_ref` (::circt::moore::ConcatRefOp)\u00a0[\u00b6](#mooreconcat_ref-circtmooreconcatrefop)\n\n*The copy of concat that explicitly works on the ref type.*\n\nSyntax:\n\n```\noperation ::= `moore.concat_ref` $values attr-dict `:` `(` type($values) `)` `->` type($result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-27)\n\n| Operand | Description |\n| --- | --- |\n| `values` | variadic of |\n\n#### Results:\u00a0[\u00b6](#results-25)\n\n| Result | Description |\n| --- | --- |\n| `result` |  |\n\n### `moore.conditional` (::circt::moore::ConditionalOp)\u00a0[\u00b6](#mooreconditional-circtmooreconditionalop)\n\n*Conditional operation*\n\nSyntax:\n\n```\noperation ::= `moore.conditional` $condition attr-dict `:` type($condition) `->` type($result)\n              $trueRegion $falseRegion\n```\n\nIf the condition is true, this op evaluates the first region and returns its\nresult without evaluating the second region. If the the condition is false,\nthis op evaluates the second region and returns its result without\nevaluating the first region.\n\nIf the condition is unknown (X or Z), *both* regions are evaluated. If both\nresults are equal as per `case_eq`, one of the results is returned. If the\nresults are not equal, this op returns a value based on the data types of\nthe results.\n\nIn case the results of the first and second region are of an integral type,\nthey are merged by applying the following bit-wise truth table:\n\n| ?: | 0 | 1 | X | Z |\n| --- | --- | --- | --- | --- |\n| 0 | 0 | X | X | X |\n| 1 | X | 1 | X | X |\n| X | X | X | X | X |\n| Z | X | X | X | X |\n\nNon-integral data types define other rules which are not yet implemented.\nSee IEEE 1800-2017 \u00a7 11.4.11 \u201cConditional operator\u201d.\n\nTraits: `NoRegionArguments`, `RecursiveMemoryEffects`\n\n#### Operands:\u00a0[\u00b6](#operands-28)\n\n| Operand | Description |\n| --- | --- |\n| `condition` | single bit type |\n\n#### Results:\u00a0[\u00b6](#results-26)\n\n| Result | Description |\n| --- | --- |\n| `result` | unpacked type |\n\n### `moore.constant` (::circt::moore::ConstantOp)\u00a0[\u00b6](#mooreconstant-circtmooreconstantop)\n\n*A constant integer value*\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-7)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::circt::moore::FVIntegerAttr | An attribute containing a four-valued integer |\n\n#### Results:\u00a0[\u00b6](#results-27)\n\n| Result | Description |\n| --- | --- |\n| `result` | a simple bit vector type |\n\n### `moore.constant_real` (::circt::moore::ConstantRealOp)\u00a0[\u00b6](#mooreconstant_real-circtmooreconstantrealop)\n\n*A constant real value*\n\nSyntax:\n\n```\noperation ::= `moore.constant_real` $value attr-dict\n```\n\nProduces a constant value of a real type.\n\nSee IEEE 1800-2017 \u00a7 5.7.2 \u201cReal literal constants\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-8)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | mlir::FloatAttr | arbitrary float attribute |\n\n#### Results:\u00a0[\u00b6](#results-28)\n\n| Result | Description |\n| --- | --- |\n| `result` | a SystemVerilog real type |\n\n### `moore.constant_string` (::circt::moore::ConstantStringOp)\u00a0[\u00b6](#mooreconstant_string-circtmooreconstantstringop)\n\n*A constant integer value defined by a string of bytes*\n\nSyntax:\n\n```\noperation ::= `moore.constant_string` $value attr-dict `:` type($result)\n```\n\nDefines a constant integer value based on the bytes of a string. The\nresulting integer contains 8 bits for each byte in the string. The first,\nleft-most character is placed in the most significnat bits; the last,\nright-most character is placed in the least significant bits.\n\nConstant strings are represented as integers since they have a known width\nand bit-pattern, which is often used in SV to assign strings to parameters,\nor store strings in bit vectors. In contrast, the `string` type is a dynamic\nstring with runtime-known length. To obtain a constant `string` value, the\nresulting integer should be converted to a `string`.\n\nSee IEEE 1800-2017 \u00a7 5.9 \u201cString literals\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-9)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-29)\n\n| Result | Description |\n| --- | --- |\n| `result` | a simple bit vector type |\n\n### `moore.constant_time` (::circt::moore::ConstantTimeOp)\u00a0[\u00b6](#mooreconstant_time-circtmooreconstanttimeop)\n\n*A constant time value in femtoseconds*\n\nSyntax:\n\n```\noperation ::= `moore.constant_time` $value `fs` attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-10)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::IntegerAttr | 64-bit unsigned integer attribute |\n\n#### Results:\u00a0[\u00b6](#results-30)\n\n| Result | Description |\n| --- | --- |\n| `result` | the SystemVerilog `time` and `realtime` type |\n\n### `moore.assign` (::circt::moore::ContinuousAssignOp)\u00a0[\u00b6](#mooreassign-circtmoorecontinuousassignop)\n\n*Continuous assignment within a module*\n\nSyntax:\n\n```\noperation ::= `moore.assign` $dst `,` $src attr-dict `:` type($src)\n```\n\nA continuous assignment in module scope, such as `assign x = y;`, which\ncontinuously drives the value on the right-hand side onto the left-hand\nside.\n\nSee IEEE 1800-2017 \u00a7 10.3 \u201cContinuous assignments\u201d.\n\nTraits: `HasParent<SVModuleOp>`\n\n#### Operands:\u00a0[\u00b6](#operands-29)\n\n| Operand | Description |\n| --- | --- |\n| `dst` |  |\n| `src` | unpacked type |\n\n### `moore.conversion` (::circt::moore::ConversionOp)\u00a0[\u00b6](#mooreconversion-circtmooreconversionop)\n\n*A type conversion*\n\nSyntax:\n\n```\noperation ::= `moore.conversion` $input attr-dict `:` type($input) `->` type($result)\n```\n\nAn explicit or implicit type conversion. These are either generated\nautomatically in order to make assignments compatible:\n\n```\nint a;\nshortint b;\na = b;  // generates an implicit cast from shortint to int\n```\n\nOr explicitly by the user through a type, sign, or const cast expression:\n\n```\nbyte'(a)\nunsigned'(a)\nsigned'(a)\n42'(a)\n```\n\nSee IEEE 1800-2017 \u00a7 6.24 \u201cCasting\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-30)\n\n| Operand | Description |\n| --- | --- |\n| `input` | any type |\n\n#### Results:\u00a0[\u00b6](#results-31)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `moore.convert_real` (::circt::moore::ConvertRealOp)\u00a0[\u00b6](#mooreconvert_real-circtmooreconvertrealop)\n\n*Convert a real to a different bitwidth*\n\nSyntax:\n\n```\noperation ::= `moore.convert_real` $input attr-dict `:` type($input) `->` type($result)\n```\n\nThe value is rounded to the nearest value representable by the target type.\nSee IEEE 1800-2023 Section 6.24.1.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-31)\n\n| Operand | Description |\n| --- | --- |\n| `input` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-32)\n\n| Result | Description |\n| --- | --- |\n| `result` | a SystemVerilog real type |\n\n### `moore.builtin.cos` (::circt::moore::CosBIOp)\u00a0[\u00b6](#moorebuiltincos-circtmoorecosbiop)\n\n*Cosine*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.cos` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-32)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-33)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.builtin.cosh` (::circt::moore::CoshBIOp)\u00a0[\u00b6](#moorebuiltincosh-circtmoorecoshbiop)\n\n*Hyperbolic cosine*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.cosh` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-33)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-34)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.cover` (::circt::moore::CoverOp)\u00a0[\u00b6](#moorecover-circtmoorecoverop)\n\n*Monitor the coverage information.*\n\nSyntax:\n\n```\noperation ::= `moore.cover` $defer $cond (`label` $label^)? attr-dict `:` type($cond)\n```\n\nTraits: `HasParent<ProcedureOp>`\n\n#### Attributes:\u00a0[\u00b6](#attributes-11)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `defer` | circt::moore::DeferAssertAttr | assertion deferring mode |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-34)\n\n| Operand | Description |\n| --- | --- |\n| `cond` | single bit type |\n\n### `moore.delayed_assign` (::circt::moore::DelayedContinuousAssignOp)\u00a0[\u00b6](#mooredelayed_assign-circtmooredelayedcontinuousassignop)\n\n*Delayed continuous assignment within a module*\n\nSyntax:\n\n```\noperation ::= `moore.delayed_assign` $dst `,` $src `,` $delay attr-dict `:` type($src)\n```\n\nA continuous assignment with a delay.\n\nSee the `moore.assign` op.\nSee IEEE 1800-2017 \u00a7 10.3 \u201cContinuous assignments\u201d.\n\nTraits: `HasParent<SVModuleOp>`\n\n#### Operands:\u00a0[\u00b6](#operands-35)\n\n| Operand | Description |\n| --- | --- |\n| `dst` |  |\n| `src` | unpacked type |\n| `delay` | the SystemVerilog `time` and `realtime` type |\n\n### `moore.delayed_nonblocking_assign` (::circt::moore::DelayedNonBlockingAssignOp)\u00a0[\u00b6](#mooredelayed_nonblocking_assign-circtmooredelayednonblockingassignop)\n\n*Delayed nonblocking procedural assignment*\n\nSyntax:\n\n```\noperation ::= `moore.delayed_nonblocking_assign` $dst `,` $src `,` $delay attr-dict `:` type($src)\n```\n\nA nonblocking procedural assignment with an intra-assignment delay control.\n\nSee the `moore.nonblocking_assign` op.\nSee IEEE 1800-2017 \u00a7 9.4.5 \u201cIntra-assignment timing controls\u201d.\n\n#### Operands:\u00a0[\u00b6](#operands-36)\n\n| Operand | Description |\n| --- | --- |\n| `dst` |  |\n| `src` | unpacked type |\n| `delay` | the SystemVerilog `time` and `realtime` type |\n\n### `moore.detect_event` (::circt::moore::DetectEventOp)\u00a0[\u00b6](#mooredetect_event-circtmooredetecteventop)\n\n*Check if an event occured within a `wait_event` op*\n\nSyntax:\n\n```\noperation ::= `moore.detect_event` $edge $input (`if` $condition^)? attr-dict `:` type($input)\n```\n\nThe `moore.detect_event` op is used inside the body of a `moore.wait_event`\nto check if an interesting value change has occurred on its operand. The\n`moore.detect_event` op implicitly stores the previous value of its operand\nand compares it against the current value to detect an interesting edge:\n\n* `posedge` checks for a low-to-high transition\n* `negedge` checks for a high-to-low transition\n* `edge` checks for either a `posedge` or a `negedge`\n* `any` checks for any value change (including e.g. X to Z)\n\nThe edges are detected as follows:\n\n* `0` to `1 X Z`: `posedge`\n* `1` to `0 X Z`: `negedge`\n* `X Z` to `1`: `posedge`\n* `X Z` to `0`: `negedge`\n\n| From | To 0 | To 1 | To X | To Z |\n| --- | --- | --- | --- | --- |\n| 0 | - | posedge | posedge | posedge |\n| 1 | negedge | - | negedge | negedge |\n| X | negedge | posedge | - | - |\n| Z | negedge | posedge | - | - |\n\nSee IEEE 1800-2017 \u00a7 9.4.2 \u201cEvent control\u201d.\n\nTraits: `HasParent<WaitEventOp>`\n\n#### Attributes:\u00a0[\u00b6](#attributes-12)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `edge` | circt::moore::EdgeAttr | Edge kind |\n\n#### Operands:\u00a0[\u00b6](#operands-37)\n\n| Operand | Description |\n| --- | --- |\n| `input` | unpacked type |\n| `condition` | `bit` type |\n\n### `moore.builtin.display` (::circt::moore::DisplayBIOp)\u00a0[\u00b6](#moorebuiltindisplay-circtmooredisplaybiop)\n\n*Print a text message*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.display` $message attr-dict\n```\n\nPrints the given format string to the standard text output of the simulator.\nIn most cases this should be stdout. This corresponds to the `$display` and\n`$write` system tasks. Message formatting is handled by `moore.fmt.*` ops.\n\nSee IEEE 1800-2017 \u00a7 21.2 \u201cDisplay system tasks\u201d.\n\n#### Operands:\u00a0[\u00b6](#operands-38)\n\n| Operand | Description |\n| --- | --- |\n| `message` | a format string type |\n\n### `moore.fdiv` (::circt::moore::DivRealOp)\u00a0[\u00b6](#moorefdiv-circtmooredivrealop)\n\n*Division; Divide the LHS real operand by the LHS\nreal operand.*\n\nSyntax:\n\n```\noperation ::= `moore.fdiv` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d and \u00a7 11.3.1 \u201cOperators\nwith real operands\u201d\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-39)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a SystemVerilog real type |\n| `rhs` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-35)\n\n| Result | Description |\n| --- | --- |\n| `result` | a SystemVerilog real type |\n\n### `moore.divs` (::circt::moore::DivSOp)\u00a0[\u00b6](#mooredivs-circtmooredivsop)\n\n*Division*\n\nSyntax:\n\n```\noperation ::= `moore.divs` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nDivide the left-hand side by the right-hand side operand. Any fractional\npart is truncated toward zero. If the right-hand side is zero, all bits of\nthe result are X. If any bit in the two operands is Z or X, all bits in the\nresult are X.\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-40)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-36)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.divu` (::circt::moore::DivUOp)\u00a0[\u00b6](#mooredivu-circtmooredivuop)\n\n*Division*\n\nSyntax:\n\n```\noperation ::= `moore.divu` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nDivide the left-hand side by the right-hand side operand. Any fractional\npart is truncated toward zero. If the right-hand side is zero, all bits of\nthe result are X. If any bit in the two operands is Z or X, all bits in the\nresult are X.\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-41)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-37)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.dyn_extract` (::circt::moore::DynExtractOp)\u00a0[\u00b6](#mooredyn_extract-circtmooredynextractop)\n\nSyntax:\n\n```\noperation ::= `moore.dyn_extract` $input `from` $lowBit attr-dict `:`\n              type($input) `,` type($lowBit) `->` type($result)\n```\n\nIt\u2019s similar with extract, but it\u2019s used to select from a value\nwith a dynamic low bit.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-42)\n\n| Operand | Description |\n| --- | --- |\n| `input` | unpacked type |\n| `lowBit` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-38)\n\n| Result | Description |\n| --- | --- |\n| `result` | unpacked type |\n\n### `moore.dyn_extract_ref` (::circt::moore::DynExtractRefOp)\u00a0[\u00b6](#mooredyn_extract_ref-circtmooredynextractrefop)\n\nSyntax:\n\n```\noperation ::= `moore.dyn_extract_ref` $input `from` $lowBit attr-dict `:`\n              type($input) `,` type($lowBit) `->` type($result)\n```\n\nThe copy of dyn\\_extract that explicitly works on the ref type.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-43)\n\n| Operand | Description |\n| --- | --- |\n| `input` |  |\n| `lowBit` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-39)\n\n| Result | Description |\n| --- | --- |\n| `result` |  |\n\n### `moore.dyn_queue_extract` (::circt::moore::DynQueueExtractOp)\u00a0[\u00b6](#mooredyn_queue_extract-circtmooredynqueueextractop)\n\nSyntax:\n\n```\noperation ::= `moore.dyn_queue_extract` $input `from` $lowerIdx attr-dict `:`\n              type($input) `,` type($lowerIdx) `->` type($result)\n```\n\nIt\u2019s similar to extract, but it\u2019s used to select from a value\nwith a dynamic lower index.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-44)\n\n| Operand | Description |\n| --- | --- |\n| `input` | a queue type |\n| `lowerIdx` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-40)\n\n| Result | Description |\n| --- | --- |\n| `result` | unpacked type |\n\n### `moore.dyn_queue_extract_ref` (::circt::moore::DynQueueExtractRefOp)\u00a0[\u00b6](#mooredyn_queue_extract_ref-circtmooredynqueueextractrefop)\n\nSyntax:\n\n```\noperation ::= `moore.dyn_queue_extract_ref` $input `from` $lowerIdx attr-dict `:`\n              type($input) `,` type($lowerIdx) `->` type($result)\n```\n\nThe copy of dyn\\_extract that explicitly works on the ref type.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-45)\n\n| Operand | Description |\n| --- | --- |\n| `input` |  |\n| `lowerIdx` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-41)\n\n| Result | Description |\n| --- | --- |\n| `result` |  |\n\n### `moore.eq` (::circt::moore::EqOp)\u00a0[\u00b6](#mooreeq-circtmooreeqop)\n\n*Logical equality*\n\nSyntax:\n\n```\noperation ::= `moore.eq` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the bits in the left- and right-hand side operand and returns a\nsingle bit 0, 1, or X result. If all corresponding bits in the left- and\nright-hand side are equal, and all are 0 or 1 (not X or Z), the two operands\nare considered equal (`eq` returns 1, `ne` returns 0). If any bits are not\nequal, but all are 0 or 1, the two operands are considered not equal (`eq`\nreturns 0, `ne` returns 1). If any bit in the two operands is Z or X,\nreturns X. `eq` corresponds to the `==` operator and `ne` to the `!=`\noperator.\n\nSee IEEE 1800-2017 \u00a7 11.4.5 \u201cEquality operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-46)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-42)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.feq` (::circt::moore::EqRealOp)\u00a0[\u00b6](#moorefeq-circtmooreeqrealop)\n\n*Logical equality*\n\nSyntax:\n\n```\noperation ::= `moore.feq` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the bits in the left- and right-hand side operand and returns a\nsingle bit 0 or 1. If all corresponding bits in the left- and\nright-hand side are equal, and all are 0 or 1, the two operands\nare considered equal (`eq` returns 1, `ne` returns 0). If any bits are not\nequal, but all are 0 or 1, the two operands are considered not equal (`eq`\nreturns 0, `ne` returns 1). `eq` corresponds to the `==` operator and `ne`\nto the `!=` operator.\n\nSee IEEE 1800-2017 \u00a7 11.4.5 \u201cEquality operators\u201d and \u00a7 11.3.1 \u201cOperators\nwith real operands\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-47)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a SystemVerilog real type |\n| `rhs` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-43)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.builtin.exp` (::circt::moore::ExpBIOp)\u00a0[\u00b6](#moorebuiltinexp-circtmooreexpbiop)\n\n*Exponential*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.exp` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-48)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-44)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.extract` (::circt::moore::ExtractOp)\u00a0[\u00b6](#mooreextract-circtmooreextractop)\n\n*Extract a range or single bits from a value*\n\nSyntax:\n\n```\noperation ::= `moore.extract` $input `from` $lowBit attr-dict `:` type($input) `->` type($result)\n```\n\nIt\u2019s used to select from a value with a constant low bit.\nThis operation includes the vector bit/part-select, array, and memory\naddressing.If the address is invalid\u2013out of bounds or has x or z bit\u2013\nthen it will produce x for 4-state or 0 for 2-state.\nBit-select results are unsigned, regardless of the operands.\nPart-select results are unsigned, regardless of the operands even if\nthe part-select specifies the entire vector.\nSee IEEE 1800-2017 \u00a7 11.8.1 \u201cRules for expression types\u201d\n\nExample:\n\n```\nlogic v [7:0];\nv[1];                      // the bit-select addressing\nv[3:0];                    // the part-select addressing\nv[3-:4];  v[0+:4];         // They are equivalent to v[3:0]\n```\n\nSee IEEE 1800-2017 \u00a7 11.5.1 \u201cVector bit-select and part-select addressing\u201d.\n\nExample:\n\n```\n// an array of 256-by-256 8-bit elements\nlogic [7:0] twod_array [0:255][0:255];\nlogic [7:0] mem_name [0:1023];      // a memory of 1024 8-bit words\n```\n\nSee IEEE 1800-2017 \u00a7 11.5.2 \u201cArray and memory addressing\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-13)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `lowBit` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-49)\n\n| Operand | Description |\n| --- | --- |\n| `input` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-45)\n\n| Result | Description |\n| --- | --- |\n| `result` | unpacked type |\n\n### `moore.extract_ref` (::circt::moore::ExtractRefOp)\u00a0[\u00b6](#mooreextract_ref-circtmooreextractrefop)\n\nSyntax:\n\n```\noperation ::= `moore.extract_ref` $input `from` $lowBit attr-dict `:` type($input) `->` type($result)\n```\n\nThe copy of extract that explicitly works on the ref type.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-14)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `lowBit` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-50)\n\n| Operand | Description |\n| --- | --- |\n| `input` |  |\n\n#### Results:\u00a0[\u00b6](#results-46)\n\n| Result | Description |\n| --- | --- |\n| `result` |  |\n\n### `moore.fge` (::circt::moore::FgeOp)\u00a0[\u00b6](#moorefge-circtmoorefgeop)\n\n*Real-valued greater than or equal comparison*\n\nSyntax:\n\n```\noperation ::= `moore.fge` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the left- and right-hand side operand and returns a single bit 0,\nor 1 result. If all bits are 0 or 1, `flt`, `fle`, `fgt`, and\n`fge` return whether the left-hand side is less than, less than or equal\nto, greater than, or greater than or equal to the right-hand side,\nrespectively. `flt` corresponds to the `<` operator, `fle` to `<=`,\n`fgt` to `>`, and `fge` to `>=`.\n\nSee IEEE 1800-2017 \u00a7 11.4.4 \u201cRelational operators\u201d and \u00a7 11.3.1 \u201cOperators\nwith real operands\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-51)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a SystemVerilog real type |\n| `rhs` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-47)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.fgt` (::circt::moore::FgtOp)\u00a0[\u00b6](#moorefgt-circtmoorefgtop)\n\n*Real-valued greater than comparison*\n\nSyntax:\n\n```\noperation ::= `moore.fgt` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the left- and right-hand side operand and returns a single bit 0,\nor 1 result. If all bits are 0 or 1, `flt`, `fle`, `fgt`, and\n`fge` return whether the left-hand side is less than, less than or equal\nto, greater than, or greater than or equal to the right-hand side,\nrespectively. `flt` corresponds to the `<` operator, `fle` to `<=`,\n`fgt` to `>`, and `fge` to `>=`.\n\nSee IEEE 1800-2017 \u00a7 11.4.4 \u201cRelational operators\u201d and \u00a7 11.3.1 \u201cOperators\nwith real operands\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-52)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a SystemVerilog real type |\n| `rhs` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-48)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.builtin.finish` (::circt::moore::FinishBIOp)\u00a0[\u00b6](#moorebuiltinfinish-circtmoorefinishbiop)\n\n*Exit simulation*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.finish` $exitCode attr-dict\n```\n\nCorresponds to the `$finish` system task. Causes the simulator to exit and\npass control back to the host operating system. Printing of the optional\ndiagnostic message is handled by the `finish_message` op.\n\nThe exit code argument of this op is not directly accessible from Verilog,\nbut is used to distinguish between the implicit `$finish` call in `$fatal`\nand an explicit `$finish` called by the user.\n\nSee IEEE 1800-2017 \u00a7 20.2 \u201cSimulation control system tasks\u201d.\n\n#### Attributes:\u00a0[\u00b6](#attributes-15)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `exitCode` | ::mlir::IntegerAttr | 8-bit signless integer attribute |\n\n### `moore.builtin.finish_message` (::circt::moore::FinishMessageBIOp)\u00a0[\u00b6](#moorebuiltinfinish_message-circtmoorefinishmessagebiop)\n\n*Print diagnostic message for the finish system task*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.finish_message` $withStats attr-dict\n```\n\nPrints the diagnostic message for `$stop`, `$finish`, `$exit`, and `$fatal`\nmandated by the SystemVerilog standard. The exact message is controlled by\nthe verbosity parameter as specified in the standard:\n\n* The absence of this op corresponds to `$finish(0)`.\n* `moore.builtin.finish_message false` corresponds to `$finish(1)`.\n* `moore.builtin.finish_message true` corresponds to `$finish(2)`.\n\nThe `withStats` argument controls how detailed the printed message is:\n\n* **false**: Print simulation time and location.\n* **true**: Print simulation time, location, and statistics about the memory\n  and CPU usage of the simulator.\n\nSee IEEE 1800-2017 \u00a7 20.2 \u201cSimulation control system tasks\u201d.\n\n#### Attributes:\u00a0[\u00b6](#attributes-16)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `withStats` | ::mlir::IntegerAttr | 1-bit signless integer attribute |\n\n### `moore.fle` (::circt::moore::FleOp)\u00a0[\u00b6](#moorefle-circtmoorefleop)\n\n*Real-valued less than or equal comparison*\n\nSyntax:\n\n```\noperation ::= `moore.fle` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the left- and right-hand side operand and returns a single bit 0,\nor 1 result. If all bits are 0 or 1, `flt`, `fle`, `fgt`, and\n`fge` return whether the left-hand side is less than, less than or equal\nto, greater than, or greater than or equal to the right-hand side,\nrespectively. `flt` corresponds to the `<` operator, `fle` to `<=`,\n`fgt` to `>`, and `fge` to `>=`.\n\nSee IEEE 1800-2017 \u00a7 11.4.4 \u201cRelational operators\u201d and \u00a7 11.3.1 \u201cOperators\nwith real operands\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-53)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a SystemVerilog real type |\n| `rhs` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-49)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.builtin.floor` (::circt::moore::FloorBIOp)\u00a0[\u00b6](#moorebuiltinfloor-circtmoorefloorbiop)\n\n*Floor*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.floor` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-54)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-50)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.flt` (::circt::moore::FltOp)\u00a0[\u00b6](#mooreflt-circtmoorefltop)\n\n*Real-valued less than comparison*\n\nSyntax:\n\n```\noperation ::= `moore.flt` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the left- and right-hand side operand and returns a single bit 0,\nor 1 result. If all bits are 0 or 1, `flt`, `fle`, `fgt`, and\n`fge` return whether the left-hand side is less than, less than or equal\nto, greater than, or greater than or equal to the right-hand side,\nrespectively. `flt` corresponds to the `<` operator, `fle` to `<=`,\n`fgt` to `>`, and `fge` to `>=`.\n\nSee IEEE 1800-2017 \u00a7 11.4.4 \u201cRelational operators\u201d and \u00a7 11.3.1 \u201cOperators\nwith real operands\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-55)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a SystemVerilog real type |\n| `rhs` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-51)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.fmt.concat` (::circt::moore::FormatConcatOp)\u00a0[\u00b6](#moorefmtconcat-circtmooreformatconcatop)\n\n*Concatenate string fragments*\n\nSyntax:\n\n```\noperation ::= `moore.fmt.concat` ` ` `(` $inputs `)` attr-dict\n```\n\nConcatenates an arbitrary number of format string into one larger format\nstring. The strings are concatenated from left to right, with the first\noperand appearing at the left start of the result string, and the last\noperand appearing at the right end. Produces an empty string if no inputs\nare provided.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-56)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a format string type |\n\n#### Results:\u00a0[\u00b6](#results-52)\n\n| Result | Description |\n| --- | --- |\n| `result` | a format string type |\n\n### `moore.fmt.int` (::circt::moore::FormatIntOp)\u00a0[\u00b6](#moorefmtint-circtmooreformatintop)\n\n*Format an integer value*\n\nSyntax:\n\n```\noperation ::= `moore.fmt.int` $format $value `,`\n              `align` $alignment `,`\n              `pad` $padding\n              (`width` $specifierWidth^)?\n              (`signed` $isSigned^)?\n              attr-dict `:` type($value)\n```\n\nFormat an integer value as a string according to the specified format.\n\nSee IEEE 1800-2017 \u00a7 21.2.1.2 \u201cFormat specifications\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-17)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `format` | circt::moore::IntFormatAttr | Integer format |\n| `alignment` | circt::moore::IntAlignAttr | Integer alignment |\n| `padding` | circt::moore::IntPaddingAttr | Integer alignment |\n| `specifierWidth` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `isSigned` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-57)\n\n| Operand | Description |\n| --- | --- |\n| `value` | a simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-53)\n\n| Result | Description |\n| --- | --- |\n| `result` | a format string type |\n\n### `moore.fmt.literal` (::circt::moore::FormatLiteralOp)\u00a0[\u00b6](#moorefmtliteral-circtmooreformatliteralop)\n\n*A constant string fragment*\n\nSyntax:\n\n```\noperation ::= `moore.fmt.literal` $literal attr-dict\n```\n\nCreates a constant string fragment to be used as a format string. The\nliteral is printed as is, without any further escaping or processing of its\ncharacters.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-18)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `literal` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-54)\n\n| Result | Description |\n| --- | --- |\n| `result` | a format string type |\n\n### `moore.fmt.real` (::circt::moore::FormatRealOp)\u00a0[\u00b6](#moorefmtreal-circtmooreformatrealop)\n\n*Format a real number value*\n\nSyntax:\n\n```\noperation ::= `moore.fmt.real` $format $value `,`\n              `align` $alignment\n              (`fieldWidth` $fieldWidth^)?\n              (`fracDigits` $fracDigits^)?\n              attr-dict `:` type($value)\n```\n\nFormat a real value as a string according to the specified format.\n\nSee IEEE 1800-2017 \u00a7 21.2.1.2 \u201cFormat specifications\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-19)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `format` | circt::moore::RealFormatAttr | Real format |\n| `alignment` | circt::moore::IntAlignAttr | Integer alignment |\n| `fieldWidth` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `fracDigits` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-58)\n\n| Operand | Description |\n| --- | --- |\n| `value` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-55)\n\n| Result | Description |\n| --- | --- |\n| `result` | a format string type |\n\n### `moore.fmt.string` (::circt::moore::FormatStringOp)\u00a0[\u00b6](#moorefmtstring-circtmooreformatstringop)\n\n*A dynamic string fragment*\n\nSyntax:\n\n```\noperation ::= `moore.fmt.string` $string\n              (`,` `width` $width^)?\n              (`,` `alignment` $alignment^)?\n              (`,` `padding` $padding^)?\n              attr-dict\n```\n\nCreates a dynamic string fragment to be used as a format string. The\nstring is printed as is, without any further escaping or processing of its\ncharacters.\n\nUse fmt.literal over this operator for any constant strings / literals.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-20)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `width` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `alignment` | circt::moore::IntAlignAttr | Integer alignment |\n| `padding` | circt::moore::IntPaddingAttr | Integer alignment |\n\n#### Operands:\u00a0[\u00b6](#operands-59)\n\n| Operand | Description |\n| --- | --- |\n| `string` | the SystemVerilog `string` type |\n\n#### Results:\u00a0[\u00b6](#results-56)\n\n| Result | Description |\n| --- | --- |\n| `result` | a format string type |\n\n### `moore.fstring_to_string` (::circt::moore::FormatStringToStringOp)\u00a0[\u00b6](#moorefstring_to_string-circtmooreformatstringtostringop)\n\n*A dynamic string created through formatting*\n\nSyntax:\n\n```\noperation ::= `moore.fstring_to_string` $fmtstring attr-dict\n```\n\nCreates a dynamic string from a format string.\nTranslates into a no-op.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-60)\n\n| Operand | Description |\n| --- | --- |\n| `fmtstring` | a format string type |\n\n#### Results:\u00a0[\u00b6](#results-57)\n\n| Result | Description |\n| --- | --- |\n| `result` | the SystemVerilog `string` type |\n\n### `moore.get_global_variable` (::circt::moore::GetGlobalVariableOp)\u00a0[\u00b6](#mooreget_global_variable-circtmooregetglobalvariableop)\n\n*Get a reference to a global variable*\n\nSyntax:\n\n```\noperation ::= `moore.get_global_variable` $global_name attr-dict `:` type($result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-21)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `global_name` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Results:\u00a0[\u00b6](#results-58)\n\n| Result | Description |\n| --- | --- |\n| `result` |  |\n\n### `moore.global_variable` (::circt::moore::GlobalVariableOp)\u00a0[\u00b6](#mooreglobal_variable-circtmooreglobalvariableop)\n\n*A global variable declaration*\n\nSyntax:\n\n```\noperation ::= `moore.global_variable` $sym_name attr-dict `:` $type (`init` $initRegion^)?\n```\n\nDefines a global or package variable.\n\nSee IEEE 1800-2017 \u00a7 6.8 \u201cVariable declarations\u201d.\n\nTraits: `IsolatedFromAbove`, `NoRegionArguments`, `SingleBlock`\n\nInterfaces: `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-22)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `type` | ::mlir::TypeAttr | type attribute of unpacked type |\n\n### `moore.handle_case_eq` (::circt::moore::HandleCaseEqOp)\u00a0[\u00b6](#moorehandle_case_eq-circtmoorehandlecaseeqop)\n\n*Case equality for handle types*\n\nSyntax:\n\n```\noperation ::= `moore.handle_case_eq` $lhs `,` $rhs attr-dict `:` type($lhs) `,` type($rhs)\n```\n\nCompares two handle-typed (ChandleType, ClassHandleType) operands and\nreturns a single bit 0 or 1 result. `case_eq` corresponds to the `===`\noperator and `case_ne` to the `!==` operator. If the handles are not\nidentical, or both null, the two operands are considered not equal (`eq`\nreturns 0, `ne` returns 1).\n\nSee IEEE 1800-2023 \u00a7 8.4 \u201cObjects (class instances)\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-61)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | Nullable handle type |\n| `rhs` | Nullable handle type |\n\n#### Results:\u00a0[\u00b6](#results-59)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.handle_case_ne` (::circt::moore::HandleCaseNeOp)\u00a0[\u00b6](#moorehandle_case_ne-circtmoorehandlecaseneop)\n\n*Case inequality for handle types*\n\nSyntax:\n\n```\noperation ::= `moore.handle_case_ne` $lhs `,` $rhs attr-dict `:` type($lhs) `,` type($rhs)\n```\n\nCompares two handle-typed (ChandleType, ClassHandleType) operands and\nreturns a single bit 0 or 1 result. `case_eq` corresponds to the `===`\noperator and `case_ne` to the `!==` operator. If the handles are not\nidentical, or both null, the two operands are considered not equal (`eq`\nreturns 0, `ne` returns 1).\n\nSee IEEE 1800-2023 \u00a7 8.4 \u201cObjects (class instances)\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-62)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | Nullable handle type |\n| `rhs` | Nullable handle type |\n\n#### Results:\u00a0[\u00b6](#results-60)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.handle_eq` (::circt::moore::HandleEqOp)\u00a0[\u00b6](#moorehandle_eq-circtmoorehandleeqop)\n\n*Handle equality*\n\nSyntax:\n\n```\noperation ::= `moore.handle_eq` $lhs `,` $rhs attr-dict `:` type($lhs) `:` type($rhs) `->` type($result)\n```\n\nCompares two handle-typed (ChandleType, ClassHandleType) operands and\nreturns a single bit 0 or 1 result. If both operands correspond to the same\nmemory address, the two operands are considered equal (`eq` returns 1, `ne`\nreturns 0). If the handles are not identical, or both null, the two operands\nare considered not equal (`eq` returns 0, `ne` returns 1).\n\nSee IEEE 1800-2023 \u00a7 8.4 \u201cObjects (class instances)\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-63)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | Nullable handle type |\n| `rhs` | Nullable handle type |\n\n#### Results:\u00a0[\u00b6](#results-61)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.handle_ne` (::circt::moore::HandleNeOp)\u00a0[\u00b6](#moorehandle_ne-circtmoorehandleneop)\n\n*Handle inequality*\n\nSyntax:\n\n```\noperation ::= `moore.handle_ne` $lhs `,` $rhs attr-dict `:` type($lhs) `:` type($rhs) `->` type($result)\n```\n\nCompares two handle-typed (ChandleType, ClassHandleType) operands and\nreturns a single bit 0 or 1 result. If both operands correspond to the same\nmemory address, the two operands are considered equal (`eq` returns 1, `ne`\nreturns 0). If the handles are not identical, or both null, the two operands\nare considered not equal (`eq` returns 0, `ne` returns 1).\n\nSee IEEE 1800-2023 \u00a7 8.4 \u201cObjects (class instances)\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-64)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | Nullable handle type |\n| `rhs` | Nullable handle type |\n\n#### Results:\u00a0[\u00b6](#results-62)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.instance` (::circt::moore::InstanceOp)\u00a0[\u00b6](#mooreinstance-circtmooreinstanceop)\n\n*Create an instance of a module*\n\nThe `moore.instance` operation instantiates a `moore.module` operation.\n\nSee IEEE 1800-2017 \u00a7 23.3 \u201cModule instances\u201d.\n\nInterfaces: `OpAsmOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-23)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `instanceName` | ::mlir::StringAttr | string attribute |\n| `moduleName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n| `inputNames` | ::mlir::ArrayAttr | string array attribute |\n| `outputNames` | ::mlir::ArrayAttr | string array attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-65)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-63)\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `moore.int_to_logic` (::circt::moore::IntToLogicOp)\u00a0[\u00b6](#mooreint_to_logic-circtmooreinttologicop)\n\n*Convert a two-valued to a four-valued integer*\n\nSyntax:\n\n```\noperation ::= `moore.int_to_logic` $input attr-dict `:` type($input)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-66)\n\n| Operand | Description |\n| --- | --- |\n| `input` | two-valued integer type |\n\n#### Results:\u00a0[\u00b6](#results-64)\n\n| Result | Description |\n| --- | --- |\n| `result` | four-valued integer type |\n\n### `moore.int_to_string` (::circt::moore::IntToStringOp)\u00a0[\u00b6](#mooreint_to_string-circtmooreinttostringop)\n\n*Convert an integer to a string*\n\nSyntax:\n\n```\noperation ::= `moore.int_to_string` $input attr-dict `:` type($input)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-67)\n\n| Operand | Description |\n| --- | --- |\n| `input` | two-valued integer type |\n\n#### Results:\u00a0[\u00b6](#results-65)\n\n| Result | Description |\n| --- | --- |\n| `result` | the SystemVerilog `string` type |\n\n### `moore.builtin.ln` (::circt::moore::LnBIOp)\u00a0[\u00b6](#moorebuiltinln-circtmoorelnbiop)\n\n*Natural logarithm*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.ln` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-68)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-66)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.builtin.log10` (::circt::moore::Log10BIOp)\u00a0[\u00b6](#moorebuiltinlog10-circtmoorelog10biop)\n\n*Decimal logarithm*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.log10` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-69)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-67)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.logic_to_int` (::circt::moore::LogicToIntOp)\u00a0[\u00b6](#moorelogic_to_int-circtmoorelogictointop)\n\n*Convert a four-valued to a two-valued integer*\n\nSyntax:\n\n```\noperation ::= `moore.logic_to_int` $input attr-dict `:` type($input)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-70)\n\n| Operand | Description |\n| --- | --- |\n| `input` | four-valued integer type |\n\n#### Results:\u00a0[\u00b6](#results-68)\n\n| Result | Description |\n| --- | --- |\n| `result` | two-valued integer type |\n\n### `moore.logic_to_time` (::circt::moore::LogicToTimeOp)\u00a0[\u00b6](#moorelogic_to_time-circtmoorelogictotimeop)\n\n*Convert an integer number of femtoseconds to a time type*\n\nSyntax:\n\n```\noperation ::= `moore.logic_to_time` $input attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-71)\n\n| Operand | Description |\n| --- | --- |\n| `input` | 64-bit four-valued integer type |\n\n#### Results:\u00a0[\u00b6](#results-69)\n\n| Result | Description |\n| --- | --- |\n| `result` | the SystemVerilog `time` and `realtime` type |\n\n### `moore.mods` (::circt::moore::ModSOp)\u00a0[\u00b6](#mooremods-circtmooremodsop)\n\n*Remainder*\n\nSyntax:\n\n```\noperation ::= `moore.mods` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nCompute the remainder of the left-hand side divided by the right-hand side\noperand. If the right-hand side is zero, all bits of the result are X. The\nsign of the result is the sign of the left-hand side. If any bit in the two\noperands is Z or X, all bits in the result are X.\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d.\n\nConsider the following examples:\n\n| LHS | RHS | Result |\n| --- | --- | --- |\n| 11 | 3 | 2 |\n| -11 | 3 | -2 |\n| 11 | -3 | 2 |\n| -11 | -3 | -2 |\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-72)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-70)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.modu` (::circt::moore::ModUOp)\u00a0[\u00b6](#mooremodu-circtmooremoduop)\n\n*Remainder*\n\nSyntax:\n\n```\noperation ::= `moore.modu` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nCompute the remainder of the left-hand side divided by the right-hand side\noperand. If the right-hand side is zero, all bits of the result are X. The\nsign of the result is the sign of the left-hand side. If any bit in the two\noperands is Z or X, all bits in the result are X.\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d.\n\nConsider the following examples:\n\n| LHS | RHS | Result |\n| --- | --- | --- |\n| 11 | 3 | 2 |\n| -11 | 3 | -2 |\n| 11 | -3 | 2 |\n| -11 | -3 | -2 |\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-73)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-71)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.mul` (::circt::moore::MulOp)\u00a0[\u00b6](#mooremul-circtmooremulop)\n\n*Multiplication*\n\nSyntax:\n\n```\noperation ::= `moore.mul` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nMultiply the operands. If any bit in the two operands is Z or X, all bits in\nthe result are X.\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-74)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-72)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.fmul` (::circt::moore::MulRealOp)\u00a0[\u00b6](#moorefmul-circtmooremulrealop)\n\n*Multiplication; Multiply the RHS real operand with the LHS\nreal operand.*\n\nSyntax:\n\n```\noperation ::= `moore.fmul` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d and \u00a7 11.3.1 \u201cOperators\nwith real operands\u201d\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-75)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a SystemVerilog real type |\n| `rhs` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-73)\n\n| Result | Description |\n| --- | --- |\n| `result` | a SystemVerilog real type |\n\n### `moore.ne` (::circt::moore::NeOp)\u00a0[\u00b6](#moorene-circtmooreneop)\n\n*Logical inequality*\n\nSyntax:\n\n```\noperation ::= `moore.ne` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the bits in the left- and right-hand side operand and returns a\nsingle bit 0, 1, or X result. If all corresponding bits in the left- and\nright-hand side are equal, and all are 0 or 1 (not X or Z), the two operands\nare considered equal (`eq` returns 1, `ne` returns 0). If any bits are not\nequal, but all are 0 or 1, the two operands are considered not equal (`eq`\nreturns 0, `ne` returns 1). If any bit in the two operands is Z or X,\nreturns X. `eq` corresponds to the `==` operator and `ne` to the `!=`\noperator.\n\nSee IEEE 1800-2017 \u00a7 11.4.5 \u201cEquality operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-76)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-74)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.fne` (::circt::moore::NeRealOp)\u00a0[\u00b6](#moorefne-circtmoorenerealop)\n\n*Logical inequality*\n\nSyntax:\n\n```\noperation ::= `moore.fne` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the bits in the left- and right-hand side operand and returns a\nsingle bit 0 or 1. If all corresponding bits in the left- and\nright-hand side are equal, and all are 0 or 1, the two operands\nare considered equal (`eq` returns 1, `ne` returns 0). If any bits are not\nequal, but all are 0 or 1, the two operands are considered not equal (`eq`\nreturns 0, `ne` returns 1). `eq` corresponds to the `==` operator and `ne`\nto the `!=` operator.\n\nSee IEEE 1800-2017 \u00a7 11.4.5 \u201cEquality operators\u201d and \u00a7 11.3.1 \u201cOperators\nwith real operands\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-77)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a SystemVerilog real type |\n| `rhs` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-75)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.neg` (::circt::moore::NegOp)\u00a0[\u00b6](#mooreneg-circtmoorenegop)\n\n*Arithmetic negation*\n\nSyntax:\n\n```\noperation ::= `moore.neg` $input attr-dict `:` type($input)\n```\n\nNegate a value to its two\u2019s complement form. If any bit in the input is Z or\nX, all bits in the result are X.\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-78)\n\n| Operand | Description |\n| --- | --- |\n| `input` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-76)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.fneg` (::circt::moore::NegRealOp)\u00a0[\u00b6](#moorefneg-circtmoorenegrealop)\n\n*Arithmetic negation*\n\nSyntax:\n\n```\noperation ::= `moore.fneg` $input attr-dict `:` type($input)\n```\n\nNegate a real value.\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d and \u00a7 11.3.1 \u201cOperators\nwith real operands\u201d\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-79)\n\n| Operand | Description |\n| --- | --- |\n| `input` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-77)\n\n| Result | Description |\n| --- | --- |\n| `result` | a SystemVerilog real type |\n\n### `moore.net` (::circt::moore::NetOp)\u00a0[\u00b6](#moorenet-circtmoorenetop)\n\n*A net declaration*\n\nSyntax:\n\n```\noperation ::= `moore.net` `` custom<ImplicitSSAName>($name) $kind ($assignment^)? attr-dict\n              `:` type($result)\n```\n\nThe `moore.net` operation is a net declaration. Net types defines different\ntypes of net connection in SV. There are twelve built-in net types defined\nin the official standard construct of the operation:\n`supply0`, `supply1`, `tri`, `triand`, `trior`, `trireg`, `tri0`, `tri1`,\n`uwire`, `wire`, `wand`, `wor`.\nOptional assignment argument allows net operation to be initialized with\nspecific values as soon as it is created. Only one net declaration\nassignment can be made for a particular net. See IEEE 1800-2017 \u00a7 10.3.1\n\u201cThe net declaration assignment\u201d for the differences between net declaration\nassignments and continuous assign statements. It has some features that are\nnot supported: declaring an interconnect net and using user-defined types in\nthe net operation.\n\nSee IEEE 1800-2017 \u00a7 6.7 \u201cNet declarations\u201d.\n\nInterfaces: `OpAsmOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-24)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `kind` | ::circt::moore::NetKindAttr | Net type kind |\n\n#### Operands:\u00a0[\u00b6](#operands-80)\n\n| Operand | Description |\n| --- | --- |\n| `assignment` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-78)\n\n| Result | Description |\n| --- | --- |\n| `result` |  |\n\n### `moore.nonblocking_assign` (::circt::moore::NonBlockingAssignOp)\u00a0[\u00b6](#moorenonblocking_assign-circtmoorenonblockingassignop)\n\n*Nonblocking procedural assignment*\n\nSyntax:\n\n```\noperation ::= `moore.nonblocking_assign` $dst `,` $src attr-dict `:` type($src)\n```\n\nA nonblocking procedural assignment in a sequential block, such as `x <= y;`\nor `x <= @(posedge y) z` or `x <= #1ns y`. The assignment does not take\neffect immediately. Subsequent operations in the block do not see the\neffects of this assignment. Instead, the assignment is scheduled to happen\nin a subsequent time step as dictated by the delay or event control.\n\nSee IEEE 1800-2017 \u00a7 10.4.2 \u201cNonblocking procedural assignments\u201d.\n\n#### Operands:\u00a0[\u00b6](#operands-81)\n\n| Operand | Description |\n| --- | --- |\n| `dst` |  |\n| `src` | unpacked type |\n\n### `moore.not` (::circt::moore::NotOp)\u00a0[\u00b6](#moorenot-circtmoorenotop)\n\n*Bitwise unary negation*\n\nSyntax:\n\n```\noperation ::= `moore.not` $input attr-dict `:` type($input)\n```\n\nApplies the boolean NOT operation to each bit in the input. Corresponds to\nthe `~` operator, as well as the negation in the `~&`, `~|`, `^~`, and `~^`\nreduction operators.\n\nSee IEEE 1800-2017 \u00a7 11.4.8 \u201cBitwise operators\u201d.\n\n| Input | Result |\n| --- | --- |\n| 0 | 1 |\n| 1 | 0 |\n| X | X |\n| Z | X |\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-82)\n\n| Operand | Description |\n| --- | --- |\n| `input` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-79)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.null` (::circt::moore::NullOp)\u00a0[\u00b6](#moorenull-circtmoorenullop)\n\n*SystemVerilog literal constant `null`*\n\nSyntax:\n\n```\noperation ::= `moore.null` attr-dict\n```\n\nRepresents the SystemVerilog literal constant `null`, which is a valid\nprimary and constant\\_primary in IEEE 1800-2023.\n\nThe result type must be a null-able handle-like type (e.g., a class handle,\nvirtual interface, event, chandle). Verification enforces this to prevent\nmis-modeling `null` as a numeric constant.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Results:\u00a0[\u00b6](#results-80)\n\n| Result | Description |\n| --- | --- |\n| `result` | A type that represents null literals for chandles, classhandles, |\n| and virtual interfaces |  |\n\n### `moore.or` (::circt::moore::OrOp)\u00a0[\u00b6](#mooreor-circtmooreorop)\n\n*Bitwise OR operation*\n\nSyntax:\n\n```\noperation ::= `moore.or` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nApplies the boolean OR operation to each pair of corresponding bits in the\nleft- and right-hand side operand. Corresponds to the `|` operator.\n\nSee IEEE 1800-2017 \u00a7 11.4.8 \u201cBitwise operators\u201d.\n\n|  | 0 | 1 | X | Z |\n| --- | --- | --- | --- | --- |\n| 0 | 0 | 1 | X | X |\n| 1 | 1 | 1 | 1 | 1 |\n| X | X | 1 | X | X |\n| Z | X | 1 | X | X |\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-83)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-81)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.output` (::circt::moore::OutputOp)\u00a0[\u00b6](#mooreoutput-circtmooreoutputop)\n\n*Assign module outputs*\n\nSyntax:\n\n```\noperation ::= `moore.output` attr-dict ($outputs^ `:` type($outputs))?\n```\n\nThe `moore.output` operation marks the end of a `moore.module` body region\nand specifies the values to present for the module\u2019s output ports.\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<SVModuleOp>`, `ReturnLike`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-84)\n\n| Operand | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `moore.packed_to_sbv` (::circt::moore::PackedToSBVOp)\u00a0[\u00b6](#moorepacked_to_sbv-circtmoorepackedtosbvop)\n\n*Convert a packed type to its simple bit vector equivalent*\n\nSyntax:\n\n```\noperation ::= `moore.packed_to_sbv` $input attr-dict `:` type($input)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-85)\n\n| Operand | Description |\n| --- | --- |\n| `input` | packed type with known size |\n\n#### Results:\u00a0[\u00b6](#results-82)\n\n| Result | Description |\n| --- | --- |\n| `result` | a simple bit vector type |\n\n### `moore.fpow` (::circt::moore::PowRealOp)\u00a0[\u00b6](#moorefpow-circtmoorepowrealop)\n\n*Power; Exponentiate the LHS real base with the RHS real\nexponent.*\n\nSyntax:\n\n```\noperation ::= `moore.fpow` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d and \u00a7 11.3.1 \u201cOperators\nwith real operands\u201d\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-86)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a SystemVerilog real type |\n| `rhs` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-83)\n\n| Result | Description |\n| --- | --- |\n| `result` | a SystemVerilog real type |\n\n### `moore.pows` (::circt::moore::PowSOp)\u00a0[\u00b6](#moorepows-circtmoorepowsop)\n\n*Power*\n\nSyntax:\n\n```\noperation ::= `moore.pows` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nRaise the left-hand side to the power of the right-hand side. `powu` treats\nits operands as unsigned numbers, while `pows` treats them as signed\nnumbers.\n\nEvaluation rules for `a ** b`:\n\n|  | a < -1 | a = -1 | a = 0 | a = 1 | a > 1 |\n| --- | --- | --- | --- | --- | --- |\n| b > 0 | a \\*\\* b | b odd ? -1 : 1 | 0 | 1 | a \\*\\* b |\n| b = 0 | 1 | 1 | 1 | 1 | 1 |\n| b < 0 | 0 | b odd ? -1 : 1 | X | 1 | 0 |\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-87)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-84)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.powu` (::circt::moore::PowUOp)\u00a0[\u00b6](#moorepowu-circtmoorepowuop)\n\n*Power*\n\nSyntax:\n\n```\noperation ::= `moore.powu` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nRaise the left-hand side to the power of the right-hand side. `powu` treats\nits operands as unsigned numbers, while `pows` treats them as signed\nnumbers.\n\nEvaluation rules for `a ** b`:\n\n|  | a < -1 | a = -1 | a = 0 | a = 1 | a > 1 |\n| --- | --- | --- | --- | --- | --- |\n| b > 0 | a \\*\\* b | b odd ? -1 : 1 | 0 | 1 | a \\*\\* b |\n| b = 0 | 1 | 1 | 1 | 1 | 1 |\n| b < 0 | 0 | b odd ? -1 : 1 | X | 1 | 0 |\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-88)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-85)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.procedure` (::circt::moore::ProcedureOp)\u00a0[\u00b6](#mooreprocedure-circtmooreprocedureop)\n\n*A procedure executed at different points in time*\n\nSyntax:\n\n```\noperation ::= `moore.procedure` $kind attr-dict-with-keyword $body\n```\n\nThe `moore.procedure` operation represents the SystemVerilog `initial`,\n`final`, `always`, `always_comb`, `always_latch`, and `always_ff`\nprocedures.\n\nExecution times of the various procedures:\n\n* An `initial` procedure is executed once at the start of a design\u2019s\n  lifetime, before any other procedures are executed.\n* A `final` procedure is executed once at the end of a design\u2019s lifetime,\n  after all other procedures have stopped execution.\n* An `always` or `always_ff` procedure is repeatedly executed during a\n  design\u2019s lifetime. Timing and event control inside the procedure can\n  suspend its execution, for example to wait for a signal to change. If no\n  such timing or event control is present, the procedure repeats infinitely\n  at the current timestep, effectively deadlocking the design.\n* An `always_comb` or `always_latch` procedure is executed once at the start\n  of a design\u2019s lifetime, after any `initial` procedures, and throughout the\n  lifetime of the design whenever any of the variables read by the body of\n  the procedure changes. Since the procedure is only executed when its\n  change, and not repeatedly, the body generally does not contain any timing\n  or event control. This behavior mitigates a shortcoming of `always`\n  procedures, which commonly have an event control like `@*` that blocks\n  and waits for a change of any input signals. This prevents the body from\n  executing when the design is initialized and properly reacting to the\n  initial values of signals. In contrast, `always_comb` and `always_latch`\n  procedures have an implicit unconditional execution at design start-up.\n\nSee IEEE 1800-2017 \u00a7 9.2 \u201cStructured procedures\u201d.\n\nTraits: `NoRegionArguments`, `RecursiveMemoryEffects`, `RecursivelySpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`\n\n#### Attributes:\u00a0[\u00b6](#attributes-25)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `kind` | circt::moore::ProcedureKindAttr | Procedure kind |\n\n### `moore.pop_back` (::circt::moore::QueuePopBackOp)\u00a0[\u00b6](#moorepop_back-circtmoorequeuepopbackop)\n\n*Return and remove an element from the back of a queue*\n\nSyntax:\n\n```\noperation ::= `moore.pop_back` `from` $queue attr-dict `:` type($queue)\n```\n\nSee IEEE 1800-2023 \u00a7 7.10.2.4 \u201cPop\\_back()\u201d\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-89)\n\n| Operand | Description |\n| --- | --- |\n| `queue` | a queue type |\n\n#### Results:\u00a0[\u00b6](#results-86)\n\n| Result | Description |\n| --- | --- |\n| `result` | unpacked type |\n\n### `moore.pop_front` (::circt::moore::QueuePopFrontOp)\u00a0[\u00b6](#moorepop_front-circtmoorequeuepopfrontop)\n\n*Return and remove an element from the front of a queue*\n\nSyntax:\n\n```\noperation ::= `moore.pop_front` `from` $queue attr-dict `:` type($queue)\n```\n\nSee IEEE 1800-2023 \u00a7 7.10.2.5 \u201cPop\\_front()\u201d\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-90)\n\n| Operand | Description |\n| --- | --- |\n| `queue` | a queue type |\n\n#### Results:\u00a0[\u00b6](#results-87)\n\n| Result | Description |\n| --- | --- |\n| `result` | unpacked type |\n\n### `moore.push_back` (::circt::moore::QueuePushBackOp)\u00a0[\u00b6](#moorepush_back-circtmoorequeuepushbackop)\n\n*Push an element to the back of a queue*\n\nSyntax:\n\n```\noperation ::= `moore.push_back` $element `into` $queue attr-dict `:` type($queue)\n```\n\nSee IEEE 1800-2023 \u00a7 7.10.2.7 \u201cPush\\_back()\u201d\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-91)\n\n| Operand | Description |\n| --- | --- |\n| `queue` | a queue type |\n| `element` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-88)\n\n| Result | Description |\n| --- | --- |\n| `out` | the SystemVerilog `void` type |\n\n### `moore.push_front` (::circt::moore::QueuePushFrontOp)\u00a0[\u00b6](#moorepush_front-circtmoorequeuepushfrontop)\n\n*Push an element to the front of a queue*\n\nSyntax:\n\n```\noperation ::= `moore.push_front` $element `into` $queue attr-dict `:` type($queue)\n```\n\nSee IEEE 1800-2023 \u00a7 7.10.2.6 \u201cPush\\_front()\u201d\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-92)\n\n| Operand | Description |\n| --- | --- |\n| `queue` | a queue type |\n| `element` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-89)\n\n| Result | Description |\n| --- | --- |\n| `out` | the SystemVerilog `void` type |\n\n### `moore.builtin.size` (::circt::moore::QueueSizeBIOp)\u00a0[\u00b6](#moorebuiltinsize-circtmoorequeuesizebiop)\n\n*Return the number of elements in a queue*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.size` $queue `:` type($queue) attr-dict\n```\n\nCorresponds to the `size` system function. Returns the number of items in a queue.\nAccording to spec the returned size fits an `int`.\n\nSee IEEE 1800-2023 \u00a7 7.10.2.1 \u201cSize()\u201d.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-93)\n\n| Operand | Description |\n| --- | --- |\n| `queue` | a queue type |\n\n#### Results:\u00a0[\u00b6](#results-90)\n\n| Result | Description |\n| --- | --- |\n| `result` | 32-bit two-valued integer type |\n\n### `moore.builtin.random` (::circt::moore::RandomBIOp)\u00a0[\u00b6](#moorebuiltinrandom-circtmoorerandombiop)\n\n*Generate a true random signed integer (optionally seeded)*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.random` ($seed^)? attr-dict\n```\n\nCorresponds to the `$random` system function. Returns a 32-bit\ntrue random integer. The seed is optional; when provided, it initializes\nthe generator. If not provided, treat it as 0 in semantics/lowering.\n\n`$random` is largely considered to be deprecated since it leads to\nnon-reproducible simulation results. Consider using `$urandom` instead.\n\nSee IEEE 1800-2023 \u00a7 20.14 \u201cProbablistic distribution functions\u201d.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-94)\n\n| Operand | Description |\n| --- | --- |\n| `seed` | 32-bit two-valued integer type |\n\n#### Results:\u00a0[\u00b6](#results-91)\n\n| Result | Description |\n| --- | --- |\n| `result` | 32-bit two-valued integer type |\n\n### `moore.read` (::circt::moore::ReadOp)\u00a0[\u00b6](#mooreread-circtmoorereadop)\n\n*Read the current value of a declaration*\n\nSyntax:\n\n```\noperation ::= `moore.read` $input attr-dict `:` type($input)\n```\n\nSamples the current value of a declaration. This is a helper to capture the\nexact point at which declarations that can be targeted by all possible\nexpressions are read. It\u2019s similar to llvm.load.\n\nInterfaces: `InferTypeOpInterface`, `PromotableMemOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-95)\n\n| Operand | Description |\n| --- | --- |\n| `input` |  |\n\n#### Results:\u00a0[\u00b6](#results-92)\n\n| Result | Description |\n| --- | --- |\n| `result` | unpacked type |\n\n### `moore.real_to_int` (::circt::moore::RealToIntOp)\u00a0[\u00b6](#moorereal_to_int-circtmoorerealtointop)\n\n*Convert a real value to a two-valued integer*\n\nSyntax:\n\n```\noperation ::= `moore.real_to_int` $input attr-dict `:` type($input) `->` type($result)\n```\n\nSee IEEE 1800-2023 Section 6.24.1: \u201cCast operator\u201d and 6.12:\n\u201cReal, shortreal and realtime data types\u201d. Accordingly,\noutput values are rounded.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-96)\n\n| Operand | Description |\n| --- | --- |\n| `input` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-93)\n\n| Result | Description |\n| --- | --- |\n| `result` | two-valued integer type |\n\n### `moore.builtin.realtobits` (::circt::moore::RealtobitsBIOp)\u00a0[\u00b6](#moorebuiltinrealtobits-circtmoorerealtobitsbiop)\n\n*Convert a real-valued number to its logic vector representation*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.realtobits` $value attr-dict\n```\n\nCorresponds to the `$realtobits` system function. Returns a 64-bit\nlogic vector corresponding to the bit representation of the real number.\nNote that this does not correspond to a cast to another type, but rather a no-op.\n\nSee IEEE 1800-2023 \u00a7 20.5 \u201cConversion functions\u201d.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-97)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-94)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit two-valued integer type |\n\n### `moore.reduce_and` (::circt::moore::ReduceAndOp)\u00a0[\u00b6](#moorereduce_and-circtmoorereduceandop)\n\n*Reduction AND operator*\n\nSyntax:\n\n```\noperation ::= `moore.reduce_and` $input attr-dict `:` type($input) `->` type($result)\n```\n\nReduces all bits in the input to a single result bit by iteratively applying\nthe boolean AND operator. If the input has only a single bit, that bit is\nreturned.\n\nSee IEEE 1800-2017 \u00a7 11.4.9 \u201cReduction operators\u201d. See the corresponding\n`and`, `or`, and `xor` operations for the truth table.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-98)\n\n| Operand | Description |\n| --- | --- |\n| `input` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-95)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.reduce_or` (::circt::moore::ReduceOrOp)\u00a0[\u00b6](#moorereduce_or-circtmoorereduceorop)\n\n*Reduction OR operator*\n\nSyntax:\n\n```\noperation ::= `moore.reduce_or` $input attr-dict `:` type($input) `->` type($result)\n```\n\nReduces all bits in the input to a single result bit by iteratively applying\nthe boolean OR operator. If the input has only a single bit, that bit is\nreturned.\n\nSee IEEE 1800-2017 \u00a7 11.4.9 \u201cReduction operators\u201d. See the corresponding\n`and`, `or`, and `xor` operations for the truth table.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-99)\n\n| Operand | Description |\n| --- | --- |\n| `input` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-96)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.reduce_xor` (::circt::moore::ReduceXorOp)\u00a0[\u00b6](#moorereduce_xor-circtmoorereducexorop)\n\n*Reduction XOR operator*\n\nSyntax:\n\n```\noperation ::= `moore.reduce_xor` $input attr-dict `:` type($input) `->` type($result)\n```\n\nReduces all bits in the input to a single result bit by iteratively applying\nthe boolean XOR operator. If the input has only a single bit, that bit is\nreturned.\n\nSee IEEE 1800-2017 \u00a7 11.4.9 \u201cReduction operators\u201d. See the corresponding\n`and`, `or`, and `xor` operations for the truth table.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-100)\n\n| Operand | Description |\n| --- | --- |\n| `input` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-97)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.replicate` (::circt::moore::ReplicateOp)\u00a0[\u00b6](#moorereplicate-circtmoorereplicateop)\n\n*Multiple concatenation of expressions*\n\nSyntax:\n\n```\noperation ::= `moore.replicate` $value attr-dict `:` type($value) `->` type($result)\n```\n\nThis operation indicates a joining together of that many copies of the\nconcatenation `{constant{w}}`. Which enclosed together within brace.\nThe \u2018constant\u2019 must a non-negative, non-x, and non-z constant expression.\nThe \u2018constant\u2019 may be a value of zero, but it only exists in parameterized\ncode, and it will be ignored(type is changed to the void).\n\nExample:\n\n```\n  {0{w}}   // empty! ignore it.\n  {4{w}}   // the same as {w, w, w, w}\n```\n\nSee IEEE 1800-2017 \u00a711.4.12 \u201cConcatenation operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-101)\n\n| Operand | Description |\n| --- | --- |\n| `value` | a simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-98)\n\n| Result | Description |\n| --- | --- |\n| `result` | a simple bit vector type |\n\n### `moore.return` (::circt::moore::ReturnOp)\u00a0[\u00b6](#moorereturn-circtmoorereturnop)\n\n*Return from a procedure*\n\nSyntax:\n\n```\noperation ::= `moore.return` attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<ProcedureOp>`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n### `moore.sbv_to_packed` (::circt::moore::SBVToPackedOp)\u00a0[\u00b6](#mooresbv_to_packed-circtmooresbvtopackedop)\n\n*Convert a simple bit vector to an equivalent packed type*\n\nSyntax:\n\n```\noperation ::= `moore.sbv_to_packed` $input attr-dict `:` type($result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-102)\n\n| Operand | Description |\n| --- | --- |\n| `input` | a simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-99)\n\n| Result | Description |\n| --- | --- |\n| `result` | packed type with known size |\n\n### `moore.sext` (::circt::moore::SExtOp)\u00a0[\u00b6](#mooresext-circtmooresextop)\n\n*Sign-extend a value*\n\nSyntax:\n\n```\noperation ::= `moore.sext` $input attr-dict `:` type($input) `->` type($result)\n```\n\nIncrease the bit width of a value by replicating its most significant bit.\nThis keeps the signed value constant.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-103)\n\n| Operand | Description |\n| --- | --- |\n| `input` | a simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-100)\n\n| Result | Description |\n| --- | --- |\n| `result` | a simple bit vector type |\n\n### `moore.sint_to_real` (::circt::moore::SIntToRealOp)\u00a0[\u00b6](#mooresint_to_real-circtmooresinttorealop)\n\n*Convert an integer value to a real*\n\nSyntax:\n\n```\noperation ::= `moore.sint_to_real` $input attr-dict `:` type($input) `->` type($result)\n```\n\nSee IEEE 1800-2023 Section 6.24.1: \u201cCast operator\u201d and 6.12:\n\u201cReal, shortreal and realtime data types\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-104)\n\n| Operand | Description |\n| --- | --- |\n| `input` | two-valued integer type |\n\n#### Results:\u00a0[\u00b6](#results-101)\n\n| Result | Description |\n| --- | --- |\n| `result` | a SystemVerilog real type |\n\n### `moore.module` (::circt::moore::SVModuleOp)\u00a0[\u00b6](#mooremodule-circtmooresvmoduleop)\n\n*A module definition*\n\nThe `moore.module` operation represents a SystemVerilog module, including\nits name, port list, and the constituent parts that make up its body. The\nmodule\u2019s body is a graph region.\n\nSee IEEE 1800-2017 \u00a7 3.3 \u201cModules\u201d and \u00a7 23.2 \u201cModule definitions\u201d.\n\nTraits: `IsolatedFromAbove`, `SingleBlockImplicitTerminator<OutputOp>`, `SingleBlock`\n\nInterfaces: `OpAsmOpInterface`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-26)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `module_type` | ::mlir::TypeAttr | type attribute of module type |\n| `sym_visibility` | ::mlir::StringAttr | string attribute |\n\n### `moore.builtin.severity` (::circt::moore::SeverityBIOp)\u00a0[\u00b6](#moorebuiltinseverity-circtmooreseveritybiop)\n\n*Print a diagnostic message*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.severity` $severity $message attr-dict\n```\n\nPrints the given format string to the standard diagnostic output of the\nsimulator. In most cases this should be stderr. This corresponds to the\n`$info`, `$warning`, `$error`, and `$fatal` system tasks. Message formatting\nis handled by `moore.fmt.*` ops. This only handles the message printing of\n`$fatal`; printing of the additional statistics and the call to `$finish`\nmust be done through the `finish_message` and `finish` ops.\n\nSee IEEE 1800-2017 \u00a7 20.10 \u201cSeverity tasks\u201d.\n\n#### Attributes:\u00a0[\u00b6](#attributes-27)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `severity` | circt::moore::SeverityAttr | Diagnostic severity |\n\n#### Operands:\u00a0[\u00b6](#operands-105)\n\n| Operand | Description |\n| --- | --- |\n| `message` | a format string type |\n\n### `moore.sge` (::circt::moore::SgeOp)\u00a0[\u00b6](#mooresge-circtmooresgeop)\n\n*Signed greater than or equal comparison*\n\nSyntax:\n\n```\noperation ::= `moore.sge` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the left- and right-hand side operand and returns a single bit 0,\n1, or X result. If any bit in the two operands is Z or X, returns X.\nOtherwise, if all bits are 0 or 1, `ult/slt`, `ule/sle`, `ugt/sgt`, and\n`uge/sge` return whether the left-hand side is less than, less than or equal\nto, greater than, or greater than or equal to the right-hand side,\nrespectively. `ult/slt` corresponds to the `<` operator, `ule/sle` to `<=`,\n`ugt/sgt` to `>`, and `uge/sge` to `>=`.\n\nSee IEEE 1800-2017 \u00a7 11.4.4 \u201cRelational operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-106)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-102)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.sgt` (::circt::moore::SgtOp)\u00a0[\u00b6](#mooresgt-circtmooresgtop)\n\n*Signed greater than comparison*\n\nSyntax:\n\n```\noperation ::= `moore.sgt` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the left- and right-hand side operand and returns a single bit 0,\n1, or X result. If any bit in the two operands is Z or X, returns X.\nOtherwise, if all bits are 0 or 1, `ult/slt`, `ule/sle`, `ugt/sgt`, and\n`uge/sge` return whether the left-hand side is less than, less than or equal\nto, greater than, or greater than or equal to the right-hand side,\nrespectively. `ult/slt` corresponds to the `<` operator, `ule/sle` to `<=`,\n`ugt/sgt` to `>`, and `uge/sge` to `>=`.\n\nSee IEEE 1800-2017 \u00a7 11.4.4 \u201cRelational operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-107)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-103)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.shl` (::circt::moore::ShlOp)\u00a0[\u00b6](#mooreshl-circtmooreshlop)\n\n*Logical left shift*\n\nSyntax:\n\n```\noperation ::= `moore.shl` $value `,` $amount attr-dict `:` type($value) `,` type($amount)\n```\n\nShifts the `value` to the left or right by `amount` number of bits. The\nresult has the same type as the input value. The amount is always treated as\nan unsigned number and has no effect on the signedness of the result. X or\nZ bits in the input value are simply shifted left or right the same way 0 or\n1 bits are. If the amount contains X or Z bits, all result bits are X.\n\n`shl` shifts bits to the left, filling in 0 for the vacated least\nsignificant bits. `shr` and `ashr` shift bits to the right; `shr` fills in\n0 for the vacated most significant bits, and `ashr` copies the input\u2019s sign\nbit into the vacated most significant bits. Note that in contrast to the SV\nspec, the `ashr` *always* fills in the sign bit regardless of the signedness\nof the input.\n\n`shl` corresponds to the `<<` and `<<<` operators. `shr` corresponds to the\n`>>` operator, and the `>>>` operator applied to an unsigned value. `ashr`\ncorresponds to the `>>>` operator applied to a signed value.\n\nSee IEEE 1800-2017 \u00a7 11.4.10 \u201cShift operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-108)\n\n| Operand | Description |\n| --- | --- |\n| `value` | simple bit vector type |\n| `amount` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-104)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.builtin.shortrealtobits` (::circt::moore::ShortrealtobitsBIOp)\u00a0[\u00b6](#moorebuiltinshortrealtobits-circtmooreshortrealtobitsbiop)\n\n*Convert a real-valued number to its logic vector representation*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.shortrealtobits` $value attr-dict\n```\n\nCorresponds to the `$shortrealtobits` system function. Returns a 64-bit\nlogic vector corresponding to the bit representation of the real number.\nNote that this does not correspond to a cast to another type, but rather a no-op.\n\nSee IEEE 1800-2023 \u00a7 20.5 \u201cConversion functions\u201d.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-109)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 32-bit real type, aka. shortreal |\n\n#### Results:\u00a0[\u00b6](#results-105)\n\n| Result | Description |\n| --- | --- |\n| `result` | 32-bit two-valued integer type |\n\n### `moore.shr` (::circt::moore::ShrOp)\u00a0[\u00b6](#mooreshr-circtmooreshrop)\n\n*Logical right shift*\n\nSyntax:\n\n```\noperation ::= `moore.shr` $value `,` $amount attr-dict `:` type($value) `,` type($amount)\n```\n\nShifts the `value` to the left or right by `amount` number of bits. The\nresult has the same type as the input value. The amount is always treated as\nan unsigned number and has no effect on the signedness of the result. X or\nZ bits in the input value are simply shifted left or right the same way 0 or\n1 bits are. If the amount contains X or Z bits, all result bits are X.\n\n`shl` shifts bits to the left, filling in 0 for the vacated least\nsignificant bits. `shr` and `ashr` shift bits to the right; `shr` fills in\n0 for the vacated most significant bits, and `ashr` copies the input\u2019s sign\nbit into the vacated most significant bits. Note that in contrast to the SV\nspec, the `ashr` *always* fills in the sign bit regardless of the signedness\nof the input.\n\n`shl` corresponds to the `<<` and `<<<` operators. `shr` corresponds to the\n`>>` operator, and the `>>>` operator applied to an unsigned value. `ashr`\ncorresponds to the `>>>` operator applied to a signed value.\n\nSee IEEE 1800-2017 \u00a7 11.4.10 \u201cShift operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-110)\n\n| Operand | Description |\n| --- | --- |\n| `value` | simple bit vector type |\n| `amount` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-106)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.builtin.sin` (::circt::moore::SinBIOp)\u00a0[\u00b6](#moorebuiltinsin-circtmooresinbiop)\n\n*Sine*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.sin` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-111)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-107)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.builtin.sinh` (::circt::moore::SinhBIOp)\u00a0[\u00b6](#moorebuiltinsinh-circtmooresinhbiop)\n\n*Hyperbolic sine*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.sinh` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-112)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-108)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.sle` (::circt::moore::SleOp)\u00a0[\u00b6](#mooresle-circtmooresleop)\n\n*Signed less than or equal comparison*\n\nSyntax:\n\n```\noperation ::= `moore.sle` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the left- and right-hand side operand and returns a single bit 0,\n1, or X result. If any bit in the two operands is Z or X, returns X.\nOtherwise, if all bits are 0 or 1, `ult/slt`, `ule/sle`, `ugt/sgt`, and\n`uge/sge` return whether the left-hand side is less than, less than or equal\nto, greater than, or greater than or equal to the right-hand side,\nrespectively. `ult/slt` corresponds to the `<` operator, `ule/sle` to `<=`,\n`ugt/sgt` to `>`, and `uge/sge` to `>=`.\n\nSee IEEE 1800-2017 \u00a7 11.4.4 \u201cRelational operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-113)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-109)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.slt` (::circt::moore::SltOp)\u00a0[\u00b6](#mooreslt-circtmooresltop)\n\n*Signed less than comparison*\n\nSyntax:\n\n```\noperation ::= `moore.slt` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the left- and right-hand side operand and returns a single bit 0,\n1, or X result. If any bit in the two operands is Z or X, returns X.\nOtherwise, if all bits are 0 or 1, `ult/slt`, `ule/sle`, `ugt/sgt`, and\n`uge/sge` return whether the left-hand side is less than, less than or equal\nto, greater than, or greater than or equal to the right-hand side,\nrespectively. `ult/slt` corresponds to the `<` operator, `ule/sle` to `<=`,\n`ugt/sgt` to `>`, and `uge/sge` to `>=`.\n\nSee IEEE 1800-2017 \u00a7 11.4.4 \u201cRelational operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-114)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-110)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.builtin.sqrt` (::circt::moore::SqrtBIOp)\u00a0[\u00b6](#moorebuiltinsqrt-circtmooresqrtbiop)\n\n*Square root*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.sqrt` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-115)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-111)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.builtin.stop` (::circt::moore::StopBIOp)\u00a0[\u00b6](#moorebuiltinstop-circtmoorestopbiop)\n\n*Suspend simulation*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.stop` attr-dict\n```\n\nCorresponds to the `$stop` system task. Causes the simulation to be\nsuspended but the simulator does not exit. Printing of the optional\ndiagnostic message is handled by the `finish_message` op.\n\nSee IEEE 1800-2017 \u00a7 20.2 \u201cSimulation control system tasks\u201d.\n\n### `moore.string_cmp` (::circt::moore::StringCmpOp)\u00a0[\u00b6](#moorestring_cmp-circtmoorestringcmpop)\n\nSyntax:\n\n```\noperation ::= `moore.string_cmp` $predicate $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares two string operands using the specified\npredicate and returns a single bit result. Supported predicates:\n\n* eq : equal\n* ne : not equal\n* lt : less than\n* le : less or equal\n* gt : greater than\n* ge : greater or equal\n\nThe equality operator yields 1 if its operands are equal and 0 otherwise.\nRelational operators compare two strings lexicographically,\nreturning 1 when the specified condition holds and 0 when it does not.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-28)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `predicate` | circt::moore::StringCmpPredicateAttr | allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5 |\n\n#### Operands:\u00a0[\u00b6](#operands-116)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | the SystemVerilog `string` type |\n| `rhs` | the SystemVerilog `string` type |\n\n#### Results:\u00a0[\u00b6](#results-112)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.string.concat` (::circt::moore::StringConcatOp)\u00a0[\u00b6](#moorestringconcat-circtmoorestringconcatop)\n\n*Concatenate strings*\n\nSyntax:\n\n```\noperation ::= `moore.string.concat` ` ` `(` $inputs `)` attr-dict\n```\n\nConcatenates an arbitrary number of strings into one larger string. The\nstrings are concatenated from left to right, with the first operand\nappearing at the left start of the result string, and the last operand\nappearing at the right end. Produces an empty string if no inputs are\nprovided.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-117)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of the SystemVerilog `string` type |\n\n#### Results:\u00a0[\u00b6](#results-113)\n\n| Result | Description |\n| --- | --- |\n| `result` | the SystemVerilog `string` type |\n\n### `moore.string.getc` (::circt::moore::StringGetCOp)\u00a0[\u00b6](#moorestringgetc-circtmoorestringgetcop)\n\n*Get a character from a string*\n\nSyntax:\n\n```\noperation ::= `moore.string.getc` $str `[` $index `]` attr-dict\n```\n\nReturns the character at the specified index in the given string.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-118)\n\n| Operand | Description |\n| --- | --- |\n| `str` | the SystemVerilog `string` type |\n| `index` | 32-bit two-valued integer type |\n\n#### Results:\u00a0[\u00b6](#results-114)\n\n| Result | Description |\n| --- | --- |\n| `result` | 8-bit two-valued integer type |\n\n### `moore.string.len` (::circt::moore::StringLenOp)\u00a0[\u00b6](#moorestringlen-circtmoorestringlenop)\n\n*Get the length of a string*\n\nSyntax:\n\n```\noperation ::= `moore.string.len` $str attr-dict\n```\n\nReturns the number of characters in the given string.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-119)\n\n| Operand | Description |\n| --- | --- |\n| `str` | the SystemVerilog `string` type |\n\n#### Results:\u00a0[\u00b6](#results-115)\n\n| Result | Description |\n| --- | --- |\n| `result` | 32-bit two-valued integer type |\n\n### `moore.string_to_int` (::circt::moore::StringToIntOp)\u00a0[\u00b6](#moorestring_to_int-circtmoorestringtointop)\n\n*Convert a string to an integer*\n\nSyntax:\n\n```\noperation ::= `moore.string_to_int` $input attr-dict `:` type($result)\n```\n\nIf the width of the result type is smaller than the input string, it is\ntruncated. If it is larger, it is appended with 0s.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-120)\n\n| Operand | Description |\n| --- | --- |\n| `input` | the SystemVerilog `string` type |\n\n#### Results:\u00a0[\u00b6](#results-116)\n\n| Result | Description |\n| --- | --- |\n| `result` | two-valued integer type |\n\n### `moore.string.tolower` (::circt::moore::StringToLowerOp)\u00a0[\u00b6](#moorestringtolower-circtmoorestringtolowerop)\n\n*Convert a string to lowercase*\n\nSyntax:\n\n```\noperation ::= `moore.string.tolower` $str attr-dict\n```\n\nConverts all characters in the given string to lowercase.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-121)\n\n| Operand | Description |\n| --- | --- |\n| `str` | the SystemVerilog `string` type |\n\n#### Results:\u00a0[\u00b6](#results-117)\n\n| Result | Description |\n| --- | --- |\n| `result` | the SystemVerilog `string` type |\n\n### `moore.string.toupper` (::circt::moore::StringToUpperOp)\u00a0[\u00b6](#moorestringtoupper-circtmoorestringtoupperop)\n\n*Convert a string to uppercase*\n\nSyntax:\n\n```\noperation ::= `moore.string.toupper` $str attr-dict\n```\n\nConverts all characters in the given string to uppercase.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-122)\n\n| Operand | Description |\n| --- | --- |\n| `str` | the SystemVerilog `string` type |\n\n#### Results:\u00a0[\u00b6](#results-118)\n\n| Result | Description |\n| --- | --- |\n| `result` | the SystemVerilog `string` type |\n\n### `moore.struct_create` (::circt::moore::StructCreateOp)\u00a0[\u00b6](#moorestruct_create-circtmoorestructcreateop)\n\n*Create a struct value from individual fields*\n\nSyntax:\n\n```\noperation ::= `moore.struct_create` $fields attr-dict `:` type($fields) `->` type($result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-123)\n\n| Operand | Description |\n| --- | --- |\n| `fields` | variadic of unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-119)\n\n| Result | Description |\n| --- | --- |\n| `result` | packed or unpacked struct type |\n\n### `moore.struct_extract` (::circt::moore::StructExtractOp)\u00a0[\u00b6](#moorestruct_extract-circtmoorestructextractop)\n\n*Obtain the value of a struct field*\n\nSyntax:\n\n```\noperation ::= `moore.struct_extract` $input `,` $fieldName attr-dict `:` type($input) `->` type($result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-29)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-124)\n\n| Operand | Description |\n| --- | --- |\n| `input` | packed or unpacked struct type |\n\n#### Results:\u00a0[\u00b6](#results-120)\n\n| Result | Description |\n| --- | --- |\n| `result` | unpacked type |\n\n### `moore.struct_extract_ref` (::circt::moore::StructExtractRefOp)\u00a0[\u00b6](#moorestruct_extract_ref-circtmoorestructextractrefop)\n\n*Create a reference to a struct field*\n\nSyntax:\n\n```\noperation ::= `moore.struct_extract_ref` $input `,` $fieldName attr-dict `:` type($input) `->` type($result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `DestructurableAccessorOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-30)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-125)\n\n| Operand | Description |\n| --- | --- |\n| `input` | ref of packed or unpacked struct type |\n\n#### Results:\u00a0[\u00b6](#results-121)\n\n| Result | Description |\n| --- | --- |\n| `result` |  |\n\n### `moore.struct_inject` (::circt::moore::StructInjectOp)\u00a0[\u00b6](#moorestruct_inject-circtmoorestructinjectop)\n\n*Update the value of a struct field*\n\nSyntax:\n\n```\noperation ::= `moore.struct_inject` $input `,` $fieldName `,` $newValue attr-dict\n              `:` type($input) `,` type($newValue)\n```\n\nTakes an existing struct value, sets one of its fields to a new value, and\nreturns the resulting struct value.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-31)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-126)\n\n| Operand | Description |\n| --- | --- |\n| `input` | packed or unpacked struct type |\n| `newValue` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-122)\n\n| Result | Description |\n| --- | --- |\n| `result` | packed or unpacked struct type |\n\n### `moore.sub` (::circt::moore::SubOp)\u00a0[\u00b6](#mooresub-circtmooresubop)\n\n*Subtraction*\n\nSyntax:\n\n```\noperation ::= `moore.sub` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nSubtract the right-hand side from the left-hand side operand. If any bit in\nthe two operands is Z or X, all bits in the result are X.\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-127)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-123)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.fsub` (::circt::moore::SubRealOp)\u00a0[\u00b6](#moorefsub-circtmooresubrealop)\n\n*Subtraction; subtract the RHS real operand from the LHS\nreal operand.*\n\nSyntax:\n\n```\noperation ::= `moore.fsub` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nSee IEEE 1800-2017 \u00a7 11.4.3 \u201cArithmetic operators\u201d and \u00a7 11.3.1 \u201cOperators\nwith real operands\u201d\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-128)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | a SystemVerilog real type |\n| `rhs` | a SystemVerilog real type |\n\n#### Results:\u00a0[\u00b6](#results-124)\n\n| Result | Description |\n| --- | --- |\n| `result` | a SystemVerilog real type |\n\n### `moore.builtin.tan` (::circt::moore::TanBIOp)\u00a0[\u00b6](#moorebuiltintan-circtmooretanbiop)\n\n*Tangent*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.tan` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-129)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-125)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.builtin.tanh` (::circt::moore::TanhBIOp)\u00a0[\u00b6](#moorebuiltintanh-circtmooretanhbiop)\n\n*Hyperbolic tangent*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.tanh` $value attr-dict `:` type($value)\n```\n\nThe system real math functions shall accept real value arguments and return\na real result type. Their behavior shall match the equivalent C language\nstandard math library function indicated.\n\nSee IEEE 1800-2017 \u00a7 20.8.2 \u201cReal math functions\u201d.\n\nTraits: `SameOperandsAndResultType`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-130)\n\n| Operand | Description |\n| --- | --- |\n| `value` | 64-bit real type, aka. real |\n\n#### Results:\u00a0[\u00b6](#results-126)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit real type, aka. real |\n\n### `moore.builtin.time` (::circt::moore::TimeBIOp)\u00a0[\u00b6](#moorebuiltintime-circtmooretimebiop)\n\n*Return the current simulation time*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.time` attr-dict\n```\n\nCorresponds to the `$time` system function. Returns a int-rounded 64-bit\ninteger corresponding to the elapsed simulation time scaled by the\nsimulation\u2019s timescale.\n\nSee IEEE 1800-2023 \u00a7 20.3 \u201cSimulation time system functions\u201d.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Results:\u00a0[\u00b6](#results-127)\n\n| Result | Description |\n| --- | --- |\n| `result` | the SystemVerilog `time` and `realtime` type |\n\n### `moore.time_to_logic` (::circt::moore::TimeToLogicOp)\u00a0[\u00b6](#mooretime_to_logic-circtmooretimetologicop)\n\n*Convert a time type to an integer number of femtoseconds*\n\nSyntax:\n\n```\noperation ::= `moore.time_to_logic` $input attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-131)\n\n| Operand | Description |\n| --- | --- |\n| `input` | the SystemVerilog `time` and `realtime` type |\n\n#### Results:\u00a0[\u00b6](#results-128)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit four-valued integer type |\n\n### `moore.to_builtin_bool` (::circt::moore::ToBuiltinBoolOp)\u00a0[\u00b6](#mooreto_builtin_bool-circtmooretobuiltinboolop)\n\n*Convert a `!moore.l1` or `!moore.i1` to a builtin `i1`*\n\nSyntax:\n\n```\noperation ::= `moore.to_builtin_bool` $input attr-dict `:` type($input)\n```\n\nMaps `X` and `Z` to 0, and passes through 1 and 0 unchanged.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-132)\n\n| Operand | Description |\n| --- | --- |\n| `input` | single bit type |\n\n#### Results:\u00a0[\u00b6](#results-129)\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit signless integer |\n\n### `moore.to_builtin_int` (::circt::moore::ToBuiltinIntOp)\u00a0[\u00b6](#mooreto_builtin_int-circtmooretobuiltinintop)\n\n*Convert a `!moore.i<n>` to a builtin `i<n>`*\n\nSyntax:\n\n```\noperation ::= `moore.to_builtin_int` $input attr-dict `:` type($input)\n```\n\nCasts from a two-valued Moore integer to a builtin integer.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-133)\n\n| Operand | Description |\n| --- | --- |\n| `input` | two-valued integer type |\n\n#### Results:\u00a0[\u00b6](#results-130)\n\n| Result | Description |\n| --- | --- |\n| `result` | integer |\n\n### `moore.trunc` (::circt::moore::TruncOp)\u00a0[\u00b6](#mooretrunc-circtmooretruncop)\n\n*Truncate a value*\n\nSyntax:\n\n```\noperation ::= `moore.trunc` $input attr-dict `:` type($input) `->` type($result)\n```\n\nReduce the bit width of a value by removing some of its most significant\nbits. This can only change the bit width of an integer type.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-134)\n\n| Operand | Description |\n| --- | --- |\n| `input` | a simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-131)\n\n| Result | Description |\n| --- | --- |\n| `result` | a simple bit vector type |\n\n### `moore.uarray_cmp` (::circt::moore::UArrayCmpOp)\u00a0[\u00b6](#mooreuarray_cmp-circtmooreuarraycmpop)\n\nSyntax:\n\n```\noperation ::= `moore.uarray_cmp` $predicate $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nPerforms an elementwise comparison of two unpacked arrays\nusing the specified predicate (for example, \u201ceq\u201d for equality or \u201cne\u201d for inequality)\nand returns a single bit result.\nIts first argument is an attribute that defines which type of comparison is\nperformed. The following comparisons are supported:\n\n* equal (mnemonic: `\"eq\"`; integer value: `0`)\n* not equal (mnemonic: `\"ne\"`; integer value: `1`)\n\nThe result is `1` if the comparison is true and `0` otherwise.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-32)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `predicate` | circt::moore::UArrayCmpPredicateAttr | allowed 64-bit signless integer cases: 0, 1 |\n\n#### Operands:\u00a0[\u00b6](#operands-135)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | an unpacked array type |\n| `rhs` | an unpacked array type |\n\n#### Results:\u00a0[\u00b6](#results-132)\n\n| Result | Description |\n| --- | --- |\n| `result` | `bit` type |\n\n### `moore.uint_to_real` (::circt::moore::UIntToRealOp)\u00a0[\u00b6](#mooreuint_to_real-circtmooreuinttorealop)\n\n*Convert an integer value to a real*\n\nSyntax:\n\n```\noperation ::= `moore.uint_to_real` $input attr-dict `:` type($input) `->` type($result)\n```\n\nSee IEEE 1800-2023 Section 6.24.1: \u201cCast operator\u201d and 6.12:\n\u201cReal, shortreal and realtime data types\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-136)\n\n| Operand | Description |\n| --- | --- |\n| `input` | two-valued integer type |\n\n#### Results:\u00a0[\u00b6](#results-133)\n\n| Result | Description |\n| --- | --- |\n| `result` | a SystemVerilog real type |\n\n### `moore.uge` (::circt::moore::UgeOp)\u00a0[\u00b6](#mooreuge-circtmooreugeop)\n\n*Unsigned greater than or equal comparison*\n\nSyntax:\n\n```\noperation ::= `moore.uge` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the left- and right-hand side operand and returns a single bit 0,\n1, or X result. If any bit in the two operands is Z or X, returns X.\nOtherwise, if all bits are 0 or 1, `ult/slt`, `ule/sle`, `ugt/sgt`, and\n`uge/sge` return whether the left-hand side is less than, less than or equal\nto, greater than, or greater than or equal to the right-hand side,\nrespectively. `ult/slt` corresponds to the `<` operator, `ule/sle` to `<=`,\n`ugt/sgt` to `>`, and `uge/sge` to `>=`.\n\nSee IEEE 1800-2017 \u00a7 11.4.4 \u201cRelational operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-137)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-134)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.ugt` (::circt::moore::UgtOp)\u00a0[\u00b6](#mooreugt-circtmooreugtop)\n\n*Unsigned greater than comparison*\n\nSyntax:\n\n```\noperation ::= `moore.ugt` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the left- and right-hand side operand and returns a single bit 0,\n1, or X result. If any bit in the two operands is Z or X, returns X.\nOtherwise, if all bits are 0 or 1, `ult/slt`, `ule/sle`, `ugt/sgt`, and\n`uge/sge` return whether the left-hand side is less than, less than or equal\nto, greater than, or greater than or equal to the right-hand side,\nrespectively. `ult/slt` corresponds to the `<` operator, `ule/sle` to `<=`,\n`ugt/sgt` to `>`, and `uge/sge` to `>=`.\n\nSee IEEE 1800-2017 \u00a7 11.4.4 \u201cRelational operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-138)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-135)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.ule` (::circt::moore::UleOp)\u00a0[\u00b6](#mooreule-circtmooreuleop)\n\n*Unsigned less than or equal comparison*\n\nSyntax:\n\n```\noperation ::= `moore.ule` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the left- and right-hand side operand and returns a single bit 0,\n1, or X result. If any bit in the two operands is Z or X, returns X.\nOtherwise, if all bits are 0 or 1, `ult/slt`, `ule/sle`, `ugt/sgt`, and\n`uge/sge` return whether the left-hand side is less than, less than or equal\nto, greater than, or greater than or equal to the right-hand side,\nrespectively. `ult/slt` corresponds to the `<` operator, `ule/sle` to `<=`,\n`ugt/sgt` to `>`, and `uge/sge` to `>=`.\n\nSee IEEE 1800-2017 \u00a7 11.4.4 \u201cRelational operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-139)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-136)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.ult` (::circt::moore::UltOp)\u00a0[\u00b6](#mooreult-circtmooreultop)\n\n*Unsigned less than comparison*\n\nSyntax:\n\n```\noperation ::= `moore.ult` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the left- and right-hand side operand and returns a single bit 0,\n1, or X result. If any bit in the two operands is Z or X, returns X.\nOtherwise, if all bits are 0 or 1, `ult/slt`, `ule/sle`, `ugt/sgt`, and\n`uge/sge` return whether the left-hand side is less than, less than or equal\nto, greater than, or greater than or equal to the right-hand side,\nrespectively. `ult/slt` corresponds to the `<` operator, `ule/sle` to `<=`,\n`ugt/sgt` to `>`, and `uge/sge` to `>=`.\n\nSee IEEE 1800-2017 \u00a7 11.4.4 \u201cRelational operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-140)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-137)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.union_create` (::circt::moore::UnionCreateOp)\u00a0[\u00b6](#mooreunion_create-circtmooreunioncreateop)\n\n*Union Create operation*\n\nSyntax:\n\n```\noperation ::= `moore.union_create` $input attr-dict `:` type($input) `->` type($result)\n```\n\nA union is a data type that represents a single piece\nof storage that can be accessed using one of\nthe named member data types. Only one of the\ndata types in the union can be used at a time.\nBy default, a union is unpacked, meaning there\nis no required representation for how members\nof the union are stored. Dynamic types and chandle\ntypes can only be used in tagged unions.\nSee IEEE 1800-2017 \u00a7 7.3 \u201cUnions\u201d\n\nExample:\n\n```\ntypedef union { int i; shortreal f; } num; // named union type\nnum n;\nn.f = 0.0; // set n in floating point format\ntypedef struct {\nbit isfloat;\nunion { int i; shortreal f; } n;           // anonymous union type\n} tagged_st;                               // named structure\n```\n\nSee IEEE 1800-2017 \u00a7 7.3 \u201cUnions\u201d\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-33)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-141)\n\n| Operand | Description |\n| --- | --- |\n| `input` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-138)\n\n| Result | Description |\n| --- | --- |\n| `result` | unpacked type |\n\n### `moore.union_extract` (::circt::moore::UnionExtractOp)\u00a0[\u00b6](#mooreunion_extract-circtmooreunionextractop)\n\n*Union Extract operation*\n\nSyntax:\n\n```\noperation ::= `moore.union_extract` $input `,`   $fieldName  attr-dict `:`\n              type($input) `->` type($result)\n```\n\nWith packed unions, writing one member and reading another is\nindependent of the byte ordering of the machine,\nunlike an unpacked union of unpacked structures,\nwhich are C-compatible and have members in ascending address order.\nSee IEEE 1800-2017 \u00a7 7.3.1 \u201cPacked unions\u201d\n\nExample:\n\n```\ntypedef union packed { // default unsigned\ns_atmcell acell;\nbit [423:0] bit_slice;\nbit [52:0][7:0] byte_slice;\n} u_atmcell;\nu_atmcell u1;\nbyte b; bit [3:0] nib;\nb = u1.bit_slice[415:408]; // same as b = u1.byte_slice[51];\nnib = u1.bit_slice [423:420];\n```\n\nSee IEEE 1800-2017 \u00a7 7.3.1 \u201cPacked unions\u201d\n\n#### Attributes:\u00a0[\u00b6](#attributes-34)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-142)\n\n| Operand | Description |\n| --- | --- |\n| `input` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-139)\n\n| Result | Description |\n| --- | --- |\n| `result` | unpacked type |\n\n### `moore.union_extract_ref` (::circt::moore::UnionExtractRefOp)\u00a0[\u00b6](#mooreunion_extract_ref-circtmooreunionextractrefop)\n\n*Union Extract operation*\n\nSyntax:\n\n```\noperation ::= `moore.union_extract_ref` $input `,`   $fieldName  attr-dict `:`\n              type($input) `->` type($result)\n```\n\n#### Attributes:\u00a0[\u00b6](#attributes-35)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `fieldName` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-143)\n\n| Operand | Description |\n| --- | --- |\n| `input` |  |\n\n#### Results:\u00a0[\u00b6](#results-140)\n\n| Result | Description |\n| --- | --- |\n| `result` |  |\n\n### `moore.unreachable` (::circt::moore::UnreachableOp)\u00a0[\u00b6](#mooreunreachable-circtmooreunreachableop)\n\n*Terminates a block as unreachable*\n\nSyntax:\n\n```\noperation ::= `moore.unreachable` attr-dict\n```\n\nThe `moore.unreachable` op is used to indicate that control flow never\nreaches the end of a block. This is useful for operations such as `$fatal`\nwhich never return as they cause the simulator to shut down. Behavior is\nundefined if control actually *does* reach this terminator, but should\nprobably crash the process with a useful error message.\n\nTraits: `Terminator`\n\n### `moore.builtin.urandom` (::circt::moore::UrandomBIOp)\u00a0[\u00b6](#moorebuiltinurandom-circtmooreurandombiop)\n\n*Generate a pseudo-random unsigned integer (optionally seeded)*\n\nSyntax:\n\n```\noperation ::= `moore.builtin.urandom` ($seed^)? attr-dict\n```\n\nCorresponds to the `$urandom` system function. Returns a 32-bit\npseudo-random integer. The seed is optional; when provided, it initializes\nthe generator. If not provided, treat it as 0 in semantics/lowering.\n\nSee IEEE 1800-2023 \u00a7 18.13 \u201cRandom number system functions and methods\u201d.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-144)\n\n| Operand | Description |\n| --- | --- |\n| `seed` | 32-bit two-valued integer type |\n\n#### Results:\u00a0[\u00b6](#results-141)\n\n| Result | Description |\n| --- | --- |\n| `result` | 32-bit two-valued integer type |\n\n### `moore.vtable_entry` (::circt::moore::VTableEntryOp)\u00a0[\u00b6](#moorevtable_entry-circtmoorevtableentryop)\n\n*One vtable slot pointing to the selected implementation*\n\nSyntax:\n\n```\noperation ::= `moore.vtable_entry` $name `->` $target attr-dict\n```\n\nEach entry references the resolved implementation with a SymbolRefAttr.\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-36)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n| `target` | ::mlir::SymbolRefAttr | symbol reference attribute |\n\n### `moore.vtable.load_method` (::circt::moore::VTableLoadMethodOp)\u00a0[\u00b6](#moorevtableload_method-circtmoorevtableloadmethodop)\n\n*Load a virtual method entry from a vtable.*\n\nSyntax:\n\n```\noperation ::= `moore.vtable.load_method` $object `:` $methodSym `of` type($object) `->` type($result) attr-dict\n```\n\nLoads a virtual method function pointer from a vtable.\nThe verifier resolves the symbols in the symbol table and ensures that the\nresult function type matches the erased ABI.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-37)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `methodSym` | ::mlir::SymbolRefAttr | symbol reference attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-145)\n\n| Operand | Description |\n| --- | --- |\n| `object` | Class object handle type, pointing to an object on the heap. |\n\n#### Results:\u00a0[\u00b6](#results-142)\n\n| Result | Description |\n| --- | --- |\n| `result` |  |\n\n### `moore.vtable` (::circt::moore::VTableOp)\u00a0[\u00b6](#moorevtable-circtmoorevtableop)\n\n*Virtual dispatch table*\n\nSyntax:\n\n```\noperation ::= `moore.vtable` $sym_name attr-dict-with-keyword $body\n```\n\nLives at module top-level. Contains `moore.vtable_entry` and nested\n`moore.vtable` ops for base segments. Holds the dispatch targets for every\npossible virtual method call of a class and its ancestors.\n\nTraits: `IsolatedFromAbove`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `SymbolUserOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-38)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::SymbolRefAttr | symbol reference attribute |\n\n### `moore.variable` (::circt::moore::VariableOp)\u00a0[\u00b6](#moorevariable-circtmoorevariableop)\n\n*A variable declaration*\n\nSyntax:\n\n```\noperation ::= `moore.variable` `` custom<ImplicitSSAName>($name) ($initial^)? attr-dict\n              `:` type($result)\n```\n\nSee IEEE 1800-2017 \u00a7 6.8 \u201cVariable declarations\u201d.\n\nInterfaces: `DestructurableAllocationOpInterface`, `OpAsmOpInterface`, `PromotableAllocationOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-39)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `name` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-146)\n\n| Operand | Description |\n| --- | --- |\n| `initial` | unpacked type |\n\n#### Results:\u00a0[\u00b6](#results-143)\n\n| Result | Description |\n| --- | --- |\n| `result` |  |\n\n### `moore.wait_delay` (::circt::moore::WaitDelayOp)\u00a0[\u00b6](#moorewait_delay-circtmoorewaitdelayop)\n\n*Suspend execution for a given amount of time*\n\nSyntax:\n\n```\noperation ::= `moore.wait_delay` $delay attr-dict\n```\n\nThe `moore.wait_delay` op suspends execution of the current process for the\namount of time specified by its operand. Corresponds to the `#` delay\ncontrol in SystemVerilog.\n\nSee IEEE 1800-2017 \u00a7 9.4.1 \u201cDelay control\u201d.\n\n#### Operands:\u00a0[\u00b6](#operands-147)\n\n| Operand | Description |\n| --- | --- |\n| `delay` | the SystemVerilog `time` and `realtime` type |\n\n### `moore.wait_event` (::circt::moore::WaitEventOp)\u00a0[\u00b6](#moorewait_event-circtmoorewaiteventop)\n\n*Suspend execution until an event occurs*\n\nSyntax:\n\n```\noperation ::= `moore.wait_event` attr-dict-with-keyword $body\n```\n\nThe `moore.wait_event` op suspends execution of the current process until\nits body signals that an event has been the detected. Conceptually, the body\nof this op is executed whenever any potentially relevant signal has changed.\nIf one of the contained `moore.detect_event` ops detect an event, execution\nresumes after the `moore.wait_event` operation. If no event is detected, the\ncurrent process remains suspended.\n\nExample corresponding to the SystemVerilog `@(posedge x, negedge y iff z)`:\n\n```\nmoore.wait_event {\n  %0 = moore.read %x : <i1>\n  %1 = moore.read %y : <i1>\n  %2 = moore.read %z : <i1>\n  moore.detect_event posedge %0 : i1\n  moore.detect_event negedge %1 if %2 : i1\n}\n```\n\nThe body may also contain any operations necessary to evaluate the event\nconditions. For example, the SV `@(posedge ~x iff i == 42)`:\n\n```\nmoore.wait_event {\n  %0 = moore.read %x : <i1>\n  %1 = moore.not %0 : i1\n  %2 = moore.read %i : <i19>\n  %3 = moore.constant 42 : i19\n  %4 = moore.eq %2, %3 : i19\n  moore.detect_event posedge %0 if %4 : i1\n}\n```\n\nSee IEEE 1800-2017 \u00a7 9.4.2 \u201cEvent control\u201d.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\n### `moore.wildcard_eq` (::circt::moore::WildcardEqOp)\u00a0[\u00b6](#moorewildcard_eq-circtmoorewildcardeqop)\n\n*Wildcard equality*\n\nSyntax:\n\n```\noperation ::= `moore.wildcard_eq` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the bits in the left- and right-hand side operand and returns a\nsingle bit 0, 1, or X result. If any bit in the left-hand side is Z or X,\nreturns X. Performs the same comparison as the `eq` and `ne` operations, but\nall right-hand side bits that are X or Z are skipped. Therefore, X and Z in\nthe right-hand side act as wildcards or \u201cdon\u2019t care\u201d values. `wildcard_eq`\ncorresponds to the `==?` operator and `wildcard_ne` to the `!=?` operator.\n\nSee IEEE 1800-2017 \u00a7 11.4.6 \u201cWildcard equality operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-148)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-144)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.wildcard_ne` (::circt::moore::WildcardNeOp)\u00a0[\u00b6](#moorewildcard_ne-circtmoorewildcardneop)\n\n*Wildcard inequality*\n\nSyntax:\n\n```\noperation ::= `moore.wildcard_ne` $lhs `,` $rhs attr-dict `:` type($lhs) `->` type($result)\n```\n\nCompares the bits in the left- and right-hand side operand and returns a\nsingle bit 0, 1, or X result. If any bit in the left-hand side is Z or X,\nreturns X. Performs the same comparison as the `eq` and `ne` operations, but\nall right-hand side bits that are X or Z are skipped. Therefore, X and Z in\nthe right-hand side act as wildcards or \u201cdon\u2019t care\u201d values. `wildcard_eq`\ncorresponds to the `==?` operator and `wildcard_ne` to the `!=?` operator.\n\nSee IEEE 1800-2017 \u00a7 11.4.6 \u201cWildcard equality operators\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-149)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-145)\n\n| Result | Description |\n| --- | --- |\n| `result` | single bit type |\n\n### `moore.xor` (::circt::moore::XorOp)\u00a0[\u00b6](#moorexor-circtmoorexorop)\n\n*Bitwise XOR operation*\n\nSyntax:\n\n```\noperation ::= `moore.xor` $lhs `,` $rhs attr-dict `:` type($result)\n```\n\nApplies the boolean XOR operation to each pair of corresponding bits in the\nleft- and right-hand side operand. Corresponds to the `^` operator.\n\nSee IEEE 1800-2017 \u00a7 11.4.8 \u201cBitwise operators\u201d.\n\n|  | 0 | 1 | X | Z |\n| --- | --- | --- | --- | --- |\n| 0 | 0 | 1 | X | X |\n| 1 | 1 | 0 | X | X |\n| X | X | X | X | X |\n| Z | X | X | X | X |\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-150)\n\n| Operand | Description |\n| --- | --- |\n| `lhs` | simple bit vector type |\n| `rhs` | simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-146)\n\n| Result | Description |\n| --- | --- |\n| `result` | simple bit vector type |\n\n### `moore.yield` (::circt::moore::YieldOp)\u00a0[\u00b6](#mooreyield-circtmooreyieldop)\n\n*Conditional yield and termination operation*\n\nSyntax:\n\n```\noperation ::= `moore.yield` attr-dict $result `:` type($result)\n```\n\n\u201cmoore.yield\u201d yields an SSA value from the Moore dialect op region and\nterminates the regions. The semantics of how the values are yielded is\ndefined by the parent operation.\nIf \u201cmoore.yield\u201d has any operands, the operands must match the parent\noperation\u2019s results.\nIf the parent operation defines no values, then the \u201cmoore.yield\u201d may be\nleft out in the custom syntax and the builders will insert one implicitly.\nOtherwise, it has to be present in the syntax to indicate which values are\nyielded.\n\nTraits: `AlwaysSpeculatableImplTrait`, `HasParent<ConditionalOp, GlobalVariableOp>`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-151)\n\n| Operand | Description |\n| --- | --- |\n| `result` | unpacked type |\n\n### `moore.zext` (::circt::moore::ZExtOp)\u00a0[\u00b6](#moorezext-circtmoorezextop)\n\n*Zero-extend a value*\n\nSyntax:\n\n```\noperation ::= `moore.zext` $input attr-dict `:` type($input) `->` type($result)\n```\n\nIncrease the bit width of a value by inserting additional zero most\nsignificant bits. This keeps the unsigned value constant.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-152)\n\n| Operand | Description |\n| --- | --- |\n| `input` | a simple bit vector type |\n\n#### Results:\u00a0[\u00b6](#results-147)\n\n| Result | Description |\n| --- | --- |\n| `result` | a simple bit vector type |\n\n [Prev - LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/ \"LTL Dialect\")\n[Next - Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/ \"Random Test Generation (RTG) Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/RTG/index.md"
  },
  {
    "role": "user",
    "content": "Random Test Generation (RTG) Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nRandom Test Generation (RTG) Rationale\n======================================\n\nThis dialect provides types, operations, and interfaces modeling randomization\nconstructs for random test generation. Furthermore, it contains passes to\nperform and analyze the represented randomization.\n\n* [Rationale](#rationale)\n* [Interfacing with the RTG dialect](#interfacing-with-the-rtg-dialect)\n* [Randomization](#randomization)\n* [Example](#example)\n* [Use-case-specific constructs](#use-case-specific-constructs)\n  + [ISA Tests](#isa-tests)\n* [Frontends](#frontends)\n* [Backends](#backends)\n* [Operations](#operations)\n  + [`rtg.array_create` (::circt::rtg::ArrayCreateOp)](#rtgarray_create-circtrtgarraycreateop)\n  + [`rtg.array_extract` (::circt::rtg::ArrayExtractOp)](#rtgarray_extract-circtrtgarrayextractop)\n  + [`rtg.array_inject` (::circt::rtg::ArrayInjectOp)](#rtgarray_inject-circtrtgarrayinjectop)\n  + [`rtg.array_size` (::circt::rtg::ArraySizeOp)](#rtgarray_size-circtrtgarraysizeop)\n  + [`rtg.bag_convert_to_set` (::circt::rtg::BagConvertToSetOp)](#rtgbag_convert_to_set-circtrtgbagconverttosetop)\n  + [`rtg.bag_create` (::circt::rtg::BagCreateOp)](#rtgbag_create-circtrtgbagcreateop)\n  + [`rtg.bag_difference` (::circt::rtg::BagDifferenceOp)](#rtgbag_difference-circtrtgbagdifferenceop)\n  + [`rtg.bag_select_random` (::circt::rtg::BagSelectRandomOp)](#rtgbag_select_random-circtrtgbagselectrandomop)\n  + [`rtg.bag_union` (::circt::rtg::BagUnionOp)](#rtgbag_union-circtrtgbagunionop)\n  + [`rtg.bag_unique_size` (::circt::rtg::BagUniqueSizeOp)](#rtgbag_unique_size-circtrtgbaguniquesizeop)\n  + [`rtg.comment` (::circt::rtg::CommentOp)](#rtgcomment-circtrtgcommentop)\n  + [`rtg.isa.concat_immediate` (::circt::rtg::ConcatImmediateOp)](#rtgisaconcat_immediate-circtrtgconcatimmediateop)\n  + [`rtg.constant` (::circt::rtg::ConstantOp)](#rtgconstant-circtrtgconstantop)\n  + [`rtg.constraint` (::circt::rtg::ConstraintOp)](#rtgconstraint-circtrtgconstraintop)\n  + [`rtg.context_switch` (::circt::rtg::ContextSwitchOp)](#rtgcontext_switch-circtrtgcontextswitchop)\n  + [`rtg.embed_sequence` (::circt::rtg::EmbedSequenceOp)](#rtgembed_sequence-circtrtgembedsequenceop)\n  + [`rtg.get_sequence` (::circt::rtg::GetSequenceOp)](#rtgget_sequence-circtrtggetsequenceop)\n  + [`rtg.isa.int_to_immediate` (::circt::rtg::IntToImmediateOp)](#rtgisaint_to_immediate-circtrtginttoimmediateop)\n  + [`rtg.interleave_sequences` (::circt::rtg::InterleaveSequencesOp)](#rtginterleave_sequences-circtrtginterleavesequencesop)\n  + [`rtg.label_decl` (::circt::rtg::LabelDeclOp)](#rtglabel_decl-circtrtglabeldeclop)\n  + [`rtg.label` (::circt::rtg::LabelOp)](#rtglabel-circtrtglabelop)\n  + [`rtg.label_unique_decl` (::circt::rtg::LabelUniqueDeclOp)](#rtglabel_unique_decl-circtrtglabeluniquedeclop)\n  + [`rtg.isa.memory_alloc` (::circt::rtg::MemoryAllocOp)](#rtgisamemory_alloc-circtrtgmemoryallocop)\n  + [`rtg.isa.memory_base_address` (::circt::rtg::MemoryBaseAddressOp)](#rtgisamemory_base_address-circtrtgmemorybaseaddressop)\n  + [`rtg.isa.memory_block_declare` (::circt::rtg::MemoryBlockDeclareOp)](#rtgisamemory_block_declare-circtrtgmemoryblockdeclareop)\n  + [`rtg.isa.memory_size` (::circt::rtg::MemorySizeOp)](#rtgisamemory_size-circtrtgmemorysizeop)\n  + [`rtg.on_context` (::circt::rtg::OnContextOp)](#rtgon_context-circtrtgoncontextop)\n  + [`rtg.random_number_in_range` (::circt::rtg::RandomNumberInRangeOp)](#rtgrandom_number_in_range-circtrtgrandomnumberinrangeop)\n  + [`rtg.randomize_sequence` (::circt::rtg::RandomizeSequenceOp)](#rtgrandomize_sequence-circtrtgrandomizesequenceop)\n  + [`rtg.sequence` (::circt::rtg::SequenceOp)](#rtgsequence-circtrtgsequenceop)\n  + [`rtg.set_cartesian_product` (::circt::rtg::SetCartesianProductOp)](#rtgset_cartesian_product-circtrtgsetcartesianproductop)\n  + [`rtg.set_convert_to_bag` (::circt::rtg::SetConvertToBagOp)](#rtgset_convert_to_bag-circtrtgsetconverttobagop)\n  + [`rtg.set_create` (::circt::rtg::SetCreateOp)](#rtgset_create-circtrtgsetcreateop)\n  + [`rtg.set_difference` (::circt::rtg::SetDifferenceOp)](#rtgset_difference-circtrtgsetdifferenceop)\n  + [`rtg.set_select_random` (::circt::rtg::SetSelectRandomOp)](#rtgset_select_random-circtrtgsetselectrandomop)\n  + [`rtg.set_size` (::circt::rtg::SetSizeOp)](#rtgset_size-circtrtgsetsizeop)\n  + [`rtg.set_union` (::circt::rtg::SetUnionOp)](#rtgset_union-circtrtgsetunionop)\n  + [`rtg.isa.slice_immediate` (::circt::rtg::SliceImmediateOp)](#rtgisaslice_immediate-circtrtgsliceimmediateop)\n  + [`rtg.isa.space` (::circt::rtg::SpaceOp)](#rtgisaspace-circtrtgspaceop)\n  + [`rtg.isa.string_data` (::circt::rtg::StringDataOp)](#rtgisastring_data-circtrtgstringdataop)\n  + [`rtg.substitute_sequence` (::circt::rtg::SubstituteSequenceOp)](#rtgsubstitute_sequence-circtrtgsubstitutesequenceop)\n  + [`rtg.target` (::circt::rtg::TargetOp)](#rtgtarget-circtrtgtargetop)\n  + [`rtg.test.failure` (::circt::rtg::TestFailureOp)](#rtgtestfailure-circtrtgtestfailureop)\n  + [`rtg.test` (::circt::rtg::TestOp)](#rtgtest-circtrtgtestop)\n  + [`rtg.test.success` (::circt::rtg::TestSuccessOp)](#rtgtestsuccess-circtrtgtestsuccessop)\n  + [`rtg.tuple_create` (::circt::rtg::TupleCreateOp)](#rtgtuple_create-circtrtgtuplecreateop)\n  + [`rtg.tuple_extract` (::circt::rtg::TupleExtractOp)](#rtgtuple_extract-circtrtgtupleextractop)\n  + [`rtg.validate` (::circt::rtg::ValidateOp)](#rtgvalidate-circtrtgvalidateop)\n  + [`rtg.virtual_reg` (::circt::rtg::VirtualRegisterOp)](#rtgvirtual_reg-circtrtgvirtualregisterop)\n  + [`rtg.yield` (::circt::rtg::YieldOp)](#rtgyield-circtrtgyieldop)\n* [Types](#types)\n  + [ArrayType](#arraytype)\n  + [BagType](#bagtype)\n  + [BFloat16Type](#bfloat16type)\n  + [ComplexType](#complextype)\n  + [Float4E2M1FNType](#float4e2m1fntype)\n  + [Float6E2M3FNType](#float6e2m3fntype)\n  + [Float6E3M2FNType](#float6e3m2fntype)\n  + [Float8E3M4Type](#float8e3m4type)\n  + [Float8E4M3Type](#float8e4m3type)\n  + [Float8E4M3B11FNUZType](#float8e4m3b11fnuztype)\n  + [Float8E4M3FNType](#float8e4m3fntype)\n  + [Float8E4M3FNUZType](#float8e4m3fnuztype)\n  + [Float8E5M2Type](#float8e5m2type)\n  + [Float8E5M2FNUZType](#float8e5m2fnuztype)\n  + [Float8E8M0FNUType](#float8e8m0fnutype)\n  + [Float16Type](#float16type)\n  + [Float32Type](#float32type)\n  + [Float64Type](#float64type)\n  + [Float80Type](#float80type)\n  + [Float128Type](#float128type)\n  + [FloatTF32Type](#floattf32type)\n  + [FunctionType](#functiontype)\n  + [GraphType](#graphtype)\n  + [IndexType](#indextype)\n  + [IntegerType](#integertype)\n  + [MemRefType](#memreftype)\n  + [NoneType](#nonetype)\n  + [OpaqueType](#opaquetype)\n  + [RankedTensorType](#rankedtensortype)\n  + [TupleType](#tupletype)\n  + [UnrankedMemRefType](#unrankedmemreftype)\n  + [UnrankedTensorType](#unrankedtensortype)\n  + [VectorType](#vectortype)\n  + [DictType](#dicttype)\n  + [ImmediateType](#immediatetype)\n  + [LabelType](#labeltype)\n  + [MemoryBlockType](#memoryblocktype)\n  + [MemoryType](#memorytype)\n  + [RandomizedSequenceType](#randomizedsequencetype)\n  + [SequenceType](#sequencetype)\n  + [SetType](#settype)\n  + [TupleType](#tupletype-1)\n* [Passes](#passes)\n  + [`-rtg-elaborate`](#-rtg-elaborate)\n  + [`-rtg-embed-validation-values`](#-rtg-embed-validation-values)\n  + [`-rtg-emit-isa-assembly`](#-rtg-emit-isa-assembly)\n  + [`-rtg-inline-sequences`](#-rtg-inline-sequences)\n  + [`-rtg-insert-test-to-file-mapping`](#-rtg-insert-test-to-file-mapping)\n  + [`-rtg-linear-scan-register-allocation`](#-rtg-linear-scan-register-allocation)\n  + [`-rtg-lower-unique-labels`](#-rtg-lower-unique-labels)\n  + [`-rtg-lower-validate-to-labels`](#-rtg-lower-validate-to-labels)\n  + [`-rtg-materialize-constraints`](#-rtg-materialize-constraints)\n  + [`-rtg-memory-allocation`](#-rtg-memory-allocation)\n  + [`-rtg-print-test-names`](#-rtg-print-test-names)\n  + [`-rtg-simple-test-inliner`](#-rtg-simple-test-inliner)\n  + [`-rtg-unique-validate`](#-rtg-unique-validate)\n\nRationale\u00a0[\u00b6](#rationale)\n-------------------------\n\nThis dialect aims to provide a unified representation for randomized tests, more\nprecisely the parts of the tests that encode the randomization constructs (e.g.,\npicking a random resource from a set of resources).\nThis means, this dialect is only useful in combination with at least one other\ndialect that represents the actual test constructs, i.e., the parts that get\nrandomized. After all the randomization constructs are fully elaborated, the\nresulting test will only consist of those dialects.\n\nExamples for tests that can be randomized, and thus candidates for companion\ndialects, are instruction sequences of any ISA (Instruction Set Architecture),\ntransaction sequences over a latency insensitive (ready-valid) channel, input\nsequences to an FSM (Finite State Machine), transaction sequences for\npotentially any other protocol. Albeit, the initial motivation is ISA tests and\nwill thus be the best supported, at least initially.\n\nWhile it should be valid to add constructs to this dialect that are special to\nany of the above mentioned use-cases, the dialect should generally be designed\nsuch that all of them can be supported.\n\nInterfacing with the RTG dialect\u00a0[\u00b6](#interfacing-with-the-rtg-dialect)\n-----------------------------------------------------------------------\n\nThe RTG dialect is only useful in combination with at least one other dialect\nrepresenting the test. Such a dialect has to be aware of the RTG dialect and\nhas to implement various interfaces (depending on which parts of the RTG\ninfrastructure it intends to use).\n\nA test can be declared with the `rtg.test` operation which takes an\n`!rtg.target` type attribute to specify requirements for the test to be able to\nbe generated and executed. In addition to the target having to provide an\n`!rtg.target` typed value that is a refinement of the required target type, the\ntest can specify additional requirements using the `rtg.require` operation.\n\nTargets can be defined using the `rtg.target` operation. Certain operations\nare only allowed inside the target operation but not the test operation to\nguarantee that certain resources (specifically contexts) cannot be generated\non-the-fly.\n\nThe RTG framework will match all tests with all targets that fulfill their\nrequirements. The user can specify which targets and tests should be included\nin the test generation process and how many tests should be generated per\ntarget or in total.\n\nCurrently, there are three concepts in the RTG dialect the companion dialects\ncan map their constructs to:\n\n* *Instructions*: instructions/operations intended to be performed in series\n  by the test, such as ISA instructions, or protocol transactions\n* *Resources*: resources the instructions operate on, such as registers or\n  memories in ISA tests, or channels in hardware transaction tests\n* *Contexts*: the context or environment the instuctions are performed in,\n  e.g., on which CPU and in which mode for ISA test.\n\nTo express their mapping, the companion dialects must implement the the\ninterfaces as follows.\n\n**Instructions**\n\nThey implement `InstructionOpInterface` on all operations that represent an\ninstruction, transaction, or similar. Those operations are intended to be\nstatements and not define SSA values.\n\n**Resources**\n\nOperations that create, declare, define, or produce a handle to a resource\ninstance must implement the `ResourceOpInterface` interface and define at least\none SSA value of a type that implements the `ResourceTypeInterface` interface.\n(TODO: maybe we don\u2019t actually need the `ResourceTypeInterface`?)\n\nThe `RegisterOpInterface` can be implemented in addition to the\n`ResourceOpInterface` if the resource is a register to become supported by the\nregister allocation and assembly emission pass.\n\n**Contexts**\n\nThe `ContextResourceType` is used to represent contexts. Instructions can be\nplaced in specific context using the `rtg.on_context` operation (Note: we might\npromote this to a type interface in the future).\nOperations that define contexts (i.e., create new contexts) must implement the\n`ContextResourceOpInterface` interface.\nOperations implementing the `ContextResourceOpInterface` interface are only\nallowed inside the `rtg.target` operation.\n\nRandomization\u00a0[\u00b6](#randomization)\n---------------------------------\n\nThis dialect aims to provide utilities that allow users to generate tests\nanywhere on the spectrum from directed tests to (almost) fully random tests\n(refer to *fuzzing*).\n\n* *Constraints*: allow the user to specify constraints to avoid generating\n  illegal or useless tests, e.g., by\n  + allowing to specify a sequence of instructions that always have to be picked\n    in exactly that order and form (see `rtg.sequence` operation)\n  + dependencies between resources or resource usages\n  + etc.\n* *Probabilities and Biases*: allow certain tests (or parts of a test) to be\n  picked more likely than others (can be seen as \u2018soft-constraints\u2019) (see\n  `!rtg.bag` type and associated operations)\n* *Enumerations*: allow to enumerate all tests that can be produced by the\n  current randomness constraints, possibly in a way that places the more likely\n  tests to occur earlier in the enumeration\n\n(TODO: expand here once these things are built out)\n\nMain IR constructs to introduce randomness:\n\n* *Sets*: a set of elements of the same type; the usual set operations apply as\n  well as uniformly at random picking one element of the set\n* *Bags/Biased Sets*: a generalization of *sets* that allows one element to\n  occur multiple times and thus make it more likely to be picked (i.e., models\n  non-uniform distributions)\n\nExample\u00a0[\u00b6](#example)\n---------------------\n\nThis section provides an (almost) E2E walkthrough of a simple example starting\nat a Python implmentation using the library wrapping around the python bindings,\nshowing the generated RTG IR, and the fully elaborated IR. This compilation\nprocess can be performed in one go using the `rtgtool.py` driver script.\n\n```\n# Define a test target (essentially a design/machine with 4 CPUs)\n@rtg.target([('cpus', rtg.set_of(rtg.context_resource()))])\ndef example_target():\n  # return a set containing 4 CPUs which the test can schedule instruction\n  # sequences on\n  return [rtg.Set.create([rv64.core(0), rv64.core(1), rv64.core(2), rv64.core(3)])]\n\n# Define a sequence (for simplicity it only contains one instruction)\n# Note: not adding the sequence decorator is also valid in this example  but\n# means the function is fully inlined at python execution time. It is not valid,\n# however, if the sequence is added to a set or bag to be selected at random.\n@rtg.sequence\ndef seq(register):\n  # ADD Immediate instruction adding 4 to to the given register\n  rtgtest.addi(register, rtgtest.imm(4, 12))\n\n# Define a test that requires a target with CPUs to schedule instruction\n# sequences on\n@rtg.test([('cpus', rtg.set_of(rtg.context_resource()))])\ndef example(cpus):\n  # Pick a random CPU and schedule the ADD operation on it\n  with rtg.context(cpus.get_random_and_exclude()):\n    rtg.label('label0')\n    seq(rtgtest.sp())\n\n  # Pick a random CPU that was not already picked above and zero out the stack\n  # pointer register on it\n  with rtg.context(cpus.get_random()):\n    ra = rtgtest.sp()\n    rtgtest.xor(ra, ra)\n```\n\nThe driver script will elaborate this python file and produce the following RTG\nIR as an intermediate step:\n\n```\nrtg.target @example_target : !rtg.target<cpus: !rtg.set<!rtg.context_resource>> {\n  %0 = rtgtest.coreid 0\n  %1 = rtgtest.coreid 1\n  %2 = rtgtest.coreid 2\n  %3 = rtgtest.coreid 3\n  %4 = rtg.set_create %0, %1, %2, %3 : !rtg.context_resource\n  rtg.yield %4 : !rtg.set<!rtg.context_resource>\n}\nrtg.sequence @seq {\n^bb0(%reg: !rtgtest.reg):\n  %c4_i12 = arith.constant 4 : i12\n  rtgtest.addi %reg, %c4_i12\n}\nrtg.sequence @context0 {\n  // Labels are declared before being placed in the instruction stream such that\n  // we can insert jump instructions before the jump target.\n  %0 = rtg.label.decl \"label0\" -> index\n  rtg.label %0 : index\n  %sp = rtgtest.sp\n  // Construct a closure such that it can be easily passed around, e.g.,\n  // inserted into a set with other sequence closures to be selected at random.\n  %1 = rtg.sequence_closure @seq(%sp) : !rtgtest.reg\n  // Place the sequence here (i.e., inline it here with the arguments passed to\n  // the closure).\n  // This is essentially the same as an `rtg.on_context` with the context\n  // operand matching the one of the parent `on_context`.\n  rtg.sequence_invoke %1\n}\nrtg.sequence @context1 {\n  %0 = rtgtest.sp\n  rtgtest.xor %sp, %sp\n}\nrtg.test @example : !rtg.target<cpus: !rtg.set<!rtg.context_resource>> {\n^bb0(%arg0: !rtg.set<!rtg.context_resource>):\n  // Select an element from the set uniformly at random\n  %0 = rtg.set_select_random %arg0 : !rtg.set<!rtg.context_resource>\n  %3 = rtg.sequence_closure @context0\n  // Place the sequence closure on the given context. In this example, there\n  // will be guards inserted that make sure the inlined sequence is only\n  // executed by the CPU specified by the selected coreid.\n  rtg.on_context %0, %3 : !rtg.context_resource\n  // Construct a new set that doesn't contain the selected element (RTG sets are\n  // immutable) and select another element randomly from this new set.\n  %1 = rtg.set_create %0 : !rtg.context_resource\n  %2 = rtg.set_difference %arg0, %1 : !rtg.set<!rtg.context_resource>\n  %7 = rtg.set_select_random %2 : !rtg.set<!rtg.context_resource>\n  %8 = rtg.sequence_closure @context1\n  rtg.on_context %7, %8 : !rtg.context_resource\n}\n```\n\nOnce all the RTG randomization passes were performed, the example looks like\nthis:\n\n```\n// Two regions, the first one to be executed on CPU with coreid 0 and the second\n// one on CPU with coreid 2\nrtg.rendered_context [0,2] {\n  %0 = rtg.label.decl \"label0\" -> index\n  rtg.label %0 : index\n  %reg = rtgtest.sp\n  %c4 = arith.constant 4 : i12\n  rtgtest.addi %sp, %c4\n  // Is emitted to assembly looking something like:\n  // label0:\n  // addi sp, 4\n}, {\n  %sp = rtgtest.sp\n  rtgtest.xor %sp, %sp\n}\n```\n\nThe last step to run this test is to print it in assembly format and invoke the\nassembler. This also includes the insertion of a considerable amount of\nboilerplate setup code to run the above instructions on the right CPUs which is\nomitted in this example for clarity.\n\nUse-case-specific constructs\u00a0[\u00b6](#use-case-specific-constructs)\n---------------------------------------------------------------\n\nThis section provides an overview of operations/types/interfaces added with the\nintend to be only used for one (or a few) specific use-cases/test-targets.\n\n### ISA Tests\u00a0[\u00b6](#isa-tests)\n\n* *Labels*: Handling of labels is added to the RTG dialect because they are common\n  across ISAs. Leaving them to the ISA specific companion dialects would likely\n  lead to frequent code duplication (once for each ISA).\n* *Register Allocation Pass*\n* *Assembly Emission Pass*\n\nFrontends\u00a0[\u00b6](#frontends)\n-------------------------\n\nAny dialect or entry point is allowed to generate valid RTG IR with a companion\ndialect. The dialect already comes with an extensive CAPI, Python Bindings, and\na small Python library that simplify usage over the pure Python Bindings.\n\nBackends\u00a0[\u00b6](#backends)\n-----------------------\n\nThe RTG dialect does not have a backend itself. It is fully lowered by its\ndialect transformation passes that perform the randomization. The result will be\nIR consisting purely of the companion dialect and thus it is up to this\ncompanion dialect to define any backends.\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `rtg.array_create` (::circt::rtg::ArrayCreateOp)\u00a0[\u00b6](#rtgarray_create-circtrtgarraycreateop)\n\n*Create an array with an initial list of elements*\n\nThis operation creates an array from a list of values. The element on the\nleft-most position in the MLIR assembly format ends up at index 0.\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `elements` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| `result` | an array type with dynamic size |\n\n### `rtg.array_extract` (::circt::rtg::ArrayExtractOp)\u00a0[\u00b6](#rtgarray_extract-circtrtgarrayextractop)\n\n*Get an element from an array*\n\nSyntax:\n\n```\noperation ::= `rtg.array_extract` $array `[` $index `]` `:` qualified(type($array)) attr-dict\n```\n\nThis operation returns the element at the given index of the array.\nAccessing out-of-bounds indices is (immediate) UB.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `array` | an array type with dynamic size |\n| `index` | index |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `rtg.array_inject` (::circt::rtg::ArrayInjectOp)\u00a0[\u00b6](#rtgarray_inject-circtrtgarrayinjectop)\n\n*Set an element in an array*\n\nSyntax:\n\n```\noperation ::= `rtg.array_inject` $array `[` $index `]` `,` $value `:` qualified(type($array)) attr-dict\n```\n\nThis operation produces a new array of the same type as the input array and\nsets the element at the given index to the given value. All other values\nremain the same. An OOB access is (immediate) undefined behavior.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `array` | an array type with dynamic size |\n| `index` | index |\n| `value` | any type |\n\n#### Results:\u00a0[\u00b6](#results-2)\n\n| Result | Description |\n| --- | --- |\n| `result` | an array type with dynamic size |\n\n### `rtg.array_size` (::circt::rtg::ArraySizeOp)\u00a0[\u00b6](#rtgarray_size-circtrtgarraysizeop)\n\n*Return the size of an array*\n\nSyntax:\n\n```\noperation ::= `rtg.array_size` $array `:` qualified(type($array)) attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-3)\n\n| Operand | Description |\n| --- | --- |\n| `array` | an array type with dynamic size |\n\n#### Results:\u00a0[\u00b6](#results-3)\n\n| Result | Description |\n| --- | --- |\n| `result` | index |\n\n### `rtg.bag_convert_to_set` (::circt::rtg::BagConvertToSetOp)\u00a0[\u00b6](#rtgbag_convert_to_set-circtrtgbagconverttosetop)\n\n*Convert a bag to a set*\n\nSyntax:\n\n```\noperation ::= `rtg.bag_convert_to_set` $input `:` qualified(type($input)) attr-dict\n```\n\nThis operation converts a bag to a set by dropping all duplicate elements.\nFor example, the bag `{a, a, b}` is converted to `{a, b}`.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-4)\n\n| Operand | Description |\n| --- | --- |\n| `input` | a bag of values |\n\n#### Results:\u00a0[\u00b6](#results-4)\n\n| Result | Description |\n| --- | --- |\n| `result` | a set of values |\n\n### `rtg.bag_create` (::circt::rtg::BagCreateOp)\u00a0[\u00b6](#rtgbag_create-circtrtgbagcreateop)\n\n*Constructs a bag*\n\nThis operation constructs a bag with the provided values and associated\nmultiples. This means the bag constructed in the following example contains\ntwo of each `%arg0` and `%arg0` (`{%arg0, %arg0, %arg1, %arg1}`).\n\n```\n%0 = arith.constant 2 : index\n%1 = rtg.bag_create (%0 x %arg0, %0 x %arg1) : i32\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameVariadicOperandSize`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-5)\n\n| Operand | Description |\n| --- | --- |\n| `elements` | variadic of any type |\n| `multiples` | variadic of index |\n\n#### Results:\u00a0[\u00b6](#results-5)\n\n| Result | Description |\n| --- | --- |\n| `bag` | a bag of values |\n\n### `rtg.bag_difference` (::circt::rtg::BagDifferenceOp)\u00a0[\u00b6](#rtgbag_difference-circtrtgbagdifferenceop)\n\n*Computes the difference of two bags*\n\nSyntax:\n\n```\noperation ::= `rtg.bag_difference` $original `,` $diff (`inf` $inf^)? `:` qualified(type($output)) attr-dict\n```\n\nFor each element the resulting bag will have as many fewer than the\n\u2018original\u2019 bag as there are in the \u2018diff\u2019 bag. However, if the \u2018inf\u2019\nattribute is attached, all elements of that kind will be removed (i.e., it\nis assumed the \u2018diff\u2019 bag has infinitely many copies of each element).\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `inf` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-6)\n\n| Operand | Description |\n| --- | --- |\n| `original` | a bag of values |\n| `diff` | a bag of values |\n\n#### Results:\u00a0[\u00b6](#results-6)\n\n| Result | Description |\n| --- | --- |\n| `output` | a bag of values |\n\n### `rtg.bag_select_random` (::circt::rtg::BagSelectRandomOp)\u00a0[\u00b6](#rtgbag_select_random-circtrtgbagselectrandomop)\n\n*Select a random element from the bag*\n\nSyntax:\n\n```\noperation ::= `rtg.bag_select_random` $bag `:` qualified(type($bag)) attr-dict\n```\n\nThis operation returns an element from the bag selected uniformely at\nrandom. Therefore, the number of duplicates of each element can be used to\nbias the distribution.\nIf the bag does not contain any elements, the behavior of this operation is\nundefined.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-7)\n\n| Operand | Description |\n| --- | --- |\n| `bag` | a bag of values |\n\n#### Results:\u00a0[\u00b6](#results-7)\n\n| Result | Description |\n| --- | --- |\n| `output` | any type |\n\n### `rtg.bag_union` (::circt::rtg::BagUnionOp)\u00a0[\u00b6](#rtgbag_union-circtrtgbagunionop)\n\n*Computes the union of bags*\n\nSyntax:\n\n```\noperation ::= `rtg.bag_union` $bags `:` qualified(type($result)) attr-dict\n```\n\nComputes the union of the given bags. The list of sets must contain at\nleast one element.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-8)\n\n| Operand | Description |\n| --- | --- |\n| `bags` | variadic of a bag of values |\n\n#### Results:\u00a0[\u00b6](#results-8)\n\n| Result | Description |\n| --- | --- |\n| `result` | a bag of values |\n\n### `rtg.bag_unique_size` (::circt::rtg::BagUniqueSizeOp)\u00a0[\u00b6](#rtgbag_unique_size-circtrtgbaguniquesizeop)\n\n*Returns the number of unique elements in the bag*\n\nSyntax:\n\n```\noperation ::= `rtg.bag_unique_size` $bag `:` qualified(type($bag)) attr-dict\n```\n\nThis operation returns the number of unique elements in the bag, i.e., for\nthe bag `{a, a, b, c, c}` it returns 3.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-9)\n\n| Operand | Description |\n| --- | --- |\n| `bag` | a bag of values |\n\n#### Results:\u00a0[\u00b6](#results-9)\n\n| Result | Description |\n| --- | --- |\n| `result` | index |\n\n### `rtg.comment` (::circt::rtg::CommentOp)\u00a0[\u00b6](#rtgcomment-circtrtgcommentop)\n\n*Emit a comment in instruction stream*\n\nSyntax:\n\n```\noperation ::= `rtg.comment` $comment attr-dict\n```\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `comment` | ::mlir::StringAttr | string attribute |\n\n### `rtg.isa.concat_immediate` (::circt::rtg::ConcatImmediateOp)\u00a0[\u00b6](#rtgisaconcat_immediate-circtrtgconcatimmediateop)\n\n*Concatenate immediates*\n\nSyntax:\n\n```\noperation ::= `rtg.isa.concat_immediate` $operands `:` qualified(type($operands)) attr-dict\n```\n\nThis operation concatenates a variadic number of immediates into a single\nimmediate. The operands are concatenated in order, with the first operand\nbecoming the most significant bits of the result.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-10)\n\n| Operand | Description |\n| --- | --- |\n| `operands` | variadic of an ISA immediate |\n\n#### Results:\u00a0[\u00b6](#results-10)\n\n| Result | Description |\n| --- | --- |\n| `result` | an ISA immediate |\n\n### `rtg.constant` (::circt::rtg::ConstantOp)\u00a0[\u00b6](#rtgconstant-circtrtgconstantop)\n\n*Create an SSA value from an attribute*\n\nSyntax:\n\n```\noperation ::= `rtg.constant` $value attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `OpAsmOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-2)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `value` | ::mlir::TypedAttr | TypedAttr instance |\n\n#### Results:\u00a0[\u00b6](#results-11)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `rtg.constraint` (::circt::rtg::ConstraintOp)\u00a0[\u00b6](#rtgconstraint-circtrtgconstraintop)\n\n*Enforce a constraint*\n\nSyntax:\n\n```\noperation ::= `rtg.constraint` $condition attr-dict\n```\n\nThis operation enforces a constraint. This allows to specify additional\nconstraints on values after their construction. It should be avoided when\npossible as these backward constraints are computationally more expensive.\n\nConstraints should be tried to be solved such that all of them evaluate to\n\u2019true\u2019. If the constraint system turns out to be unsolvable, the compiler\nshould error out gracefully as early as possible (it might also error out\nwhen the system is too expensive to solve).\n\n#### Operands:\u00a0[\u00b6](#operands-11)\n\n| Operand | Description |\n| --- | --- |\n| `condition` | 1-bit signless integer |\n\n### `rtg.context_switch` (::circt::rtg::ContextSwitchOp)\u00a0[\u00b6](#rtgcontext_switch-circtrtgcontextswitchop)\n\n*A specification of how to switch contexts*\n\nSyntax:\n\n```\noperation ::= `rtg.context_switch` $from `->` $to `,` $sequence `:` qualified(type($sequence)) attr-dict\n```\n\nThis operation allows the user to specify a sequence of instructions to\nswitch from context \u2018from\u2019 to context \u2019to\u2019, randomize and embed a provided\nsequence, and switch back from context \u2019to\u2019 to context \u2018from\u2019. This\nsequence of instructions should be provided as the \u2018sequence\u2019 operand which\nis a sequence of the type \u2018!rtg.sequence<context-type-interface,\ncontext-type-interface, !rtg.sequence>\u2019. The first parameter is the \u2018from\u2019\ncontext, the second one the \u2019to\u2019 context, and the third is the sequence to\nrandomize and embed under the \u2019to\u2019 context.\n\nTraits: `HasParent<rtg::TargetOp>`\n\n#### Attributes:\u00a0[\u00b6](#attributes-3)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `from` | ::circt::rtg::ContextResourceAttrInterface | ContextResourceAttrInterface instance |\n| `to` | ::circt::rtg::ContextResourceAttrInterface | ContextResourceAttrInterface instance |\n\n#### Operands:\u00a0[\u00b6](#operands-12)\n\n| Operand | Description |\n| --- | --- |\n| `sequence` | handle to a sequence or sequence family |\n\n### `rtg.embed_sequence` (::circt::rtg::EmbedSequenceOp)\u00a0[\u00b6](#rtgembed_sequence-circtrtgembedsequenceop)\n\n*Embed a sequence of instructions into another sequence*\n\nSyntax:\n\n```\noperation ::= `rtg.embed_sequence` $sequence attr-dict\n```\n\nThis operation takes a fully randomized sequence and embeds it into another\nsequence or test at the position of this operation.\nIn particular, this is not any kind of function call, it doesn\u2019t set up a\nstack frame, etc. It behaves as if the sequence of instructions it refers to\nwere directly inlined relacing this operation.\n\n#### Operands:\u00a0[\u00b6](#operands-13)\n\n| Operand | Description |\n| --- | --- |\n| `sequence` | handle to a fully randomized sequence |\n\n### `rtg.get_sequence` (::circt::rtg::GetSequenceOp)\u00a0[\u00b6](#rtgget_sequence-circtrtggetsequenceop)\n\n*Create a sequence value*\n\nSyntax:\n\n```\noperation ::= `rtg.get_sequence` $sequence `:` qualified(type($ref)) attr-dict\n```\n\nThis operation creates a sequence value referring to the provided sequence\nby symbol. It allows sequences to be passed around as an SSA value. For\nexample, it can be inserted into a set and selected at random which is one\nof the main ways to do randomization.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `SymbolUserOpInterface`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-4)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sequence` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Results:\u00a0[\u00b6](#results-12)\n\n| Result | Description |\n| --- | --- |\n| `ref` | handle to a sequence or sequence family |\n\n### `rtg.isa.int_to_immediate` (::circt::rtg::IntToImmediateOp)\u00a0[\u00b6](#rtgisaint_to_immediate-circtrtginttoimmediateop)\n\n*Construct an immediate from an integer*\n\nSyntax:\n\n```\noperation ::= `rtg.isa.int_to_immediate` $input `:` qualified(type($result)) attr-dict\n```\n\nCreate an immediate of static bit-width from the provided integer. If the\ninteger does not fit in the specified bit-width, an error shall be emitted\nwhen executing this operation.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-14)\n\n| Operand | Description |\n| --- | --- |\n| `input` | index |\n\n#### Results:\u00a0[\u00b6](#results-13)\n\n| Result | Description |\n| --- | --- |\n| `result` | an ISA immediate |\n\n### `rtg.interleave_sequences` (::circt::rtg::InterleaveSequencesOp)\u00a0[\u00b6](#rtginterleave_sequences-circtrtginterleavesequencesop)\n\n*Interleave a list of sequences*\n\nSyntax:\n\n```\noperation ::= `rtg.interleave_sequences` $sequences (`batch` $batchSize^)? attr-dict\n```\n\nThis operation takes a list of (at least one) fully randomized sequences and\ninterleaves them by taking the next `batchSize` number of operations\nimplementing the `InstructionOpInterface` of each sequence round-robin.\n\nTherefore, if only one sequence is in the list, this operation returns that\nsequence unchanged.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-5)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `batchSize` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-15)\n\n| Operand | Description |\n| --- | --- |\n| `sequences` | variadic of handle to a fully randomized sequence |\n\n#### Results:\u00a0[\u00b6](#results-14)\n\n| Result | Description |\n| --- | --- |\n| `interleavedSequence` | handle to a fully randomized sequence |\n\n### `rtg.label_decl` (::circt::rtg::LabelDeclOp)\u00a0[\u00b6](#rtglabel_decl-circtrtglabeldeclop)\n\n*Declares a label for an instruction sequence*\n\nSyntax:\n\n```\noperation ::= `rtg.label_decl` $formatString (`,` $args^)? attr-dict\n```\n\nDeclares a label that can then be placed by an `rtg.label` operation in an\ninstruction sequence, passed on to sequences via their arguments, and used\nby instructions (e.g., as jump targets) by allowing ISA dialects to use them\ndirectly as an operand of an instruction or by casting it to a value\nrepresenting an immediate.\n\nThe format string may contain placeholders of the form `{i}` where `i`\nrefers to the i-th element in `args`.\nThe declared label is uniqued by the compiler to no collide with any other\nlabel declarations.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-6)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `formatString` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-16)\n\n| Operand | Description |\n| --- | --- |\n| `args` | variadic of index |\n\n#### Results:\u00a0[\u00b6](#results-15)\n\n| Result | Description |\n| --- | --- |\n| `label` | a reference to a label |\n\n### `rtg.label` (::circt::rtg::LabelOp)\u00a0[\u00b6](#rtglabel-circtrtglabelop)\n\n*Places a label in an instruction sequence*\n\nSyntax:\n\n```\noperation ::= `rtg.label` $visibility $label attr-dict\n```\n\nAny declared label must only be placed at most once in any fully elaborated\ninstruction sequence.\n\n#### Attributes:\u00a0[\u00b6](#attributes-7)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `visibility` | ::circt::rtg::LabelVisibilityAttr | visibility specifiers for labels |\n\n#### Operands:\u00a0[\u00b6](#operands-17)\n\n| Operand | Description |\n| --- | --- |\n| `label` | a reference to a label |\n\n### `rtg.label_unique_decl` (::circt::rtg::LabelUniqueDeclOp)\u00a0[\u00b6](#rtglabel_unique_decl-circtrtglabeluniquedeclop)\n\n*Declares a unique label for an instruction sequence*\n\nSyntax:\n\n```\noperation ::= `rtg.label_unique_decl` $formatString (`,` $args^)? attr-dict\n```\n\nDeclares a label that can then be placed by an `rtg.label` operation in an\ninstruction sequence, passed on to sequences via their arguments, and used\nby instructions (e.g., as jump targets) by allowing ISA dialects to use them\ndirectly as an operand of an instruction or by casting it to a value\nrepresenting an immediate.\n\nThe format string may contain placeholders of the form `{i}` where `i`\nrefers to the i-th element in `args`.\nThe declared label is uniqued by the compiler to no collide with any other\nlabel declarations.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-8)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `formatString` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-18)\n\n| Operand | Description |\n| --- | --- |\n| `args` | variadic of index |\n\n#### Results:\u00a0[\u00b6](#results-16)\n\n| Result | Description |\n| --- | --- |\n| `label` | a reference to a label |\n\n### `rtg.isa.memory_alloc` (::circt::rtg::MemoryAllocOp)\u00a0[\u00b6](#rtgisamemory_alloc-circtrtgmemoryallocop)\n\n*Allocate a memory with the provided properties*\n\nSyntax:\n\n```\noperation ::= `rtg.isa.memory_alloc` $memoryBlock `,` $size `,` $alignment\n              `:` qualified(type($memoryBlock)) attr-dict\n```\n\nThis operation declares a memory to be allocated with the provided\nproperties. It is only allowed to declare new memories in the `rtg.target`\noperations and must be passed as argument to the `rtg.test`.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-19)\n\n| Operand | Description |\n| --- | --- |\n| `memoryBlock` | handle to a memory block |\n| `size` | index |\n| `alignment` | index |\n\n#### Results:\u00a0[\u00b6](#results-17)\n\n| Result | Description |\n| --- | --- |\n| `result` | handle to a memory |\n\n### `rtg.isa.memory_base_address` (::circt::rtg::MemoryBaseAddressOp)\u00a0[\u00b6](#rtgisamemory_base_address-circtrtgmemorybaseaddressop)\n\n*Get the memory base address as an immediate*\n\nSyntax:\n\n```\noperation ::= `rtg.isa.memory_base_address` $memory `:` qualified(type($memory)) attr-dict\n```\n\nThis operation returns the base address of the given memory. The bit-width\nof the returned immediate must match the address width of the given memory.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-20)\n\n| Operand | Description |\n| --- | --- |\n| `memory` | handle to a memory |\n\n#### Results:\u00a0[\u00b6](#results-18)\n\n| Result | Description |\n| --- | --- |\n| `result` | an ISA immediate |\n\n### `rtg.isa.memory_block_declare` (::circt::rtg::MemoryBlockDeclareOp)\u00a0[\u00b6](#rtgisamemory_block_declare-circtrtgmemoryblockdeclareop)\n\n*Declare a memory block with the provided properties*\n\nThis operation declares a memory block to be allocated with the provided\nproperties. It is only allowed to declare new memory blocks in the\n`rtg.target` operations and must be passed as argument to the `rtg.test`.\nThis is because the available memory blocks are specified by the hardware\ndesign. This specification is fixed from the start and thus a test should\nnot be able to declare new memory blocks on-the-fly. However, tests are\nallowed to allocate memory regions from these memory blocks.\n\nThe \u2018baseAddress\u2019 attribute specifies the first memory address (lowest\naddress representing a valid access to the memory) and the \u2019endAddress\u2019\nrepresents the last address (highest address that is valid to access the\nmemory).\n\nTraits: `HasParent<rtg::TargetOp>`\n\n#### Attributes:\u00a0[\u00b6](#attributes-9)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `baseAddress` | ::mlir::IntegerAttr | arbitrary integer attribute |\n| `endAddress` | ::mlir::IntegerAttr | arbitrary integer attribute |\n\n#### Results:\u00a0[\u00b6](#results-19)\n\n| Result | Description |\n| --- | --- |\n| `result` | handle to a memory block |\n\n### `rtg.isa.memory_size` (::circt::rtg::MemorySizeOp)\u00a0[\u00b6](#rtgisamemory_size-circtrtgmemorysizeop)\n\n*Get the size of the memory in bytes*\n\nSyntax:\n\n```\noperation ::= `rtg.isa.memory_size` $memory `:` qualified(type($memory)) attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-21)\n\n| Operand | Description |\n| --- | --- |\n| `memory` | handle to a memory |\n\n#### Results:\u00a0[\u00b6](#results-20)\n\n| Result | Description |\n| --- | --- |\n| `result` | index |\n\n### `rtg.on_context` (::circt::rtg::OnContextOp)\u00a0[\u00b6](#rtgon_context-circtrtgoncontextop)\n\n*Places a sequence on a context*\n\nSyntax:\n\n```\noperation ::= `rtg.on_context` $context `,` $sequence `:` qualified(type($context)) attr-dict\n```\n\nThis operation takes a context and a fully substituted, but not yet\nrandomized sequence and inserts the necessary instructions to switch from\nthe current context to the provided context, randomizes and embeds the given\nsequence under the given context, and inserts instructions to switch back to\nthe original context.\n\nThese instructions are provided by the \u2018rtg.context\\_switch\u2019 operation. If no\n\u2018rtg.context\\_switch\u2019 for this transition is provided, the compiler will\nerror out. If multiple such context switches apply, the most recently\nregistered one takes precedence.\n\n#### Operands:\u00a0[\u00b6](#operands-22)\n\n| Operand | Description |\n| --- | --- |\n| `context` | ContextResourceTypeInterface instance |\n| `sequence` | fully substituted sequence type |\n\n### `rtg.random_number_in_range` (::circt::rtg::RandomNumberInRangeOp)\u00a0[\u00b6](#rtgrandom_number_in_range-circtrtgrandomnumberinrangeop)\n\n*Returns a number uniformly at random within the given range*\n\nSyntax:\n\n```\noperation ::= `rtg.random_number_in_range` ` ` `[` $lowerBound `,` $upperBound `]` attr-dict\n```\n\nThis operation computes a random number based on a uniform distribution\nwithin the given range. Both the lower and upper bounds are inclusive. If\nthe range is empty, compilation will fail. This is (obviously) more\nperformant than inserting all legal numbers into a set and using\n\u2018set\\_select\\_random\u2019, but yields the same behavior.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-23)\n\n| Operand | Description |\n| --- | --- |\n| `lowerBound` | index |\n| `upperBound` | index |\n\n#### Results:\u00a0[\u00b6](#results-21)\n\n| Result | Description |\n| --- | --- |\n| `result` | index |\n\n### `rtg.randomize_sequence` (::circt::rtg::RandomizeSequenceOp)\u00a0[\u00b6](#rtgrandomize_sequence-circtrtgrandomizesequenceop)\n\n*Randomize the content of a sequence*\n\nSyntax:\n\n```\noperation ::= `rtg.randomize_sequence` $sequence attr-dict\n```\n\nThis operation takes a fully substituted sequence and randomizes its\ncontent. This means, no operations the returned sequence does not contain\nany randomization constructs anymore (such as random selection from sets and\nbags, or other \u2018randomize\\_sequence\u2019 operations).\n\nIt is useful to have this operation separate from \u2019embed\\_sequence\u2019 such that\nthe exact same sequence (i.e., with the same random choices taken) can be\nembedded at multiple places.\nIt is also useful to have this separate from sequence substitution because\nthis operation is sensitive to the context, but the substitution values for\na sequence family might already be available in a parent sequence that is\nplaced on a different context. Thus, not having it separated would mean that\nthe substitution values must all be passed down as arguments to the child\nsequence instead of a a single fully substituted sequence value.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-24)\n\n| Operand | Description |\n| --- | --- |\n| `sequence` | fully substituted sequence type |\n\n#### Results:\u00a0[\u00b6](#results-22)\n\n| Result | Description |\n| --- | --- |\n| `randomizedSequence` | handle to a fully randomized sequence |\n\n### `rtg.sequence` (::circt::rtg::SequenceOp)\u00a0[\u00b6](#rtgsequence-circtrtgsequenceop)\n\n*A sequence of instructions*\n\nThis operation collects a sequence of instructions such that they can be\nplaced as one unit. This is effectively the way to impose a constraint on\nthe order and presence of some instructions.\n\nIt is allowed to contain randomization constructs and invokations on any\ncontexts. It is not allowed to create new context resources inside a\nsequence, however.\n\nThis operation can be invoked by the `invoke` and `on_context` operations.\nIt is referred to by symbol and isolated from above to ease multi-threading\nand it allows the `rtg.test` operation to be isolated-from-above to provide\nstronger top-level isolation guarantees.\n\nTraits: `HasParent<mlir::ModuleOp>`, `IsolatedFromAbove`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `SymbolOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-10)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `sequenceType` | ::mlir::TypeAttr | type attribute of handle to a sequence or sequence family |\n\n### `rtg.set_cartesian_product` (::circt::rtg::SetCartesianProductOp)\u00a0[\u00b6](#rtgset_cartesian_product-circtrtgsetcartesianproductop)\n\n*Computes the n-ary cartesian product of sets*\n\nSyntax:\n\n```\noperation ::= `rtg.set_cartesian_product` $inputs `:` qualified(type($inputs)) attr-dict\n```\n\nThis operation computes a set of tuples from a list of input sets such that\neach combination of elements from the input sets is present in the result\nset. More formally, for n input sets it computes\n`X_1 x ... x X_n = {(x_1, ..., x_n) | x_i \\in X_i for i \\in {1, ..., n}}`.\nAt least one input set has to be provided (i.e., `n > 0`).\n\nFor example, given two sets A and B with elements\n`A = {a0, a1}, B = {b0, b1}` the result set R will be\n`R = {(a0, b0), (a0, b1), (a1, b0), (a1, b1)}`.\n\nNote that an RTG set does not provide any guarantees about the order of\nelements an can thus not be iterated over or indexed into, however, a\nrandom element can be selected and subtracted from the set until it is\nempty. This procedure is determinstic and will yield the same sequence of\nelements for a fixed seed and RTG version. If more guarantees about the\norder of elements is necessary, use arrays instead (and compute the\ncartesian product manually using nested loops).\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-25)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of a set of values |\n\n#### Results:\u00a0[\u00b6](#results-23)\n\n| Result | Description |\n| --- | --- |\n| `result` | a set of values |\n\n### `rtg.set_convert_to_bag` (::circt::rtg::SetConvertToBagOp)\u00a0[\u00b6](#rtgset_convert_to_bag-circtrtgsetconverttobagop)\n\n*Convert a set to a bag*\n\nSyntax:\n\n```\noperation ::= `rtg.set_convert_to_bag` $input `:` qualified(type($input)) attr-dict\n```\n\nThis operation converts a set to a bag. Each element in the set occurs\nexactly once in the resulting bag.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-26)\n\n| Operand | Description |\n| --- | --- |\n| `input` | a set of values |\n\n#### Results:\u00a0[\u00b6](#results-24)\n\n| Result | Description |\n| --- | --- |\n| `result` | a bag of values |\n\n### `rtg.set_create` (::circt::rtg::SetCreateOp)\u00a0[\u00b6](#rtgset_create-circtrtgsetcreateop)\n\n*Constructs a set of the given values*\n\nTraits: `AlwaysSpeculatableImplTrait`, `SameTypeOperands`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-27)\n\n| Operand | Description |\n| --- | --- |\n| `elements` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-25)\n\n| Result | Description |\n| --- | --- |\n| `set` | a set of values |\n\n### `rtg.set_difference` (::circt::rtg::SetDifferenceOp)\u00a0[\u00b6](#rtgset_difference-circtrtgsetdifferenceop)\n\n*Computes the difference of two sets*\n\nSyntax:\n\n```\noperation ::= `rtg.set_difference` $original `,` $diff `:` qualified(type($output)) attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-28)\n\n| Operand | Description |\n| --- | --- |\n| `original` | a set of values |\n| `diff` | a set of values |\n\n#### Results:\u00a0[\u00b6](#results-26)\n\n| Result | Description |\n| --- | --- |\n| `output` | a set of values |\n\n### `rtg.set_select_random` (::circt::rtg::SetSelectRandomOp)\u00a0[\u00b6](#rtgset_select_random-circtrtgsetselectrandomop)\n\n*Selects an element uniformly at random from a set*\n\nSyntax:\n\n```\noperation ::= `rtg.set_select_random` $set `:` qualified(type($set)) attr-dict\n```\n\nThis operation returns an element from the given set uniformly at random.\nApplying this operation to an empty set is undefined behavior.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-29)\n\n| Operand | Description |\n| --- | --- |\n| `set` | a set of values |\n\n#### Results:\u00a0[\u00b6](#results-27)\n\n| Result | Description |\n| --- | --- |\n| `output` | any type |\n\n### `rtg.set_size` (::circt::rtg::SetSizeOp)\u00a0[\u00b6](#rtgset_size-circtrtgsetsizeop)\n\n*Returns the number of elements in the set*\n\nSyntax:\n\n```\noperation ::= `rtg.set_size` $set `:` qualified(type($set)) attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-30)\n\n| Operand | Description |\n| --- | --- |\n| `set` | a set of values |\n\n#### Results:\u00a0[\u00b6](#results-28)\n\n| Result | Description |\n| --- | --- |\n| `result` | index |\n\n### `rtg.set_union` (::circt::rtg::SetUnionOp)\u00a0[\u00b6](#rtgset_union-circtrtgsetunionop)\n\n*Computes the union of sets*\n\nSyntax:\n\n```\noperation ::= `rtg.set_union` $sets `:` qualified(type($result)) attr-dict\n```\n\nComputes the union of the given sets. The list of sets must contain at\nleast one element.\n\nTraits: `AlwaysSpeculatableImplTrait`, `Commutative`, `SameOperandsAndResultType`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-31)\n\n| Operand | Description |\n| --- | --- |\n| `sets` | variadic of a set of values |\n\n#### Results:\u00a0[\u00b6](#results-29)\n\n| Result | Description |\n| --- | --- |\n| `result` | a set of values |\n\n### `rtg.isa.slice_immediate` (::circt::rtg::SliceImmediateOp)\u00a0[\u00b6](#rtgisaslice_immediate-circtrtgsliceimmediateop)\n\n*Extract a slice from an immediate*\n\nSyntax:\n\n```\noperation ::= `rtg.isa.slice_immediate` $input `from` $lowBit `:`\n              qualified(type($input)) `->` qualified(type($result)) attr-dict\n```\n\nThis operation extracts a contiguous slice of bits from an immediate value.\nThe slice is specified by a low bit index (inclusive) and the width of the\nslice is determined by the result type. The slice must fit within the input\nimmediate\u2019s width.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-11)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `lowBit` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-32)\n\n| Operand | Description |\n| --- | --- |\n| `input` | an ISA immediate |\n\n#### Results:\u00a0[\u00b6](#results-30)\n\n| Result | Description |\n| --- | --- |\n| `result` | an ISA immediate |\n\n### `rtg.isa.space` (::circt::rtg::SpaceOp)\u00a0[\u00b6](#rtgisaspace-circtrtgspaceop)\n\n*Reserve the given number of bytes*\n\nSyntax:\n\n```\noperation ::= `rtg.isa.space` $size attr-dict\n```\n\n#### Operands:\u00a0[\u00b6](#operands-33)\n\n| Operand | Description |\n| --- | --- |\n| `size` | index |\n\n### `rtg.isa.string_data` (::circt::rtg::StringDataOp)\u00a0[\u00b6](#rtgisastring_data-circtrtgstringdataop)\n\n*Reserve a string*\n\nSyntax:\n\n```\noperation ::= `rtg.isa.string_data` $data attr-dict\n```\n\nAlways appends a zero character (\\00).\n\n#### Attributes:\u00a0[\u00b6](#attributes-12)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `data` | ::mlir::StringAttr | string attribute |\n\n### `rtg.substitute_sequence` (::circt::rtg::SubstituteSequenceOp)\u00a0[\u00b6](#rtgsubstitute_sequence-circtrtgsubstitutesequenceop)\n\n*Partially substitute arguments of a sequence family*\n\nThis operation substitutes the first N of the M >= N arguments of the given\nsequence family, where N is the size of provided argument substitution list.\nA new sequence (if N == M) or sequence family with M-N will be returned.\n\nNot having to deal with sequence arguments after randomly selecting a\nsequence simplifies the problem of coming up with values to pass as\narguments, but also provides a way for the user to constrain the arguments\nat the location where they are added to a set or bag.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-34)\n\n| Operand | Description |\n| --- | --- |\n| `sequence` | handle to a sequence or sequence family |\n| `replacements` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-31)\n\n| Result | Description |\n| --- | --- |\n| `result` | handle to a sequence or sequence family |\n\n### `rtg.target` (::circt::rtg::TargetOp)\u00a0[\u00b6](#rtgtarget-circtrtgtargetop)\n\n*Defines a test target*\n\nSyntax:\n\n```\noperation ::= `rtg.target` $sym_name `:` $target attr-dict-with-keyword $bodyRegion\n```\n\nThis operation specifies capabilities of a specific test target and can\nprovide additional information about it. These are added as operands to the\n`yield` terminator and implicitly packed up into an `!rtg.dict` type which\nis passed to tests that are matched with this target.\n\nThese capabilities can, for example, consist of the number of CPUs, supported\npriviledge modes, available memories, etc.\n\nTraits: `HasParent<mlir::ModuleOp>`, `IsolatedFromAbove`, `NoRegionArguments`, `SingleBlockImplicitTerminator<rtg::YieldOp>`, `SingleBlock`\n\nInterfaces: `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-13)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `target` | ::mlir::TypeAttr | type attribute of a dictionary |\n\n### `rtg.test.failure` (::circt::rtg::TestFailureOp)\u00a0[\u00b6](#rtgtestfailure-circtrtgtestfailureop)\n\n*Exit the test and report failure*\n\nSyntax:\n\n```\noperation ::= `rtg.test.failure` $errorMessage attr-dict\n```\n\n#### Attributes:\u00a0[\u00b6](#attributes-14)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `errorMessage` | ::mlir::StringAttr | string attribute |\n\n### `rtg.test` (::circt::rtg::TestOp)\u00a0[\u00b6](#rtgtest-circtrtgtestop)\n\n*The root of a test*\n\nThis operation declares the root of a randomized or directed test.\nThe target attribute specifies requirements of this test. These can be\nrefined by `rtg.require` operations inside this operation\u2019s body. A test\ncan only be matched with a target if the target fulfills all the test\u2019s\nrequirements. However, the target may provide more than the test requires.\nFor example, if the target allows execution in a user and privileged mode,\nbut the test only requires and runs in user mode, it can still be matched\nwith that target.\n\nBy default each test can be matched with all targets that fulfill its\nrequirements, but the user can also directly provide a target via the\n\u2019target\u2019 attribute. In that case, the test will only be randomized against\nthat target.\n\nThe \u2019templateName\u2019 attribute specifies the name of the original test\ntemplate (mostly for result reporting purposes). This is because a test\n(template) can be matched against many targets and during this process one\ntest per match is created, but all of them preserve the same test template\nname.\n\nThe body of this operation shall be processed the same way as an\n`rtg.sequence`\u2019s body with the exception of the block arguments.\nThe arguments must match the fields of the dict type in the target attribute\nexactly. The test must not have any additional arguments and cannot be\nreferenced by an `rtg.get_sequence` operation.\n\nIf the end of the test is reached without executing an `rtg.test.success`\nor `rtg.test.failure` it is as if an `rtg.test.success` is executed at the\nvery end.\n\nTraits: `HasParent<mlir::ModuleOp>`, `IsolatedFromAbove`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `Emittable`, `OpAsmOpInterface`, `SymbolUserOpInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-15)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `templateName` | ::mlir::StringAttr | string attribute |\n| `targetType` | ::mlir::TypeAttr | type attribute of a dictionary |\n| `target` | ::mlir::StringAttr | string attribute |\n\n### `rtg.test.success` (::circt::rtg::TestSuccessOp)\u00a0[\u00b6](#rtgtestsuccess-circtrtgtestsuccessop)\n\n*Exit the test and report success*\n\nSyntax:\n\n```\noperation ::= `rtg.test.success` attr-dict\n```\n\n### `rtg.tuple_create` (::circt::rtg::TupleCreateOp)\u00a0[\u00b6](#rtgtuple_create-circtrtgtuplecreateop)\n\n*Create a tuple*\n\nSyntax:\n\n```\noperation ::= `rtg.tuple_create` ($elements^ `:` qualified(type($elements)))? attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-35)\n\n| Operand | Description |\n| --- | --- |\n| `elements` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-32)\n\n| Result | Description |\n| --- | --- |\n| `result` | a tuple of zero or more fields |\n\n### `rtg.tuple_extract` (::circt::rtg::TupleExtractOp)\u00a0[\u00b6](#rtgtuple_extract-circtrtgtupleextractop)\n\n*Get an element from a tuple*\n\nSyntax:\n\n```\noperation ::= `rtg.tuple_extract` $tuple `at` $index `:` qualified(type($tuple)) attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-16)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `index` | ::mlir::IntegerAttr | index attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-36)\n\n| Operand | Description |\n| --- | --- |\n| `tuple` | a tuple of zero or more fields |\n\n#### Results:\u00a0[\u00b6](#results-33)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `rtg.validate` (::circt::rtg::ValidateOp)\u00a0[\u00b6](#rtgvalidate-circtrtgvalidateop)\n\n*Validate the value in the given resource*\n\nSyntax:\n\n```\noperation ::= `rtg.validate` $ref `,` $defaultValue (`,` $id^)?\n              (` ``(` $defaultUsedValues^ `else` $elseValues `:`\n              qualified(type($defaultUsedValues)) `)`)? `:`\n              qualified(type($ref)) `->` qualified(type($defaultValue)) attr-dict\n```\n\nValidates the content of a reference-style value from the payload dialect\nat the position of this operation. This validation may happen in a single\nlowering step, e.g., a compiler pass that interprets the IR and inlines the\ninterpreted value directly, or a program that can be run to generate the\ndesired values may be generated first and in a second compilation run those\nvalues (possibly stored in a file by the first run) may be inlined at the\nposition of these operations. For the latter, the ID attribute may be used\nto match the values to the right operations and the \u2018defaultValue\u2019 is used\nby the first run instead of the simulated value.\n\nIf the control-flow of the payload program visits this operation multiple\ntimes, a possibly different value may be logged each time. In such\nsituations, the lowering should fail as no single value can be determined\nthat can be hardcoded/inlined in its place.\n\nThe value returned by this operation is not known during elaboration and\nis thus treated like a value with identity (even though it might just be\na simple integer). Therefore, it is strongly recommended to not use the\nresult value of this operation in situations that expect structural\nequivalence checks such as adding it to sets or bags.\n\nThe \u2018defaultUsedValues\u2019 are forwarded to the \u2018values\u2019 results without any\nmodification whenever the \u2018defaultValue\u2019 is used as replacement for \u2018value\u2019.\nOtherwise, the \u2019elseValues\u2019 are forwarded. This can be used to conditionally\nexecute code based on whether the default value was used or a proper value\nwas used as replacement. Note that this is not the most light-weight\nimplementation as, in principle, a single \u2018i1\u2019 result could achieve the same\nin combination with an \u2018scf.if\u2019 or \u2018select\u2019 operation. However, these\noperations are fully resolved during elaboration while the \u2018validate\u2019\noperation remains until later in the pipeline because the repeated\ncompilation runs to resolve the validate operations should use the same\nelaboration result which is difficult to achieve with multiple elaboration\nruns even with the same seed as a different elaboration of the validate op\nfor the different compilation runs can lead to subtle differences in the\nRNG querrying behavior.\n\nAnother alternative could be a region that is conditionally inlined or\ndeleted. However, this is even more heavy-weight and implies a strategy that\ninvolves some instructions to be present in one run but not the other which\ncan lead to different label addresses, etc. and thus more likely to problems\nwith AOT co-simulation.\n\nTraits: `AttrSizedOperandSegments`\n\n#### Attributes:\u00a0[\u00b6](#attributes-17)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `id` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-37)\n\n| Operand | Description |\n| --- | --- |\n| `ref` | ValidationTypeInterface instance |\n| `defaultValue` | any type |\n| `defaultUsedValues` | variadic of any type |\n| `elseValues` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-34)\n\n| Result | Description |\n| --- | --- |\n| `value` | any type |\n| `values` | variadic of any type |\n\n### `rtg.virtual_reg` (::circt::rtg::VirtualRegisterOp)\u00a0[\u00b6](#rtgvirtual_reg-circtrtgvirtualregisterop)\n\n*Returns a value representing a virtual register*\n\nSyntax:\n\n```\noperation ::= `rtg.virtual_reg` $allowedRegs attr-dict\n```\n\nThis operation creates a value representing a virtual register. The\n\u2018allowedRegisters\u2019 attribute specifies the concrete registers that may be\nchosen during register allocation.\n\nInterfaces: `InferTypeOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-18)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `allowedRegs` | ::circt::rtg::VirtualRegisterConfigAttr | an allowed register configuration for a virtual register |\n\n#### Results:\u00a0[\u00b6](#results-35)\n\n| Result | Description |\n| --- | --- |\n| `result` | RegisterTypeInterface instance |\n\n### `rtg.yield` (::circt::rtg::YieldOp)\u00a0[\u00b6](#rtgyield-circtrtgyieldop)\n\n*Terminates RTG operation regions*\n\nSyntax:\n\n```\noperation ::= `rtg.yield` ($operands^ `:` type($operands))? attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`, `Terminator`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-38)\n\n| Operand | Description |\n| --- | --- |\n| `operands` | variadic of any type |\n\nTypes\u00a0[\u00b6](#types)\n-----------------\n\n### ArrayType\u00a0[\u00b6](#arraytype)\n\n*An array type with dynamic size*\n\nSyntax:\n\n```\n!rtg.array<\n  ::mlir::Type   # elementType\n>\n```\n\nRepresents an array type with dynamic size. The array contains elements of\nthe specified type only.\n\n#### Parameters:\u00a0[\u00b6](#parameters)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `::mlir::Type` |  |\n\n### BagType\u00a0[\u00b6](#bagtype)\n\n*A bag of values*\n\nSyntax:\n\n```\n!rtg.bag<\n  ::mlir::Type   # elementType\n>\n```\n\nThis type represents a standard bag/multiset datastructure. It does not make\nany assumptions about the underlying implementation.\n\n#### Parameters:\u00a0[\u00b6](#parameters-1)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `::mlir::Type` |  |\n\n### BFloat16Type\u00a0[\u00b6](#bfloat16type)\n\n*Bfloat16 floating-point type*\n\n### ComplexType\u00a0[\u00b6](#complextype)\n\n*Complex number with a parameterized element type*\n\nSyntax:\n\n```\ncomplex-type ::= `complex` `<` type `>`\n```\n\nThe value of `complex` type represents a complex number with a parameterized\nelement type, which is composed of a real and imaginary value of that\nelement type. The element must be a floating point or integer scalar type.\n\n#### Example:\u00a0[\u00b6](#example-1)\n\n```\ncomplex<f32>\ncomplex<i32>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-2)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `Type` |  |\n\n### Float4E2M1FNType\u00a0[\u00b6](#float4e2m1fntype)\n\n*4-bit floating point with 2-bit exponent and 1-bit mantissa*\n\nAn 4-bit floating point type with 1 sign bit, 2 bits exponent and 1 bit\nmantissa. This is not a standard type as defined by IEEE-754, but it\nfollows similar conventions with the following characteristics:\n\n* bit encoding: S1E2M1\n* exponent bias: 1\n* infinities: Not supported\n* NaNs: Not supported\n* denormals when exponent is 0\n\nOpen Compute Project (OCP) microscaling formats (MX) specification:\n<https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>\n\n### Float6E2M3FNType\u00a0[\u00b6](#float6e2m3fntype)\n\n*6-bit floating point with 2-bit exponent and 3-bit mantissa*\n\nAn 6-bit floating point type with 1 sign bit, 2 bits exponent and 3 bits\nmantissa. This is not a standard type as defined by IEEE-754, but it\nfollows similar conventions with the following characteristics:\n\n* bit encoding: S1E2M3\n* exponent bias: 1\n* infinities: Not supported\n* NaNs: Not supported\n* denormals when exponent is 0\n\nOpen Compute Project (OCP) microscaling formats (MX) specification:\n<https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>\n\n### Float6E3M2FNType\u00a0[\u00b6](#float6e3m2fntype)\n\n*6-bit floating point with 3-bit exponent and 2-bit mantissa*\n\nAn 6-bit floating point type with 1 sign bit, 3 bits exponent and 2 bits\nmantissa. This is not a standard type as defined by IEEE-754, but it\nfollows similar conventions with the following characteristics:\n\n* bit encoding: S1E3M2\n* exponent bias: 3\n* infinities: Not supported\n* NaNs: Not supported\n* denormals when exponent is 0\n\nOpen Compute Project (OCP) microscaling formats (MX) specification:\n<https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>\n\n### Float8E3M4Type\u00a0[\u00b6](#float8e3m4type)\n\n*8-bit floating point with 3 bits exponent and 4 bit mantissa*\n\nAn 8-bit floating point type with 1 sign bit, 3 bits exponent and 4 bits\nmantissa. This is not a standard type as defined by IEEE-754, but it\nfollows similar conventions with the following characteristics:\n\n* bit encoding: S1E3M4\n* exponent bias: 3\n* infinities: supported with exponent set to all 1s and mantissa 0s\n* NaNs: supported with exponent bits set to all 1s and mantissa values of\n  {0,1}\u2074 except S.111.0000\n* denormals when exponent is 0\n\n### Float8E4M3Type\u00a0[\u00b6](#float8e4m3type)\n\n*8-bit floating point with 3 bit mantissa*\n\nAn 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits\nmantissa. This is not a standard type as defined by IEEE-754, but it\nfollows similar conventions with the following characteristics:\n\n* bit encoding: S1E4M3\n* exponent bias: 7\n* infinities: supported with exponent set to all 1s and mantissa 0s\n* NaNs: supported with exponent bits set to all 1s and mantissa of\n  (001, 010, 011, 100, 101, 110, 111)\n* denormals when exponent is 0\n\n### Float8E4M3B11FNUZType\u00a0[\u00b6](#float8e4m3b11fnuztype)\n\n*8-bit floating point with 3 bit mantissa*\n\nAn 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits\nmantissa. This is not a standard type as defined by IEEE-754, but it follows\nsimilar conventions, with the exception that there are no infinity values,\nno negative zero, and only one NaN representation. This type has the\nfollowing characteristics:\n\n* bit encoding: S1E4M3\n* exponent bias: 11\n* infinities: Not supported\n* NaNs: Supported with sign bit set to 1, exponent bits and mantissa bits set to all 0s\n* denormals when exponent is 0\n\nRelated to:\n<https://dl.acm.org/doi/10.5555/3454287.3454728>\n\n### Float8E4M3FNType\u00a0[\u00b6](#float8e4m3fntype)\n\n*8-bit floating point with 3 bit mantissa*\n\nAn 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits\nmantissa. This is not a standard type as defined by IEEE-754, but it follows\nsimilar conventions, with the exception that there are no infinity values\nand only two NaN representations. This type has the following\ncharacteristics:\n\n* bit encoding: S1E4M3\n* exponent bias: 7\n* infinities: Not supported\n* NaNs: supported with exponent bits and mantissa bits set to all 1s\n* denormals when exponent is 0\n\nDescribed in:\n<https://arxiv.org/abs/2209.05433>\n\n### Float8E4M3FNUZType\u00a0[\u00b6](#float8e4m3fnuztype)\n\n*8-bit floating point with 3 bit mantissa*\n\nAn 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits\nmantissa. This is not a standard type as defined by IEEE-754, but it follows\nsimilar conventions, with the exception that there are no infinity values,\nno negative zero, and only one NaN representation. This type has the\nfollowing characteristics:\n\n* bit encoding: S1E4M3\n* exponent bias: 8\n* infinities: Not supported\n* NaNs: Supported with sign bit set to 1, exponent bits and mantissa bits set to all 0s\n* denormals when exponent is 0\n\nDescribed in:\n<https://arxiv.org/abs/2209.05433>\n\n### Float8E5M2Type\u00a0[\u00b6](#float8e5m2type)\n\n*8-bit floating point with 2 bit mantissa*\n\nAn 8-bit floating point type with 1 sign bit, 5 bits exponent and 2 bits\nmantissa. This is not a standard type as defined by IEEE-754, but it\nfollows similar conventions with the following characteristics:\n\n* bit encoding: S1E5M2\n* exponent bias: 15\n* infinities: supported with exponent set to all 1s and mantissa 0s\n* NaNs: supported with exponent bits set to all 1s and mantissa of\n  (01, 10, or 11)\n* denormals when exponent is 0\n\nDescribed in:\n<https://arxiv.org/abs/2209.05433>\n\n### Float8E5M2FNUZType\u00a0[\u00b6](#float8e5m2fnuztype)\n\n*8-bit floating point with 2 bit mantissa*\n\nAn 8-bit floating point type with 1 sign bit, 5 bits exponent and 2 bits\nmantissa. This is not a standard type as defined by IEEE-754, but it follows\nsimilar conventions, with the exception that there are no infinity values,\nno negative zero, and only one NaN representation. This type has the\nfollowing characteristics:\n\n* bit encoding: S1E5M2\n* exponent bias: 16\n* infinities: Not supported\n* NaNs: Supported with sign bit set to 1, exponent bits and mantissa bits set to all 0s\n* denormals when exponent is 0\n\nDescribed in:\n<https://arxiv.org/abs/2206.02915>\n\n### Float8E8M0FNUType\u00a0[\u00b6](#float8e8m0fnutype)\n\n*8-bit floating point with 8-bit exponent, no mantissa or sign*\n\nAn 8-bit floating point type with no sign bit, 8 bits exponent and no\nmantissa. This is not a standard type as defined by IEEE-754; it is intended\nto be used for representing scaling factors, so it cannot represent zeros\nand negative numbers. The values it can represent are powers of two in the\nrange [-127,127] and NaN.\n\n* bit encoding: S0E8M0\n* exponent bias: 127\n* infinities: Not supported\n* NaNs: Supported with all bits set to 1\n* denormals: Not supported\n\nOpen Compute Project (OCP) microscaling formats (MX) specification:\n<https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>\n\n### Float16Type\u00a0[\u00b6](#float16type)\n\n*16-bit floating-point type*\n\n### Float32Type\u00a0[\u00b6](#float32type)\n\n*32-bit floating-point type*\n\n### Float64Type\u00a0[\u00b6](#float64type)\n\n*64-bit floating-point type*\n\n### Float80Type\u00a0[\u00b6](#float80type)\n\n*80-bit floating-point type*\n\n### Float128Type\u00a0[\u00b6](#float128type)\n\n*128-bit floating-point type*\n\n### FloatTF32Type\u00a0[\u00b6](#floattf32type)\n\n*TF32 floating-point type*\n\n### FunctionType\u00a0[\u00b6](#functiontype)\n\n*Map from a list of inputs to a list of results*\n\nSyntax:\n\n```\n// Function types may have multiple results.\nfunction-result-type ::= type-list-parens | non-function-type\nfunction-type ::= type-list-parens `->` function-result-type\n```\n\nThe function type can be thought of as a function signature. It consists of\na list of formal parameter types and a list of formal result types.\n\n#### Example:\u00a0[\u00b6](#example-2)\n\n```\nfunc.func @add_one(%arg0 : i64) -> i64 {\n  %c1 = arith.constant 1 : i64\n  %0 = arith.addi %arg0, %c1 : i64\n  return %0 : i64\n}\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-3)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| inputs | `ArrayRef<Type>` |  |\n| results | `ArrayRef<Type>` |  |\n\n### GraphType\u00a0[\u00b6](#graphtype)\n\n*Map from a list of inputs to a list of results*\n\nSyntax:\n\n```\n// Function types may have multiple results.\nfunction-result-type ::= type-list-parens | non-function-type\nfunction-type ::= type-list-parens `->` function-result-type\n```\n\nThe function type can be thought of as a function signature. It consists of\na list of formal parameter types and a list of formal result types.\n\n#### Example:\u00a0[\u00b6](#example-3)\n\n```\nfunc.func @add_one(%arg0 : i64) -> i64 {\n  %c1 = arith.constant 1 : i64\n  %0 = arith.addi %arg0, %c1 : i64\n  return %0 : i64\n}\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-4)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| inputs | `ArrayRef<Type>` |  |\n| results | `ArrayRef<Type>` |  |\n\n### IndexType\u00a0[\u00b6](#indextype)\n\n*Integer-like type with unknown platform-dependent bit width*\n\nSyntax:\n\n```\n// Target word-sized integer.\nindex-type ::= `index`\n```\n\nThe index type is a signless integer whose size is equal to the natural\nmachine word of the target (\n[rationale](../../Rationale/Rationale/#integer-signedness-semantics) )\nand is used by the affine constructs in MLIR.\n\n**Rationale:** integers of platform-specific bit widths are practical to\nexpress sizes, dimensionalities and subscripts.\n\n### IntegerType\u00a0[\u00b6](#integertype)\n\n*Integer type with arbitrary precision up to a fixed limit*\n\nSyntax:\n\n```\n// Sized integers like i1, i4, i8, i16, i32.\nsigned-integer-type ::= `si` [1-9][0-9]*\nunsigned-integer-type ::= `ui` [1-9][0-9]*\nsignless-integer-type ::= `i` [1-9][0-9]*\ninteger-type ::= signed-integer-type |\n                 unsigned-integer-type |\n                 signless-integer-type\n```\n\nInteger types have a designated bit width and may optionally have signedness\nsemantics.\n\n**Rationale:** low precision integers (like `i2`, `i4` etc) are useful for\nlow-precision inference chips, and arbitrary precision integers are useful\nfor hardware synthesis (where a 13 bit multiplier is a lot cheaper/smaller\nthan a 16 bit one).\n\n#### Parameters:\u00a0[\u00b6](#parameters-5)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| width | `unsigned` |  |\n| signedness | `SignednessSemantics` |  |\n\n### MemRefType\u00a0[\u00b6](#memreftype)\n\n*Shaped reference to a region of memory*\n\nSyntax:\n\n```\nlayout-specification ::= attribute-value\nmemory-space ::= attribute-value\nmemref-type ::= `memref` `<` dimension-list-ranked type\n                (`,` layout-specification)? (`,` memory-space)? `>`\n```\n\nA `memref` type is a reference to a region of memory (similar to a buffer\npointer, but more powerful). The buffer pointed to by a memref can be\nallocated, aliased and deallocated. A memref can be used to read and write\ndata from/to the memory region which it references. Memref types use the\nsame shape specifier as tensor types. Note that `memref<f32>`,\n`memref<0 x f32>`, `memref<1 x 0 x f32>`, and `memref<0 x 1 x f32>` are all\ndifferent types.\n\nA `memref` is allowed to have an unknown rank (e.g. `memref<*xf32>`). The\npurpose of unranked memrefs is to allow external library functions to\nreceive memref arguments of any rank without versioning the functions based\non the rank. Other uses of this type are disallowed or will have undefined\nbehavior.\n\nAre accepted as elements:\n\n* built-in integer types;\n* built-in index type;\n* built-in floating point types;\n* built-in vector types with elements of the above types;\n* another memref type;\n* any other type implementing `MemRefElementTypeInterface`.\n\n##### Layout\u00a0[\u00b6](#layout)\n\nA memref may optionally have a layout that indicates how indices are\ntransformed from the multi-dimensional form into a linear address. The\nlayout must avoid internal aliasing, i.e., two distinct tuples of\n*in-bounds* indices must be pointing to different elements in memory. The\nlayout is an attribute that implements `MemRefLayoutAttrInterface`. The\nbulitin dialect offers two kinds of layouts: strided and affine map, each\nof which is available as an attribute. Other attributes may be used to\nrepresent the layout as long as they can be converted to a\n[semi-affine map](Affine.md/#semi-affine-maps) and implement the required\ninterface. Users of memref are expected to fallback to the affine\nrepresentation when handling unknown memref layouts. Multi-dimensional\naffine forms are interpreted in *row-major* fashion.\n\nIn absence of an explicit layout, a memref is considered to have a\nmulti-dimensional identity affine map layout. Identity layout maps do not\ncontribute to the MemRef type identification and are discarded on\nconstruction. That is, a type with an explicit identity map is\n`memref<?x?xf32, (i,j)->(i,j)>` is strictly the same as the one without a\nlayout, `memref<?x?xf32>`.\n\n##### Affine Map Layout\u00a0[\u00b6](#affine-map-layout)\n\nThe layout may be represented directly as an affine map from the index space\nto the storage space. For example, the following figure shows an index map\nwhich maps a 2-dimensional index from a 2x2 index space to a 3x3 index\nspace, using symbols `S0` and `S1` as offsets.\n\n![Index Map Example](/includes/img/index-map.svg)\n\nSemi-affine maps are sufficiently flexible to represent a wide variety of\ndense storage layouts, including row- and column-major and tiled:\n\n```\n// MxN matrix stored in row major layout in memory:\n#layout_map_row_major = (i, j) -> (i, j)\n\n// MxN matrix stored in column major layout in memory:\n#layout_map_col_major = (i, j) -> (j, i)\n\n// MxN matrix stored in a 2-d blocked/tiled layout with 64x64 tiles.\n#layout_tiled = (i, j) -> (i floordiv 64, j floordiv 64, i mod 64, j mod 64)\n```\n\n##### Strided Layout\u00a0[\u00b6](#strided-layout)\n\nMemref layout can be expressed using strides to encode the distance, in\nnumber of elements, in (linear) memory between successive entries along a\nparticular dimension. For example, a row-major strided layout for\n`memref<2x3x4xf32>` is `strided<[12, 4, 1]>`, where the last dimension is\ncontiguous as indicated by the unit stride and the remaining strides are\nproducts of the sizes of faster-variying dimensions. Strided layout can also\nexpress non-contiguity, e.g., `memref<2x3, strided<[6, 2]>>` only accesses\neven elements of the dense consecutive storage along the innermost\ndimension.\n\nThe strided layout supports an optional *offset* that indicates the\ndistance, in the number of elements, between the beginning of the memref\nand the first accessed element. When omitted, the offset is considered to\nbe zero. That is, `memref<2, strided<[2], offset: 0>>` and\n`memref<2, strided<[2]>>` are strictly the same type.\n\nBoth offsets and strides may be *dynamic*, that is, unknown at compile time.\nThis is represented by using a question mark (`?`) instead of the value in\nthe textual form of the IR.\n\nThe strided layout converts into the following canonical one-dimensional\naffine form through explicit linearization:\n\n```\naffine_map<(d0, ... dN)[offset, stride0, ... strideN] ->\n            (offset + d0 * stride0 + ... dN * strideN)>\n```\n\nTherefore, it is never subject to the implicit row-major layout\ninterpretation.\n\n##### Codegen of Unranked Memref\u00a0[\u00b6](#codegen-of-unranked-memref)\n\nUsing unranked memref in codegen besides the case mentioned above is highly\ndiscouraged. Codegen is concerned with generating loop nests and specialized\ninstructions for high-performance, unranked memref is concerned with hiding\nthe rank and thus, the number of enclosing loops required to iterate over\nthe data. However, if there is a need to code-gen unranked memref, one\npossible path is to cast into a static ranked type based on the dynamic\nrank. Another possible path is to emit a single while loop conditioned on a\nlinear index and perform delinearization of the linear index to a dynamic\narray containing the (unranked) indices. While this is possible, it is\nexpected to not be a good idea to perform this during codegen as the cost\nof the translations is expected to be prohibitive and optimizations at this\nlevel are not expected to be worthwhile. If expressiveness is the main\nconcern, irrespective of performance, passing unranked memrefs to an\nexternal C++ library and implementing rank-agnostic logic there is expected\nto be significantly simpler.\n\nUnranked memrefs may provide expressiveness gains in the future and help\nbridge the gap with unranked tensors. Unranked memrefs will not be expected\nto be exposed to codegen but one may query the rank of an unranked memref\n(a special op will be needed for this purpose) and perform a switch and cast\nto a ranked memref as a prerequisite to codegen.\n\nExample:\n\n```\n// With static ranks, we need a function for each possible argument type\n%A = alloc() : memref<16x32xf32>\n%B = alloc() : memref<16x32x64xf32>\ncall @helper_2D(%A) : (memref<16x32xf32>)->()\ncall @helper_3D(%B) : (memref<16x32x64xf32>)->()\n\n// With unknown rank, the functions can be unified under one unranked type\n%A = alloc() : memref<16x32xf32>\n%B = alloc() : memref<16x32x64xf32>\n// Remove rank info\n%A_u = memref_cast %A : memref<16x32xf32> -> memref<*xf32>\n%B_u = memref_cast %B : memref<16x32x64xf32> -> memref<*xf32>\n// call same function with dynamic ranks\ncall @helper(%A_u) : (memref<*xf32>)->()\ncall @helper(%B_u) : (memref<*xf32>)->()\n```\n\nThe core syntax and representation of a layout specification is a\n[semi-affine map](Affine.md/#semi-affine-maps). Additionally,\nsyntactic sugar is supported to make certain layout specifications more\nintuitive to read. For the moment, a `memref` supports parsing a strided\nform which is converted to a semi-affine map automatically.\n\nThe memory space of a memref is specified by a target-specific attribute.\nIt might be an integer value, string, dictionary or custom dialect attribute.\nThe empty memory space (attribute is None) is target specific.\n\nThe notionally dynamic value of a memref value includes the address of the\nbuffer allocated, as well as the symbols referred to by the shape, layout\nmap, and index maps.\n\nExamples of memref static type\n\n```\n// Identity index/layout map\n#identity = affine_map<(d0, d1) -> (d0, d1)>\n\n// Column major layout.\n#col_major = affine_map<(d0, d1, d2) -> (d2, d1, d0)>\n\n// A 2-d tiled layout with tiles of size 128 x 256.\n#tiled_2d_128x256 = affine_map<(d0, d1) -> (d0 div 128, d1 div 256, d0 mod 128, d1 mod 256)>\n\n// A tiled data layout with non-constant tile sizes.\n#tiled_dynamic = affine_map<(d0, d1)[s0, s1] -> (d0 floordiv s0, d1 floordiv s1,\n                             d0 mod s0, d1 mod s1)>\n\n// A layout that yields a padding on two at either end of the minor dimension.\n#padded = affine_map<(d0, d1) -> (d0, (d1 + 2) floordiv 2, (d1 + 2) mod 2)>\n\n\n// The dimension list \"16x32\" defines the following 2D index space:\n//\n//   { (i, j) : 0 <= i < 16, 0 <= j < 32 }\n//\nmemref<16x32xf32, #identity>\n\n// The dimension list \"16x4x?\" defines the following 3D index space:\n//\n//   { (i, j, k) : 0 <= i < 16, 0 <= j < 4, 0 <= k < N }\n//\n// where N is a symbol which represents the runtime value of the size of\n// the third dimension.\n//\n// %N here binds to the size of the third dimension.\n%A = alloc(%N) : memref<16x4x?xf32, #col_major>\n\n// A 2-d dynamic shaped memref that also has a dynamically sized tiled\n// layout. The memref index space is of size %M x %N, while %B1 and %B2\n// bind to the symbols s0, s1 respectively of the layout map #tiled_dynamic.\n// Data tiles of size %B1 x %B2 in the logical space will be stored\n// contiguously in memory. The allocation size will be\n// (%M ceildiv %B1) * %B1 * (%N ceildiv %B2) * %B2 f32 elements.\n%T = alloc(%M, %N) [%B1, %B2] : memref<?x?xf32, #tiled_dynamic>\n\n// A memref that has a two-element padding at either end. The allocation\n// size will fit 16 * 64 float elements of data.\n%P = alloc() : memref<16x64xf32, #padded>\n\n// Affine map with symbol 's0' used as offset for the first dimension.\n#imapS = affine_map<(d0, d1) [s0] -> (d0 + s0, d1)>\n// Allocate memref and bind the following symbols:\n// '%n' is bound to the dynamic second dimension of the memref type.\n// '%o' is bound to the symbol 's0' in the affine map of the memref type.\n%n = ...\n%o = ...\n%A = alloc (%n)[%o] : <16x?xf32, #imapS>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-6)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| shape | `::llvm::ArrayRef<int64_t>` |  |\n| elementType | `Type` |  |\n| layout | `MemRefLayoutAttrInterface` |  |\n| memorySpace | `Attribute` |  |\n\n### NoneType\u00a0[\u00b6](#nonetype)\n\n*A unit type*\n\nSyntax:\n\n```\nnone-type ::= `none`\n```\n\nNoneType is a unit type, i.e. a type with exactly one possible value, where\nits value does not have a defined dynamic representation.\n\n#### Example:\u00a0[\u00b6](#example-4)\n\n```\nfunc.func @none_type() {\n  %none_val = \"foo.unknown_op\"() : () -> none\n  return\n}\n```\n\n### OpaqueType\u00a0[\u00b6](#opaquetype)\n\n*Type of a non-registered dialect*\n\nSyntax:\n\n```\nopaque-type ::= `opaque` `<` type `>`\n```\n\nOpaque types represent types of non-registered dialects. These are types\nrepresented in their raw string form, and can only usefully be tested for\ntype equality.\n\n#### Example:\u00a0[\u00b6](#example-5)\n\n```\nopaque<\"llvm\", \"struct<(i32, float)>\">\nopaque<\"pdl\", \"value\">\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-7)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| dialectNamespace | `StringAttr` |  |\n| typeData | `::llvm::StringRef` |  |\n\n### RankedTensorType\u00a0[\u00b6](#rankedtensortype)\n\n*Multi-dimensional array with a fixed number of dimensions*\n\nSyntax:\n\n```\ntensor-type ::= `tensor` `<` dimension-list type (`,` encoding)? `>`\ndimension-list ::= (dimension `x`)*\ndimension ::= `?` | decimal-literal\nencoding ::= attribute-value\n```\n\nValues with tensor type represents aggregate N-dimensional data values, and\nhave a known element type and a fixed rank with a list of dimensions. Each\ndimension may be a static non-negative decimal constant or be dynamically\ndetermined (indicated by `?`).\n\nThe runtime representation of the MLIR tensor type is intentionally\nabstracted - you cannot control layout or get a pointer to the data. For\nlow level buffer access, MLIR has a\n[`memref` type](#memreftype). This\nabstracted runtime representation holds both the tensor data values as well\nas information about the (potentially dynamic) shape of the tensor. The\n[`dim` operation](MemRef.md/#memrefdim-mlirmemrefdimop) returns the size of a\ndimension from a value of tensor type.\n\nThe `encoding` attribute provides additional information on the tensor.\nAn empty attribute denotes a straightforward tensor without any specific\nstructure. But particular properties, like sparsity or other specific\ncharacteristics of the data of the tensor can be encoded through this\nattribute. The semantics are defined by a type and attribute interface\nand must be respected by all passes that operate on tensor types.\nTODO: provide this interface, and document it further.\n\nNote: hexadecimal integer literals are not allowed in tensor type\ndeclarations to avoid confusion between `0xf32` and `0 x f32`. Zero sizes\nare allowed in tensors and treated as other sizes, e.g.,\n`tensor<0 x 1 x i32>` and `tensor<1 x 0 x i32>` are different types. Since\nzero sizes are not allowed in some other types, such tensors should be\noptimized away before lowering tensors to vectors.\n\n#### Example:\u00a0[\u00b6](#example-6)\n\n```\n// Known rank but unknown dimensions.\ntensor<? x ? x ? x ? x f32>\n\n// Partially known dimensions.\ntensor<? x ? x 13 x ? x f32>\n\n// Full static shape.\ntensor<17 x 4 x 13 x 4 x f32>\n\n// Tensor with rank zero. Represents a scalar.\ntensor<f32>\n\n// Zero-element dimensions are allowed.\ntensor<0 x 42 x f32>\n\n// Zero-element tensor of f32 type (hexadecimal literals not allowed here).\ntensor<0xf32>\n\n// Tensor with an encoding attribute (where #ENCODING is a named alias).\ntensor<?x?xf64, #ENCODING>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-8)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| shape | `::llvm::ArrayRef<int64_t>` |  |\n| elementType | `Type` |  |\n| encoding | `Attribute` |  |\n\n### TupleType\u00a0[\u00b6](#tupletype)\n\n*Fixed-sized collection of other types*\n\nSyntax:\n\n```\ntuple-type ::= `tuple` `<` (type ( `,` type)*)? `>`\n```\n\nThe value of `tuple` type represents a fixed-size collection of elements,\nwhere each element may be of a different type.\n\n**Rationale:** Though this type is first class in the type system, MLIR\nprovides no standard operations for operating on `tuple` types\n(\n[rationale](../../Rationale/Rationale/#tuple-types)).\n\n#### Example:\u00a0[\u00b6](#example-7)\n\n```\n// Empty tuple.\ntuple<>\n\n// Single element\ntuple<f32>\n\n// Many elements.\ntuple<i32, f32, tensor<i1>, i5>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-9)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| types | `ArrayRef<Type>` |  |\n\n### UnrankedMemRefType\u00a0[\u00b6](#unrankedmemreftype)\n\n*Shaped reference, with unknown rank, to a region of memory*\n\nSyntax:\n\n```\nunranked-memref-type ::= `memref` `<*x` type (`,` memory-space)? `>`\nmemory-space ::= attribute-value\n```\n\nA `memref` type with an unknown rank (e.g. `memref<*xf32>`). The purpose of\nunranked memrefs is to allow external library functions to receive memref\narguments of any rank without versioning the functions based on the rank.\nOther uses of this type are disallowed or will have undefined behavior.\n\nSee\n[MemRefType](#memreftype) for more information on\nmemref types.\n\n#### Examples:\u00a0[\u00b6](#examples)\n\n```\nmemref<*f32>\n\n// An unranked memref with a memory space of 10.\nmemref<*f32, 10>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-10)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `Type` |  |\n| memorySpace | `Attribute` |  |\n\n### UnrankedTensorType\u00a0[\u00b6](#unrankedtensortype)\n\n*Multi-dimensional array with unknown dimensions*\n\nSyntax:\n\n```\ntensor-type ::= `tensor` `<` `*` `x` type `>`\n```\n\nAn unranked tensor is a type of tensor in which the set of dimensions have\nunknown rank. See\n[RankedTensorType](#rankedtensortype)\nfor more information on tensor types.\n\n#### Examples:\u00a0[\u00b6](#examples-1)\n\n```\ntensor<*xf32>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-11)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `Type` |  |\n\n### VectorType\u00a0[\u00b6](#vectortype)\n\n*Multi-dimensional SIMD vector type*\n\nSyntax:\n\n```\nvector-type ::= `vector` `<` vector-dim-list vector-element-type `>`\nvector-element-type ::= float-type | integer-type | index-type\nvector-dim-list := (static-dim-list `x`)?\nstatic-dim-list ::= static-dim (`x` static-dim)*\nstatic-dim ::= (decimal-literal | `[` decimal-literal `]`)\n```\n\nThe vector type represents a SIMD style vector used by target-specific\noperation sets like AVX or SVE. While the most common use is for 1D\nvectors (e.g. vector<16 x f32>) we also support multidimensional registers\non targets that support them (like TPUs). The dimensions of a vector type\ncan be fixed-length, scalable, or a combination of the two. The scalable\ndimensions in a vector are indicated between square brackets ([ ]).\n\nVector shapes must be positive decimal integers. 0D vectors are allowed by\nomitting the dimension: `vector<f32>`.\n\nNote: hexadecimal integer literals are not allowed in vector type\ndeclarations, `vector<0x42xi32>` is invalid because it is interpreted as a\n2D vector with shape `(0, 42)` and zero shapes are not allowed.\n\n#### Examples:\u00a0[\u00b6](#examples-2)\n\n```\n// A 2D fixed-length vector of 3x42 i32 elements.\nvector<3x42xi32>\n\n// A 1D scalable-length vector that contains a multiple of 4 f32 elements.\nvector<[4]xf32>\n\n// A 2D scalable-length vector that contains a multiple of 2x8 f32 elements.\nvector<[2]x[8]xf32>\n\n// A 2D mixed fixed/scalable vector that contains 4 scalable vectors of 4 f32 elements.\nvector<4x[4]xf32>\n\n// A 3D mixed fixed/scalable vector in which only the inner dimension is\n// scalable.\nvector<2x[4]x8xf32>\n```\n\n#### Parameters:\u00a0[\u00b6](#parameters-12)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| shape | `::llvm::ArrayRef<int64_t>` |  |\n| elementType | `::mlir::Type` | VectorElementTypeInterface instance |\n| scalableDims | `::llvm::ArrayRef<bool>` |  |\n\n### DictType\u00a0[\u00b6](#dicttype)\n\n*A dictionary*\n\nThis type is a dictionary with a static set of entries. This datatype does\nnot make any assumptions about how the values are stored (could be a struct,\na map, etc.). Furthermore, two values of this type should be considered\nequivalent if they have the same set of entry names and types and the values\nmatch for each entry, independent of the order.\n\n#### Parameters:\u00a0[\u00b6](#parameters-13)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| entries | `::llvm::ArrayRef<::circt::rtg::DictEntry>` | dict entries |\n\n### ImmediateType\u00a0[\u00b6](#immediatetype)\n\n*An ISA immediate*\n\nSyntax:\n\n```\n!rtg.isa.immediate<\n  uint32_t   # width\n>\n```\n\nThis type represents immediates of arbitrary but fixed bit-width.\nThe RTG dialect provides this type to avoid duplication in ISA payload\ndialects.\n\n#### Parameters:\u00a0[\u00b6](#parameters-14)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| width | `uint32_t` |  |\n\n### LabelType\u00a0[\u00b6](#labeltype)\n\n*A reference to a label*\n\nSyntax: `!rtg.isa.label`\n\nThis type represents a label. Payload dialects can add operations to cast\nfrom this type to an immediate type they can use as an operand to an\ninstruction or allow an operand of this type directly.\n\n### MemoryBlockType\u00a0[\u00b6](#memoryblocktype)\n\n*Handle to a memory block*\n\nSyntax:\n\n```\n!rtg.isa.memory_block<\n  uint32_t   # addressWidth\n>\n```\n\nA memory block is representing a continuous region in a memory map with a\nfixed size and base address. It can refer to actual memory or a memory\nmapped device.\n\nIt is assumed that there is only a single address space.\n\n#### Parameters:\u00a0[\u00b6](#parameters-15)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| addressWidth | `uint32_t` |  |\n\n### MemoryType\u00a0[\u00b6](#memorytype)\n\n*Handle to a memory*\n\nSyntax:\n\n```\n!rtg.isa.memory<\n  uint32_t   # addressWidth\n>\n```\n\nThis type is used to represent memory resources that are allocated from\nmemory blocks and can be accessed and manipulated by payload dialect\noperations.\n\n#### Parameters:\u00a0[\u00b6](#parameters-16)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| addressWidth | `uint32_t` |  |\n\n### RandomizedSequenceType\u00a0[\u00b6](#randomizedsequencetype)\n\n*Handle to a fully randomized sequence*\n\nSyntax: `!rtg.randomized_sequence`\n\nSequences can contain operations to randomize their content in various ways.\nA sequence of this type is guaranteed to not have any such operations\nanymore (transitively).\n\n### SequenceType\u00a0[\u00b6](#sequencetype)\n\n*Handle to a sequence or sequence family*\n\nSyntax:\n\n```\n!rtg.sequence<\n  ::llvm::ArrayRef<mlir::Type>   # elementTypes\n>\n```\n\nAn SSA value of this type refers to a sequence if the list of element types\nis empty or a sequence family if there are elements left to be substituted.\n\n#### Parameters:\u00a0[\u00b6](#parameters-17)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementTypes | `::llvm::ArrayRef<mlir::Type>` | element types |\n\n### SetType\u00a0[\u00b6](#settype)\n\n*A set of values*\n\nSyntax:\n\n```\n!rtg.set<\n  ::mlir::Type   # elementType\n>\n```\n\nThis type represents a standard set datastructure. It does not make any\nassumptions about the underlying implementation. Thus a hash set, tree set,\netc. can be used in a backend.\n\n#### Parameters:\u00a0[\u00b6](#parameters-18)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| elementType | `::mlir::Type` |  |\n\n### TupleType\u00a0[\u00b6](#tupletype-1)\n\n*A tuple of zero or more fields*\n\nSyntax:\n\n```\n!rtg.tuple<\n  ::llvm::ArrayRef<::mlir::Type>   # fieldTypes\n>\n```\n\nThis type represents a tuple of zero or more fields. The fields can be\nof any type. The builtin tuple type is not used because it does not allow\nzero fields.\n\n#### Parameters:\u00a0[\u00b6](#parameters-19)\n\n| Parameter | C++ type | Description |\n| --- | --- | --- |\n| fieldTypes | `::llvm::ArrayRef<::mlir::Type>` | tuple field types |\n\nPasses\u00a0[\u00b6](#passes)\n-------------------\n\n### `-rtg-elaborate`\u00a0[\u00b6](#-rtg-elaborate)\n\n*Elaborate the randomization parts*\n\nThis pass interprets most RTG operations to perform the represented\nrandomization and in the process get rid of those operations. This means,\nafter this pass the IR does not contain any random constructs within tests\nanymore.\n\n#### Options\u00a0[\u00b6](#options)\n\n```\n-seed                   : The seed for any RNG constructs used in the pass.\n-delete-unmatched-tests : Delete tests that could not be matched with a target.\n```\n\n### `-rtg-embed-validation-values`\u00a0[\u00b6](#-rtg-embed-validation-values)\n\n*Lower validate operations to the externally provided values*\n\nThis pass replaces \u2018rtg.validate\u2019 operations with concrete values read from\nan external file. The file should contain the expected validation values\nwith matching IDs computed, e.g., by running the program in a simulator.\n\nEach validate operation is matched with its corresponding value using the\nunique identifier. If an identifier occurs multiple times in the file, the\npass fails. If an identifier for a \u2018validate\u2019 operation is missing in the\nfile, the pass will not modify that operation. Otherwise, the values are\nparsed according to the implementation provided by the\n\u2018ValidationTypeInterface\u2019 implementation of the \u2018ref\u2019 operand type and\nmaterialized in the IR as constants to replace the \u2018validate\u2019 operation.\n\nThis pass is typically used as part of a two-phase compilation process that\nforks after the \u2018rtg-unique-valiate\u2019 pass is run:\n\n1. Run the \u2018rtg-lower-validate-ops-to-labels\u2019 pass and the rest of the\n   pipeline, then simulate the output in a reference simulator to generate\n   a file with the expected values.\n2. Run this pass and the rest of the pipeline to produce the final test.\n\n#### Options\u00a0[\u00b6](#options-1)\n\n```\n-filename : The file with the validation values.\n```\n\n### `-rtg-emit-isa-assembly`\u00a0[\u00b6](#-rtg-emit-isa-assembly)\n\n*Emits the instructions in a format understood by assemblers*\n\nThis pass expects all instructions to be inside \u2019emit.file\u2019 operations with\nan appropriate filename attribute. There are two special filenames:\n\n* \u201c-\u201d means that the output should be emitted to stdout.\n* \"\" means that the output should be emitted to stderr.\n\nIn order to operate on \u2019emit.file\u2019 operations in parallel, the pass\nrequires that all \u2019emit.file\u2019 operations have a unique filename (this is not\nchecked by the pass and violations will result in race conditions).\n\nThere are two options to specify lists of instructions that are not\nsupported by the assembler. For instructions in any of those lists, this\npass will emit the equivalent binary representation.\n\n#### Options\u00a0[\u00b6](#options-2)\n\n```\n-unsupported-instructions-file : An absolute path to a file with a list of instruction names not supported by the assembler.\n-unsupported-instructions      : A list of ISA instruction names not supported by the assembler.\n```\n\n### `-rtg-inline-sequences`\u00a0[\u00b6](#-rtg-inline-sequences)\n\n*Inline and interleave sequences*\n\nInline all sequences into tests and remove the \u2018rtg.sequence\u2019 operations.\nAlso computes and materializes all interleaved sequences\n(\u2018interleave\\_sequences\u2019 operation).\n\n#### Statistics\u00a0[\u00b6](#statistics)\n\n```\nnum-sequences-inlined     : Number of sequences inlined into another sequence or test.\nnum-sequences-interleaved : Number of sequences interleaved with another sequence.\n```\n\n### `-rtg-insert-test-to-file-mapping`\u00a0[\u00b6](#-rtg-insert-test-to-file-mapping)\n\n*Insert Emit dialect ops to prepare for emission*\n\nThis pass inserts emit dialect operations to group tests to output files.\nAll tests can be put in a single output file, each test in its own file, or\ntests can be grouped according to some properties (e.g., machine mode vs.\nuser mode tests) (TODO).\n\n#### Options\u00a0[\u00b6](#options-3)\n\n```\n-split-output : If 'true' emits one file per 'rtg.test' in the IR. The name of the file matches the test name and is placed in 'path'. Otherwise, path is interpreted as the full file path including filename.\n-path         : The directory or file path in which the output files should be created. If empty is is emitted to stderr (not allowed if 'split-output' is set to 'true')\n```\n\n### `-rtg-linear-scan-register-allocation`\u00a0[\u00b6](#-rtg-linear-scan-register-allocation)\n\n*Simple linear scan register allocation for RTG*\n\nPerforms a simple version of the linear scan register allocation algorithm\nbased on the \u2018rtg.virtual\\_reg\u2019 operations.\n\nThis pass is expected to be run after elaboration.\n\n#### Statistics\u00a0[\u00b6](#statistics-1)\n\n```\nnum-registers-spilled : Number of registers spilled to the stack.\n```\n\n### `-rtg-lower-unique-labels`\u00a0[\u00b6](#-rtg-lower-unique-labels)\n\n*Lower label\\_unique\\_decl to label\\_decl operations*\n\nThis pass lowers label\\_unique\\_decl operations to label\\_decl operations by\ncreating a unique label string based on all the existing unique and\nnon-unique label declarations in the module.\n\n#### Statistics\u00a0[\u00b6](#statistics-2)\n\n```\nnum-labels-lowered : Number of unique labels lowered to regular label declarations.\n```\n\n### `-rtg-lower-validate-to-labels`\u00a0[\u00b6](#-rtg-lower-validate-to-labels)\n\n*Lower validation operations to intrinsic labels*\n\nLowers the \u2018rtg.validate\u2019 operations to special intrinsic labels understood\nby the target simulator to print the register contents.\n\n### `-rtg-materialize-constraints`\u00a0[\u00b6](#-rtg-materialize-constraints)\n\n*Materialize implicit constraints*\n\n### `-rtg-memory-allocation`\u00a0[\u00b6](#-rtg-memory-allocation)\n\n*Lower memories to immediates or labels*\n\nThis pass lowers \u2018memory\\_alloc\u2019 and other memory handling operations to\nimmediates or labels by computing offsets within memory blocks according to\nthe memory allocation\u2019s size and alignments.\n\n#### Options\u00a0[\u00b6](#options-4)\n\n```\n-use-immediates : Whether the pass should lower memories to immediates instead of labels.\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-3)\n\n```\nnum-memories-allocated : Number of memories allocated from memory blocks.\n```\n\n### `-rtg-print-test-names`\u00a0[\u00b6](#-rtg-print-test-names)\n\n*Print the names of all tests to the given file*\n\nPrints the names of all tests in the module to the given file.\nA CSV format is used with the first column being the properly uniqued name\nof the test and the second column being the original name of the test as it\nappeared in the frontend. The original name of a test may occur several\ntimes because the test might have been duplicated for multiple targets or\nbecause multiple elaborations of the same test/target pair were requested.\n\n#### Options\u00a0[\u00b6](#options-5)\n\n```\n-filename : The file to print the test names to.\n```\n\n### `-rtg-simple-test-inliner`\u00a0[\u00b6](#-rtg-simple-test-inliner)\n\n*Inline test contents*\n\nThis is a simple pass to inline test contents into \u2019emit.file\u2019 operations\nin which they are referenced. No \u201cglue code\u201d is inserted between tests\nadded to the same file. Thus this pass is not intended to be used in a\nproduction pipeline but just to bring the IR into a structure understood by\nthe RTG ISA assembly emission pass to avoid making that pass more complex.\n\n### `-rtg-unique-validate`\u00a0[\u00b6](#-rtg-unique-validate)\n\n*Compute unique IDs for validate operations*\n\nThis pass visits all \u2018rtg.validate\u2019 operations without an ID attribute and\nassigns a unique ID to them.\n\n [Prev - Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/ \"Moore Dialect\")\n[Next - Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/ \"Simulation Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Sim/index.md"
  },
  {
    "role": "user",
    "content": "Simulation Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nSimulation Dialect\n==================\n\nThis dialect provides a high-level representation for simulator-specific\noperations. The purpose of the dialect is to provide a high-level representation\nfor constructs which interact with simulators (Verilator, VCS, Arc, \u2026) that\nare easy to analyze and transform in the compiler.\n\n* [Rationale](#rationale)\n  + [Plusargs](#plusargs)\n* [Types](#types)\n  + [DynamicStringType](#dynamicstringtype)\n  + [FormatStringType](#formatstringtype)\n* [Operations](#operations)\n  + [`sim.clocked_pause` (::circt::sim::ClockedPauseOp)](#simclocked_pause-circtsimclockedpauseop)\n  + [`sim.clocked_terminate` (::circt::sim::ClockedTerminateOp)](#simclocked_terminate-circtsimclockedterminateop)\n  + [`sim.func.dpi.call` (::circt::sim::DPICallOp)](#simfuncdpicall-circtsimdpicallop)\n  + [`sim.func.dpi` (::circt::sim::DPIFuncOp)](#simfuncdpi-circtsimdpifuncop)\n  + [`sim.fmt.bin` (::circt::sim::FormatBinOp)](#simfmtbin-circtsimformatbinop)\n  + [`sim.fmt.char` (::circt::sim::FormatCharOp)](#simfmtchar-circtsimformatcharop)\n  + [`sim.fmt.dec` (::circt::sim::FormatDecOp)](#simfmtdec-circtsimformatdecop)\n  + [`sim.fmt.flt` (::circt::sim::FormatFloatOp)](#simfmtflt-circtsimformatfloatop)\n  + [`sim.fmt.gen` (::circt::sim::FormatGeneralOp)](#simfmtgen-circtsimformatgeneralop)\n  + [`sim.fmt.hex` (::circt::sim::FormatHexOp)](#simfmthex-circtsimformathexop)\n  + [`sim.fmt.literal` (::circt::sim::FormatLiteralOp)](#simfmtliteral-circtsimformatliteralop)\n  + [`sim.fmt.oct` (::circt::sim::FormatOctOp)](#simfmtoct-circtsimformatoctop)\n  + [`sim.fmt.exp` (::circt::sim::FormatScientificOp)](#simfmtexp-circtsimformatscientificop)\n  + [`sim.fmt.concat` (::circt::sim::FormatStringConcatOp)](#simfmtconcat-circtsimformatstringconcatop)\n  + [`sim.string.int_to_string` (::circt::sim::IntToStringOp)](#simstringint_to_string-circtsiminttostringop)\n  + [`sim.pause` (::circt::sim::PauseOp)](#simpause-circtsimpauseop)\n  + [`sim.plusargs.test` (::circt::sim::PlusArgsTestOp)](#simplusargstest-circtsimplusargstestop)\n  + [`sim.plusargs.value` (::circt::sim::PlusArgsValueOp)](#simplusargsvalue-circtsimplusargsvalueop)\n  + [`sim.print` (::circt::sim::PrintFormattedOp)](#simprint-circtsimprintformattedop)\n  + [`sim.proc.print` (::circt::sim::PrintFormattedProcOp)](#simprocprint-circtsimprintformattedprocop)\n  + [`sim.string.concat` (::circt::sim::StringConcatOp)](#simstringconcat-circtsimstringconcatop)\n  + [`sim.string.literal` (::circt::sim::StringConstantOp)](#simstringliteral-circtsimstringconstantop)\n  + [`sim.string.length` (::circt::sim::StringLengthOp)](#simstringlength-circtsimstringlengthop)\n  + [`sim.terminate` (::circt::sim::TerminateOp)](#simterminate-circtsimterminateop)\n\nRationale\u00a0[\u00b6](#rationale)\n-------------------------\n\n### Plusargs\u00a0[\u00b6](#plusargs)\n\nThe `sim.plusarg_test` and `sim.plusarg_value` operations are wrappers around\nthe SystemVerilog built-ins which access command-line arguments.\nThey are cleaner from a data-flow perspective, as they package the wires\nand if-statements involved into compact operations that can be trivially\nhandled by analyses.\n\nTypes\u00a0[\u00b6](#types)\n-----------------\n\n### DynamicStringType\u00a0[\u00b6](#dynamicstringtype)\n\n*String type with variable length*\n\nSyntax: `!sim.dstring`\n\nThe dynamic string type represents a string with a variable length that is\nonly known at runtime. The contents of the string are held as an array of\n`i8` bytes. The interpretation of these bytes as a concrete character\nencoding is undefined, but treating the bytes as a UTF-8 string is\nrecommended. A string\u2019s length must fit into an `i64`.\n\nEven though practical lowerings of this type likely have to hold the string\ncontents in dynamically-allocated heap memory, *this type has value\nsemantics*. If the same string SSA value is passed to multiple users, any\nmutation performed by one user is not visible to other users.\n\n### FormatStringType\u00a0[\u00b6](#formatstringtype)\n\n*Format string type*\n\nSyntax: `!sim.fstring`\n\nA format string type represents either a single formatting fragment or the\nconcatenation of an arbitrary but finite number of fragments.\nA formatting fragment is either a static string literal or the association\nof a dynamic hardware value with a format specifier.\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `sim.clocked_pause` (::circt::sim::ClockedPauseOp)\u00a0[\u00b6](#simclocked_pause-circtsimclockedpauseop)\n\n*Pause the simulation*\n\nSyntax:\n\n```\noperation ::= `sim.clocked_pause` $clock `,` $condition `,`\n              custom<KeywordBool>($verbose, \"\\\"verbose\\\"\" , \"\\\"quiet\\\"\") attr-dict\n```\n\nImplements the semantics of `sim.pause` if the given condition is true on\nthe rising edge of the clock operand.\n\n#### Attributes:\u00a0[\u00b6](#attributes)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `verbose` | ::mlir::BoolAttr | bool attribute |\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `clock` | A type for clock-carrying wires |\n| `condition` | 1-bit signless integer |\n\n### `sim.clocked_terminate` (::circt::sim::ClockedTerminateOp)\u00a0[\u00b6](#simclocked_terminate-circtsimclockedterminateop)\n\n*Terminate the simulation*\n\nSyntax:\n\n```\noperation ::= `sim.clocked_terminate` $clock `,` $condition `,`\n              custom<KeywordBool>($success, \"\\\"success\\\"\", \"\\\"failure\\\"\") `,`\n              custom<KeywordBool>($verbose, \"\\\"verbose\\\"\" , \"\\\"quiet\\\"\") attr-dict\n```\n\nImplements the semantics of `sim.terminate` if the given condition is true\non the rising edge of the clock operand.\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `success` | ::mlir::BoolAttr | bool attribute |\n| `verbose` | ::mlir::BoolAttr | bool attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `clock` | A type for clock-carrying wires |\n| `condition` | 1-bit signless integer |\n\n### `sim.func.dpi.call` (::circt::sim::DPICallOp)\u00a0[\u00b6](#simfuncdpicall-circtsimdpicallop)\n\n*A call option for DPI function with an optional clock and enable*\n\nSyntax:\n\n```\noperation ::= `sim.func.dpi.call` $callee `(` $inputs `)` (`clock` $clock^)? (`enable` $enable^)?\n              attr-dict `:` functional-type($inputs, results)\n```\n\n`sim.func.dpi.call` represents SystemVerilog DPI function call. There are two\noptional operands `clock` and `enable`.\n\nIf `clock` is not provided, the callee is invoked when input values are changed.\nIf provided, the DPI function is called at clock\u2019s posedge. The result values behave\nlike registers and the DPI function is used as a state transfer function of them.\n\n`enable` operand is used to conditionally call the DPI since DPI call could be quite\nmore expensive than native constructs. When `enable` is low, results of unclocked\ncalls are undefined and in SV results they are lowered into `X`. Users are expected\nto gate result values by another `enable` to model a default value of results.\n\nFor clocked calls, a low enable means that its register state transfer function is\nnot called. Hence their values will not be modify in that clock.\n\nTraits: `AttrSizedOperandSegments`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallOpInterface`, `SymbolUserOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-2)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `callee` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `clock` | A type for clock-carrying wires |\n| `enable` | 1-bit signless integer |\n| `inputs` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| \u00abunnamed\u00bb | variadic of any type |\n\n### `sim.func.dpi` (::circt::sim::DPIFuncOp)\u00a0[\u00b6](#simfuncdpi-circtsimdpifuncop)\n\n*A System Verilog function*\n\n`sim.func.dpi` models an external function in a core dialect.\n\nTraits: `IsolatedFromAbove`\n\nInterfaces: `ArgAndResultAttrsOpInterface`, `CallableOpInterface`, `FunctionOpInterface`, `OpAsmOpInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-3)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `module_type` | ::mlir::TypeAttr | type attribute of a module |\n| `per_argument_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes |\n| `argument_locs` | ::mlir::ArrayAttr | location array attribute |\n| `verilogName` | ::mlir::StringAttr | string attribute |\n\n### `sim.fmt.bin` (::circt::sim::FormatBinOp)\u00a0[\u00b6](#simfmtbin-circtsimformatbinop)\n\n*Binary format specifier*\n\nSyntax:\n\n```\noperation ::= `sim.fmt.bin` $value\n              (`isLeftAligned` $isLeftAligned^)?\n              (`paddingChar` $paddingChar^)?\n              (`specifierWidth` $specifierWidth^)?\n              attr-dict `:` qualified(type($value))\n```\n\nFormat the given integer value as binary (base two) string.\n\nThe printed value will be left-padded with \u20180\u2019 up to the number\nof bits of the argument\u2019s type. Zero width values will produce\nthe empty string. No further prefix will be added.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `ValueFormatter`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-4)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `isLeftAligned` | ::mlir::BoolAttr | bool attribute |\n| `paddingChar` | ::mlir::IntegerAttr | 8-bit signless integer attribute |\n| `specifierWidth` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-3)\n\n| Operand | Description |\n| --- | --- |\n| `value` | integer |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `result` | Format string type |\n\n### `sim.fmt.char` (::circt::sim::FormatCharOp)\u00a0[\u00b6](#simfmtchar-circtsimformatcharop)\n\n*Character format specifier*\n\nSyntax:\n\n```\noperation ::= `sim.fmt.char` $value attr-dict `:` qualified(type($value))\n```\n\nFormat the given integer value as a single character.\n\nFor integer values up to 127, ASCII compatible encoding is assumed.\nFor larger values, the encoding is unspecified.\n\nIf the argument\u2019s type width is less than eight bits, the value is\nzero extended.\nIf the width is greater than eight bits, the resulting formatted string\nis undefined.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `ValueFormatter`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-4)\n\n| Operand | Description |\n| --- | --- |\n| `value` | integer |\n\n#### Results:\u00a0[\u00b6](#results-2)\n\n| Result | Description |\n| --- | --- |\n| `result` | Format string type |\n\n### `sim.fmt.dec` (::circt::sim::FormatDecOp)\u00a0[\u00b6](#simfmtdec-circtsimformatdecop)\n\n*Decimal format specifier*\n\nSyntax:\n\n```\noperation ::= `sim.fmt.dec` $value\n              (`isLeftAligned` $isLeftAligned^)?\n              (`paddingChar` $paddingChar^)?\n              (`specifierWidth` $specifierWidth^)?\n              (`signed` $isSigned^)?\n              attr-dict `:` qualified(type($value))\n```\n\nFormat the given integer value as signed or unsigned decimal string.\n\nLeading zeros are omitted. Non-negative or unsigned values will\n*not* be prefixed with a \u2018+\u2019.\n\nFor unsigned formatting, the printed value will\nbe left-padded with spaces up to *at least* the length required to print\nthe maximum unsigned value of the argument\u2019s type.\nFor signed formatting, the printed value will be\nleft-padded with spaces up to *at least* the length required\nto print the minimum signed value of the argument\u2019s type\nincluding the \u2018-\u2019 character.\nE.g., a zero value of type `i1` requires no padding for unsigned\nformatting and one leading space for signed formatting.\nFormat specifiers of same argument type and signedness must be\npadded to the same width. Zero width values will produce\na single \u20180\u2019.\n\nBackends are recommended to not exceed the required amount of padding.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `ValueFormatter`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-5)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `isLeftAligned` | ::mlir::BoolAttr | bool attribute |\n| `paddingChar` | ::mlir::IntegerAttr | 8-bit signless integer attribute |\n| `specifierWidth` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `isSigned` | ::mlir::UnitAttr | unit attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-5)\n\n| Operand | Description |\n| --- | --- |\n| `value` | integer |\n\n#### Results:\u00a0[\u00b6](#results-3)\n\n| Result | Description |\n| --- | --- |\n| `result` | Format string type |\n\n### `sim.fmt.flt` (::circt::sim::FormatFloatOp)\u00a0[\u00b6](#simfmtflt-circtsimformatfloatop)\n\n*Real format specifier*\n\nSyntax:\n\n```\noperation ::= `sim.fmt.flt` $value\n              (`isLeftAligned` $isLeftAligned^)?\n              (`fieldWidth` $fieldWidth^)?\n              (`fracDigits` $fracDigits^)?\n              attr-dict `:` qualified(type($value))\n```\n\nFormat the given real value in floating point (decimal) notation\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `ValueFormatter`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-6)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `isLeftAligned` | ::mlir::BoolAttr | bool attribute |\n| `fieldWidth` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `fracDigits` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-6)\n\n| Operand | Description |\n| --- | --- |\n| `value` | floating-point |\n\n#### Results:\u00a0[\u00b6](#results-4)\n\n| Result | Description |\n| --- | --- |\n| `result` | Format string type |\n\n### `sim.fmt.gen` (::circt::sim::FormatGeneralOp)\u00a0[\u00b6](#simfmtgen-circtsimformatgeneralop)\n\n*Real format specifier*\n\nSyntax:\n\n```\noperation ::= `sim.fmt.gen` $value\n              (`isLeftAligned` $isLeftAligned^)?\n              (`fieldWidth` $fieldWidth^)?\n              (`fracDigits` $fracDigits^)?\n              attr-dict `:` qualified(type($value))\n```\n\nFormat floating-point numbers using either decimal or scientific notation\nbased on the exponent and precision parameter fracDigits (default: 6)\n\nFor exp \u2265 0:\nUses decimal notation if exp + 1 \u2264 max(1, fracDigits), otherwise switches\nto scientific notation with max(0, fracDigits - 1) fractional digits\n\nFor exp < 0:\nIf exp \u2265 -4: Uses decimal notation with max(b - 1, 0) + |exp| fractional digits\nIf exp < -4: Uses scientific notation with max(b - 1, 0) fractional digits\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `ValueFormatter`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-7)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `isLeftAligned` | ::mlir::BoolAttr | bool attribute |\n| `fieldWidth` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `fracDigits` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-7)\n\n| Operand | Description |\n| --- | --- |\n| `value` | floating-point |\n\n#### Results:\u00a0[\u00b6](#results-5)\n\n| Result | Description |\n| --- | --- |\n| `result` | Format string type |\n\n### `sim.fmt.hex` (::circt::sim::FormatHexOp)\u00a0[\u00b6](#simfmthex-circtsimformathexop)\n\n*Hexadecimal format specifier*\n\nSyntax:\n\n```\noperation ::= `sim.fmt.hex` $value `,`\n              `isUpper`  $isHexUppercase\n              (`isLeftAligned` $isLeftAligned^)?\n              (`paddingChar` $paddingChar^)?\n              (`specifierWidth` $specifierWidth^)?\n              attr-dict `:` qualified(type($value))\n```\n\nFormat the given integer value as lower-case hexadecimal string.\n\nThe printed value will be left-padded with \u20180\u2019 up to the\nlength required to print the maximum value of the argument\u2019s\ntype. Zero width values will produce the empty string.\nNo further prefix will be added.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `ValueFormatter`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-8)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `isHexUppercase` | ::mlir::BoolAttr | bool attribute |\n| `isLeftAligned` | ::mlir::BoolAttr | bool attribute |\n| `paddingChar` | ::mlir::IntegerAttr | 8-bit signless integer attribute |\n| `specifierWidth` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-8)\n\n| Operand | Description |\n| --- | --- |\n| `value` | integer |\n\n#### Results:\u00a0[\u00b6](#results-6)\n\n| Result | Description |\n| --- | --- |\n| `result` | Format string type |\n\n### `sim.fmt.literal` (::circt::sim::FormatLiteralOp)\u00a0[\u00b6](#simfmtliteral-circtsimformatliteralop)\n\n*Literal string fragment*\n\nSyntax:\n\n```\noperation ::= `sim.fmt.literal` $literal attr-dict\n```\n\nCreates a constant, raw ASCII string literal for formatted printing.\nThe given string attribute will be outputted as is,\nincluding non-printable characters. The literal may be empty or contain\nnull characters (\u2019\\0\u2019) which must not be interpreted as string\nterminators by backends.\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-9)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `literal` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-7)\n\n| Result | Description |\n| --- | --- |\n| `result` | Format string type |\n\n### `sim.fmt.oct` (::circt::sim::FormatOctOp)\u00a0[\u00b6](#simfmtoct-circtsimformatoctop)\n\n*Octal format specifier*\n\nSyntax:\n\n```\noperation ::= `sim.fmt.oct` $value\n              (`isLeftAligned` $isLeftAligned^)?\n              (`paddingChar` $paddingChar^)?\n              (`specifierWidth` $specifierWidth^)?\n              attr-dict `:` qualified(type($value))\n```\n\nFormat the given integer value as lower-case octal (base eight) string.\n\nThe printed value will be left-padded with \u20180\u2019 up to the\nlength required to print the maximum value of the argument\u2019s\ntype. Zero width values will produce the empty string.\nNo further prefix will be added.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `ValueFormatter`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-10)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `isLeftAligned` | ::mlir::BoolAttr | bool attribute |\n| `paddingChar` | ::mlir::IntegerAttr | 8-bit signless integer attribute |\n| `specifierWidth` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-9)\n\n| Operand | Description |\n| --- | --- |\n| `value` | integer |\n\n#### Results:\u00a0[\u00b6](#results-8)\n\n| Result | Description |\n| --- | --- |\n| `result` | Format string type |\n\n### `sim.fmt.exp` (::circt::sim::FormatScientificOp)\u00a0[\u00b6](#simfmtexp-circtsimformatscientificop)\n\n*Real format specifier*\n\nSyntax:\n\n```\noperation ::= `sim.fmt.exp` $value\n              (`isLeftAligned` $isLeftAligned^)?\n              (`fieldWidth` $fieldWidth^)?\n              (`fracDigits` $fracDigits^)?\n              attr-dict `:` qualified(type($value))\n```\n\nFormat the given real value in scientific (exponential) notation\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`, `ValueFormatter`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-11)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `isLeftAligned` | ::mlir::BoolAttr | bool attribute |\n| `fieldWidth` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `fracDigits` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-10)\n\n| Operand | Description |\n| --- | --- |\n| `value` | floating-point |\n\n#### Results:\u00a0[\u00b6](#results-9)\n\n| Result | Description |\n| --- | --- |\n| `result` | Format string type |\n\n### `sim.fmt.concat` (::circt::sim::FormatStringConcatOp)\u00a0[\u00b6](#simfmtconcat-circtsimformatstringconcatop)\n\n*Concatenate format strings*\n\nSyntax:\n\n```\noperation ::= `sim.fmt.concat` ` ` `(` $inputs `)` attr-dict\n```\n\nConcatenates an arbitrary number of format strings from\nleft to right. If the argument list is empty, the empty string\nliteral is produced.\n\nConcatenations must not be recursive. I.e., a concatenated string should\nnot contain itself directly or indirectly.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-11)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of Format string type |\n\n#### Results:\u00a0[\u00b6](#results-10)\n\n| Result | Description |\n| --- | --- |\n| `result` | Format string type |\n\n### `sim.string.int_to_string` (::circt::sim::IntToStringOp)\u00a0[\u00b6](#simstringint_to_string-circtsiminttostringop)\n\n*Convert an integer into a string*\n\nSyntax:\n\n```\noperation ::= `sim.string.int_to_string` $input attr-dict `:` qualified(type($input))\n```\n\nConverts an integer value to a string following Verilog semantics, where\nstring literals are represented as right-aligned bitvectors.\n\nThe operation reads the integer byte-by-byte, interpreting each non-zero\nbyte as an ASCII character. Zero-valued bytes are skipped and\nnot included in the output string. See Sec 6.16 of the standard saying\n\u201cA string variable shall not contain the special character \u201c\\0\u201d.\nAssigning the value 0 to a string character shall be ignored\u201d\n\nExample:\nConsider the hex value 0x00\\_00\\_00\\_48\\_00\\_00\\_6C\\_6F\nReading from MSB to LSB and filtering out null bytes:\n- 0x48 = \u2018H\u2019\n- 0x6C = \u2019l\u2019\n- 0x6F = \u2018o\u2019\nThis produces the string \u201cHlo\u201d, not \u201c\\0\\0\\0H\\0\\0lo\u201d.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-12)\n\n| Operand | Description |\n| --- | --- |\n| `input` | integer |\n\n#### Results:\u00a0[\u00b6](#results-11)\n\n| Result | Description |\n| --- | --- |\n| `result` | String type with variable length |\n\n### `sim.pause` (::circt::sim::PauseOp)\u00a0[\u00b6](#simpause-circtsimpauseop)\n\n*Pause the simulation*\n\nSyntax:\n\n```\noperation ::= `sim.pause` custom<KeywordBool>($verbose, \"\\\"verbose\\\"\" , \"\\\"quiet\\\"\") attr-dict\n```\n\nInterrupt the simulation and give control back to the user in case of an\ninteractive simulation. Non-interactive simulations may choose to terminate\ninstead. Depending on the `verbose` operand, simulators may print additional\ninformation about the current simulation time and hierarchical location of\nthe op.\n\nThis op corresponds to the following SystemVerilog constructs:\n\n| Operation | SystemVerilog |\n| --- | --- |\n| `sim.pause quiet` | `$stop(0)` |\n| `sim.pause verbose` | `$stop` or `$stop(1)` |\n\n#### Attributes:\u00a0[\u00b6](#attributes-12)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `verbose` | ::mlir::BoolAttr | bool attribute |\n\n### `sim.plusargs.test` (::circt::sim::PlusArgsTestOp)\u00a0[\u00b6](#simplusargstest-circtsimplusargstestop)\n\n*SystemVerilog `$test$plusargs` call*\n\nSyntax:\n\n```\noperation ::= `sim.plusargs.test` $formatString attr-dict\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-13)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `formatString` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-12)\n\n| Result | Description |\n| --- | --- |\n| `found` | 1-bit signless integer |\n\n### `sim.plusargs.value` (::circt::sim::PlusArgsValueOp)\u00a0[\u00b6](#simplusargsvalue-circtsimplusargsvalueop)\n\n*SystemVerilog `$value$plusargs` call*\n\nSyntax:\n\n```\noperation ::= `sim.plusargs.value` $formatString attr-dict `:` type($result)\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-14)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `formatString` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-13)\n\n| Result | Description |\n| --- | --- |\n| `found` | 1-bit signless integer |\n| `result` | any type |\n\n### `sim.print` (::circt::sim::PrintFormattedOp)\u00a0[\u00b6](#simprint-circtsimprintformattedop)\n\n*Print a formatted string on a given clock and condition*\n\nSyntax:\n\n```\noperation ::= `sim.print` $input `on` $clock `if` $condition attr-dict\n```\n\nEvaluate a format string and print it to the simulation console on the\nrising edge of the given clock, if, and only if, the condition argument\nis \u2019true\u2019.\n\nMultiple print operations in the same module and on the same clock edge\nare performed according to their order of occurence in the IR. The order\nof printing for operations in different modules, instances or on different\nclocks is undefined.\n\n#### Operands:\u00a0[\u00b6](#operands-13)\n\n| Operand | Description |\n| --- | --- |\n| `input` | Format string type |\n| `clock` | A type for clock-carrying wires |\n| `condition` | 1-bit signless integer |\n\n### `sim.proc.print` (::circt::sim::PrintFormattedProcOp)\u00a0[\u00b6](#simprocprint-circtsimprintformattedprocop)\n\n*Print a formatted string within a procedural region*\n\nSyntax:\n\n```\noperation ::= `sim.proc.print` $input attr-dict\n```\n\nEvaluate a format string and print it to the simulation console.\n\nThis operation must be within a procedural region.\n\n#### Operands:\u00a0[\u00b6](#operands-14)\n\n| Operand | Description |\n| --- | --- |\n| `input` | Format string type |\n\n### `sim.string.concat` (::circt::sim::StringConcatOp)\u00a0[\u00b6](#simstringconcat-circtsimstringconcatop)\n\n*Concatenate strings*\n\nSyntax:\n\n```\noperation ::= `sim.string.concat` ` ` `(` $inputs `)` attr-dict\n```\n\nConcatenates multiple strings into a single, longer string. The first\noperand appears first in the output string. The last character of the first\noperand is immediately followed by the first character of the second\noperand. If the operation has a single operand, its result is equal to that\noperand. If the operation has zero operands, it returns an empty string.\nThe length of the result is the sum of each operand\u2019s length.\n\nExample:\n\n```\n%0 = sim.string.literal \"abc\"\n%1 = sim.string.literal \"def\"\n%2 = sim.string.literal \"ghj\"\n%3 = sim.string.concat (%0, %1, %2)  // %3 is \"abcdefghj\"\n%4 = sim.string.concat (%0)          // %4 is \"abc\"\n%5 = sim.string.concat ()            // %5 is \"\"\n```\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-15)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of String type with variable length |\n\n#### Results:\u00a0[\u00b6](#results-14)\n\n| Result | Description |\n| --- | --- |\n| `result` | String type with variable length |\n\n### `sim.string.literal` (::circt::sim::StringConstantOp)\u00a0[\u00b6](#simstringliteral-circtsimstringconstantop)\n\n*Literal string fragment*\n\nSyntax:\n\n```\noperation ::= `sim.string.literal` $literal attr-dict\n```\n\nCreates a dynamic string from a constant string literal.\n\nTraits: `AlwaysSpeculatableImplTrait`, `ConstantLike`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-15)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `literal` | ::mlir::StringAttr | string attribute |\n\n#### Results:\u00a0[\u00b6](#results-15)\n\n| Result | Description |\n| --- | --- |\n| `result` | String type with variable length |\n\n### `sim.string.length` (::circt::sim::StringLengthOp)\u00a0[\u00b6](#simstringlength-circtsimstringlengthop)\n\n*Length of a string*\n\nSyntax:\n\n```\noperation ::= `sim.string.length` $input attr-dict\n```\n\nReturns the length of a dynamic string as an `i64` value.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Operands:\u00a0[\u00b6](#operands-16)\n\n| Operand | Description |\n| --- | --- |\n| `input` | String type with variable length |\n\n#### Results:\u00a0[\u00b6](#results-16)\n\n| Result | Description |\n| --- | --- |\n| `result` | 64-bit signless integer |\n\n### `sim.terminate` (::circt::sim::TerminateOp)\u00a0[\u00b6](#simterminate-circtsimterminateop)\n\n*Terminate the simulation*\n\nSyntax:\n\n```\noperation ::= `sim.terminate` custom<KeywordBool>($success, \"\\\"success\\\"\", \"\\\"failure\\\"\") `,`\n              custom<KeywordBool>($verbose, \"\\\"verbose\\\"\" , \"\\\"quiet\\\"\") attr-dict\n```\n\nTerminate the simulation with a success or failure exit code. Depending on\nthe `verbose` operand, simulators may print additional information about the\ncurrent simulation time and hierarchical location of the op.\n\nThis op correpsonds to the following SystemVerilog constructs:\n\n| Operation | SystemVerilog |\n| --- | --- |\n| `sim.terminate success, quiet` | `$finish(0)` |\n| `sim.terminate success, verbose` | `$finish` or `$finish(1)` |\n| `sim.terminate failure, quiet` | `$fatal(0)` |\n| `sim.terminate failure, verbose` | `$fatal` or `$fatal(1)` |\n\nNote that this op does not match the behavior of the `$exit` system task in\nSystemVerilog, which blocks execution of the calling process until all\n`program` instances have terminated, and then calls `$finish`.\n\n#### Attributes:\u00a0[\u00b6](#attributes-16)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `success` | ::mlir::BoolAttr | bool attribute |\n| `verbose` | ::mlir::BoolAttr | bool attribute |\n\n [Prev - Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/ \"Random Test Generation (RTG) Rationale\")\n[Next - SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/ \"SMT Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/SMT/index.md"
  },
  {
    "role": "user",
    "content": "SMT Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nSMT Dialect\n===========\n\nThis dialect provides types and operations modeling the SMT (Satisfiability\nModulo Theories) operations and datatypes commonly found in SMT-LIB and SMT\nsolvers.\n\n* [Rationale](#rationale)\n* [Dialect Structure](#dialect-structure)\n* [Optimizations](#optimizations)\n* [Backends](#backends)\n  + [LLVM IR](#llvm-ir)\n  + [SMT-LIB](#smt-lib)\n  + [C/C++](#cc)\n* [Handling counter-examples](#handling-counter-examples)\n* [Non-Goals](#non-goals)\n* [Operations](#operations)\n* [Types](#types)\n\nRationale\u00a0[\u00b6](#rationale)\n-------------------------\n\nThis dialect aims to provide a unified interface for expressing SMT problems\ndirectly within MLIR, enabling seamless integration with other MLIR dialects and\noptimization passes. It models the\n[SMT-LIB standard\n2.6](https://smtlib.cs.uiowa.edu/), but may also include features of commonly\nused SMT solvers that are not part of the standard. In particular, the IR\nconstructs are designed to enable more interactive communication with the solver\n(allowing if-statements, etc. to react on solver feedback).\n\nThe SMT dialect is motivated by the following advantages over directly printing\nSMT-LIB or exporting to a solver:\n\n* Reuse MLIR\u2019s infrastructure: passes and pass managers to select different SMT\n  encodings, operation builders and rewrite patterns to build SMT formulae (and\n  hide the solver\u2019s API in a provided lowering pass), common textual format to\n  share rather than dumping the solver\u2019s state, etc.\n* No need to add a link-dependency on SMT solvers to CIRCT (just provide the\n  path to the library as an argument to the JIT runner or manually link the\n  produced binary against it).\n* Using an SMT dialect as intermediary allows it to be mixed with concrete\n  computations, the debug dialect, etc. This is complicated to achieve and\n  reason about when building the external solver\u2019s state directly.\n* Enable easy addition of new backends\n* Have a common representation and infrastructure for all SMT related efforts,\n  such that people don\u2019t have to build their own isolated tools.\n\nThe dialect follows these design principles:\n\n* **Solver-independent**: don\u2019t model one particular solver\u2019s API\n* **Seemless interoperability** with other dialects. E.g., to allow using the\n  debug dialect to back-propagate counter examples\n* **Small surface for errors**: try to keep the SMT dialect and its lowerings\n  simple to avoid mistakes, implement optimizations defensively or prove them\n  formally; since higher-level dialects will be lowered through the SMT dialect\n  to construct formal proofs it is essential that this dialect does not\n  introduce bugs\n* **Interactive**: the IR should be designed such that it can be interleaved\n  with operations (from other dialects) that take the current feedback of the\n  solver to steer the execution of further SMT operations. It shouldn\u2019t just\n  model the very rigid SMT-LIB.\n* Don\u2019t heavily integrate the dialect itself with CIRCT to make potential\n  upstreaming easy\n\nDialect Structure\u00a0[\u00b6](#dialect-structure)\n-----------------------------------------\n\nThe SMT dialect is structured into multiple \u201csub-dialects\u201d, one for each of the\nfollowing theories (this separation is also made clear in the prefix of\noperation and type names as indicated in parentheses):\n\n* Core boolean logic including quantifiers and solver interaction (`smt.*`)\n* Bit-vectors (`smt.bv.*`)\n* Arbitrary-precision integers (`smt.int.*`)\n* Arrays (`smt.array.*`)\n* Floating-point numbers (`smt.real.*`)\n\nSeveral operations in the core part (e.g., quantifiers, equality, etc.) allow\noperands of any SMT type (including bit-vectors, arrays, etc.). Therefore, all\ntype and attribute declarations are part of the core.\n\nCertain arithmetic, bitwise, and comparison operations exist for multiple\ntheories. For example, there exists an AND operation for booleans and one for\nbit-vectors, or there exists and ADD operation for integers and bit-vectors. In\nsuch cases, each \u201csub-dialect\u201d defines its own operation specific to its\ndatatypes. This simplifies the operations such that an optimization or\nconversion pass only using bit-vectors does not have to take care of other\npotentially supported datatypes.\n\nOptimizations\u00a0[\u00b6](#optimizations)\n---------------------------------\n\nThe primary purpose of the SMT dialect is not to optimize SMT formulae. However,\nSMT solvers can exhibit significant differences in runtime, even with slight\nchanges in input. Improving solver performance by implementing rewrite patterns\nthat slightly restructure the SMT formulae may be possible.\n\nMoreover, SMT solvers may differ in terms of built-in operators. If a solver\nlacks support for advanced operators, the problem can be simplified before\npassing it to the solver.\n\nBackends\u00a0[\u00b6](#backends)\n-----------------------\n\nHaving an SMT dialect instead of directly interpreting the IR and building an\nSMT expression enables multiple different backends to be used in addition to the\napplication of SMT dialect level optimizations that rewrite the formulae for\nfaster and more predictable runtime performance of the solver backend (e.g.,\nZ3).\n\nIn the following, we outline the different backend lowerings and their\nadvantages and disadvantages.\n\n### LLVM IR\u00a0[\u00b6](#llvm-ir)\n\nLowering to LLVM IR that calls the C API of a given SMT solver is practical for\na few reasons:\n\n* enables using LLVM JIT or compilation to a standalone binary\n* easy to mix with Debug dialect to report back nice counter examples\n* allows mixing concrete and symbolic executions (e.g., for dynamic BMC upper\n  bounds, or more dynamic interaction with the solver such as extraction of\n  multiple/all possible models)\n\nHowever, it is solver-dependent and more complicated to implement than an\nSMT-LIB printer.\n\n### SMT-LIB\u00a0[\u00b6](#smt-lib)\n\nThe SMT-LIB format is a standardized format supported by practically all SMT\nsolvers and thus an ideal target to support as many solver backends as possible.\nHowever,\n\n* this format is quite static and does not allow easy interaction with the\n  solver, in particular, it is not easily possible to make future asserts\n  dependent on current solver outputs,\n* providing good counter-examples to the user would mean parsing the textual\n  model output of the solver and mapping it to an CIRCT-internal datastructure.\n* it is impossible to mix symbolic and concrete executions, as well as debug\n  constructs (see Debug Dialect).\n* it is impossible to just use the LLVM JIT compiler to directly get a result,\n  but instead the external solver has to be called directly, either by adding a\n  compile-time dependency, or using a shell call.\n\n### C/C++\u00a0[\u00b6](#cc)\n\nA C/C++ exporter that produces code which calls the C/C++ API of a given solver\ncould allow for easier debugging and allows to support solvers without C API\nwithout the restrictions of SMT-LIB. However, this means the JIT compilation\nflow would not be available.\n\nHandling counter-examples\u00a0[\u00b6](#handling-counter-examples)\n---------------------------------------------------------\n\nSMT solvers check formulae for satisfiability. Typically, there are three kinds\nof output a solver may give:\n\n* **Satisfiable**: In this case a model (counter-example) can be provided by the\n  solver. However, it may not be feasible to evaluate/interpret this model for a\n  given SMT constant to get a constant value. This is, in particular, the case\n  when the SMT encoding contains quantifiers which can lead to the model\n  containing quantifiers as well. Solvers (e.g., Z3) usually don\u2019t evaluate\n  quantifiers in models (even if they are closed). If constants can be\n  evaluated, a counter example can be provided and back-propagated to the\n  source-code, e.g., using the debug dialect.\n* **Unsatisfiable**: formal verification problems are typically encoded such\n  that this output indicates correctness; a proof can be provided by the solver,\n  but is often not needed\n* **Unknown**: there can be various reasons why the result is unknown; a common\n  one is the use of symbolic functions to represent operators and encode, e.g.,\n  a LEC problem as a rewrite task of patterns of function applications. This is\n  a frequent application and the unknown result is just treated like a\n  satisfiable result without counter example.\n\nNon-Goals\u00a0[\u00b6](#non-goals)\n-------------------------\n\n* The SMT Dialect does not aim to include any operations or types that model\n  verification constructs not specific to SMT, i.e., things that could also be\n  lowered to other kind of verification systems such as inductive theorem\n  provers (e.g., Lean4).\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\nTypes\u00a0[\u00b6](#types)\n-----------------\n\n [Prev - Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/ \"Simulation Dialect\")\n[Next - Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/ \"Verif Dialect\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Dialects/Verif/index.md"
  },
  {
    "role": "user",
    "content": "Verif Dialect - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nVerif Dialect\n=============\n\nThis dialect provides a collection of operations to express various verification concerns, such as assertions and interacting with a piece of hardware for the sake of verifying its proper functioning.\n\n* [Contracts](#contracts)\n  + [Multiply-by-9 Example](#multiply-by-9-example)\n  + [Carry-Save Compressor Example](#carry-save-compressor-example)\n  + [Carry-Save Adder Example](#carry-save-adder-example)\n  + [Multiplexer-based Shifter](#multiplexer-based-shifter)\n* [Operations](#operations)\n  + [`verif.assert` (circt::verif::AssertOp)](#verifassert-circtverifassertop)\n  + [`verif.assume` (circt::verif::AssumeOp)](#verifassume-circtverifassumeop)\n  + [`verif.bmc` (circt::verif::BoundedModelCheckingOp)](#verifbmc-circtverifboundedmodelcheckingop)\n  + [`verif.clocked_assert` (circt::verif::ClockedAssertOp)](#verifclocked_assert-circtverifclockedassertop)\n  + [`verif.clocked_assume` (circt::verif::ClockedAssumeOp)](#verifclocked_assume-circtverifclockedassumeop)\n  + [`verif.clocked_cover` (circt::verif::ClockedCoverOp)](#verifclocked_cover-circtverifclockedcoverop)\n  + [`verif.contract` (circt::verif::ContractOp)](#verifcontract-circtverifcontractop)\n  + [`verif.cover` (circt::verif::CoverOp)](#verifcover-circtverifcoverop)\n  + [`verif.ensure` (circt::verif::EnsureOp)](#verifensure-circtverifensureop)\n  + [`verif.formal` (circt::verif::FormalOp)](#verifformal-circtverifformalop)\n  + [`verif.format_verilog_string` (circt::verif::FormatVerilogStringOp)](#verifformat_verilog_string-circtverifformatverilogstringop)\n  + [`verif.has_been_reset` (circt::verif::HasBeenResetOp)](#verifhas_been_reset-circtverifhasbeenresetop)\n  + [`verif.lec` (circt::verif::LogicEquivalenceCheckingOp)](#veriflec-circtveriflogicequivalencecheckingop)\n  + [`verif.print` (circt::verif::PrintOp)](#verifprint-circtverifprintop)\n  + [`verif.refines` (circt::verif::RefinementCheckingOp)](#verifrefines-circtverifrefinementcheckingop)\n  + [`verif.require` (circt::verif::RequireOp)](#verifrequire-circtverifrequireop)\n  + [`verif.simulation` (circt::verif::SimulationOp)](#verifsimulation-circtverifsimulationop)\n  + [`verif.symbolic_value` (circt::verif::SymbolicValueOp)](#verifsymbolic_value-circtverifsymbolicvalueop)\n  + [`verif.yield` (circt::verif::YieldOp)](#verifyield-circtverifyieldop)\n\nContracts\u00a0[\u00b6](#contracts)\n-------------------------\n\nFormal contracts are a key building block of the Verif dialect to help make formal verification scale to larger designs and deep module hierarchies.\nContracts describe what a circuit expects from its inputs (`verif.require`) and what it guarantees its output to be (`verif.ensure`).\nThe `verif.contract` op can be inserted into an SSA edge similar to an `hw.wire`, where the contract simply passes its operands through to its results.\nDuring formal verification the contract results are replaced by symbolic values that uphold the guarantees described in the contract\u2019s body.\nConceptually, contracts are similar to Hoare triples used in software verification, where a piece of code is verified to produce a given set of postconditions when the given set of preconditions is met.\n\nThese contracts can then be used in two key ways:\n\n1. A contract can be *checked* by turning `require`s into `assume`s and `ensure`s into `assert`s.\n   Doing so verifies that a circuit upholds the contract by placing asserts on the values it produces, and by placing assumes on the input values the circuit sees.\n   In a nutshell, this checks that, assuming the inputs to the circuit honor the contract, the output from the circuit also upholds the contract.\n   This check can be done very efficiently by creating `verif.formal` ops to verify each contract.\n2. A contract can be *applied* by turning `require`s into `assert`s and `ensure`s into `assume`s.\n   Doing so verifies that the inputs fed into a circuit uphold the contract, such that the outputs can be assumed to have the promised values.\n   In a nutshell, this checks that the inputs to a circuit honor the contract and therefore the circuit can be assumed to uphold the contract.\n   Assuming a contract can often eliminate large parts of the circuit\u2019s actual implementation, since the contracts tend to be a simpler description of a circuit\u2019s functionality.\n\n### Multiply-by-9 Example\u00a0[\u00b6](#multiply-by-9-example)\n\nConsider the following example of a HW module that computes `9 * a` using a left-shift and an addition.\nNote that this is using `verif.ensure_equal` as a standin for `verif.ensure(comb.icmp eq)`.\nThe module\u2019s output `%z` is the result of a `verif.contract` operation.\nContracts can be completely ignored by simply passing through their operands, `%1` in this case, to their results.\nThis is their normal interpretation outside a formal verification flow, for example for synthesis.\n\n```\nhw.module @Mul9(in %a: i42, out z: i42) {\n  // Compute 9*a as (a<<3)+a.\n  %c3_i42 = hw.constant 3 : i42\n  %0 = comb.shl %a, %c3_i42 : i42\n  %1 = comb.add %a, %0 : i42\n\n  // Contract to check that the circuit actually produces 9*a.\n  %z = verif.contract %1 : i42 {\n    %c9_i42 = hw.constant 9 : i42\n    %a9 = comb.mul %a, %c9_i42 : i42\n    verif.ensure_equal %z, %a9\n  }\n\n  hw.output %z : i42\n}\n```\n\nTo check that the contract holds, it can be pulled out into a `verif.formal` op along with all ops in its fan-in cone.\nThe contract\u2019s results are then replaced with its operands, the body is inlined, and `ensure` ops are replaced with `assert` and `require` ops are replaced with `assume`.\nRunning this formal test will check that the `(a<<3)+a` implemented by the module is indeed the same as the `9*a` promised by the contract.\n\n```\nverif.formal @Mul9_CheckContract {\n  %a = verif.symbolic_value : i42\n\n  %c3_i42 = hw.constant 3 : i42\n  %0 = comb.shl %a, %c3_i42 : i42\n  %1 = comb.add %a, %0 : i42\n\n  // Contract inlined with ensure -> assert, %z -> %1\n  %c9_i42 = hw.constant 9 : i42\n  %a9 = comb.mul %a, %c9_i42 : i42\n  verif.assert_equal %1, %a9 : i42\n}\n```\n\nOnce the contract is checked, it can be assumed to hold everywhere.\nAssuming it holds can be done by inlining it into its parent block and replacing its results with symbolic values.\nAt the same time, `ensure`s are replaced with `assume`s and `require`s with `assert`s.\nInlining the contract in this example and replacing the symbolic value with what it is assumed to be equal to will make the module produce the simple `9*a` term.\nThis means that the ops describing the original implementation become obsolete and will be DCEd.\nMaking bits of a module\u2019s implementation unused is *the* key characteristic of contracts that makes them help formal verification scale.\nIf all of a module\u2019s behavior can be described by one or more simpler contracts, its entire original implementation would simply disappear in favor of the simpler contracts.\n\n```\nhw.module @Mul9_ApplyContract(in %a: i42, out z: i42) {\n  // The original implementation has become unused since the contract results\n  // have been replaced with symbolic values. Dead code elimination will clean\n  // this up.\n  %c3_i42 = hw.constant 3 : i42\n  %0 = comb.shl %a, %c3_i42 : i42\n  %1 = comb.add %a, %0 : i42\n\n  // Results of the contract are replaced with symbolic values.\n  // Contract inlined with ensure -> assume, %z -> %any\n  // assume(eq(any, x)) can be canonicalized to an any -> x replacement.\n  %any = verif.symbolic_value : i42\n  %c9_i42 = hw.constant 9 : i42\n  %a9 = comb.mul %a, %c9_i42 : i42\n  verif.assume_equal %any, %a9 : i42\n\n  hw.output %any : i42\n}\n\n// ----- after canonicalization, CSE, and DCE ----- //\n\nhw.module @Mul9_ApplyContract_Simplified(in %a: i42, out z: i42) {\n  %c9_i42 = hw.constant 9 : i42\n  %a9 = comb.mul %a, %c9_i42 : i42\n  hw.output %a9 : i42\n}\n```\n\nThese two constructs can coexist in the IR.\nA contract can be turned into a `verif.formal` proof that it holds, and inlined everywhere else to leverage the fact that the contract holds.\n\n### Carry-Save Compressor Example\u00a0[\u00b6](#carry-save-compressor-example)\n\nConsider the following slightly more involved example of a compression stage you would find in a carry-save adder.\nThis module takes 3 input values and produces 2 output values that sum up to the same value as its inputs.\nHowever, the contract in the module does not specify which *exact* output values the module produces.\nInstead, it uses two symbolic values to express that the module can produce *any* output values that sum up to the inputs.\nIn a sense, how exactly the compressor combines 3 values into 2 is left as an implementation detail that you can\u2019t know about, but the guarantee you can work with is that the sum will be correct.\nThis is different from the previous example, where the contract produced an exact replacement value for the module output.\nAlso, note how this uses an `assume` to constrain the sum of the symbolic values instead of an `ensure` or `require`.\n\n```\n// A module that takes 3 input values and produces 2 output values that sum up\n// to the same value as the inputs. Instead of just using add it uses a\n// bit-parallel full adder that takes each 3-tuple of bits in the 3 inputs, runs\n// them through a full adder, and treats the resulting sum and carry as the 2\n// corresponding bits for its 2 output values.\nhw.module @CarrySaveCompress3to2(\n  in %a0: i42, in %a1: i42, in %a2: i42,\n  out z0: i42, out z1: i42\n) {\n  %c1_i42 = hw.constant 1 : i42\n  %0 = comb.xor %a0, %a1, %a2 : i42  // sum bits of FA (a0^a1^a2)\n  %1 = comb.and %a0, %a1 : i42\n  %2 = comb.or %a0, %a1 : i42\n  %3 = comb.and %2, %a2 : i42\n  %4 = comb.or %1, %3 : i42          // carry bits of FA (a0&a1 | a2&(a0|a1))\n  %5 = comb.shl %4, %c1_i42 : i42    // %5 = carry << 1\n  // At this point, %0+%5 is the same as %a0+%a1+%a2, but without creating a\n  // long ripple-carry chain.\n\n  // Contract to check that we output _some_ two numbers that sum up to the same\n  // value as the sum of the three inputs. We don't say which exact numbers.\n  %z0, %z1 = verif.contract %0, %5 {\n    // The contract promises that its outputs will sum up to the same value as\n    // the sum of the module inputs.\n    %inputSum = comb.add %a0, %a1, %a2 : i42\n    %outputSum = comb.add %z0, %z1 : i42\n    verif.ensure_equal %inputSum, %outputSum : i42\n  }\n\n  hw.output %z0, %z1 : i42, i42\n}\n```\n\nThe contract can be checked by extracting it into a new `verif.formal` op alongside its entire fan-in cone.\nAgain we pretend that the contract doesn\u2019t exist by passing its operands `%0` and `%5`, the actual implementation, through to its results `%z0` and `%z1`.\nReplacing ensures with asserts then verifies that the module\u2019s outputs do indeed sum up to the same value as the inputs.\n\n```\nverif.formal @CarrySaveCompress3to2_CheckContract {\n  %a0 = verif.symbolic_value : i42\n  %a1 = verif.symbolic_value : i42\n  %a2 = verif.symbolic_value : i42\n\n  %c1_i42 = hw.constant 1 : i42\n  %0 = comb.xor %a0, %a1, %a2 : i42\n  %1 = comb.and %a0, %a1 : i42\n  %2 = comb.or %a0, %a1 : i42\n  %3 = comb.and %2, %a2 : i42\n  %4 = comb.or %1, %3 : i42\n  %5 = comb.shl %4, %c1_i42 : i42\n\n  // Contract inlined with ensure -> assert, (%z0, %z1) -> (%0, %5).\n  %inputSum = comb.add %a0, %a1, %a2 : i42\n  %outputSum = comb.add %0, %5 : i42\n  verif.assert_equal %inputSum, %outputSum : i42\n}\n```\n\nWith the contract checked it can be assumed to hold by inlining it everywhere and replacing its results `%z0` and `%z1` with symbolic values.\nThis provides the symbolic values as a replacement for the actual implementation of the module, which causes the entire original implementation to be DCEd.\n\n```\nhw.module @CarrySaveCompress3to2_ApplyContract(\n  in %a0: i42, in %a1: i42, in %a2: i42,\n  out z0: i42, out z1: i42\n) {\n  // The original implementation has become unused since the contract results\n  // have been replaced with symbolic values. Dead code elimination will clean\n  // this up.\n  %c1_i42 = hw.constant 1 : i42\n  %0 = comb.xor %a0, %a1, %a2 : i42\n  %1 = comb.and %a0, %a1 : i42\n  %2 = comb.or %a0, %a1 : i42\n  %3 = comb.and %2, %a2 : i42\n  %4 = comb.or %1, %3 : i42\n  %5 = comb.shl %4, %c1_i42 : i42\n\n  // Results of the contract are replaced with symbolic values.\n  // Contract inlined with ensure -> assume, (%z0, %z1) -> (%any0, %any1).\n  %any0 = verif.symbolic_value : i42\n  %any1 = verif.symbolic_value : i42\n  %inputSum = comb.add %a0, %a1, %a2 : i42\n  %outputSum = comb.add %any0, %any1 : i42\n  verif.assume_equal %inputSum, %outputSum : i42\n\n  hw.output %any0, %any1 : i42, i42\n}\n\n// ----- after canonicalization, CSE, and DCE ----- //\n\nhw.module @CarrySaveCompress3to2_ApplyContract_Simplified(\n  in %a0: i42, in %a1: i42, in %a2: i42,\n  out z0: i42, out z1: i42\n) {\n  %any0 = verif.symbolic_value : i42\n  %any1 = verif.symbolic_value : i42\n  %inputSum = comb.add %a0, %a1, %a2 : i42\n  %outputSum = comb.add %any0, %any1 : i42\n  verif.assume_equal %inputSum, %outputSum : i42\n  hw.output %any0, %any1 : i42, i42\n}\n```\n\n### Carry-Save Adder Example\u00a0[\u00b6](#carry-save-adder-example)\n\nConsider the following carry-save adder built based on the compressor from the previous example.\nIt takes 5 input values and sums them up.\nTo do so, it uses multiple instances of the compressor to compress three of the input terms down to two iteratively, until only two terms are left.\nThe remaining two terms are then summed up with a plain old adder to get the final result.\nThis carry-save adder module has its own little contract which promises that the output is going to be the sum of all input terms.\n\n```\n// A module that takes 5 input values and sums them up using a carry save adder.\nhw.module @CarrySaveAdder5(\n  in %a0: i42, in %a1: i42, in %a2: i42, in %a3: i42, in %a4: i42,\n  out z: i42\n) {\n  // Each stage takes 3 of the terms and compresses them to 2.\n  // terms: [a0, a1, a2, a3, a4]\n  %b0, %b1 = hw.instance \"comp0\" @CarrySaveCompress3to2(a0: %a0: i42, a1: %a1: i42, a2: %a2: i42) -> (z0: i42, z1: i42)\n  // terms: [b0, b1, a3, a4]\n  %c0, %c1 = hw.instance \"comp1\" @CarrySaveCompress3to2(a0: %b1: i42, a1: %a3: i42, a2: %a4: i42) -> (z0: i42, z1: i42)\n  // terms: [b0, c0, c1]\n  %d0, %d1 = hw.instance \"comp2\" @CarrySaveCompress3to2(a0: %b0: i42, a1: %c0: i42, a2: %c1: i42) -> (z0: i42, z1: i42)\n  // terms: [d0, d1]\n  %e = comb.add %d0, %d1 : i42\n  // terms: [e]\n\n  // Contract to check that the output is the sum of all inputs.\n  %z = verif.contract %e {\n    %inputSum = comb.add %a0, %a1, %a2, %a3, %a4, %a5 : i42\n    verif.ensure_equal %z, %inputSum : i42\n  }\n\n  hw.output %z : i42\n}\n```\n\nChecking the contract looks as follows.\nNote how the formal proof can already assume that contracts inside the compressor submodule hold.\nThis is a neat example of recursive use of contracts, and how checking contracts in parent modules can benefit from contracts in child modules.\nInstead of having to include the compressor module implementation in this test again, potentially complicating the proof, we can already use the simplified version described by the compressor\u2019s contract.\nThis turns the compressor instances basically into a few additions among symbolic values, which formal solvers are very good at working with.\n\n```\nverif.formal @CarrySaveAdder5_CheckContract {\n  %a0 = verif.symbolic_value : i42\n  %a1 = verif.symbolic_value : i42\n  %a2 = verif.symbolic_value : i42\n  %a3 = verif.symbolic_value : i42\n  %a4 = verif.symbolic_value : i42\n\n  // The following instances are just two symbolic values each, constrained to\n  // sum up to the instance inputs. This makes for a more trivial solve.\n  %b0, %b1 = hw.instance \"comp0\" @CarrySaveCompress3to2_ApplyContract(a0: %a0: i42, a1: %a1: i42, a2: %a2: i42) -> (z0: i42, z1: i42)\n  %c0, %c1 = hw.instance \"comp1\" @CarrySaveCompress3to2_ApplyContract(a0: %b1: i42, a1: %a3: i42, a2: %a4: i42) -> (z0: i42, z1: i42)\n  %d0, %d1 = hw.instance \"comp2\" @CarrySaveCompress3to2_ApplyContract(a0: %b0: i42, a1: %c0: i42, a2: %c1: i42) -> (z0: i42, z1: i42)\n  %e = comb.add %d0, %d1 : i42\n\n  // Contract inlined with ensure -> assert, %z -> %e.\n  %inputSum = comb.add %a0, %a1, %a2, %a3, %a4, %a5 : i42\n  verif.assert_equal %e, %inputSum : i42\n}\n```\n\nThe contract can then be assumed to hold by inlining it into the carry-save adder as follows.\n\n```\nhw.module @CarrySaveAdder5_ApplyContract(\n  in %a0: i42, in %a1: i42, in %a2: i42, in %a3: i42, in %a4: i42,\n  out z: i42\n) {\n  // The original implementation has become unused since the contract results\n  // have been replaced with symbolic values. Dead code elimination will clean\n  // this up.\n  %b0, %b1 = hw.instance \"comp0\" @CarrySaveCompress3to2_ApplyContract(a0: %a0: i42, a1: %a1: i42, a2: %a2: i42) -> (z0: i42, z1: i42)\n  %c0, %c1 = hw.instance \"comp1\" @CarrySaveCompress3to2_ApplyContract(a0: %b1: i42, a1: %a3: i42, a2: %a4: i42) -> (z0: i42, z1: i42)\n  %d0, %d1 = hw.instance \"comp2\" @CarrySaveCompress3to2_ApplyContract(a0: %b0: i42, a1: %c0: i42, a2: %c1: i42) -> (z0: i42, z1: i42)\n  %e = comb.add %d0, %d1 : i42\n\n  // Results of the contract are replaced with symbolic values.\n  // Contract inlined with ensure -> assume, %z -> %any.\n  %any = verif.symbolic_value : i42\n  %inputSum = comb.add %a0, %a1, %a2, %a3, %a4, %a5 : i42\n  // assume(eq(any, x)) can be canonicalized to an any -> x replacement.\n  verif.assume_equal %any, %inputSum : i42\n\n  hw.output %any : i42\n}\n\n// ----- after canonicalization, CSE, and DCE ----- //\n\nhw.module @CarrySaveAdder5_ApplyContract_Simplified(\n  in %a0: i42, in %a1: i42, in %a2: i42, in %a3: i42, in %a4: i42,\n  out z: i42\n) {\n  %inputSum = comb.add %a0, %a1, %a2, %a3, %a4, %a5 : i42\n  hw.output %inputSum : i42\n}\n```\n\n### Multiplexer-based Shifter\u00a0[\u00b6](#multiplexer-based-shifter)\n\nConsider the following module that left-shifts a value.\nIt uses a multiplexer tree to perform the shift, which cannot shift out the value completely.\nTherefore, a `require` is placed in its contract to force the users of the shifter to never provide shift amounts outside the valid range.\n\n```\nhw.module @ShiftLeft(in %a: i8, in %b: i8, out z: i8) {\n  %c4_i8 = hw.constant 4 : i8\n  %c2_i8 = hw.constant 2 : i8\n  %c1_i8 = hw.constant 1 : i8\n  %b2 = comb.extract %b, 2 : i8 -> i1\n  %b1 = comb.extract %b, 1 : i8 -> i1\n  %b0 = comb.extract %b, 0 : i8 -> i1\n  %0 = comb.shl %a, %c4_i8 : i8\n  %1 = comb.mux %b2, %0, %a : i8\n  %2 = comb.shl %1, %c2_i8 : i8\n  %3 = comb.mux %b1, %2, %1 : i8\n  %4 = comb.shl %3, %c1_i8 : i8\n  %5 = comb.mux %b0, %4, %3 : i8\n\n  // Contract to check that the multiplexers and constant shifts above indeed\n  // produce the correct shift by 0 to 7 places, assuming the shift amount is\n  // less than 8 (we can't shift a number out).\n  %z = verif.contract %5 {\n    // Shift amount must be less than 8.\n    %c8_i8 = hw.constant 8 : i8\n    %blt8 = comb.icmp ult %b, %c8_i8 : i8\n    verif.require %blt8\n\n    // In that case the mux tree computes the correct left-shift.\n    %ashl = comb.shl %a, %b : i8\n    verif.ensure_equal %z, %ashl : i42\n  }\n\n  hw.output %z : i8\n}\n```\n\nThe contract in the shifter can be checked as follows.\nNote how the `require` is replaced by an `assume` in addition to the `ensure` being replaced by an `assert`.\n\n```\nverif.formal @ShiftLeft_CheckContract {\n  %a = verif.symbolic_value : i8\n  %b = verif.symbolic_value : i8\n\n  %c4_i8 = hw.constant 4 : i8\n  %c2_i8 = hw.constant 2 : i8\n  %c1_i8 = hw.constant 1 : i8\n  %b2 = comb.extract %b, 2 : i8 -> i1\n  %b1 = comb.extract %b, 1 : i8 -> i1\n  %b0 = comb.extract %b, 0 : i8 -> i1\n  %0 = comb.shl %a, %c4_i8 : i8\n  %1 = comb.mux %b2, %0, %a : i8\n  %2 = comb.shl %1, %c2_i8 : i8\n  %3 = comb.mux %b1, %2, %1 : i8\n  %4 = comb.shl %3, %c1_i8 : i8\n  %5 = comb.mux %b0, %4, %3 : i8\n\n  // Contract inlined with ensure -> assert, require -> assume, %z -> %5.\n  %c8_i8 = hw.constant 8 : i8\n  %blt8 = comb.icmp ult %b, %c8_i8 : i8\n  verif.assume %blt8\n  %ashl = comb.shl %a, %b : i8\n  verif.assert_equal %5, %ashl : i42\n}\n```\n\nOnce checked, the contract can be assumed to hold by inlining it into the shift-left module as follows.\nNote how the value of input `b` is now asserted to be less than 8.\nThis causes the instantiation sites of this module to be checked to provide values for `b` that are less than 8, thus upholding the contract.\nAt the same time, it allows those sites to use the simplified `comb.shl %a, %b` implementation described in the contract.\n\n```\nhw.module @ShiftLeft_ApplyContract(in %a: i8, in %b: i8, out z: i8) {\n  // The original implementation has become unused since the contract results\n  // have been replaced with symbolic values. Dead code elimination will clean\n  // this up.\n  %c4_i8 = hw.constant 4 : i8\n  %c2_i8 = hw.constant 2 : i8\n  %c1_i8 = hw.constant 1 : i8\n  %b2 = comb.extract %b, 2 : i8 -> i1\n  %b1 = comb.extract %b, 1 : i8 -> i1\n  %b0 = comb.extract %b, 0 : i8 -> i1\n  %0 = comb.shl %a, %c4_i8 : i8\n  %1 = comb.mux %b2, %0, %a : i8\n  %2 = comb.shl %1, %c2_i8 : i8\n  %3 = comb.mux %b1, %2, %1 : i8\n  %4 = comb.shl %3, %c1_i8 : i8\n  %5 = comb.mux %b0, %4, %3 : i8\n\n  // Results of the contract are replaced with symbolic values.\n  // Contract inlined with ensure -> assume, require -> assert, %z -> %any\n  // assume(eq(any, x)) can be canonicalized to an any -> x replacement.\n  %any = verif.symbolic_value : i8\n  %c8_i8 = hw.constant 8 : i8\n  %blt8 = comb.icmp ult %b, %c8_i8 : i8\n  verif.assert %blt8\n  %ashl = comb.shl %a, %b : i8\n  verif.assume_equal %any, %ashl : i42\n\n  hw.output %any : i8\n}\n\n// ----- after canonicalization, CSE, and DCE ----- //\n\nhw.module @ShiftLeft_ApplyContract_Simplified(in %a: i8, in %b: i8, out z: i8) {\n  %c8_i8 = hw.constant 8 : i8\n  %blt8 = comb.icmp ult %b, %c8_i8 : i8\n  verif.assert %blt8\n  %ashl = comb.shl %a, %b : i8\n  hw.output %ashl : i8\n}\n```\n\nOperations\u00a0[\u00b6](#operations)\n---------------------------\n\n### `verif.assert` (circt::verif::AssertOp)\u00a0[\u00b6](#verifassert-circtverifassertop)\n\n*Assert that a property holds.*\n\nSyntax:\n\n```\noperation ::= `verif.assert` $property (`if` $enable^)? (`label` $label^)? attr-dict `:` type($property)\n```\n\n#### Attributes:\u00a0[\u00b6](#attributes)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands)\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `enable` | 1-bit signless integer |\n\n### `verif.assume` (circt::verif::AssumeOp)\u00a0[\u00b6](#verifassume-circtverifassumeop)\n\n*Assume that a property holds.*\n\nSyntax:\n\n```\noperation ::= `verif.assume` $property (`if` $enable^)? (`label` $label^)? attr-dict `:` type($property)\n```\n\n#### Attributes:\u00a0[\u00b6](#attributes-1)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-1)\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `enable` | 1-bit signless integer |\n\n### `verif.bmc` (circt::verif::BoundedModelCheckingOp)\u00a0[\u00b6](#verifbmc-circtverifboundedmodelcheckingop)\n\n*Perform a bounded model check*\n\nSyntax:\n\n```\noperation ::= `verif.bmc` `bound` $bound `num_regs` $num_regs `initial_values` $initial_values attr-dict-with-keyword `init` $init `loop` $loop `circuit`\n              $circuit\n```\n\nThis operation represents a bounded model checking problem explicitly in\nthe IR. The `bound` attribute indicates how many times the `circuit` region\nshould be executed, and `num_regs` indicates the number of registers in the\ndesign that have been externalized and appended to the region\u2019s\ninputs/outputs (these values are fed from each `circuit` region execution\nto the next, as they represent register state, rather than being\noverwritten with fresh variables like other inputs). `initial_values` is an\narray containing the initial value of each register - where the register\nhas no initial value, a unit attribute is given. The `circuit` region\ncontains the circuit (alongside the `verif` property checking operations)\nto be checked.\n\nThe `init` region contains the logic to initialize the clock signals, and\nwill be executed once before any other region - it cannot take any\narguments, and should return as many `!seq.clock` values as the `circuit`\nregion has `!seq.clock` arguments, followed by any initial arguments of\n\u2018state\u2019 arguments to be fed to the `loop` region (see below).\n\nThe `loop` region contains the logic to advance the clock signals, and will\nbe executed after each execution of the `circuit` region. It should take as\narguments as many `!seq.clock` values as the `circuit` region has, and\nthese can be followed by additional \u2018state\u2019 arguments to represent e.g.\nwhich clock should be toggled next. The types yielded should be the same,\nas this region yields the updated clock and state values (this should also\nmatch the types yielded by the `init` region).\n\nTraits: `IsolatedFromAbove`, `SingleBlockImplicitTerminator<verif::YieldOp>`, `SingleBlock`\n\nInterfaces: `InferTypeOpInterface`\n\n#### Attributes:\u00a0[\u00b6](#attributes-2)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `bound` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `num_regs` | ::mlir::IntegerAttr | 32-bit signless integer attribute |\n| `initial_values` | ::mlir::ArrayAttr | array attribute |\n\n#### Results:\u00a0[\u00b6](#results)\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit signless integer |\n\n### `verif.clocked_assert` (circt::verif::ClockedAssertOp)\u00a0[\u00b6](#verifclocked_assert-circtverifclockedassertop)\n\n*Assert that a property holds, checked on a given clock\u2019s\nticks and enabled if a given condition holds. Only supports\na single clock and a single disable.*\n\nSyntax:\n\n```\noperation ::= `verif.clocked_assert` $property (`if` $enable^)? `,` $edge $clock\n              (`label` $label^)? attr-dict `:` type($property)\n```\n\n#### Attributes:\u00a0[\u00b6](#attributes-3)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `edge` | circt::verif::ClockEdgeAttr | clock edge |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-2)\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `clock` | 1-bit signless integer |\n| `enable` | 1-bit signless integer |\n\n### `verif.clocked_assume` (circt::verif::ClockedAssumeOp)\u00a0[\u00b6](#verifclocked_assume-circtverifclockedassumeop)\n\n*Assume that a property holds, checked on a given clock\u2019s\nticks and enabled if a given condition holds. Only supports\na single clock and a single disable.*\n\nSyntax:\n\n```\noperation ::= `verif.clocked_assume` $property (`if` $enable^)? `,` $edge $clock\n              (`label` $label^)? attr-dict `:` type($property)\n```\n\n#### Attributes:\u00a0[\u00b6](#attributes-4)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `edge` | circt::verif::ClockEdgeAttr | clock edge |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-3)\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `clock` | 1-bit signless integer |\n| `enable` | 1-bit signless integer |\n\n### `verif.clocked_cover` (circt::verif::ClockedCoverOp)\u00a0[\u00b6](#verifclocked_cover-circtverifclockedcoverop)\n\n*Cover on the holding of a property, checked on a given clock\u2019s\nticks and enabled if a given condition holds. Only supports\na single clock and a single disable.*\n\nSyntax:\n\n```\noperation ::= `verif.clocked_cover` $property (`if` $enable^)? `,` $edge $clock\n              (`label` $label^)? attr-dict `:` type($property)\n```\n\n#### Attributes:\u00a0[\u00b6](#attributes-5)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `edge` | circt::verif::ClockEdgeAttr | clock edge |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-4)\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `clock` | 1-bit signless integer |\n| `enable` | 1-bit signless integer |\n\n### `verif.contract` (circt::verif::ContractOp)\u00a0[\u00b6](#verifcontract-circtverifcontractop)\n\n*A formal contract*\n\nSyntax:\n\n```\noperation ::= `verif.contract` ($inputs^ `:` type($inputs))? attr-dict-with-keyword $body\n```\n\nThis operation creates a new formal contract which can be used to locally\nverify a part of the IR and provide simplifying substitutions. Contracts\ncontain `verif.require` ops to establish conditions that must hold for a\npiece of IR to work properly, and `verif.ensure` ops to describe the\nproperties that the piece of IR must guarantees when the requirements hold.\nOutside of formal verification, operands are simply passed through to the\nresults.\n\nContracts are checked by extracting them into their own `verif.formal` test\nand replacing `require` with `assume` and `ensure` with `assert`. The\nresults of the contract are replaced with the operands of the contract.\n\nContracts are used as simplifications for other verification tasks by\ninlining them and replacing `require` with `assert` and `ensure` with\n`assume`. The results of the contract are replaced with symbolic values.\n\nSee the documentation of the Verif dialect for more details.\n\nTraits: `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `RegionKindInterface`\n\n#### Operands:\u00a0[\u00b6](#operands-5)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-1)\n\n| Result | Description |\n| --- | --- |\n| `outputs` | variadic of any type |\n\n### `verif.cover` (circt::verif::CoverOp)\u00a0[\u00b6](#verifcover-circtverifcoverop)\n\n*Ensure that a property can hold.*\n\nSyntax:\n\n```\noperation ::= `verif.cover` $property (`if` $enable^)? (`label` $label^)? attr-dict `:` type($property)\n```\n\n#### Attributes:\u00a0[\u00b6](#attributes-6)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-6)\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `enable` | 1-bit signless integer |\n\n### `verif.ensure` (circt::verif::EnsureOp)\u00a0[\u00b6](#verifensure-circtverifensureop)\n\n*A postcondition of a contract*\n\nSyntax:\n\n```\noperation ::= `verif.ensure` $property\n              (`if` $enable^)?\n              (`label` $label^)?\n              attr-dict `:` type($property)\n```\n\nThis operation specifies a condition that is asserted when checking a\ncontract, and assumed when applying the contract as a simplification.\n\nThe `verif.ensure` op is commonly used to specify the conditions that output\nvalues from a part of the IR are guaranteed to fulfill, under the condition\nthat all requirements are fulfilled.\n\nTraits: `HasParent<verif::ContractOp>`\n\nInterfaces: `RequireLike`\n\n#### Attributes:\u00a0[\u00b6](#attributes-7)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-7)\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `enable` | 1-bit signless integer |\n\n### `verif.formal` (circt::verif::FormalOp)\u00a0[\u00b6](#verifformal-circtverifformalop)\n\n*A formal unit test*\n\nSyntax:\n\n```\noperation ::= `verif.formal` $sym_name $parameters attr-dict-with-keyword $body\n```\n\nThis operation defines a formal unit test that can be automatically run by\nvarious tools. To describe a test, the body of this op should contain the\nhardware to be tested, alongside any asserts, assumes, and covers to be\nformally verified. The body can contain instances of other modules, in which\ncase all asserts, assumes, and covers in those modules are also verified.\n\nThe `verif.symbolic_value` op can be used to create symbolic values to feed\ninto the hardware to be tested. Testing tools will then try to find concrete\nvalues for them that violate any asserts or make any covers true.\n\n#### Example\u00a0[\u00b6](#example)\n\n```\nverif.formal @AdderTest {myParam = 42, myTag = \"hello\"} {\n  %0 = verif.symbolic_value : i42\n  %1 = verif.symbolic_value : i42\n  %2 = hw.instance \"dut\" @Adder(a: %0: i42, b: %1: i42) -> (c: i42)\n  %3 = comb.add %0, %1 : i42\n  %4 = comb.icmp eq %2, %3 : i42\n  verif.assert %4 : i1\n}\n```\n\n#### Parameters\u00a0[\u00b6](#parameters)\n\nThe following parameters have a predefined meaning and are interpreted by\ntools such as `circt-test` to guide execution of tests:\n\n* `ignore`: Indicates whether the test should be ignored and skipped. This\n  can be useful for temporarily disabling tests without having to remove\n  them from the input. Must be a *boolean* value.\n\n  ```\n  verif.formal @Foo {ignore = true}\n  ```\n* `require_runners`: A list of test runners that may be used to execute this\n  test. This option may be used to force a test to run using one of a few\n  known-good runners, acting like a whitelist. Must be an *array* of\n  *strings*.\n\n  ```\n  verif.formal @Foo {require_runners = [\"sby\", \"circt-bmc\"]}\n  ```\n* `exclude_runners`: A list of test runners that must not be used to execute\n  this test. This option may be used to exclude a few known-bad runners from\n  executing this test, acting like a blacklist. Must be an *array* of\n  *strings*.\n\n  ```\n  verif.formal @Foo {exclude_runners = [\"sby\", \"circt-bmc\"]}\n  ```\n\nTraits: `IsolatedFromAbove`, `NoRegionArguments`, `NoTerminator`, `SingleBlock`\n\nInterfaces: `RegionKindInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-8)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `parameters` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n### `verif.format_verilog_string` (circt::verif::FormatVerilogStringOp)\u00a0[\u00b6](#verifformat_verilog_string-circtverifformatverilogstringop)\n\n*Creates a formatted string.*\n\nSyntax:\n\n```\noperation ::= `verif.format_verilog_string` $formatString `(` $substitutions `)` `:` type($substitutions) attr-dict\n```\n\nCreates a formatted string suitable for printing via the `verif.print` op.\nThe formatting syntax is expected to be identical to verilog string\nformatting to keep things simple for emission.\nIf we in the future would like to be less tied to verilog formatting,\nplease ask your friendly neighbourhood compiler engineer to e.g. implement\na `FormatStringOp` which itself may lower to a `FormatVerilogStringOp`.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-9)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `formatString` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-8)\n\n| Operand | Description |\n| --- | --- |\n| `substitutions` | variadic of any type |\n\n#### Results:\u00a0[\u00b6](#results-2)\n\n| Result | Description |\n| --- | --- |\n| `str` | a HW string |\n\n### `verif.has_been_reset` (circt::verif::HasBeenResetOp)\u00a0[\u00b6](#verifhas_been_reset-circtverifhasbeenresetop)\n\n*Check that a proper reset has been seen.*\n\nSyntax:\n\n```\noperation ::= `verif.has_been_reset` $clock `,` custom<KeywordBool>($async, \"\\\"async\\\"\", \"\\\"sync\\\"\")\n              $reset attr-dict\n```\n\nThe result of `verif.has_been_reset` reads as 0 immediately after simulation\nstartup and after each power-cycle in a power-aware simulation. The result\nremains 0 before and during reset and only switches to 1 after the reset is\ndeasserted again.\n\nThis is a useful utility to disable the evaluation of assertions and other\nverification constructs in the IR before the circuit being tested has been\nproperly reset. Verification failures due to uninitialized or randomized\ninitial state can thus be prevented.\n\nUsing the result of `verif.has_been_reset` to enable verification is more\npowerful and proper than just disabling verification during reset. The\nlatter does not properly handle the period of time between simulation\nstartup or power-cycling and the start of reset. `verif.has_been_reset` is\nguaranteed to produce a 0 value in that period, as well as during the reset.\n\nTraits: `AlwaysSpeculatableImplTrait`\n\nInterfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`\n\nEffects: `MemoryEffects::Effect{}`\n\n#### Attributes:\u00a0[\u00b6](#attributes-10)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `async` | ::mlir::BoolAttr | bool attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-9)\n\n| Operand | Description |\n| --- | --- |\n| `clock` | 1-bit signless integer |\n| `reset` | 1-bit signless integer |\n\n#### Results:\u00a0[\u00b6](#results-3)\n\n| Result | Description |\n| --- | --- |\n| `result` | 1-bit signless integer |\n\n### `verif.lec` (circt::verif::LogicEquivalenceCheckingOp)\u00a0[\u00b6](#veriflec-circtveriflogicequivalencecheckingop)\n\n*Represents a logical equivalence checking problem*\n\nSyntax:\n\n```\noperation ::= `verif.lec` attr-dict (`:` type($isProven)^)?\n              `first` $firstCircuit\n              `second` $secondCircuit\n```\n\nThis operation represents a logic equivalence checking problem explicitly in\nthe IR. There are several possibilities to perform logical equivalence\nchecking. For example, equivalence checking of combinational circuits can be\ndone by constructing a miter circuit and testing whether the result is\nsatisfiable (can be non-zero for some input), or two canonical BDDs could be\nconstructed and compared for identity, etc.\n\nThe number and types of the inputs and outputs of the two circuits (and thus\nalso the block arguments and yielded values of both regions) have to match.\nOtherwise, the two should be considered trivially non-equivalent.\n\nThe operation can return a boolean result that is `true` iff equivalence\nof the two circuits has been proven. The result can be omitted for use-cases\nwhich do not allow further processing (e.g., SMT-LIB exporting).\n\nTraits: `IsolatedFromAbove`, `SingleBlockImplicitTerminator<verif::YieldOp>`, `SingleBlock`\n\n#### Results:\u00a0[\u00b6](#results-4)\n\n| Result | Description |\n| --- | --- |\n| `isProven` | 1-bit signless integer |\n\n### `verif.print` (circt::verif::PrintOp)\u00a0[\u00b6](#verifprint-circtverifprintop)\n\n*Prints a message.*\n\nSyntax:\n\n```\noperation ::= `verif.print` $string attr-dict\n```\n\n#### Operands:\u00a0[\u00b6](#operands-10)\n\n| Operand | Description |\n| --- | --- |\n| `string` | a HW string |\n\n### `verif.refines` (circt::verif::RefinementCheckingOp)\u00a0[\u00b6](#verifrefines-circtverifrefinementcheckingop)\n\n*Check if the second module is a refinement of the first module*\n\nSyntax:\n\n```\noperation ::= `verif.refines` attr-dict (`:` type($isProven)^)?\n              `first` $firstCircuit\n              `second` $secondCircuit\n```\n\nThis operation represents a refinement checking problem explicitly in the\nIR. Given two (purely combinational) circuits A and B with the same\nsignature, B refines A iff for all inputs the set of possible output\nvalues of B is a subset of the possible output values of A given the\nsame input.\n\nFor strictly deterministic circuits the \u2018refines\u2019 relation is identical to\nlogical equivalence. Informally speaking, refining allows maintaining or\nreducing the non-determinism of a circuit.\n\nIf the signatures of the circuits do not match, the second circuit is\ntrivially assumed to *not* be a refinement of the first circuit. Sequential\nelements (i.e., registers and memories) are currently unsupported.\n\nThe operation can return a boolean result that is `true` iff the refinement\nrelation has been proven. The result can be omitted for use-cases which do\nnot allow further processing (e.g., SMT-LIB exporting).\n\nTraits: `IsolatedFromAbove`, `SingleBlockImplicitTerminator<verif::YieldOp>`, `SingleBlock`\n\n#### Results:\u00a0[\u00b6](#results-5)\n\n| Result | Description |\n| --- | --- |\n| `isProven` | 1-bit signless integer |\n\n### `verif.require` (circt::verif::RequireOp)\u00a0[\u00b6](#verifrequire-circtverifrequireop)\n\n*A precondition of a contract*\n\nSyntax:\n\n```\noperation ::= `verif.require` $property\n              (`if` $enable^)?\n              (`label` $label^)?\n              attr-dict `:` type($property)\n```\n\nThis operation specifies a condition that is assumed when checking against\nthe contract, and asserted when applying the contract as a simplification.\n\nThe `verif.require` op is commonly used to specify the conditions that input\nvalues into a part of the IR must fulfill in order for the IR to work as\nexpected, i.e., as outlined in the contract.\n\nTraits: `HasParent<verif::ContractOp>`\n\nInterfaces: `RequireLike`\n\n#### Attributes:\u00a0[\u00b6](#attributes-11)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `label` | ::mlir::StringAttr | string attribute |\n\n#### Operands:\u00a0[\u00b6](#operands-11)\n\n| Operand | Description |\n| --- | --- |\n| `property` | 1-bit signless integer or LTL sequence type or LTL property type |\n| `enable` | 1-bit signless integer |\n\n### `verif.simulation` (circt::verif::SimulationOp)\u00a0[\u00b6](#verifsimulation-circtverifsimulationop)\n\n*A simulation unit test*\n\nSyntax:\n\n```\noperation ::= `verif.simulation` $sym_name $parameters attr-dict-with-keyword $region\n```\n\nThis operation defines a simulation unit test that can be automatically run\nby various tools. To describe a test, the body of this op should contain the\nhardware to be tested, alongside any necessary forms of stimulus generation.\n\n#### Inputs\u00a0[\u00b6](#inputs)\n\nThe body has two block arguments as input values: a \u201cclock\u201d signal of type\n`!seq.clock` and an \u201cinit\u201d signal of type `i1`. The clock signal starts at 0\nand continuously toggles between 0 and 1 throughout the simulation. The init\nsignal starts at 1, remains 1 during a single 0-to-1 transition of the\nclock, and then drops to 0 for the remainder of the simulation.\n\n#### Outputs\u00a0[\u00b6](#outputs)\n\nThe body must have a `verif.yield` terminator op with exactly two operands:\n\nThe first operand is a \u201cdone\u201d signal of type `i1` which indicates the end of\nthe simulation. The simulation stops when the done signal is 1 during a\n0-to-1 transition of the clock after the init signal has dropped to 0. No\nadditional clock toggles occur once done has been sampled as 1.\n\nThe second operand is a \u201csuccess\u201d signal of type `i1` which indicates the\nsuccess of a test as 1, or failure as 0. The signal is sampled at the same\ntime as the done signal. Simulators must signal failure to the operating\nsystem through a non-zero exit code.\n\n#### Schedule\u00a0[\u00b6](#schedule)\n\nThe clock and init values adhere to the following schedule during\nsimulation:\n\n| Time | Clock | Init | Comment |\n| --- | --- | --- | --- |\n| t0 (>=0s) | undef | undef | Clock and init may initially be undefined. |\n| t1 (>=t0) | 0 | 1 | Initialization code (e.g., `seq.initial`, Verilog `initial` procedures) may run before or after clock and init change to their initial value. |\n| t2 (>t1) | 1 | 1 | Single rising clock edge occurs while init is high. |\n| t3 (>t2) | 0 | 1 | Init may stay during the falling clock edge. |\n| t4 (>=t3) | 0 | 0 | Init goes to 0 before second rising clock edge. |\n| t5 (>t4) | 1 | 0 | Clock toggles continue indefinitely. |\n| t6 (>t5) | 0 | 0 |  |\n\nSimulation termination occurs when the done signal is 1 during a 0-to-1\ntransition of the clock.\n\n#### Example\u00a0[\u00b6](#example-1)\n\n```\nverif.simulation @AdderTest {myParam = 42, myTag = \"hello\"} {\n^bb0(%clock: !seq.clock, %init: i1):\n  // Count the first 9001 simulation cycles.\n  %c0_i19 = hw.constant 0 : i19\n  %c1_i19 = hw.constant 1 : i19\n  %c9001_i19 = hw.constant 9001 : i19\n  %count = seq.compreg %0, %clock reset %init, %c0_i19 : i19\n  %done = comb.icmp eq %count, %c9001_i19 : i19\n  %0 = comb.add %count, %c1_i19 : i19\n\n  // Generate inputs to the adder.\n  %1, %2 = func.call @generateAdderInputs(%count) : (i19) -> (i42, i42)\n  %3 = hw.instance \"dut\" @Adder(a: %1: i42, b: %2: i42) -> (c: i42)\n\n  // Check results and track failures.\n  %4 = comb.add %1, %2 : i42\n  %5 = comb.icmp eq %3, %4 : i42\n  %true = hw.constant true\n  %success = seq.compreg %6, %clock reset %init, %true : i1\n  %6 = comb.and %success, %5 : i1\n\n  verif.yield %done, %success : i1, i1\n}\n```\n\nTraits: `IsolatedFromAbove`, `SingleBlockImplicitTerminator<verif::YieldOp>`, `SingleBlock`\n\nInterfaces: `OpAsmOpInterface`, `RegionKindInterface`, `Symbol`\n\n#### Attributes:\u00a0[\u00b6](#attributes-12)\n\n| Attribute | MLIR Type | Description |\n| --- | --- | --- |\n| `sym_name` | ::mlir::StringAttr | string attribute |\n| `parameters` | ::mlir::DictionaryAttr | dictionary of named attribute values |\n\n### `verif.symbolic_value` (circt::verif::SymbolicValueOp)\u00a0[\u00b6](#verifsymbolic_value-circtverifsymbolicvalueop)\n\n*Create a symbolic value for formal verification*\n\nSyntax:\n\n```\noperation ::= `verif.symbolic_value` attr-dict `:` type($result)\n```\n\nThis operation creates a new symbolic value that can be used to formally\nverify designs. Verification tools will try to find concrete assignments for\nsymbolic values that violate asserts or make covers true. This value is not\nfixed - the value taken can vary arbitrarily between timesteps.\n\nTraits: `HasParent<verif::FormalOp, hw::HWModuleOp>`\n\n#### Results:\u00a0[\u00b6](#results-6)\n\n| Result | Description |\n| --- | --- |\n| `result` | any type |\n\n### `verif.yield` (circt::verif::YieldOp)\u00a0[\u00b6](#verifyield-circtverifyieldop)\n\n*Yields values from a region*\n\nSyntax:\n\n```\noperation ::= `verif.yield` ($inputs^ `:` type($inputs))? attr-dict\n```\n\nTraits: `HasParent<verif::BoundedModelCheckingOp, verif::LogicEquivalenceCheckingOp, verif::RefinementCheckingOp, verif::SimulationOp>`, `Terminator`\n\n#### Operands:\u00a0[\u00b6](#operands-12)\n\n| Operand | Description |\n| --- | --- |\n| `inputs` | variadic of any type |\n\n [Prev - SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/ \"SMT Dialect\")\n[Next - EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/ \"EDA Tool Workarounds\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects-](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/ToolsWorkarounds/index.md"
  },
  {
    "role": "user",
    "content": "EDA Tool Workarounds - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nEDA Tool Workarounds\n====================\n\nThis documents various bugs found in EDA tools and their workarounds in circt.\nEach but will have a brief description, example code, and the mitigation added\n(with links to the commit when possible).\n\nAutomatic Variables Cause Latch Warnings\n========================================\n\nVerilator issues a latch warning for fully-initialized, automatic variables. This precludes using locally scoped variables.\n<https://github.com/verilator/verilator/issues/4022>\n\nExample\u00a0[\u00b6](#example)\n---------------------\n\n```\nmodule ALU(\n  input         clock,\n  input  [4:0]  operation,\n  input  [63:0] inputs_1,\n                inputs_0,\n                inputs_2,\n  input  [16:0] immediate,\n  output [63:0] output_0\n);\n  reg  [63:0]  casez_tmp_1;\n  always_comb begin\n    automatic logic [63:0] lowHigh;\n    casez (operation)\n      5'b00011:\n        casez_tmp_1 = inputs_0 & inputs_1;\n      5'b00100:\n        casez_tmp_1 = inputs_0 | inputs_1;\n      5'b00101:\n        casez_tmp_1 = inputs_0 ^ inputs_1;\n      5'b01001: begin\n        automatic logic [16:0] _aluOutput_T_22 =\n          immediate >> {14'h0, inputs_2, inputs_1[0], inputs_0[0]};\n        casez_tmp_1 = {63'h0, _aluOutput_T_22[0]};\n      end\n      default:\n        casez_tmp_1 = inputs_0;\n    endcase\n  end\nendmodule\n```\n\nGives:\n\n```\n$ verilator --version\nVerilator 5.008 2023-03-04 rev v5.008\n$ verilator --lint-only ALU.sv\n%Warning-LATCH: ALU.sv:11:3: Latch inferred for signal 'ALU.unnamedblk1.unnamedblk2._aluOutput_T_22' (not all control paths of combinational always assign a value)\n                           : ... Suggest use of always_latch for intentional latches\n   11 |   always_comb begin\n      |   ^~~~~~~~~~~\n                ... For warning description see https://verilator.org/warn/LATCH?v=4.218\n                ... Use \"/* verilator lint_off LATCH */\" and lint_on around source to disable this message.\n%Error: Exiting due to 1 warning(s)\n```\n\nWorkaround\u00a0[\u00b6](#workaround)\n---------------------------\n\nFlag added to promote all storage to the top level of a module.\n<https://github.com/llvm/circt/commit/3c8b4b47b600ea6bcc6da56fe9b81d6fe4022e4c>\n\nInline Array calculations can cause synthesis failures\n======================================================\n\nSome tools have bugs (version dependent) in const prop in this case.\n\nExample\u00a0[\u00b6](#example-1)\n-----------------------\n\n```\nmodule Foo (input clock, input in, output [2:0] out);\n  reg [2:0] state;\n  wire [7:0][2:0] array = 24'h4 << 6;\n  wire [2:0] a = array[state];\n  wire [2:0] b = array[state + 3'h1 + 3'h1];\n  // works:      array[state + (3'h1 + 3'h1)]\n  // works:      array[state + 3'h2]\n  always @(posedge clock) state <= in ? a : b;\n  assign out = b;\nendmodule\n```\n\nWorkaround\u00a0[\u00b6](#workaround-1)\n-----------------------------\n\nFlag added to export verilog to force array index calculations to not be inline.\n\n<https://github.com/llvm/circt/commit/15a1f95f2d59767f20b459a12ac42338de22bc97>\n\nMemory semantics changed by synthesis\n=====================================\n\nRead/Write forwarding behavior is dependent on memory size, since the synthesis\ntool changes it\u2019s mapping based on that. The \u201coptimized\u201d mapping does not\npreserve the behavior of the verilog. This is a known issue reported on various\nforums by multiple people. There are some version dependencies on when this\nmanifests.\n\nExample\u00a0[\u00b6](#example-2)\n-----------------------\n\n```\nQux:\n  module Qux:\n    input clock: Clock\n    input addr: UInt<1>\n    input r: {en: UInt<1>, flip data: {a: UInt<32>, b: UInt<32>}, addr: UInt<1>}\n    input w: {en: UInt<1>, data: {a: UInt<32>, b: UInt<32>}, addr: UInt<1>, mask: {a: UInt<1>, b: UInt<1>}}\n\n    mem m :\n      data-type => {a: UInt<32>, b: UInt<32>}\n      depth => 1\n      reader => r\n      writer => w\n      read-latency => 0\n      write-latency => 1\n      read-under-write => undefined\n\n    m.r.clk <= clock\n    m.r.en <= r.en\n    m.r.addr <= r.addr\n    r.data <= m.r.data\n\n    m.w.clk <= clock\n    m.w.en <= w.en\n    m.w.addr <= w.addr\n    m.w.data <= w.data\n    m.w.mask <= w.mask\n```\n\nCompile with either firtool -repl-seq-mem -repl-seq-mem-file=mem.conf Foo.fir and firrtl -i Foo.fir.\n\nWorkaround\u00a0[\u00b6](#workaround-2)\n-----------------------------\n\nFIRRTL memory lowering has a flag to generate attributes on memory\nimplementations that preserve the behavior described in the verilog. This is\nnot a general solution, this bug could impact anyone making memory-looking\nthings. It was decided not to try to reverse engineer the conditions which\ncause the bug to manifest (since they are version dependent), thus there isn\u2019t\na universal fix that can be applied in the generated verilog.\n\n<https://github.com/llvm/circt/commit/e9f443be475e0ef796c0c6af1ce09d6e783fcd5a>\n\nClock Gates and Enables Not Recognized For Registers\n====================================================\n\nClock gates in some rtl-based power estimation tools are unable to recognize\nclock gates and enables if they are not generated as if statements in always\nblocks. This is a very narrow pattern match with significant implications for\nthe tools lint results and quality of analysis results.\n\nExample\u00a0[\u00b6](#example-3)\n-----------------------\n\n```\n  %count = seq.firreg %2 clock %clock sym @count : i2\n\ufffc  %1 = comb.mux %cond, %value, %count : i2\t\t\ufffc  %1 = comb.mux bin %cond, %value, %count : i2\n\ufffc  %2 = comb.mux %reset, %c0_i2, %1 : i2\t\t\ufffc  %2 = comb.mux bin %reset, %c0_i2, %1 : i2\ufffc\n```\n\nThe mux on `cond` must become an `if` in the output since it forms a self-loop\non the register `count`.\n\nWorkaround\u00a0[\u00b6](#workaround-3)\n-----------------------------\n\nEffort at several points in lowering make effort to find self-loops through\nregister read and write ports and muxes. These are generated as `if` statements\nin the always block that updates the register.\n\n<https://github.com/llvm/circt/pull/3815>\n\n [Prev - Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/ \"Verif Dialect\")\n[Next - Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/ \"Formal Verification Tooling\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/FormalVerification/index.md"
  },
  {
    "role": "user",
    "content": "Formal Verification Tooling - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nFormal Verification Tooling\n===========================\n\nFormally verifying hardware designs is a crucial step during the development\nprocess. Various techniques exist, such as logical equivalence checking, model\nchecking, symbolic execution, etc. The preferred technique depends on the level\nof abstraction, the kind of properties to be verified, runtime limitations, etc.\nAs a hardware compiler collection, CIRCT provides infrastructure to implement\nformal verification tooling and already comes with a few tools for common\nuse-cases. This document provides an introduction to those tools and gives and\noverview over the underlying infrastructure for compiler engineers who want to\nuse CIRCT to implement their custom verification tool.\n\n* [Logical Equivalence Checking](#logical-equivalence-checking)\n* [Bounded Model Checking](#bounded-model-checking)\n* [Infrastructure Overview](#infrastructure-overview)\n  + [Building a custom LEC tool](#building-a-custom-lec-tool)\n  + [(Draft) Building a BMC tool](#draft-building-a-bmc-tool)\n\nLogical Equivalence Checking\u00a0[\u00b6](#logical-equivalence-checking)\n---------------------------------------------------------------\n\nThe `circt-lec` tool takes one or two MLIR input files with operations of the\nHW, Comb, and Seq dialects and the names of two modules to check for\nequivalence. To get to know the exact CLI command type `circt-lec --help`.\n\nFor example, the below IR contains two modules `@mulByTwo` and `@add`. Calling\n`circt-lec input.mlir -c1=mulByTwo -c2=add` will output `c1 == c2` since they\nare semantically equivalent.\n\n```\n// input.mlir\nhw.module @mulByTwo(in %in: i32, out out: i32) {\n  dbg.variable \"in\", %in : i32\n  %two = hw.constant 2 : i32\n  dbg.variable \"two\", %two : i32\n  %res = comb.mul %in, %two : i32\n  hw.output %res : i32\n}\nhw.module @add(in %in: i32, out out: i32) {\n  dbg.variable \"in\", %in : i32\n  %res = comb.add %in, %in : i32\n  hw.output %res : i32\n}\n```\n\nIn the above example, the MLIR file is compiled to LLVM IR which is then passed\nto the LLVM JIT compiler to directly output the LEC result. Alternatively, there\nare command line flags to print the LEC problem in SMT-LIB, LLVM IR, or an\nobject file that can be linked against the Z3 SMT solver to produce a standalone\nbinary.\n\nBounded Model Checking\u00a0[\u00b6](#bounded-model-checking)\n---------------------------------------------------\n\nThe `circt-bmc` tool takes one MLIR input file with operations of the HW, Comb,\nand Seq dialects, along with operations from the Verif dialect to annotate the\ndesign with properties. The name of the top module is also taken as an argument,\nalong with a bound indicating how many timesteps the design should be model\nchecked over. Similarly to `circt-lec`, the problem can be emitted as LLVM IR\nfor later compilation or can be passed to the LLVM JIT compiler and executed\nimmediately (in which case the location of a Z3 library is also required). To\nget to know the exact CLI command type `circt-bmc --help`.\n\nAn example of a file that can be provided to `circt-bmc` can be seen below:\n\n```\nhw.module @MyModule(in %clk: !seq.clock, in %i0: i1) {\n  %c-1_i1 = hw.constant -1 : i1\n  %reg = seq.compreg %i0, %clk : i1\n  %not_reg = comb.xor bin %reg, %c-1_i1 : i1\n  %not_not_reg = comb.xor bin %not_reg, %c-1_i1 : i1\n  // Condition\n  %eq = comb.icmp bin eq %not_not_reg, %reg : i1\n  verif.assert %eq : i1\n}\n```\n\nThis design negates a register\u2019s output twice and checks that the register\u2019s\noutput is always equivalent to the double-negated value - this is specified with\na `verif.assert` operation. Calling\n`circt-bmc -b 10 --module MyModule --shared-libs=<z3 library>` on this IR will\nemit `Bound reached with no violations!`, as the property holds over the 10\ncycles checked.\n\nInfrastructure Overview\u00a0[\u00b6](#infrastructure-overview)\n-----------------------------------------------------\n\nThis section provides and overview over the relevant dialects and passes for\nbuilding formal verification tools based on CIRCT. The\n[below diagram](/includes/img/smt_based_formal_verification_infra.svg) provides\na visual overview.\n\n![](https://circt.llvm.org/includes/img/smt_based_formal_verification_infra.svg)\n\nThe overall flow will insert an explicit operation to specify the verification\nproblem (e.g., `verif.lec`, `verif.bmc`). This operation could then be lowered\nto an encoding in SMT, an interactive theorem prover, a BDD, or potentially\nbeing exported to existing tools (currently only SMT is supported). Each of\nthose might have their own different backend paths as well. E.g., an encoding in\nSMT can be exported to SMT-LIB or lowered to LLVM IR that calls the Z3 solver.\n\nIn the following sections we are going to explain this lowering hierarchy in\nmore detail by looking at an example of SMT based LEC.\n\n### Building a custom LEC tool\u00a0[\u00b6](#building-a-custom-lec-tool)\n\nLet\u2019s suppose we want to implement our own custom LEC tool for our novel HDL\nwhich lowers to a CIRCT/MLIR based IR. There are two ways to implement this:\n\n1. Lower this IR to the CIRCT core representation (HW, Comb, Seq) and just use\n   the same pipeline as `circt-lec`. This has the advantage that we don\u2019t need to\n   think about SMT encodings and we might already compile to those dialects anyway\n   for Verilog emission.\n2. Implement a pass that sets up the LEC problem (lowering to the `verif.lec`\n   operation), and another pass that encodes the IRs operations and types in SMT\n   (i.e., a lowering pass to the SMT dialect). This has the advantage that\n   higher-level information from the IR could be taken advantage of to provide a\n   more efficient SMT encoding.\n\nConsider the code example from the\n[Logical Equivalence Checking section](#Logical-Equivalence-Checking) above. In\nthe first phase, the input IR is transformed to explicitly represent the LEC\nstatement using the `verif.lec` operation leading to the following IR.\n\n```\n// return values indicate:\n// * equivalent?\n// * counter-example available?\n// * counter-example value for input (undefined if not availbable)\n%0:3 = verif.lec first {\n^bb0(%in: i32):\n  dbg.variable \"in\", %in : i32\n  %c2_i32 = hw.constant 2 : i32\n  dbg.variable \"two\", %c2_i32 : i32\n  %0 = comb.mul %in, %c2_i32 : i32\n  verif.yield %0 : i32\n} second { \n^bb0(%in: i32):\n  dbg.variable \"in\", %in : i32\n  %0 = comb.add %in, %in : i32\n  verif.yield %0 : i32\n} -> i1, i1, i32\n```\n\nThe number of inputs and outputs and their types must match between the first\nand second circuit. All regions are isolated from above.\n\nFor more information about the `verif.lec` operation, refer to the Verif Dialect\ndocumentation.\n\nIn the second phase, we decide to use the SMT backend for solving the LEC\nstatement and thus call the lowering pass to SMT and provide it the conversion\npatterns necessary to encode all the operations present in the IR in terms of\nSMT formulae. In our case, that consists of the already provided lowerings for\n`comb`, `hw`, and `verif`. The result of this lowering is the following SMT\nencoding.\n\n```\n// return values indicate:\n// * equivalent?\n// * counter-example for \"in\" available?\n// * counter-example value for \"in\" (undefined if not availbable)\n// * counter-example for \"two\" available?\n// * counter-example value for \"two\" (undefined if not availbable)\n%0:5 = smt.solver (<non-smt-value-passthrough>)\n                   <solver-options-attr> : i1, i1, i32, i1, i32 {\n  // region is isolated from above\n  %true = hw.constant true\n  %false = hw.constant false\n  %c0_i32 = hw.constant 0 : i32\n  %0 = smt.declare_fun \"in\" : !smt.bv<32>\n  %1 = smt.bv.constant #smt.bv<2> : !smt.bv<32>\n  %2 = smt.bv.mul %0, %1 : !smt.bv<32>\n  %3 = smt.bv.add %0, %0 : !smt.bv<32>\n  %4 = smt.distinct %2, %3 : !smt.bv<32>\n  smt.assert %4 // operand type is !smt.bool\n  %5:3 = smt.check (<optional-assumptions>) sat {\n    %6:2 = smt.eval %0 : (!smt.bv<32>) -> (i1, i32)\n    %7:2 = smt.eval %1 : (!smt.bv<32>) -> (i1, i32)\n    smt.yield %false, %6#0, %6#1, %7#0, %7#1 : i1, i1, i32, i1, i32\n  } unknown {\n    // could request a message on why it is unknown from the solver\n    smt.yield %false, %false, %c0_i32, %false, %c0_i32 : i1, i1, i32, i1, i32\n  } unsat {\n    // could request a proof from the solver here\n    smt.yield %true, %false, %c0_i32, %false, %c0_i32 : i1, i1, i32, i1, i32\n  } -> i1, i1, i32, i1, i32\n  smt.yield %5#0, %5#1, %5#2, %5#3, %5#4 : i1, i1, i32, i1, i32\n  // no smt values may escape here\n}\ndbg.variable \"in\", %0#2 : i32\ndbg.variable \"two\", %0#4 : i32\n// TODO: how to encode that the debug variables are only\n// conditionally available?\n// Logic to report the result and potential counter-example\n// to the user goes here (potentially using the debug\n// dialect operations)\n```\n\nThis SMT IR can then be lowered through one of the available backends (e.g.,\nSMT-LIB, LLVM IR). Note that the SMT-LIB exporter as some considerable\nrestrictions on the kind of SMT IR it accepts. The ones relevant for the above\nexample are:\n\n* When exporting to SMT-LIB the `smt.check` must not return any values and all\n  regions must be empty. Usually, the solver prints `sat`, `unknown`, or `unsat`\n  to indicate the result.\n* The `smt.solver` operation must not have any return values and no passthrough\n  arguments\n* Optional assumptions in `smt.check` must be empty\n\nFor more information, refer to the SMT Dialect documentation.\n\n### (Draft) Building a BMC tool\u00a0[\u00b6](#draft-building-a-bmc-tool)\n\nFor completeness, this section describes how a BMC (bounded model checking)\ncompilation flow could look like using this intrastructure.\n**Note:** this is just a preliminary draft for now\n\nThe flow for model checking is very similar to the LEC flow above, just using\n`verif.bmc` instead of `verif.lec`. Obviously, the `seq` dialect is treated\nvastly different, but `comb` and `hw` are handled the same way. Custom SMT\nencodings can take advantage of this to implement both a LEC and BMC tool with\nonly one SMT encoding or provide separate lowering passes if necessary (or\npreferred).\n\nLet\u2019s consider the following hardware module that implements an accumulator\nwhich only takes even numbers as input, the output of the module is the inverted\nstate of the accumulator register, therefore it should always be odd.\n\n```\nhw.module @mod(in %clk: !seq.clock, in %arg0: i32, in %rst: i1,\n               in %rst_val: i32, out out: i32) {\n  %c-1_i32 = hw.constant -1 : i32\n  %c0_i32 = hw.constant 0 : i32\n  %c2_i32 = hw.constant 2 : i32\n  %0 = comb.modu %arg0, %c2_i32 : i32\n  %1 = comb.icmp eq, %0, %c0_i32 : i32\n  verif.assume %1 : i1\n  %2 = comb.modu %rst_val, %c2_i32 : i32\n  %3 = comb.icmp eq, %2, %c0_i32 : i32\n  verif.assume %3 : i1\n  %4 = comb.xor %rst, %true : i1\n  %5 = ltl.delay %4, 2 : i1\n  %6 = ltl.concat %rst, %5 : i1, !ltl.sequence\n  %7 = ltl.clock %6, posedge %clk : !ltl.sequence\n  verif.assume %7 : !ltl.sequence\n  %state0 = seq.compreg %8, %clk reset %rst, %rst_val : i32\n  %8 = comb.add %arg0, %state0 : i32\n  %9 = comb.xor %state0, %c-1_i32 : i32\n  %10 = comb.modu %9, %c2_i32 : i32\n  %11 = comb.icmp eq, %10, %c0_i32 : i32\n  verif.assert %11\n  hw.output %9 : i32\n}\n```\n\nThis could be lowered to a dedicated BMC operation like the following. Note that\nthe register was removed and instead the register state is added as an\nadditional input and output representing the old and the new state respectively.\n\n```\nverif.bmc bound 10 {\n^bb0(%clk: i1, %arg0: i32, %rst: i1, %rst_val: i32, %state0: i32):\n  %true = hw.constant true\n  %c0_i32 = hw.constant 0 : i32\n  %c1_i32 = hw.constant 1 : i32\n  %c2_i32 = hw.constant 2 : i32\n  %c-1_i32 = hw.constant -1 : i32\n  %0 = comb.modu %arg0, %c2_i32 : i32\n  %1 = comb.icmp eq, %0, %c0_i32 : i32\n  verif.assume %1 : i1\n  %2 = comb.modu %rst_val, %c2_i32 : i32\n  %3 = comb.icmp eq, %2, %c0_i32 : i32\n  verif.assume %3 : i1\n  %4 = comb.xor %rst, %true : i1\n  %5 = ltl.delay %4, 2 : i1\n  %6 = ltl.concat %rst, %5 : i1, !ltl.sequence\n  %7 = ltl.clock %6, posedge %clk : !ltl.sequence\n  verif.assume %7 : !ltl.sequence\n  %8 = comb.add %arg0, %state0 : i32\n  %9 = comb.xor %state0, %c-1_i32 : i32\n  %10 = comb.modu %9, %c2_i32 : i32\n  %11 = comb.icmp eq, %10, %c1_i32 : i32\n  verif.assert %11\n  %12 = comb.mux %rst, %rst_val, %8 : i32\n  verif.yield %9, %12 : i32, i32\n}\n```\n\nThis CIRCT Core level representation of a BMC task can then be lowered to the\nSMT dialect like the following.\n\n```\nfunc.func @helper(%cycle: i32, %prev_clk: !smt.bv<1>, %clk: !smt.bv<1>,\n                  %state0: !smt.bv<32>) -> !smt.bv<32> {\n  %zero = smt.bv.constant #smt.bv<0> : !smt.bv<32>\n  %one = smt.bv.constant #smt.bv<1> : !smt.bv<32>\n  %c-1_i32 = smt.bv.constant #smt.bv<-1> : !smt.bv<32>\n  %two = smt.bv.constant #smt.bv<2> : !smt.bv<32>\n  %arg0 = smt.declare_fun \"arg0\" : !smt.bv<32>\n  %rst = smt.declare_fun \"rst\" : !smt.bv<1>\n  %rst_val = smt.declare_fun \"rst_val\" : !smt.bv<32>\n  %smt_cycle = smt.from_concrete %cycle : i32 -> !smt.bv<32>\n  %true = smt.bv.constant #smt.bv<1> : !smt.bv<1>\n  %false = smt.bv.constant #smt.bv<0> : !smt.bv<1>\n  // assumptions for this cycle \n  %2 = smt.bv.urem %arg0, %two : !smt.bv<32>\n  %3 = smt.eq %2, %zero : !smt.bv<32>\n  %4 = smt.bv.urem %rst_val, %two : !smt.bv<32>\n  %5 = smt.eq %4, %zero : !smt.bv<32>\n  %6 = smt.bv.cmp ult, %smt_cycle, %two : !smt.bv<32>\n  %7 = smt.bv.cmp uge, %smt_cycle, %two : !smt.bv<32>\n  %8 = smt.eq %rst, %true : !smt.bv<1>\n  %9 = smt.and %6, %8\n  %10 = smt.eq %rst, %false : !smt.bv<1>\n  %11 = smt.and %7, %10\n  %12 = smt.or %9, %11\n  %assumption = smt.and %3, %5, %12\n  // circuit lowered to smt\n  %13 = smt.bv.add %arg0, %state0 : !smt.bv<32>\n  %14 = smt.bv.xor %state0, %c-1_i32 : !smt.bv<32>\n  %15 = smt.bv.urem %14, %two : !smt.bv<32>\n  %16 = smt.eq %15, %one : !smt.bv<32>\n  %17 = smt.implies %assumption, %16\n  smt.assert %17\n  %18 = smt.ite %rst, %rst_val, %13 : !smt.bv<32>\n  %19 = smt.bv.not %prev_clk : !smt.bv<1>\n  %posedge = smt.bv.and %clk, %19 : !smt.bv<1>\n  %20 = smt.ite %posedge, %18, %state0 : !smt.bv<32>\n  return %20 : !smt.bv<32>\n}\n\nsmt.solver {\n  %state0_init = smt.declare_fun \"state0\" : !smt.bv<32>\n  scf.for %i = 0 to 10 step 1 iter_args(%state0 = %state0_init) {\n    %clk = smt.bv.constant #smt.bv<0> : !smt.bv<1>\n    %clk_nxt = smt.bv.constant #smt.bv<1> : !smt.bv<1>\n    %new_state0 = func.call @helper(%i, %clk_nxt, %clk, %state0)\n      : (i32, !smt.bv<1>, !smt.bv<1>, !smt.bv<32>) -> !smt.bv<32>\n    smt.check sat {} unknown {} unsat {}\n    %next_cycle_state0 = func.call @helper(%i, %clk, %clk_nxt, %new_state0)\n      : (i32, !smt.bv<1>, !smt.bv<1>, !smt.bv<32>) -> !smt.bv<32>\n    smt.check sat {} unknown {} unsat {}\n    scf.yield %next_cycle_state0 : !smt.bv<32>\n  }\n  smt.yield\n}\n// Note: the logic to report counter-examples is omitted here.\n// There are several ways to implement it, e.g.,\n// * don't let the solver generate fresh symbol names, but unique them in a\n//   principled way ourselves such that those identifiers can be used to\n//   reconstruct the SMT expression to evaluate against the model\n// * store the values representing the symbolic values (results of\n//   declare_fun) in some array and iterate over it in the sat region\n// TODO: exit the loop early\n```\n\n [Prev - EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/ \"EDA Tool Workarounds\")\n[Next - Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/ \"Getting Started with the CIRCT Project\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/GettingStarted/index.md"
  },
  {
    "role": "user",
    "content": "Getting Started with the CIRCT Project - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nGetting Started with the CIRCT Project\n======================================\n\nOverview\u00a0[\u00b6](#overview)\n-----------------------\n\nWelcome to the CIRCT project!\n\n\u201cCIRCT\u201d stands for \u201cCircuit IR Compilers and Tools\u201d. The CIRCT project is an\n(experimental!) effort looking to apply MLIR and the LLVM development\nmethodology to the domain of hardware design tools.\n\nTake a look at the following diagram, which gives a brief overview of the\ncurrent\n[dialects and how they interact](https://circt.llvm.org/includes/img/dialects.svg):\n\n![](https://circt.llvm.org/includes/img/dialectlegend.svg)\n\n![](https://circt.llvm.org/includes/img/dialects.svg)\n\nSetting this up\u00a0[\u00b6](#setting-this-up)\n-------------------------------------\n\nThese commands can be used to setup CIRCT project:\n\n1. **Install Dependencies** of LLVM/MLIR according to\n   [the\n   instructions](https://mlir.llvm.org/getting_started/), including cmake and\n   ninja.\n\n*Note:* CIRCT is known to build with at least GCC 9.4 and Clang 13.0.1, but\nolder versions may not be supported. It is recommended to use the same C++\ntoolchain to compile both LLVM and CIRCT to avoid potential issues.\n\n*Recommendation:* In order to greatly reduce memory usage during linking, we\nrecommend using the LLVM linker\n[`lld`](https://lld.llvm.org/).\n\nIf you plan to use the Python bindings, you should start by reading\n[the\ninstructions](https://mlir.llvm.org/docs/Bindings/Python/#building) for building\nthe MLIR Python bindings, which describe extra dependencies, CMake variables,\nand helpful Python development practices. Note the extra CMake variables, which\nyou will need to specify in step 3) below.\n\n2. **Check out LLVM and CIRCT repos.** CIRCT contains LLVM as a git\n   submodule. The LLVM repo here includes staged changes to MLIR which\n   may be necessary to support CIRCT. It also represents the version of\n   LLVM that has been tested. MLIR is still changing relatively rapidly,\n   so feel free to use the current version of LLVM, but APIs may have\n   changed.\n\n```\n$ git clone git@github.com:circt/circt.git\n$ cd circt\n$ git submodule init\n$ git submodule update\n```\n\n*Note:* The repository is set up so that `git submodule update` performs a\nshallow clone, meaning it downloads just enough of the LLVM repository to check\nout the currently specified commit. If you wish to work with the full history of\nthe LLVM repository, you can manually \u201cunshallow\u201d the submodule:\n\n```\n$ cd llvm\n$ git fetch --unshallow\n```\n\n3. **Build and test LLVM/MLIR:**\n\n```\n$ cd circt\n$ mkdir llvm/build\n$ cd llvm/build\n$ cmake -G Ninja ../llvm \\\n    -DLLVM_ENABLE_PROJECTS=\"mlir\" \\\n    -DLLVM_TARGETS_TO_BUILD=\"host\" \\\n    -DLLVM_ENABLE_ASSERTIONS=ON \\\n    -DCMAKE_BUILD_TYPE=DEBUG \\\n    -DLLVM_USE_SPLIT_DWARF=ON \\\n    -DLLVM_ENABLE_LLD=ON  \n$ ninja\n$ ninja check-mlir\n```\n\n4. **Build and test CIRCT:**\n\n```\n$ cd circt\n$ mkdir build\n$ cd build\n$ cmake -G Ninja .. \\\n    -DMLIR_DIR=$PWD/../llvm/build/lib/cmake/mlir \\\n    -DLLVM_DIR=$PWD/../llvm/build/lib/cmake/llvm \\\n    -DLLVM_ENABLE_ASSERTIONS=ON \\\n    -DCMAKE_BUILD_TYPE=DEBUG \\\n    -DLLVM_USE_SPLIT_DWARF=ON \\\n    -DLLVM_ENABLE_LLD=ON  \n$ ninja\n$ ninja check-circt\n$ ninja check-circt-integration # Run the integration tests.\n```\n\nIn order to use the recommended `lld` linker, use the `-DLLVM_ENABLE_LLD=ON`.\nRemoving that flag will use your compiler\u2019s default linker. More details about\nthese problems and their solutions can be found\n[in the LLVM docs](https://llvm.org/docs/GettingStarted.html#common-problems).\n\nThe `-DCMAKE_BUILD_TYPE=DEBUG` flag enables debug information, which makes the\nwhole tree compile slower, but allows you to step through code into the LLVM\nand MLIR frameworks.\n\nTo get something that runs fast, use `-DCMAKE_BUILD_TYPE=Release` or\n`-DCMAKE_BUILD_TYPE=RelWithDebInfo` if you want to go fast and optionally if\nyou want debug info to go with it. `Release` mode makes a very large difference\nin performance.\n\nTo use the verilog frontend add `-DCIRCT_SLANG_FRONTEND_ENABLED=ON`.\n\nIf you plan to use the Python bindings, you should also specify\n`-DCIRCT_BINDINGS_PYTHON_ENABLED=ON`.\n\n5. **Optionally configure your environment**:\n\nIt is useful to add the `.../circt/build/bin` and `.../circt/llvm/build/bin`\ndirectories to the end of your PATH, allowing you to use the tools like `circt-opt`\nin a natural way on the command line. Similarly, you need to be in the build\ndirectory to invoke ninja, which is super annoying. You might find a bash/zsh\nalias like this to be useful:\n\n```\nbuild() {\n  (cd $HOME/Projects/circt/build/; ninja $1 $2 $3)\n}\n```\n\nThis allows you to invoke `build check-circt` from any directory and have it do\nthe right thing.\n\n6. **Run the Verilator tests:** (optional)\n\n[Verilator](https://github.com/verilator/verilator) can be used to check\nSystemVerilog code. To run the tests, build or install a **recent** version\nof Verilator (at least v4.034, ideally v4.110 or later to avoid a known bug).\n(Some Linux distributions have *ancient* versions.) If Verilator is in your\nPATH, `build check-circt` should run the tests which require Verilator.\n\nWe provide a script `utils/get-verilator.sh` to automate the download and\ncompilation of Verilator into a known location. The testing script will check\nthis location first. This script assumes that all the Verilator package\ndependencies are installed on your system. They are:\n\n* make\n* autoconf\n* g++\n* flex\n* bison\n* libfl2 # Ubuntu only (ignore if gives error)\n* libfl-dev # Ubuntu only (ignore if gives error)\n\n7. **Install GRPC** (optional, affects ESI runtime only)\n\nThe ESI runtime requires GRPC for cosimulation. The `utils/get-grpc.sh` script\ninstalls a known good version of GRPC to a directory within the CIRCT source\ncode. Alternatively, you can install GRPC using your package manager, though the\nversion may not be compatible with the ESI runtime so results may vary.\n\n8. **Install OR-Tools** (optional, enables additional schedulers)\n\n[OR-Tools](https://developers.google.com/optimization/) is an open source\nsoftware suite for (mathematical) optimization. It provides a uniform interface\nto several open-source and commercial solvers, e.g. for linear programs and\nsatisfiability problems. Here, it is optionally used in the static scheduling\ninfrastructure. Binary distributions often do not include the required CMake\nbuild info. The `utils/get-or-tools.sh` script downloads, compiles, and\ninstalls a known good version to a directory within the CIRCT source code,\n\nSetting up VS Code Workspace\u00a0[\u00b6](#setting-up-vs-code-workspace)\n---------------------------------------------------------------\n\nWe\u2019ve provided an example VS Code file in `.vscode/Unified.code-workspace.jsonc` that can be used with the VS Code editor. To use the file, first copy to into a workspace file:\n\n```\ncp .vscode/Unified.code-workspace.jsonc .vscode/circt.code-workspace\n```\n\nNext, open the workspace file in VS code using the command palette (Ctrl + Shift + P) and selecting \u201cOpen workspace from file\u201d and selecting the `.vscode/circt.code-workspace` file.\n\nAlternatively, open the file using:\n\n```\ncode .vscode/circt.code-workspace\n```\n\nand select \u201copen workspace\u201d on the bottom right.\n\nOnce the workspace is loaded, install the recommended tools and select \u201cCMake: Build\u201d from the command palette to start the unified build process. This will build the LLVM dependencies and CIRCT together.\n\nwhere it is then picked up automatically by the build.\n\nWindows: notes on setting up with Ninja\u00a0[\u00b6](#windows-notes-on-setting-up-with-ninja)\n------------------------------------------------------------------------------------\n\nBuilding on Windows using MSVC + Ninja + Python support is straight forward,\nthough full of landmines. Here are some notes:\n\n* Ninja and cmake must be run in a VS Developer Command shell. If you use\n  Powershell and don\u2019t want to start the VS GUI, you can run:\n\n```\n> $vsPath = &(Join-Path ${env:ProgramFiles(x86)} \"\\Microsoft Visual Studio\\Installer\\vswhere.exe\") -property installationpath\n> Import-Module (Get-ChildItem $vsPath -Recurse -File -Filter Microsoft.VisualStudio.DevShell.dll).FullName\n> Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation\n```\n\n* VSCode\u2019s cmake configure does not operate properly with Python support. The\n  symptom is that the build will complete, but importing `circt` or `mlir` crashes\n  Python. Doing everything from the command line is the only way CIRCT compiles\n  have been made to work.\n\nCheat sheet for powershell:\n\n```\n# Install cmake, ninja, and Visual Studio\n> python -m pip install psutil pyyaml numpy pybind11\n\n> $vsPath = &(Join-Path ${env:ProgramFiles(x86)} \"\\Microsoft Visual Studio\\Installer\\vswhere.exe\") -property installationpath\n> Import-Module (Get-ChildItem $vsPath -Recurse -File -Filter Microsoft.VisualStudio.DevShell.dll).FullName\n> Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation\n\n> cd <circt clone>\n> cmake -B<build_dir> llvm/llvm `\n    -GNinja `\n    -DLLVM_ENABLE_PROJECTS=mlir `\n    -DCMAKE_BUILD_TYPE=Debug `\n    -DLLVM_TARGETS_TO_BUILD=X86 `\n    -DLLVM_ENABLE_ASSERTIONS=ON `\n    -DMLIR_ENABLE_BINDINGS_PYTHON=ON `\n    -DLLVM_EXTERNAL_PROJECTS=circt `\n    -DLLVM_EXTERNAL_CIRCT_SOURCE_DIR=\"$(PWD)\" `\n    -DCIRCT_BINDINGS_PYTHON_ENABLED=ON `\n    -DCMAKE_EXPORT_COMPILE_COMMANDS=ON\n    -DLLVM_USE_SPLIT_DWARF=ON \n    -DLLVM_ENABLE_LLD=ON\n> ninja -C<build_dir> check-circt\n```\n\nSubmitting changes to CIRCT\u00a0[\u00b6](#submitting-changes-to-circt)\n-------------------------------------------------------------\n\nThe project is small so there are few formal process yet. We generally follow\nthe LLVM and MLIR community practices, but we currently use pull requests and\nGitHub issues. Here are some high-level guidelines:\n\n* Please use clang-format in the LLVM style. There are good plugins\n  for common editors like VSCode, Atom, etc, or you can run it\n  manually. This makes code easier to read and understand.\n* Beyond mechanical formatting issues, please follow the\n  [LLVM Coding\n  Standards](https://llvm.org/docs/CodingStandards.html).\n* Please practice \u201c\n  [incremental development](https://llvm.org/docs/DeveloperPolicy.html#incremental-development)\u201d,\n  preferring to send a small series of incremental patches rather than large\n  patches. There are other policies in the LLVM Developer Policy document that\n  are worth skimming.\n* Please use \u201cSquash and Merge\u201d in PRs when they are approved - we don\u2019t\n  need the intra-change history in the repository history.\n* Please create a PR to get a code review. For reviewers, it is good to look\n  at the primary author of the code you are touching to make sure they are at\n  least CC\u2019d on the PR.\n\nSubmitting changes to LLVM / MLIR\u00a0[\u00b6](#submitting-changes-to-llvm--mlir)\n------------------------------------------------------------------------\n\nThis project depends on MLIR and LLVM, and it is occasionally useful to improve\nthem.\nTo get set up for this:\n\n1. Follow the \u201c\n   [How to Contribute](https://mlir.llvm.org/getting_started/Contributing/)\u201d\n   instructions, and install the right tools, e.g. `clang-format`.\n2. Optional:\n   [Ask for LLVM commit access](https://llvm.org/docs/DeveloperPolicy.html#obtaining-commit-access),\n   the barrier is low. Alternatively, you can ask one of the reviewers on the\n   GitHub pull-request to merge for you.\n\n### Submitting a patch\u00a0[\u00b6](#submitting-a-patch)\n\nPatches are submitted to LLVM/MLIR via GitHub pull-requests, the basic flow is as follows:\n\n1. Check out the LLVM mono repo (as described above) or your fork of the same.\n2. Make changes to your codebase in a dedicated branch for your patch.\n3. Stage your changes with `git add`.\n4. Run clang-format to tidy up the patch with `git clang-format origin/main`.\n5. Run tests with `ninja check-mlir` (or whatever other target makes sense).\n6. Publish the branch on your fork of the repository and create a GitHub pull-request.\n\nWhen your review converges and your patch is approved, it can be merged directly on GitHub.\nIf you have commit access, you can do this yourself, otherwise a reviewer can do it for you.\n\nWriting a basic CIRCT Pass\u00a0[\u00b6](#writing-a-basic-circt-pass)\n-----------------------------------------------------------\n\nPasses can be added at several levels in CIRCT. Here we illustrate this with a simple pass, targetting\nthe `hw` dialect, that replaces all of the wire names with `foo. This example is very basic and is\nmeant for people who want to get a quick and dirty start at writing passes for CIRCT. For more detailed\ntutorials, we recommend looking at the\n[MLIR docs](https://mlir.llvm.org/docs/PassManagement/), and their\n[Toy tutorials](https://mlir.llvm.org/docs/Tutorials/Toy/).  \nTo add a simple dialect pass, that doesn\u2019t perform any dialect conversion, you can do the following:\n\n1. Update your dialect\u2019s Passes.td file to define what your pass will do in a high-level, well documented way,\n   e.g. in `include/circt/Dialect/HW/Passes.td`:\n\n```\ndef FooWires : Pass<\"hw-foo-wires\", \"hw::HwModuleOp\"> {\n  let summary = \"Change all wires' name to foo_<n>.\";\n  let description = [{\n    Very basic pass that numbers all of the wires in a given module.\n    The wires' names are then all converte to foo_<that number>.\n  }];\n  let constructor = \"circt::hw::createFooWiresPass()\";\n}\n```\n\nOnce this is added, compile CIRCT. This will generate a base class for your pass following the naming\ndefined in the\n[tablegen description](https://mlir.llvm.org/docs/PassManagement/#tablegen-specification).\nThis base class will contain some methods that need to be implemented.\nYour goal is to now implement those.\n\n2. Create a new file that contains your pass in the dialect\u2019s pass folder, e.g. in `lib/Dialect/HW/Transforms`.\n   Don\u2019t forget to also add it in the folder\u2019s CMakeLists.txt.\n   This file should implement:\n\n* A struct with the name of your pass, which extends the pass base class generated by the tablegen description.\n* This struct should define an override of the `void runOnOperation()` method, e.g.\n\n```\nnamespace {\n  // A test pass that simply replaces all wire names with foo_<n>\n  struct FooWiresPass : FooWiresBase<FooWiresPass> {\n    void runOnOperation() override;\n  };\n}\n```\n\n* The `runOnOperation` method will contain the actual logic of your pass, which you can now implement, e.g.\n\n```\nvoid FooWiresPass::runOnOperation() {\n  size_t nWires = 0; // Counts the number of wires modified\n  getOperation().walk([&](hw::WireOp wire) { // Walk over every wire in the module\n    wire.setName(\"foo_\" + std::to_string(nWires++)); // Rename said wire\n  });\n}\n```\n\n> *Note*: Here `getOperation().walk([&](WireOp wire) { ... });` is used to traverse every wire in the design, you can also\n> use it to generically walk over all operations and then visit them individually\n> using a\n> [visitor pattern](https://en.wikipedia.org/wiki/Visitor_pattern) by overloading type visitors\n> defined by each dialect. More details can be found in the\n> [MLIR docs](https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/), e.g.\n\n```\n#include \"circt/Dialect/HW/HWVisitors.h\" // defines dispatchTypeOpVisitor which calls visit(op)\n\nnamespace {\n  // A test pass that simply replaces all wire names with foo_<n>\n  struct VisitorExamplePass \n    : public VisitorExampleBase<VisitorExamplePass>,\n      public hw::TypeOpVisitor<VisitorExamplePass> // Allows for the visitor overloads to be added\n  {\n  public:  \n    void runOnOperation() override;\n\n    // Vistor overloads\n    void visitTypeOp(hw::ConstantOp op) { /*...*/ }\n    void visitTypeOp(/*other hw operations*/) { /*...*/ }\n  };\n}\n\nvoid VisitorExamplePass::runOnOperation() {\n  module.walk([&](Operation* op) { dispatchTypeOpVisitor(op); });\n}\n```\n\n* Finally implement the constructor for the pass, as defined in the tablegen description, e.g.\n\n```\nstd::unique_ptr<mlir::Pass> circt::hw::createFooWiresPass() {\n  return std::make_unique<FooWiresPass>();\n}\n```\n\n3. Define the pass constructor in the dialect\u2019s `Passes.h` file, e.g. in `include/circt/Dialect/hw/HWPasses.h` add:\n\n```\nstd::unique_ptr<mlir::Pass> createFooWiresPass();\n```\n\n4. Make sure to add a test to check your pass, e.g. in `test/Dialect/HW`:\n\n```\n// RUN: circt-opt --hw-foo-wires %s | FileCheck %s\n\nhw.module @foo(in %a: i32, in %b: i32, out out: i32) {\n  // CHECK:   %c1_i32 = hw.constant 1 : i32\n  %c1 = hw.constant 1 : i32\n  // CHECK:   %foo_0 = hw.wire %c1_i32  : i32\n  %wire_1 = hw.wire %c1 : i32\n  // CHECK:   %foo_1 = hw.wire %a  : i32\n  %wire_a = hw.wire %a : i32\n  // CHECK:   %foo_2 = hw.wire %b  : i32\n  %wire_b = hw.wire %b : i32\n  // CHECK:   %0 = comb.add bin %foo_1, %foo_0 : i32\n  %ap1 = comb.add bin %wire_a, %wire_1 : i32\n  // CHECK:   %foo_3 = hw.wire %0  : i32\n  %wire_ap1 = hw.wire %ap1 : i32\n  // CHECK:   %1 = comb.add bin %foo_3, %foo_2 : i32\n  %ap1pb = comb.add bin %wire_ap1, %wire_b : i32\n  // CHECK:   %foo_4 = hw.wire %1  : i32\n  %wire_ap1pb = hw.wire %ap1pb : i32\n  // CHECK:   hw.output %foo_4 : i32\n  hw.output %wire_ap1pb : i32\n}\n```\n\nNow re-run cmake and compile CIRCT and you should be able to run your new pass!\nBy default, every pass is accessible using `circt-opt` through the name that was defined in the tablegen description,\ne.g. `circt-opt --hw-foo-wires <file_name>.mlir`.\nThese passes can also be included in certain compilation pipelines that are well packaged in tools like firtool.  \nWe recommend looking at recently merged Pull-Requests or other\n[MLIR tutorials](https://mlir.llvm.org/docs/Tutorials/)\nto learn how to go beyond what we\u2019ve shown in this quick start guide.  \nThe full source code of this pass is available at the following links:\n\n* Pass Source:\n  [FooWires.cpp](https://github.com/llvm/circt/blob/main/lib/Dialect/HW/Transforms/FooWires.cpp)\n* Pass Test:\n  [foo.mlir](https://github.com/llvm/circt/blob/main/test/Dialect/HW/foo.mlir)\n* HW Dialect Pass Header:\n  [HWPasses.h](https://github.com/llvm/circt/blob/main/include/circt/Dialect/HW/HWPasses.h#L32)\n* Tablegen Description:\n  [Passes.td](https://github.com/llvm/circt/blob/main/include/circt/Dialect/HW/Passes.td#L81-L88)\n* [CMakeLists.txt](https://github.com/llvm/circt/blob/main/lib/Dialect/HW/Transforms/CMakeLists.txt#L8)\n\n [Prev - Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/ \"Formal Verification Tooling\")\n[Next - HLS in CIRCT](https://circt.llvm.org/docs/HLS/ \"HLS in CIRCT\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/HLS/index.md"
  },
  {
    "role": "user",
    "content": "HLS in CIRCT - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nHLS in CIRCT\n============\n\n// write a compelling introduction here\n\n* [`hlstool`](#hlstool)\n* [Flows](#flows)\n* [Dynamically scheduled HLS (DHLS)](#dynamically-scheduled-hls-dhls)\n* [Calyx](#calyx)\n\n`hlstool`\u00a0[\u00b6](#hlstool)\n-----------------------\n\n[`hlstool`](https://github.com/llvm/circt/blob/main/tools/hlstool/hlstool.cpp) is a tool for driving various CIRCT-based HLS flows. The tool works by defining\n[pass pipelines](https://mlir.llvm.org/docs/PassManagement/) that string together various MLIR and CIRCT passes to realize an HLS flow.  \nFor new users to MLIR, it is important to recognize the different between such compiler driver tools, and the MLIR `opt` tools (optimization drivers), such as `mlir-opt` and `circt-opt`.  \nFor instance, in `hlstool` we may specify a pass pipeline such as:\n\n```\n  // Memref legalization.\n  pm.addPass(circt::createFlattenMemRefPass());\n  pm.nest<func::FuncOp>().addPass(\n      circt::handshake::createHandshakeLegalizeMemrefsPass());\n  pm.addPass(mlir::createConvertSCFToCFPass());\n  pm.nest<handshake::FuncOp>().addPass(createSimpleCanonicalizerPass());\n```\n\nFor the compiler developer, however, we often *don\u2019t* want to run the entire HLS pass pipeline on our IR, but instead work on a specific level of IR and run a specific pass. Thus, every pass that is nested within `hlstool` can also be driven by an `opt` tool, e.g. `circt::createFlattenMemRefPass` is registered in `circt-opt` as `circt-opt --flatten-memref`.\n\nFlows\u00a0[\u00b6](#flows)\n-----------------\n\nCIRCT homes multiple actively developed HLS flows, each with their own approach to HLS. This section aims to provide a brief overview of the different flows, and how to use them.\n\n**Note:** we do mean \u2018active development\u2019**(!)** - most of these flows are the combined efforts of various student, phd and research projects, and should **not** be considered production-ready. You **will** encounter bugs, but you will also have a group of people are happy to help you fix them, and improve the flows. Feel free to reach out to the\n[codeowner](https://github.com/llvm/circt/blob/main/CODEOWNERS) of the dialect/pass that you\u2019re working on, or ask a question in the\n[LLVM discord](https://discord.gg/Jsktb5PR) which has a dedicated `circt` channel.\n\nHow flow documentation is structured:\n\n* **Description**: A brief description/rationale of the flow, what it is and why it is how it is.\n* **Relevant dialects**: A listing of the dialects used in the flow (preferably in order), as well as links to the dialect rationales. We encourage the user to read the dialect rationales to understand the design decisions behind the dialects.\n* **Example usage/relevant tests**: A vast majority of CIRCTs flow-specific knowledge is (unfortunately) institutional. However, users are often referred to the CIRCT tests to understand what different passes do, and how to drive the various CIRCT tools to achieve their goals. This section thus lists some relevant tests that may serve as important references of how to use the flow.\n\nDynamically scheduled HLS (DHLS)\u00a0[\u00b6](#dynamically-scheduled-hls-dhls)\n---------------------------------------------------------------------\n\n#### Relevant dialects:\u00a0[\u00b6](#relevant-dialects)\n\n* [cf](https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/)\n* [Handshake](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n\n#### Example usage/Relevant tests\u00a0[\u00b6](#example-usagerelevant-tests)\n\n* [handshake integration tests](https://github.com/llvm/circt/tree/main/integration_test/Dialect/Handshake) is a collection of cocotb-based tests that use `hlstool` to convert `cf`-level code to verilog.\n* [handshake-runner](https://github.com/llvm/circt/tree/main/integration_test/handshake-runner) tests show how to use the `handshake-runner` to interpret `handshake`-level IR\n\n#### Resources\u00a0[\u00b6](#resources)\n\nThe following is a list of work that has used or contributed to the DHLS flow in CIRCT:\n\n* (10/2022)\n  [Multi-Level Rewriting for Stream Processing to RTL compilation (M.Sc. Thesis) - Christian Ulmann](https://www.research-collection.ethz.ch/handle/20.500.11850/578713)\n* (01/2022)\n  [A Dynamically Scheduled HLS Flow in MLIR (M.Sc. Thesis) - Morten Borup Petersen](https://infoscience.epfl.ch/record/292189)\n\nCalyx\u00a0[\u00b6](#calyx)\n-----------------\n\n#### Relevant dialects:\u00a0[\u00b6](#relevant-dialects-1)\n\n#### Example usage/Relevant tests\u00a0[\u00b6](#example-usagerelevant-tests-1)\n\n#### Resources\u00a0[\u00b6](#resources-1)\n\n [Prev - Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/ \"Getting Started with the CIRCT Project\")\n[Next - Passes](https://circt.llvm.org/docs/Passes/ \"Passes\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Passes/index.md"
  },
  {
    "role": "user",
    "content": "Passes - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nPasses\n======\n\nThis document describes the available CIRCT passes and their contracts.\n\n* [General Passes](#general-passes)\n  + [`-convert-index-to-uint`](#-convert-index-to-uint)\n  + [`-flatten-memref`](#-flatten-memref)\n  + [`-flatten-memref-calls`](#-flatten-memref-calls)\n  + [`-hierarchical-runner`](#-hierarchical-runner)\n  + [`-insert-merge-blocks`](#-insert-merge-blocks)\n  + [`-map-arith-to-comb`](#-map-arith-to-comb)\n  + [`-maximize-ssa`](#-maximize-ssa)\n  + [`-memory-banking`](#-memory-banking)\n  + [`-print-op-count`](#-print-op-count)\n  + [`-strip-debuginfo-with-pred`](#-strip-debuginfo-with-pred)\n  + [`-switch-to-if`](#-switch-to-if)\n* [Conversion Passes](#conversion-passes)\n  + [`-calyx-native`](#-calyx-native)\n  + [`-calyx-remove-groups-fsm`](#-calyx-remove-groups-fsm)\n  + [`-convert-affine-to-loopschedule`](#-convert-affine-to-loopschedule)\n  + [`-convert-comb-to-arith`](#-convert-comb-to-arith)\n  + [`-convert-comb-to-datapath`](#-convert-comb-to-datapath)\n  + [`-convert-comb-to-smt`](#-convert-comb-to-smt)\n  + [`-convert-comb-to-synth`](#-convert-comb-to-synth)\n  + [`-convert-core-to-fsm`](#-convert-core-to-fsm)\n  + [`-convert-datapath-to-comb`](#-convert-datapath-to-comb)\n  + [`-convert-datapath-to-smt`](#-convert-datapath-to-smt)\n  + [`-convert-fsm-to-core`](#-convert-fsm-to-core)\n  + [`-convert-fsm-to-sv`](#-convert-fsm-to-sv)\n  + [`-convert-hw-to-btor2`](#-convert-hw-to-btor2)\n  + [`-convert-hw-to-llvm`](#-convert-hw-to-llvm)\n  + [`-convert-hw-to-smt`](#-convert-hw-to-smt)\n  + [`-convert-hw-to-systemc`](#-convert-hw-to-systemc)\n  + [`-convert-moore-to-core`](#-convert-moore-to-core)\n  + [`-convert-synth-to-comb`](#-convert-synth-to-comb)\n  + [`-convert-to-arcs`](#-convert-to-arcs)\n  + [`-convert-to-llvm`](#-convert-to-llvm)\n  + [`-convert-verif-to-smt`](#-convert-verif-to-smt)\n  + [`-export-split-verilog`](#-export-split-verilog)\n  + [`-export-verilog`](#-export-verilog)\n  + [`-handshake-remove-block-structure`](#-handshake-remove-block-structure)\n  + [`-hw-lower-instance-choices`](#-hw-lower-instance-choices)\n  + [`-legalize-anon-enums`](#-legalize-anon-enums)\n  + [`-lower-arc-to-llvm`](#-lower-arc-to-llvm)\n  + [`-lower-calyx-to-fsm`](#-lower-calyx-to-fsm)\n  + [`-lower-calyx-to-hw`](#-lower-calyx-to-hw)\n  + [`-lower-cf-to-handshake`](#-lower-cf-to-handshake)\n  + [`-lower-dc-to-hw`](#-lower-dc-to-hw)\n  + [`-lower-firrtl-to-hw`](#-lower-firrtl-to-hw)\n  + [`-lower-handshake-to-dc`](#-lower-handshake-to-dc)\n  + [`-lower-handshake-to-hw`](#-lower-handshake-to-hw)\n  + [`-lower-hw-to-sv`](#-lower-hw-to-sv)\n  + [`-lower-hwarith-to-hw`](#-lower-hwarith-to-hw)\n  + [`-lower-loopschedule-to-calyx`](#-lower-loopschedule-to-calyx)\n  + [`-lower-ltl-to-core`](#-lower-ltl-to-core)\n  + [`-lower-pipeline-to-hw`](#-lower-pipeline-to-hw)\n  + [`-lower-scf-to-calyx`](#-lower-scf-to-calyx)\n  + [`-lower-seq-firmem`](#-lower-seq-firmem)\n  + [`-lower-seq-to-sv`](#-lower-seq-to-sv)\n  + [`-lower-sim-to-sv`](#-lower-sim-to-sv)\n  + [`-lower-smt-to-z3-llvm`](#-lower-smt-to-z3-llvm)\n  + [`-lower-verif-to-sv`](#-lower-verif-to-sv)\n  + [`-materialize-calyx-to-fsm`](#-materialize-calyx-to-fsm)\n  + [`-prepare-for-emission`](#-prepare-for-emission)\n  + [`-test-apply-lowering-options`](#-test-apply-lowering-options)\n* [Arc Dialect Passes](#arc-dialect-passes)\n  + [`-arc-add-taps`](#-arc-add-taps)\n  + [`-arc-allocate-state`](#-arc-allocate-state)\n  + [`-arc-canonicalizer`](#-arc-canonicalizer)\n  + [`-arc-dedup`](#-arc-dedup)\n  + [`-arc-find-initial-vectors`](#-arc-find-initial-vectors)\n  + [`-arc-infer-memories`](#-arc-infer-memories)\n  + [`-arc-infer-state-properties`](#-arc-infer-state-properties)\n  + [`-arc-inline`](#-arc-inline)\n  + [`-arc-insert-runtime`](#-arc-insert-runtime)\n  + [`-arc-isolate-clocks`](#-arc-isolate-clocks)\n  + [`-arc-latency-retiming`](#-arc-latency-retiming)\n  + [`-arc-lower-arcs-to-funcs`](#-arc-lower-arcs-to-funcs)\n  + [`-arc-lower-clocks-to-funcs`](#-arc-lower-clocks-to-funcs)\n  + [`-arc-lower-lut`](#-arc-lower-lut)\n  + [`-arc-lower-state`](#-arc-lower-state)\n  + [`-arc-lower-vectorizations`](#-arc-lower-vectorizations)\n  + [`-arc-lower-verif-simulations`](#-arc-lower-verif-simulations)\n  + [`-arc-make-tables`](#-arc-make-tables)\n  + [`-arc-merge-ifs`](#-arc-merge-ifs)\n  + [`-arc-merge-taps`](#-arc-merge-taps)\n  + [`-arc-mux-to-control-flow`](#-arc-mux-to-control-flow)\n  + [`-arc-print-cost-model`](#-arc-print-cost-model)\n  + [`-arc-simplify-variadic-ops`](#-arc-simplify-variadic-ops)\n  + [`-arc-split-funcs`](#-arc-split-funcs)\n  + [`-arc-split-loops`](#-arc-split-loops)\n  + [`-arc-strip-sv`](#-arc-strip-sv)\n* [Calyx Dialect Passes](#calyx-dialect-passes)\n  + [`-affine-parallel-unroll`](#-affine-parallel-unroll)\n  + [`-affine-ploop-unparallelize`](#-affine-ploop-unparallelize)\n  + [`-calyx-affine-to-scf`](#-calyx-affine-to-scf)\n  + [`-calyx-clk-insertion`](#-calyx-clk-insertion)\n  + [`-calyx-compile-control`](#-calyx-compile-control)\n  + [`-calyx-gicm`](#-calyx-gicm)\n  + [`-calyx-go-insertion`](#-calyx-go-insertion)\n  + [`-calyx-remove-comb-groups`](#-calyx-remove-comb-groups)\n* [Example](#example)\n  + [`-calyx-remove-groups`](#-calyx-remove-groups)\n  + [`-calyx-reset-insertion`](#-calyx-reset-insertion)\n  + [`-exclude-exec-region-canonicalize`](#-exclude-exec-region-canonicalize)\n* [Comb Dialect Passes](#comb-dialect-passes)\n  + [`-comb-assume-two-valued`](#-comb-assume-two-valued)\n  + [`-comb-balance-mux`](#-comb-balance-mux)\n  + [`-comb-int-range-narrowing`](#-comb-int-range-narrowing)\n  + [`-comb-overflow-annotating`](#-comb-overflow-annotating)\n  + [`-comb-simplify-tt`](#-comb-simplify-tt)\n  + [`-lower-comb`](#-lower-comb)\n* [Datapath Dialect Passes](#datapath-dialect-passes)\n  + [`-datapath-reduce-delay`](#-datapath-reduce-delay)\n* [DC Dialect Passes](#dc-dialect-passes)\n  + [`-dc-dematerialize-forks-sinks`](#-dc-dematerialize-forks-sinks)\n  + [`-dc-materialize-forks-sinks`](#-dc-materialize-forks-sinks)\n  + [`-dc-print-dot`](#-dc-print-dot)\n* [ESI Dialect Passes](#esi-dialect-passes)\n  + [`-esi-appid-hier`](#-esi-appid-hier)\n  + [`-esi-build-manifest`](#-esi-build-manifest)\n  + [`-esi-clean-metadata`](#-esi-clean-metadata)\n  + [`-esi-connect-services`](#-esi-connect-services)\n  + [`-lower-esi-bundles`](#-lower-esi-bundles)\n  + [`-lower-esi-ports`](#-lower-esi-ports)\n  + [`-lower-esi-to-hw`](#-lower-esi-to-hw)\n  + [`-lower-esi-to-physical`](#-lower-esi-to-physical)\n  + [`-lower-esi-types`](#-lower-esi-types)\n  + [`-verify-esi-connections`](#-verify-esi-connections)\n* [FIRRTL Dialect Passes](#firrtl-dialect-passes)\n  + [`-firrtl-add-seqmem-ports`](#-firrtl-add-seqmem-ports)\n  + [`-firrtl-annotate-input-only-modules`](#-firrtl-annotate-input-only-modules)\n  + [`-firrtl-assign-output-dirs`](#-firrtl-assign-output-dirs)\n  + [`-firrtl-blackbox-reader`](#-firrtl-blackbox-reader)\n  + [`-firrtl-check-comb-loops`](#-firrtl-check-comb-loops)\n  + [`-firrtl-check-layers`](#-firrtl-check-layers)\n  + [`-firrtl-check-recursive-instantiation`](#-firrtl-check-recursive-instantiation)\n  + [`-firrtl-dedup`](#-firrtl-dedup)\n  + [`-firrtl-drop-const`](#-firrtl-drop-const)\n  + [`-firrtl-drop-names`](#-firrtl-drop-names)\n  + [`-firrtl-eliminate-wires`](#-firrtl-eliminate-wires)\n  + [`-firrtl-emit-metadata`](#-firrtl-emit-metadata)\n  + [`-firrtl-expand-whens`](#-firrtl-expand-whens)\n  + [`-firrtl-extract-instances`](#-firrtl-extract-instances)\n  + [`-firrtl-finalize-ir`](#-firrtl-finalize-ir)\n  + [`-firrtl-flatten-memory`](#-firrtl-flatten-memory)\n  + [`-firrtl-grand-central`](#-firrtl-grand-central)\n  + [`-firrtl-imconstprop`](#-firrtl-imconstprop)\n  + [`-firrtl-imdeadcodeelim`](#-firrtl-imdeadcodeelim)\n  + [`-firrtl-infer-domains`](#-firrtl-infer-domains)\n  + [`-firrtl-infer-resets`](#-firrtl-infer-resets)\n  + [`-firrtl-infer-rw`](#-firrtl-infer-rw)\n  + [`-firrtl-infer-widths`](#-firrtl-infer-widths)\n  + [`-firrtl-inject-dut-hier`](#-firrtl-inject-dut-hier)\n  + [`-firrtl-inliner`](#-firrtl-inliner)\n  + [`-firrtl-inner-symbol-dce`](#-firrtl-inner-symbol-dce)\n  + [`-firrtl-layer-merge`](#-firrtl-layer-merge)\n  + [`-firrtl-layer-sink`](#-firrtl-layer-sink)\n  + [`-firrtl-link-circuits`](#-firrtl-link-circuits)\n  + [`-firrtl-lint`](#-firrtl-lint)\n  + [`-firrtl-lower-annotations`](#-firrtl-lower-annotations)\n  + [`-firrtl-lower-chirrtl`](#-firrtl-lower-chirrtl)\n  + [`-firrtl-lower-classes`](#-firrtl-lower-classes)\n  + [`-firrtl-lower-domains`](#-firrtl-lower-domains)\n  + [`-firrtl-lower-dpi`](#-firrtl-lower-dpi)\n  + [`-firrtl-lower-intmodules`](#-firrtl-lower-intmodules)\n  + [`-firrtl-lower-intrinsics`](#-firrtl-lower-intrinsics)\n  + [`-firrtl-lower-layers`](#-firrtl-lower-layers)\n  + [`-firrtl-lower-matches`](#-firrtl-lower-matches)\n  + [`-firrtl-lower-memory`](#-firrtl-lower-memory)\n  + [`-firrtl-lower-open-aggs`](#-firrtl-lower-open-aggs)\n  + [`-firrtl-lower-signatures`](#-firrtl-lower-signatures)\n  + [`-firrtl-lower-types`](#-firrtl-lower-types)\n  + [`-firrtl-lower-xmr`](#-firrtl-lower-xmr)\n  + [`-firrtl-materialize-debug-info`](#-firrtl-materialize-debug-info)\n  + [`-firrtl-mem-to-reg-of-vec`](#-firrtl-mem-to-reg-of-vec)\n  + [`-firrtl-merge-connections`](#-firrtl-merge-connections)\n  + [`-firrtl-module-summary`](#-firrtl-module-summary)\n  + [`-firrtl-passive-wires`](#-firrtl-passive-wires)\n  + [`-firrtl-print-field-source`](#-firrtl-print-field-source)\n  + [`-firrtl-print-instance-graph`](#-firrtl-print-instance-graph)\n  + [`-firrtl-print-nla-table`](#-firrtl-print-nla-table)\n  + [`-firrtl-probes-to-signals`](#-firrtl-probes-to-signals)\n  + [`-firrtl-randomize-register-init`](#-firrtl-randomize-register-init)\n  + [`-firrtl-register-optimizer`](#-firrtl-register-optimizer)\n  + [`-firrtl-remove-unused-ports`](#-firrtl-remove-unused-ports)\n  + [`-firrtl-resolve-paths`](#-firrtl-resolve-paths)\n  + [`-firrtl-resolve-traces`](#-firrtl-resolve-traces)\n  + [`-firrtl-sfc-compat`](#-firrtl-sfc-compat)\n  + [`-firrtl-specialize-layers`](#-firrtl-specialize-layers)\n  + [`-firrtl-specialize-option`](#-firrtl-specialize-option)\n  + [`-firrtl-vb-to-bv`](#-firrtl-vb-to-bv)\n  + [`-firrtl-vectorization`](#-firrtl-vectorization)\n* [FSM Dialect Passes](#fsm-dialect-passes)\n  + [`-fsm-print-graph`](#-fsm-print-graph)\n* [Handshake Dialect Passes](#handshake-dialect-passes)\n  + [`-handshake-add-ids`](#-handshake-add-ids)\n  + [`-handshake-dematerialize-forks-sinks`](#-handshake-dematerialize-forks-sinks)\n  + [`-handshake-insert-buffers`](#-handshake-insert-buffers)\n  + [`-handshake-legalize-memrefs`](#-handshake-legalize-memrefs)\n  + [`-handshake-lock-functions`](#-handshake-lock-functions)\n  + [`-handshake-lower-extmem-to-hw`](#-handshake-lower-extmem-to-hw)\n  + [`-handshake-materialize-forks-sinks`](#-handshake-materialize-forks-sinks)\n  + [`-handshake-op-count`](#-handshake-op-count)\n  + [`-handshake-print-dot`](#-handshake-print-dot)\n  + [`-handshake-remove-buffers`](#-handshake-remove-buffers)\n  + [`-handshake-split-merges`](#-handshake-split-merges)\n* [HW Dialect Passes](#hw-dialect-passes)\n  + [`-hw-aggregate-to-comb`](#-hw-aggregate-to-comb)\n  + [`-hw-bypass-inner-symbols`](#-hw-bypass-inner-symbols)\n  + [`-hw-convert-bitcasts`](#-hw-convert-bitcasts)\n  + [`-hw-flatten-io`](#-hw-flatten-io)\n  + [`-hw-flatten-modules`](#-hw-flatten-modules)\n  + [`-hw-foo-wires`](#-hw-foo-wires)\n  + [`-hw-parameterize-constant-ports`](#-hw-parameterize-constant-ports)\n  + [`-hw-print-instance-graph`](#-hw-print-instance-graph)\n  + [`-hw-print-module-graph`](#-hw-print-module-graph)\n  + [`-hw-specialize`](#-hw-specialize)\n  + [`-hw-verify-irn`](#-hw-verify-irn)\n* [Kanagawa Dialect Passes](#kanagawa-dialect-passes)\n  + [`-kanagawa-add-operator-library`](#-kanagawa-add-operator-library)\n  + [`-kanagawa-argify-blocks`](#-kanagawa-argify-blocks)\n  + [`-kanagawa-call-prep`](#-kanagawa-call-prep)\n  + [`-kanagawa-clean-selfdrivers`](#-kanagawa-clean-selfdrivers)\n  + [`-kanagawa-containerize`](#-kanagawa-containerize)\n  + [`-kanagawa-convert-cf-to-handshake`](#-kanagawa-convert-cf-to-handshake)\n  + [`-kanagawa-convert-containers-to-hw`](#-kanagawa-convert-containers-to-hw)\n  + [`-kanagawa-convert-handshake-to-dc`](#-kanagawa-convert-handshake-to-dc)\n  + [`-kanagawa-convert-methods-to-containers`](#-kanagawa-convert-methods-to-containers)\n  + [`-kanagawa-eliminate-redundant-ops`](#-kanagawa-eliminate-redundant-ops)\n  + [`-kanagawa-inline-sblocks`](#-kanagawa-inline-sblocks)\n  + [`-kanagawa-lower-portrefs`](#-kanagawa-lower-portrefs)\n  + [`-kanagawa-prepare-scheduling`](#-kanagawa-prepare-scheduling)\n  + [`-kanagawa-reblock`](#-kanagawa-reblock)\n  + [`-kanagawa-tunneling`](#-kanagawa-tunneling)\n* [LLHD Dialect Passes](#llhd-dialect-passes)\n  + [`-llhd-combine-drives`](#-llhd-combine-drives)\n  + [`-llhd-deseq`](#-llhd-deseq)\n  + [`-llhd-hoist-signals`](#-llhd-hoist-signals)\n  + [`-llhd-inline-calls`](#-llhd-inline-calls)\n  + [`-llhd-lower-processes`](#-llhd-lower-processes)\n  + [`-llhd-mem2reg`](#-llhd-mem2reg)\n  + [`-llhd-remove-control-flow`](#-llhd-remove-control-flow)\n  + [`-llhd-sig2reg`](#-llhd-sig2reg)\n  + [`-llhd-unroll-loops`](#-llhd-unroll-loops)\n  + [`-llhd-wrap-procedural-ops`](#-llhd-wrap-procedural-ops)\n* [MSFT Dialect Passes](#msft-dialect-passes)\n  + [`-msft-export-tcl`](#-msft-export-tcl)\n  + [`-msft-lower-constructs`](#-msft-lower-constructs)\n  + [`-msft-lower-instances`](#-msft-lower-instances)\n* [OM Dialect Passes](#om-dialect-passes)\n  + [`-om-freeze-paths`](#-om-freeze-paths)\n  + [`-om-link-modules`](#-om-link-modules)\n  + [`-om-verify-object-fields`](#-om-verify-object-fields)\n  + [`-strip-om`](#-strip-om)\n* [Pipeline Dialect Passes](#pipeline-dialect-passes)\n  + [`-pipeline-explicit-regs`](#-pipeline-explicit-regs)\n  + [`-pipeline-schedule-linear`](#-pipeline-schedule-linear)\n* [Seq Dialect Passes](#seq-dialect-passes)\n  + [`-externalize-clock-gate`](#-externalize-clock-gate)\n  + [`-hw-memory-sim`](#-hw-memory-sim)\n  + [`-lower-seq-fifo`](#-lower-seq-fifo)\n  + [`-lower-seq-hlmem`](#-lower-seq-hlmem)\n  + [`-lower-seq-shiftreg`](#-lower-seq-shiftreg)\n  + [`-seq-reg-of-vec-to-mem`](#-seq-reg-of-vec-to-mem)\n* [SSP Dialect Passes](#ssp-dialect-passes)\n  + [`-ssp-print`](#-ssp-print)\n  + [`-ssp-roundtrip`](#-ssp-roundtrip)\n  + [`-ssp-schedule`](#-ssp-schedule)\n* [SV Dialect Passes](#sv-dialect-passes)\n  + [`-hw-cleanup`](#-hw-cleanup)\n  + [`-hw-eliminate-inout-ports`](#-hw-eliminate-inout-ports)\n  + [`-hw-export-module-hierarchy`](#-hw-export-module-hierarchy)\n  + [`-hw-generator-callout`](#-hw-generator-callout)\n  + [`-hw-legalize-modules`](#-hw-legalize-modules)\n  + [`-hw-stub-external-modules`](#-hw-stub-external-modules)\n  + [`-prettify-verilog`](#-prettify-verilog)\n  + [`-sv-extract-test-code`](#-sv-extract-test-code)\n  + [`-sv-trace-iverilog`](#-sv-trace-iverilog)\n* [Synth Dialect Passes](#synth-dialect-passes)\n  + [`-synth-abc-runner`](#-synth-abc-runner)\n  + [`-synth-aiger-runner`](#-synth-aiger-runner)\n  + [`-synth-generic-lut-mapper`](#-synth-generic-lut-mapper)\n  + [`-synth-lower-variadic`](#-synth-lower-variadic)\n  + [`-synth-lower-word-to-bits`](#-synth-lower-word-to-bits)\n  + [`-synth-maximum-and-cover`](#-synth-maximum-and-cover)\n  + [`-synth-print-longest-path-analysis`](#-synth-print-longest-path-analysis)\n  + [`-synth-sop-balancing`](#-synth-sop-balancing)\n  + [`-synth-structural-hash`](#-synth-structural-hash)\n  + [`-synth-tech-mapper`](#-synth-tech-mapper)\n  + [`-synth-test-priority-cuts`](#-synth-test-priority-cuts)\n* [SystemC Dialect Passes](#systemc-dialect-passes)\n  + [`-systemc-lower-instance-interop`](#-systemc-lower-instance-interop)\n* [LEC (logical equivalence checking) Passes](#lec-logical-equivalence-checking-passes)\n  + [`-construct-lec`](#-construct-lec)\n* [BMC (bounded model checking) Passes](#bmc-bounded-model-checking-passes)\n  + [`-externalize-registers`](#-externalize-registers)\n  + [`-lower-to-bmc`](#-lower-to-bmc)\n\nGeneral Passes\u00a0[\u00b6](#general-passes)\n-----------------------------------\n\n### `-convert-index-to-uint`\u00a0[\u00b6](#-convert-index-to-uint)\n\n*Rewrite index-based switch comparisons into unsigned integer ops.*\n\nReplace `arith.cmpi` operations whose operands are `index` values (often\nproduced when lowering `scf.index_switch`) with comparisons over the\noriginal integer type so that downstream hardware mapping passes (e.g.\n`--map-arith-to-comb`) do not encounter unsupported index-typed arithmetic.\nThe pass converts any associated index constants and erases the redundant\ncasts that become dead afterwards. For example, it rewrites:\n\n`arith.cmpi eq, (arith.index_cast %v : i4 to index), (arith.constant 5 : index)`\n\ninto:\n\n`arith.cmpi eq, %v, (arith.constant 5 : i4)`\n\n### `-flatten-memref`\u00a0[\u00b6](#-flatten-memref)\n\n*Flatten memrefs*\n\nFlattens multidimensional memories and accesses to them into\nsingle-dimensional memories.\n\n### `-flatten-memref-calls`\u00a0[\u00b6](#-flatten-memref-calls)\n\n*Flatten memref calls*\n\nFlattens calls to functions which have multidimensional memrefs as arguments.\nThis is done by casting memref arguments through memref.subview operations.\nAny called functions which had their type signatures changes will be replaced\nby a private function definition with the new signature.\nIt is up to users of this pass to define how these rewritten functions are\nto be implemented.\n\n### `-hierarchical-runner`\u00a0[\u00b6](#-hierarchical-runner)\n\n*Run passes under hierarchy*\n\nThis pass runs a specified pipeline of passes on the hierarchy of modules\nstarting from a given top-level module. It allows for hierarchical\napplication of transformations, which can be useful for targeting specific\nparts of a design or for applying different optimizations at different\nlevels of the module hierarchy.\n\n#### Options\u00a0[\u00b6](#options)\n\n```\n-pipeline                : The pipeline to run under hierarchy\n-top-name                : The name of the top-level module to run the pass on\n-include-bound-instances : Whether to include bound instances in the hierarchy\n```\n\n### `-insert-merge-blocks`\u00a0[\u00b6](#-insert-merge-blocks)\n\n*Insert explicit merge blocks*\n\nThis pass inserts additional merge blocks for each block with more than\ntwo successors. A merge block is a block that only contains one operation,\na terminator, and has two predecessors.\nThe order successors are merged together mirrors the order different control\npaths are created. Thus, each block with two successors will have a corresponding\nmerge block.\n\nThis pass brings the CFG into a canonical form for further transformations.\n\nTreats loops and sub-CFGs with irregular control flow like single blocks.\n\n### `-map-arith-to-comb`\u00a0[\u00b6](#-map-arith-to-comb)\n\n*Map arith ops to combinational logic*\n\nA pass which does a simple `arith` to `comb` mapping wherever possible.\nThis pass will not convert:\n\n* floating point operations\n* operations using `vector`-typed values\n\nThis **does not** intend to be the definitive lowering/HLS pass of `arith`\noperations in CIRCT (hence the name \u201cmap\u201d instead of e.g. \u201clower\u201d).\nRather, it provides a simple way (mostly for testing purposes) to map\n`arith` operations.\n\n#### Options\u00a0[\u00b6](#options-1)\n\n```\n-enable-best-effort-lowering : Enable best effort lowering of operations(eg, existing arith operations that have no lowering stay as is)\n```\n\n### `-maximize-ssa`\u00a0[\u00b6](#-maximize-ssa)\n\n*Convert every function in the module into maximal SSA form*\n\nConvert the region within every function into maximal SSA form. This\nensures that every value used within a block is also defined within the\nblock, making dataflow explicit and removing block dominance-based dataflow\nsemantics. The pass achieves this by adding block arguments wherever\nnecessary to forward values to the block(s) where they are used.\n\n### `-memory-banking`\u00a0[\u00b6](#-memory-banking)\n\n*Partition the memories used in affine parallel loops into banks*\n\n#### Options\u00a0[\u00b6](#options-2)\n\n```\n-factors    : Use banking factors to partition all memories that don't have banking attributes.The elements specified in banking factors should be greater than 1;The elements specified in banking factors will be paired with the ones specified in banking dimensions.In principle, the number of elements in banking factors should be equal to banking dimensions',with a single exception case: there is one banking factor with zero banking dimensions.\n-dimensions : The dimensions along which to bank the memory. If unspecified andthere is only one factor, the innermost dimension with size > 1 is used.\n```\n\n### `-print-op-count`\u00a0[\u00b6](#-print-op-count)\n\n*Print operation count analysis results*\n\nThis pass prints data on operation counts in a builtin.module.\n\n#### Options\u00a0[\u00b6](#options-3)\n\n```\n-emission-format : Specify the format to emit op count info in\n```\n\n### `-strip-debuginfo-with-pred`\u00a0[\u00b6](#-strip-debuginfo-with-pred)\n\n*Selectively strip debug info from all operations*\n\nThis pass extends mlir::StripDebugInfoPass to selectively strip locations with a\ngiven predicate.\n\n#### Options\u00a0[\u00b6](#options-4)\n\n```\n-drop-suffix : Drop file location info with the specified suffix. This option isintended to be used for testing.\n```\n\n### `-switch-to-if`\u00a0[\u00b6](#-switch-to-if)\n\n*Index switch to if*\n\nTransform `scf.index_switch` to a series of `scf.if` operations.\nThis is necessary for dialects that don\u2019t support switch statements, e.g., Calyx.\nAn example:\n\n```\n  %0 = scf.index_switch %cond -> i32\n    case 0 { ... }\n    case 1 { ... }\n    ...\n\n  =>\n\n  %c0 = arith.cmpi eq %0, 0\n  %c1 = arith.cmpi eq %0, 1\n  %0 = scf.if %c0 {\n   ...\n  } else {\n    %1 = scf.if %c1 {\n      ...\n    } else {\n      ...\n    }\n  }\n```\n\nConversion Passes\u00a0[\u00b6](#conversion-passes)\n-----------------------------------------\n\n### `-calyx-native`\u00a0[\u00b6](#-calyx-native)\n\n*Callout to the Calyx native compiler and run a pass pipeline*\n\nThis pass calls out to the native, Rust-based Calyx compiler to run passes\nwith it and generate a new, valid, calyx dialect program.\n\n#### Options\u00a0[\u00b6](#options-5)\n\n```\n-pass-pipeline : Passes to run with the native compiler\n```\n\n### `-calyx-remove-groups-fsm`\u00a0[\u00b6](#-calyx-remove-groups-fsm)\n\n*Perform FSM outlining and group removal*\n\nThis pass will outline the FSM into module scope and replace any SSA value references\nfrom within the FSM body with additional inputs. Given this, the FSM\nis instantiated as a `fsm.hw_module` operation within the Calyx component.\nUsing the FSM I/O (which is the group go/done signals), the `calyx.group`\noperations are removed from the component, with the group go and done signals\nbeing wired up to the FSM instance.\nExample:\n\n```\ncalyx.component {\n    %reg, ... = calyx.register ... : i1\n    calyx.wires {\n        // Groups have explicit done signals, and assignments are not guarded\n        // by a group go signal.\n        calyx.group @A {\n            ...\n            calyx.assign %reg = ...\n            ...\n            calyx.group_done %foo ? %bar\n        }\n    }\n    calyx.control {\n        // Machine is defined inside the `calyx.control` operation and references\n        // SSA values defined outside the machine.\n        fsm.machine @control(%A_done : i1) -> (%A_go : i1) {\n            ...\n            %0 = comb.not %reg // reference some SSA value defined outside the machine\n            ...\n        }\n    }\n}\n```\n\ninto\n\n```\n// The machine has been outlined into module scope, and no longer references\n// any SSA values defined outside the machine. It is now fully independent\n// from any notion of Calyx.\nfsm.machine @control(%A_done : i1, %reg : i1) -> (%A_go : i1) {\n    ...\n    %0 = comb.not %reg // reference some SSA value defined outside the machine\n    ...\n}\n\ncalyx.component {\n    %reg, ... = calyx.register ...\n    // Done signals are now wires\n    %A_done_in, %A_done_out = calyx.wire : i1\n    // The FSM is now instantiated as an `fsm.hwinstance` module\n    %A_go = fsm.hwinstance @control(%A_done_out, %reg) : ...\n    calyx.wires {\n        // Groups have been inlined, the group go signal is now a guard for\n        // all assignments, and `calyx.group_done` operations have been\n        // replaced by wire assignments.\n        ...\n        calyx.assign %reg = %A_go ? ...\n        ...\n        calyx.assign %A_done_in = %foo ? %bar\n    }\n    calyx.control {\n    }\n}\n```\n\n### `-convert-affine-to-loopschedule`\u00a0[\u00b6](#-convert-affine-to-loopschedule)\n\n*Convert Affine dialect to LoopSchedule scheduled loops*\n\nThis pass analyzes Affine loops and control flow, creates a Scheduling\nproblem using the Calyx operator library, solves the problem, and lowers\nthe loops to a LoopSchedule.\n\n### `-convert-comb-to-arith`\u00a0[\u00b6](#-convert-comb-to-arith)\n\n*Convert combinational ops and constants into arith ops*\n\n### `-convert-comb-to-datapath`\u00a0[\u00b6](#-convert-comb-to-datapath)\n\n*Lower Comb ops to Datapath ops*\n\nThis pass converts arithmetic Comb operations into Datapath operations that\nleverage redundant number representations (carry save). Primarily for use\nin the circt-synth flow.\n\n### `-convert-comb-to-smt`\u00a0[\u00b6](#-convert-comb-to-smt)\n\n*Convert combinational ops and constants to SMT ops*\n\n### `-convert-comb-to-synth`\u00a0[\u00b6](#-convert-comb-to-synth)\n\n*Lower Comb ops to Synth ops.*\n\n#### Options\u00a0[\u00b6](#options-6)\n\n```\n-additional-legal-ops       : Specify additional legal ops to partially legalize Comb\n-target-ir                  : Target IR kind\n-max-emulation-unknown-bits : Maximum number of unknown bits to emulate in a table lookup\n```\n\n### `-convert-core-to-fsm`\u00a0[\u00b6](#-convert-core-to-fsm)\n\n*Convert Core to FSM*\n\nThis pass extracts FSM structure from an RTL netlist. State registers\ncan be specified explicitly via the `state-regs` option, or they will\nbe inferred as registers whose names contain \u201cstate\u201d.\n\n#### Options\u00a0[\u00b6](#options-7)\n\n```\n-state-regs : Comma-separated list of names of registers to use as stateregisters. If not specified, registers with names containing'state' are used.\n```\n\n### `-convert-datapath-to-comb`\u00a0[\u00b6](#-convert-datapath-to-comb)\n\n*Convert Datapath ops to Comb ops*\n\n#### Options\u00a0[\u00b6](#options-8)\n\n```\n-lower-compress-to-add          : Lower compress operators to variadic add.\n-lower-partial-product-to-booth : Force all partial products to be lowered to Booth arrays.\n-timing-aware                   : Use timing-aware compressor synthesis algorithm.\n```\n\n### `-convert-datapath-to-smt`\u00a0[\u00b6](#-convert-datapath-to-smt)\n\n*Convert datapath ops to SMT ops*\n\n### `-convert-fsm-to-core`\u00a0[\u00b6](#-convert-fsm-to-core)\n\n*Convert FSM to Core*\n\n### `-convert-fsm-to-sv`\u00a0[\u00b6](#-convert-fsm-to-sv)\n\n*Convert FSM to SV and HW*\n\n### `-convert-hw-to-btor2`\u00a0[\u00b6](#-convert-hw-to-btor2)\n\n*Convert HW to BTOR2*\n\nThis pass converts a HW module into a state transition system that is then\ndirectly used to emit btor2. The output of this pass is thus a btor2 string.\n\n### `-convert-hw-to-llvm`\u00a0[\u00b6](#-convert-hw-to-llvm)\n\n*Convert HW to LLVM*\n\nThis pass translates HW to LLVM.\n\n#### Options\u00a0[\u00b6](#options-9)\n\n```\n-spill-arrays-early : If true, array values will be materialized on the stack at thepoint of definition. This can reduce redundant stack allocations.\n```\n\n### `-convert-hw-to-smt`\u00a0[\u00b6](#-convert-hw-to-smt)\n\n*Convert HW ops and constants to SMT ops*\n\n#### Options\u00a0[\u00b6](#options-10)\n\n```\n-for-smtlib-export : Produce output for SMTLIB export - this will replace hw.moduleoperations with smt.solver operations and assert the equivalenceof each module output with a symbolic constant.\n```\n\n### `-convert-hw-to-systemc`\u00a0[\u00b6](#-convert-hw-to-systemc)\n\n*Convert HW to SystemC*\n\nThis pass translates a HW design into an equivalent SystemC design.\n\n### `-convert-moore-to-core`\u00a0[\u00b6](#-convert-moore-to-core)\n\n*Convert Moore to Core*\n\nThis pass translates Moore to the core dialects.\n\n### `-convert-synth-to-comb`\u00a0[\u00b6](#-convert-synth-to-comb)\n\n*Lower Synth ops to Comb ops*\n\nThis pass converts Synth operations to Comb operations. This is mostly\nused for verifying post-synthesis results.\n\n### `-convert-to-arcs`\u00a0[\u00b6](#-convert-to-arcs)\n\n*Outline logic between registers into state transfer arcs*\n\nThis pass outlines combinational logic between registers into state transfer\narc definitions. The the original combinational logic and register is\nreplaced with an arc invocation, where the register is now represented as a\nlatency.\n\n#### Options\u00a0[\u00b6](#options-11)\n\n```\n-tap-registers : Make registers observable\n```\n\n### `-convert-to-llvm`\u00a0[\u00b6](#-convert-to-llvm)\n\n*Convert Comb and HW to LLVM*\n\nThis pass translates Comb and HW operations inside func.func to LLVM IR.\nIt combines both HW and Comb conversion patterns to provide a complete\nlowering from hardware description to LLVM IR.\n\n### `-convert-verif-to-smt`\u00a0[\u00b6](#-convert-verif-to-smt)\n\n*Convert Verif ops to SMT ops*\n\n#### Options\u00a0[\u00b6](#options-12)\n\n```\n-rising-clocks-only : When lowering verif.bmc ops, only consider the circuit and propertyon rising clock edges.\n```\n\n### `-export-split-verilog`\u00a0[\u00b6](#-export-split-verilog)\n\n*Emit the IR to a (System)Verilog directory of files*\n\nThis pass generates (System)Verilog for the current design, mutating it\nwhere necessary to be valid Verilog.\n\n#### Options\u00a0[\u00b6](#options-13)\n\n```\n-dir-name : Directory to emit into\n```\n\n### `-export-verilog`\u00a0[\u00b6](#-export-verilog)\n\n*Emit the IR to a (System)Verilog file*\n\nThis pass creates empty module bodies for external modules. This is\nuseful for linting to eliminate missing file errors.\n\n### `-handshake-remove-block-structure`\u00a0[\u00b6](#-handshake-remove-block-structure)\n\n*Remove block structure in Handshake IR*\n\n### `-hw-lower-instance-choices`\u00a0[\u00b6](#-hw-lower-instance-choices)\n\n*Prepare the collateral for instance choice emission*\n\nThis pass runs as part of verilog emission.\nIt introduces the macros & file lists to which instance choices lower to.\n\n### `-legalize-anon-enums`\u00a0[\u00b6](#-legalize-anon-enums)\n\n*Prepare anonymous enumeration types for ExportVerilog*\n\nThis pass transforms all anonymous enumeration types into typedecls to work\naround difference in how anonymous enumerations work in SystemVerilog.\n\n### `-lower-arc-to-llvm`\u00a0[\u00b6](#-lower-arc-to-llvm)\n\n*Lower state transfer arc representation to LLVM*\n\n### `-lower-calyx-to-fsm`\u00a0[\u00b6](#-lower-calyx-to-fsm)\n\n*Lower Calyx to FSM*\n\nThis pass lowers a Calyx control schedule to an FSM representation.\nAn `fsm.machine` operation is nested within the `control` region of the Calyx\ncomponent. This machine is itself in an intermediate format wherein it has\nno I/O ports and solely contains output statements with `calyx.enable`s\nreferencing `calyx.group` and transition logic guarded by the SSA values\nspecified in the source control schedule.\nThis intermediate state facilitates transformation of the FSM, given that\ntop-level I/O has yet to be materialized (one input and output per activated\ngroup) as well as guard transition logic (every transition must be guarded\non all groups active within the state having finished). As such, `calyx.enable`\noperations can easily be moved between states without worrying about updating\ntransition guards while doing so.\n\nEventually, the FSM must be materialized (materialize I/O ports, remove\n`calyx.enable` operations in favor of asserting output ports, guarding\ntransitions by input `done` ports) and outlined to a separate module.\n\n### `-lower-calyx-to-hw`\u00a0[\u00b6](#-lower-calyx-to-hw)\n\n*Lower Calyx to HW*\n\nThis pass lowers Calyx to HW.\n\n### `-lower-cf-to-handshake`\u00a0[\u00b6](#-lower-cf-to-handshake)\n\n*Lower func and CF into Handshake IR*\n\n#### Options\u00a0[\u00b6](#options-14)\n\n```\n-source-constants        : If true, will connect constants to source operations instead of to the control network. May reduce the size of the final circuit.\n-disable-task-pipelining : If true, will disable support for task pipelining. This relaxes the restrictions put on the structure of the input CDFG. Disabling task pipelining may severely reduce kernel II.\n```\n\n### `-lower-dc-to-hw`\u00a0[\u00b6](#-lower-dc-to-hw)\n\n*Lower DC to HW*\n\nLower DC to ESI/hw/comb/seq operations.\nIn case the IR contains DC operations that need to be clocked (fork, buffer),\nthere must exist a clock and reset signal in the parent `FunctionLike`\noperation. These arguments are to be marked with a `dc.clock` and `dc.reset`\nattribute, respectively.\n\n### `-lower-firrtl-to-hw`\u00a0[\u00b6](#-lower-firrtl-to-hw)\n\n*Lower FIRRTL to HW*\n\nLower a module of FIRRTL dialect to the HW dialect family.\n\n#### Options\u00a0[\u00b6](#options-15)\n\n```\n-warn-on-unprocessed-annotations : Emit warnings on unprocessed annotations during lower-to-hw pass\n-verification-flavor             : Specify a verification flavor used in the lowering\n```\n\n### `-lower-handshake-to-dc`\u00a0[\u00b6](#-lower-handshake-to-dc)\n\n*Lower Handshake to DC*\n\nLower Handshake to DC operations.\nCurrently, a `handshake.func` will be converted into a `hw.module`. This\nis principally an incorrect jump of abstraction - DC does not imply any\nRTL/hardware semantics. However, DC does not define a container operation,\nand there does not exist an e.g. `func.graph_func` which would be a generic\nfunction with graph region behaviour. Thus, for now, we just use `hw.module`\nas a container operation.\n\n#### Options\u00a0[\u00b6](#options-16)\n\n```\n-clk-name : Name of the clock signal to use in the generated DC module\n-rst-name : Name of the reset signal to use in the generated DC module\n```\n\n### `-lower-handshake-to-hw`\u00a0[\u00b6](#-lower-handshake-to-hw)\n\n*Lower Handshake to ESI/HW/Comb/Seq*\n\nLower Handshake to ESI/HW/Comb/Seq.\n\n### `-lower-hw-to-sv`\u00a0[\u00b6](#-lower-hw-to-sv)\n\n*Convert HW to SV*\n\nThis pass converts various HW contructs to SV.\n\n### `-lower-hwarith-to-hw`\u00a0[\u00b6](#-lower-hwarith-to-hw)\n\n*Lower HWArith to HW/Comb*\n\nThis pass lowers HWArith to HW/Comb.\n\n### `-lower-loopschedule-to-calyx`\u00a0[\u00b6](#-lower-loopschedule-to-calyx)\n\n*Lower LoopSchedule to Calyx*\n\nThis pass lowers LoopSchedule to Calyx.\n\n#### Options\u00a0[\u00b6](#options-17)\n\n```\n-top-level-function             : Identifier of top-level function to be the entry-point component of the Calyx program.\n-cider-source-location-metadata : Whether to track source location for the Cider debugger.\n```\n\n### `-lower-ltl-to-core`\u00a0[\u00b6](#-lower-ltl-to-core)\n\n*Convert LTL and Verif to Core*\n\nThis pass converts ltl and verif operations to core ones. This can be done directly\nwithout going through FSM if we\u2019re only working with overlapping properties (no delays).\n\n### `-lower-pipeline-to-hw`\u00a0[\u00b6](#-lower-pipeline-to-hw)\n\n*Lower Pipeline to HW*\n\nThis pass lowers `pipeline.rtp` operations to HW.\n\n#### Options\u00a0[\u00b6](#options-18)\n\n```\n-clock-gate-regs       : Clock gate each register instead of (default) input muxing  (ASIC optimization).\n-enable-poweron-values : Add power-on values to the pipeline control registers\n```\n\n### `-lower-scf-to-calyx`\u00a0[\u00b6](#-lower-scf-to-calyx)\n\n*Lower SCF/Standard to Calyx*\n\nThis pass lowers SCF / standard to Calyx.\n\n#### Options\u00a0[\u00b6](#options-19)\n\n```\n-top-level-function             : Identifier of top-level function to be the entry-point component of the Calyx program.\n-cider-source-location-metadata : Whether to track source location for the Cider debugger.\n-write-json                     : Whether to write memory contents to the json file.\n```\n\n### `-lower-seq-firmem`\u00a0[\u00b6](#-lower-seq-firmem)\n\n*Lower seq.firmem ops to instances of hw.module.generated ops*\n\n### `-lower-seq-to-sv`\u00a0[\u00b6](#-lower-seq-to-sv)\n\n*Lower sequential firrtl ops to SV.*\n\n#### Options\u00a0[\u00b6](#options-20)\n\n```\n-disable-reg-randomization   : Disable emission of register randomization code\n-disable-mem-randomization   : Disable emission of memory randomization code\n-emit-separate-always-blocks : Emit assigments to registers in separate always blocks\n-lower-to-always-ff          : Place assignments to registers into `always_ff` blocks if possible\n```\n\n#### Statistics\u00a0[\u00b6](#statistics)\n\n```\nnum-subaccess-restored : Number of lhs subaccess operations restored\n```\n\n### `-lower-sim-to-sv`\u00a0[\u00b6](#-lower-sim-to-sv)\n\n*Lower simulator-specific `sim` ops to SV.*\n\n### `-lower-smt-to-z3-llvm`\u00a0[\u00b6](#-lower-smt-to-z3-llvm)\n\n*Lower the SMT dialect to LLVM IR calling the Z3 API*\n\n#### Options\u00a0[\u00b6](#options-21)\n\n```\n-debug : Insert additional printf calls printing the solver's state to stdout (e.g. at check-sat operations) for debugging purposes\n```\n\n### `-lower-verif-to-sv`\u00a0[\u00b6](#-lower-verif-to-sv)\n\n*Convert Verif to SV*\n\nThis pass converts various Verif contructs to SV.\n\n### `-materialize-calyx-to-fsm`\u00a0[\u00b6](#-materialize-calyx-to-fsm)\n\n*Materializes an FSM embedded inside the control of this Calyx component.*\n\nMaterializes the FSM in the control of the component. This materializes the\ntop-level I/O of the FSM to receive `group_done` signals as input and\n`group_go` signals as output, based on the `calyx.enable` operations\nused within the states of the FSM.\nEach transition of the FSM is predicated on the enabled groups within a\nstate being done, or, for static groups, a separate sub-FSM is instantiated\nto await the group finishing.\n\nGiven an FSM that enables N unique groups, the top-level FSM will have N+1\nin- and output ports, wherein:\n\n* Input # 0 to N-1 are `group_done` signals\n* Input N is the top-level `go` port\n* Output 0 to N-1 are `group_go` signals\n* Output N is the top-level `done` port\n\n### `-prepare-for-emission`\u00a0[\u00b6](#-prepare-for-emission)\n\n*Prepare IR for ExportVerilog*\n\nThis pass runs only PrepareForEmission.\nIt is not necessary for users to run this pass explicitly since\nExportVerilog internally runs PrepareForEmission.\n\n### `-test-apply-lowering-options`\u00a0[\u00b6](#-test-apply-lowering-options)\n\n*Apply lowering options*\n\nThis pass allows overriding lowering options. It is intended for test\nconstruction.\n\n#### Options\u00a0[\u00b6](#options-22)\n\n```\n-options : Lowering Options\n```\n\nArc Dialect Passes\u00a0[\u00b6](#arc-dialect-passes)\n-------------------------------------------\n\n### `-arc-add-taps`\u00a0[\u00b6](#-arc-add-taps)\n\n*Add taps to ports and wires such that they remain observable*\n\n#### Options\u00a0[\u00b6](#options-23)\n\n```\n-ports        : Make module ports observable\n-wires        : Make wires observable\n-named-values : Make values with `sv.namehint` observable\n```\n\n### `-arc-allocate-state`\u00a0[\u00b6](#-arc-allocate-state)\n\n*Allocate and layout the global simulation state*\n\n#### Options\u00a0[\u00b6](#options-24)\n\n```\n-trace-taps : Insert TraceTap attributes for signal tracing\n```\n\n### `-arc-canonicalizer`\u00a0[\u00b6](#-arc-canonicalizer)\n\n*Simulation centric canonicalizations*\n\n#### Statistics\u00a0[\u00b6](#statistics-1)\n\n```\nnum-arc-args-removed : Number of arguments removed from DefineOps\n```\n\n### `-arc-dedup`\u00a0[\u00b6](#-arc-dedup)\n\n*Deduplicate identical arc definitions*\n\nThis pass deduplicates identical arc definitions. If two arcs differ only by\nconstants, the constants are outlined such that the arc can be deduplicated.\n\n#### Statistics\u00a0[\u00b6](#statistics-2)\n\n```\ndedupPassNumArcsDeduped : Number of arcs deduped\ndedupPassTotalOps       : Total number of ops deduped\n```\n\n### `-arc-find-initial-vectors`\u00a0[\u00b6](#-arc-find-initial-vectors)\n\n*Find initial groups of vectorizable ops*\n\n#### Statistics\u00a0[\u00b6](#statistics-3)\n\n```\nvectorizedOps       : Total number of ops that were vectorized\nnumOfSavedOps       : Total number of ops saved after FindInitialVectors pass\nbiggestSeedVector   : Size of the biggest seed vector\nnumOfVectorsCreated : Total number of VectorizeOps the pass inserted\n```\n\n### `-arc-infer-memories`\u00a0[\u00b6](#-arc-infer-memories)\n\n*Convert `FIRRTL_Memory` instances to dedicated memory ops*\n\n#### Options\u00a0[\u00b6](#options-25)\n\n```\n-tap-ports    : Make memory ports observable\n-tap-memories : Make memory contents observable\n```\n\n### `-arc-infer-state-properties`\u00a0[\u00b6](#-arc-infer-state-properties)\n\n*Add resets and enables explicitly to the state operations*\n\n#### Options\u00a0[\u00b6](#options-26)\n\n```\n-enables : Infer enable signals\n-resets  : Infer reset signals\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-4)\n\n```\nadded-enables  : Enables added explicitly to a StateOp\nadded-resets   : Resets added explicitly to a StateOp\nmissed-enables : Detected enables that could not be added explicitly to a StateOp\nmissed-resets  : Detected resets that could not be added explicitly to a StateOp\n```\n\n### `-arc-inline`\u00a0[\u00b6](#-arc-inline)\n\n*Inline very small arcs*\n\n#### Options\u00a0[\u00b6](#options-27)\n\n```\n-into-arcs-only : Call operations to inline\n-max-body-ops   : Max number of non-trivial ops in the region to be inlined\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-5)\n\n```\ninlined-arcs    : Arcs inlined at a use site\nremoved-arcs    : Arcs removed after full inlining\ntrivial-arcs    : Arcs with very few ops\nsingle-use-arcs : Arcs with a single use\n```\n\n### `-arc-insert-runtime`\u00a0[\u00b6](#-arc-insert-runtime)\n\n*Insert structs and function calls for the ArcRuntime library*\n\n#### Options\u00a0[\u00b6](#options-28)\n\n```\n-extra-args : Extra arguments passed to the runtime when creating simulation instances\n-trace-file : Output file name for signal trace\n```\n\n### `-arc-isolate-clocks`\u00a0[\u00b6](#-arc-isolate-clocks)\n\n*Group clocked operations into clock domains*\n\n### `-arc-latency-retiming`\u00a0[\u00b6](#-arc-latency-retiming)\n\n*Push latencies through the design*\n\n#### Statistics\u00a0[\u00b6](#statistics-6)\n\n```\nnum-ops-removed     : Number of zero-latency passthrough states removed\nlatency-units-saved : Number of latency units saved by merging them in a successor state\n```\n\n### `-arc-lower-arcs-to-funcs`\u00a0[\u00b6](#-arc-lower-arcs-to-funcs)\n\n*Lower arc definitions into functions*\n\n### `-arc-lower-clocks-to-funcs`\u00a0[\u00b6](#-arc-lower-clocks-to-funcs)\n\n*Lower clock trees into functions*\n\n### `-arc-lower-lut`\u00a0[\u00b6](#-arc-lower-lut)\n\n*Lowers arc.lut into a comb and hw only representation.*\n\n### `-arc-lower-state`\u00a0[\u00b6](#-arc-lower-state)\n\n*Split state into read and write ops grouped by clock tree*\n\n### `-arc-lower-vectorizations`\u00a0[\u00b6](#-arc-lower-vectorizations)\n\n*Lower `arc.vectorize` operations*\n\nThis pass lowers `arc.vectorize` operations. By default, the operation will\nbe fully lowered (i.e., the op disappears in the IR). Alternatively, it can\nbe partially lowered.\n\nThe \u201cmode\u201d pass option allows to only lower the boundary, only the body, or\nonly inline the body given that both the boundary and the body are already\nlowered.\n\nThe pass supports vectorization within scalar registers and SIMD\nvectorization and prioritizes vectorization by packing the vector elements\ninto a scalar value if it can fit into 64 bits.\n\nExample:\n\n```\nhw.module @example(%in0: i8, %in1: i8, %in2: i8) -> (out0: i8, out1: i8) {\n  %0:2 = arc.vectorize (%in0, %in1), (%in2, %in2) :\n    (i8, i8, i8, i8) -> (i8, i8) {\n  ^bb0(%arg0: i8, %arg1: i8):\n    %1 = comb.and %arg0, %arg1 : i8\n    arc.vectorize.return %1 : i8\n  }\n  hw.output %0#0, %0#1 : i8, i8\n}\n```\n\nThis piece of IR is lowered to the following fully vectorized IR:\n\n```\nhw.module @example(%in0: i8, %in1: i8, %in2: i8) -> (out0: i8, out1: i8) {\n  %0 = comb.concat %in0, %in1 : i8, i8\n  %1 = comb.concat %in2, %in2 : i8, i8\n  %2 = comb.and %0, %1 : i16\n  %3 = comb.extract %2 from 0 : (i16) -> i8\n  %4 = comb.extract %2 from 8 : (i16) -> i8\n  hw.output %3, %4 : i8, i8\n}\n```\n\n#### Options\u00a0[\u00b6](#options-29)\n\n```\n-mode : Select what should be lowered.\n```\n\n### `-arc-lower-verif-simulations`\u00a0[\u00b6](#-arc-lower-verif-simulations)\n\n*Lower verif.simulation ops to main functions*\n\n### `-arc-make-tables`\u00a0[\u00b6](#-arc-make-tables)\n\n*Transform appropriate arc logic into lookup tables*\n\n### `-arc-merge-ifs`\u00a0[\u00b6](#-arc-merge-ifs)\n\n*Merge control flow structures*\n\nThis pass optimizes control flow in a few ways. It moves operations closer\nto their earliest user, if possible sinking them into blocks if all uses are\nnested in the same block. It merges adjacent `scf.if` operations with the\nsame condition. And it moves operations in between two `scf.if` operations\nahead of the first if op to allow them to be merged. The pass runs on any\nSSACFG regions nested under the operation it is applied to.\n\nNote that this pass assumes that `!arc.state` and `!arc.memory` values can\nnever alias. That is, different values are assumed to never point to the\nsame storage location in simulation memory.\n\n#### Statistics\u00a0[\u00b6](#statistics-7)\n\n```\nsunk                   : Ops sunk into blocks\nmoved-to-user          : Ops moved to first user\nifs-merged             : Adjacent scf.if ops merged\nmoved-from-between-ifs : Ops moved from between ifs to enable merging\niterations             : Number of iterations until no more ops were sunk/merged\n```\n\n### `-arc-merge-taps`\u00a0[\u00b6](#-arc-merge-taps)\n\n*Merge TapOps observing the same value in the same Block.*\n\n### `-arc-mux-to-control-flow`\u00a0[\u00b6](#-arc-mux-to-control-flow)\n\n*Convert muxes with large independent fan-ins to if-statements*\n\n### `-arc-print-cost-model`\u00a0[\u00b6](#-arc-print-cost-model)\n\n*A dummy pass to test analysis passes*\n\n#### Statistics\u00a0[\u00b6](#statistics-8)\n\n```\nOperation(s)           : Number of operations in the module\nPack operations(s)     : Number of scalar to vector packking in the module\nShuffle operation(s)   : Number of shuffles done to set up the VectorizeOps\nVectorizeOps Body Cost : Number of operations inside the body of the VectorizeOps\nAll VectorizeOps Cost  : Total Cost of all VectorizeOps in the module\n```\n\n### `-arc-simplify-variadic-ops`\u00a0[\u00b6](#-arc-simplify-variadic-ops)\n\n*Convert variadic ops into distributed binary ops*\n\n#### Statistics\u00a0[\u00b6](#statistics-9)\n\n```\nskipped-multiple-blocks : Ops skipped due to operands in different blocks\nsimplified              : Ops simplified into binary ops\ncreated                 : Ops created as part of simplification\nreordered               : Ops where simplification reordered operands\n```\n\n### `-arc-split-funcs`\u00a0[\u00b6](#-arc-split-funcs)\n\n*Split large funcs into multiple smaller funcs*\n\n#### Options\u00a0[\u00b6](#options-30)\n\n```\n-split-bound : Size threshold (in ops) above which to split funcs\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-10)\n\n```\nfuncs-created : Number of new functions created\n```\n\n### `-arc-split-loops`\u00a0[\u00b6](#-arc-split-loops)\n\n*Split arcs to break zero latency loops*\n\n#### Statistics\u00a0[\u00b6](#statistics-11)\n\n```\ncreated : Arcs created during the splitting\nremoved : Arcs removed during the splitting\n```\n\n### `-arc-strip-sv`\u00a0[\u00b6](#-arc-strip-sv)\n\n*Remove SV wire, reg, and assigns*\n\n#### Options\u00a0[\u00b6](#options-31)\n\n```\n-async-resets-as-sync : Treat asynchronous resets as synchronous.\n```\n\nCalyx Dialect Passes\u00a0[\u00b6](#calyx-dialect-passes)\n-----------------------------------------------\n\n### `-affine-parallel-unroll`\u00a0[\u00b6](#-affine-parallel-unroll)\n\n*Unrolls affine.parallel operations in a way suitable for Calyx.*\n\nThis pass unrolls `affine.parallel` operations completely and wrap each unrolled body\nwith `scf.execute_region` operations to better align with `calyx.par`\u2019s representation.\nMoreover, the newly created `affine.parallel` will be attached with attributes to\nindicate that this is different from normal `affine.parallel`. Behavior is undefined if\nthere is a data race or memory banking contention.\nAn example:\n\n```\naffine.parallel (%x, %y) from (0, 0) to (2, 2) {\n  %0 = memref.load %alloc_0[%x, %y] : memref<2x2xf32>\n  %1 = memref.load %alloc_1[%x, %y] : memref<2x2xf32>\n  %2 = arith.addf %0, %1 : f32\n  memref.store %2, %alloc_2[%x, %y] : memref<2x2xf32>\n}\n=>\naffine.parallel _ from 0 to 1 {\n  scf.execute_region {\n    %0 = memref.load %alloc_0[%c0, %c0] : memref<2x2xf32>\n    %1 = memref.load %alloc_1[%c0, %c0] : memref<2x2xf32>\n    %2 = arith.addf %0, %1 : f32\n    memref.store %2, %alloc_2[%c0, %c0] : memref<2x2xf32>\n  }\n  scf.execute_region {\n    %0 = memref.load %alloc_0[%c0, %c1] : memref<2x2xf32>\n    %1 = memref.load %alloc_1[%c0, %c1] : memref<2x2xf32>\n    %2 = arith.addf %0, %1 : f32\n    memref.store %2, %alloc_2[%c0, %c1] : memref<2x2xf32>\n  }\n  scf.execute_region {\n    %0 = memref.load %alloc_0[%c1, %c0] : memref<2x2xf32>\n    %1 = memref.load %alloc_1[%c1, %c0] : memref<2x2xf32>\n    %2 = arith.addf %0, %1 : f32\n    memref.store %2, %alloc_2[%c1, %c0] : memref<2x2xf32>\n  }\n  scf.execute_region {\n    %0 = memref.load %alloc_0[%c1, %c1] : memref<2x2xf32>\n    %1 = memref.load %alloc_1[%c1, %c1] : memref<2x2xf32>\n    %2 = arith.addf %0, %1 : f32\n    memref.store %2, %alloc_2[%c1, %c1] : memref<2x2xf32>\n  }\n} {calyx.unroll = true}\n```\n\n### `-affine-ploop-unparallelize`\u00a0[\u00b6](#-affine-ploop-unparallelize)\n\n*Unparallelize `affine.parallel` op to `affine.for`*\n\nUnparallelize `affine.parallel` op to `affine.for` by the factor\nspecified in the attribute. For example:\n\n```\n#map_mod = affine_map<d0 -> d0 mod 2>\naffine.parallel (%ip) = (0) to (6) {\n  %mod = affine.apply #map_mod(%ip)\n  scf.index_switch %mod:\n  case 1 {\n    affine.store %cst, %mem0[%ip floordiv 2] : memref<3xf32>\n  }\n  case 0 {\n    affine.store %cst, %mem1[%ip floordiv 2] : memref<3xf32>\n  }\n  default {}\n} {unparallelize.factor = 2}\n\n=>\n\n#map_sum = affine_map<(d0, d1) -> (d0 + d1)>\n#map_mod = affine_map<d0 -> d0 mod 2>\naffine.for %if = 0 to 6 step 2 {\n  affine.parallel (%ip) = (0) to (2) {\n    %i = affine.apply #map_sum(%if, %ip)\n    %mod = affine.apply #map_mod(%i)\n    scf.index_switch %mod:\n    case 0 {\n      affine.store %cst, %mem0[%i floordiv 2] : memref<3xf32>\n    }\n    case 1 {\n      affine.store %cst, %mem1[%i floordiv 2] : memref<3xf32>\n    }\n    default {}\n  }\n}\n```\n\n### `-calyx-affine-to-scf`\u00a0[\u00b6](#-calyx-affine-to-scf)\n\n*Lowers the Affine dialect to the SCF dialect while attaching relevant information used for the SCFToCalyx or the LoopScheduleToCalyx pass.*\n\n### `-calyx-clk-insertion`\u00a0[\u00b6](#-calyx-clk-insertion)\n\n*Inserts assignments from component clock to sub-component clock.*\n\n### `-calyx-compile-control`\u00a0[\u00b6](#-calyx-compile-control)\n\n*Generates latency-insensitive finite state machines to realize control.*\n\nThis pass performs a bottom-up traversal of the control program and does the following:\n\n1. For each control statement such as \u201ccalyx.seq\u201d, create a new GroupOp to contain all\n   the structure to realize the schedule.\n2. Implement the schedule by setting the constituent groups\u2019 GoOp and DoneOp.\n3. Replace the control statement in the control program with the corresponding\n   compilation group.\n\n### `-calyx-gicm`\u00a0[\u00b6](#-calyx-gicm)\n\n*Lift group-invariant operations to wire-scope.*\n\nThis pass performs GICM (group-invariant code motion) of operations which are\ndeemed to be invariant of the group in which they are placed. In practice,\nthis amounts to anything which is not a `calyx.group_done/assign/group_go`\noperation. GICM\u2019d operations are lifted to wire-scope.\n\nAfter GICM, a Calyx component has the following properties:\n\n* No values are being defined within groups (excluding `calyx.group_go`).\n  As such, groups will only contain group-level assignments\n  (calyx.assign/group\\_done).\n* Any value referenced by operations within the group may safely be\n  referenced by other groups, or operations in wire scope.\n* A group does not define anything structural; it exclusively describes\n  wiring between existing structures.\n\n### `-calyx-go-insertion`\u00a0[\u00b6](#-calyx-go-insertion)\n\n*Insert go signals into the guards of a group\u2019s non-hole assignments*\n\nThis pass inserts the operation \u201ccalyx.group\\_go\u201d into the guards of all\nassignments housed in the group, with the exception of the \u201ccalyx.group\\_done\u201d\nterminator. For example,\n\nBefore:\n\n```\ncalyx.group @Group1 {\n  calyx.assign %in = %out1, %guard ? : i8\n  %done = calyx.group_done %out2 : i1\n}\n```\n\nAfter:\n\n```\n// The `go` assignment takes on an undefined\n// value until the Compile Control pass.\n%undef = calyx.undef : i1\n...\ncalyx.group @Group1 {\n  %go = calyx.group_go %undef : i1\n\n  %and = comb.and %guard, %go : i1\n  calyx.assign %in = %out1, %and ? : i8\n\n  %done = calyx.group_done %out2 : i1\n}\n```\n\n### `-calyx-remove-comb-groups`\u00a0[\u00b6](#-calyx-remove-comb-groups)\n\n*Removes combinational groups from a Calyx component.*\n\nTransforms combinational groups, which have a constant done condition,\ninto proper groups by registering the values read from the ports of cells\nused within the combinational group.\n\nIt also transforms (invoke,if,while)-with into semantically equivalent\ncontrol programs that first enable a group that calculates and registers the\nports defined by the combinational group execute the respective cond group\nand then execute the control operator.\n\nExample\u00a0[\u00b6](#example)\n---------------------\n\n```\ngroup comb_cond<\"static\"=0> {\n    lt.right = 32'd10;\n    lt.left = 32'd1;\n    eq.right = r.out;\n    eq.left = x.out;\n    comb_cond[done] = 1'd1;\n}\ncontrol {\n    invoke comp(left = lt.out, ..)(..) with comb_cond;\n    if lt.out with comb_cond {\n        ...\n    }\n    while eq.out with comb_cond {\n        ...\n    }\n}\n```\n\ninto:\n\n```\ngroup comb_cond<\"static\"=1> {\n    lt.right = 32'd10;\n    lt.left = 32'd1;\n    eq.right = r.out;\n    eq.left = x.out;\n    lt_reg.in = lt.out\n    lt_reg.write_en = 1'd1;\n    eq_reg.in = eq.out;\n    eq_reg.write_en = 1'd1;\n    comb_cond[done] = lt_reg.done & eq_reg.done ? 1'd1;\n}\ncontrol {\n    seq {\n      comb_cond;\n      invoke comp(left = lt_reg.out, ..)(..);\n    }\n    seq {\n      comb_cond;\n      if lt_reg.out {\n          ...\n      }\n    }\n    seq {\n      comb_cond;\n      while eq_reg.out {\n          ...\n          comb_cond;\n      }\n    }\n}\n```\n\n### `-calyx-remove-groups`\u00a0[\u00b6](#-calyx-remove-groups)\n\n*Inlines the groups in a Calyx component.*\n\nThis pass removes the Group interface from the Calyx program, and inlines all\nassignments. This is done in the following manner:\n\n1. Assign values to the \u2018done\u2019 signal of the component, corresponding with the\n   top-level control group\u2019s DoneOp. Add the \u2018go\u2019 signal of the component to\n   all assignments.\n2. TODO(Calyx): If there are multiple writes to a signal, replace the reads\n   with the disjunction.\n3. Remove all groups.\n\n### `-calyx-reset-insertion`\u00a0[\u00b6](#-calyx-reset-insertion)\n\n*Connect component reset to sub-component reset for applicable components.*\n\n### `-exclude-exec-region-canonicalize`\u00a0[\u00b6](#-exclude-exec-region-canonicalize)\n\n*Canonicalize all legal operations except `scf.execute_region`*\n\nThe AffineParallelUnroll pass unrolls the body of `affine.parallel`\nto multiple copies of `scf.execute_region`s. Since the semantics\nof those `scf.execute_region` has deviated from the original MLIR\ndefinition, a new canonicalization pass that does not operate on\n`scf.execute_region` is needed.\n\nComb Dialect Passes\u00a0[\u00b6](#comb-dialect-passes)\n---------------------------------------------\n\n### `-comb-assume-two-valued`\u00a0[\u00b6](#-comb-assume-two-valued)\n\n*Simplify under assumption of two-valued logic*\n\nPerforms simplifying transformations that are valid if all integer values\nare always two-valued (i.e., all bits are either 1 or 0).\n\n### `-comb-balance-mux`\u00a0[\u00b6](#-comb-balance-mux)\n\n*Balance and optimize mux chains*\n\nOptimizes mux chains through enhanced folding and priority mux\nrebalancing. Converts index comparisons to arrays and rebalances\nlinear chains into balanced trees, reducing depth from O(n) to O(log n).\n\n#### Options\u00a0[\u00b6](#options-32)\n\n```\n-mux-chain-threshold : Minimum number of linear mux chains to trigger rebalancing\n```\n\n### `-comb-int-range-narrowing`\u00a0[\u00b6](#-comb-int-range-narrowing)\n\n*Reduce comb op bitwidth based on integer range analysis.*\n\nCompute a basic value range analysis, by propagating integer intervals\nthrough the domain. The analysis is limited by a lack of sign-extension\noperator in the comb dialect, leading to an over-approximation.\nParticularly for signed arithmetic, a single interval is often an\nover-approximation, a more precise analysis would require a union of\nintervals.\n\n### `-comb-overflow-annotating`\u00a0[\u00b6](#-comb-overflow-annotating)\n\n*Annotate comb ops with no overflow signal (nuw).*\n\nUsing integer range analysis, annotate comb ops which cannot overflow with\nLLVMs no unsigned wrap (nuw) signal. This is useful for downstream passes\nwhich need to handle overflow conditions.\n\n### `-comb-simplify-tt`\u00a0[\u00b6](#-comb-simplify-tt)\n\n*Simplify truth tables that depend on 1 or less inputs*\n\nSimplifies truth tables that are constant or depend only on single input.\nFor truth tables that depend on no input, reduce them to hw.constant. For\ntruth tables that depend on single input, reduce to identity of input or\nnegation of input.\n\n### `-lower-comb`\u00a0[\u00b6](#-lower-comb)\n\n*Lowers the some of the comb ops*\n\nSome operations in the comb dialect (e.g. `comb.truth_table`) are not\ndirectly supported by ExportVerilog. They need to be lowered into ops which\nare supported. There are many ways to lower these ops so we do this in a\nseparate pass. This also allows the lowered form to participate in\noptimizations like the comb canonicalizers.\n\nDatapath Dialect Passes\u00a0[\u00b6](#datapath-dialect-passes)\n-----------------------------------------------------\n\n### `-datapath-reduce-delay`\u00a0[\u00b6](#-datapath-reduce-delay)\n\n*Reduce datapath delay at a cost of potentially greater area.*\n\nThis pass performs datapath transformations to reduce the delay of any\nmatching paths. The transformations include logic replication/duplication to\noperate on carry-save values, potentially increasing area usage.\n\nDC Dialect Passes\u00a0[\u00b6](#dc-dialect-passes)\n-----------------------------------------\n\n### `-dc-dematerialize-forks-sinks`\u00a0[\u00b6](#-dc-dematerialize-forks-sinks)\n\n*Dematerialize fork and sink operations.*\n\nThis pass analyses a function-like operation and removes all fork and sink\noperations.\n\n### `-dc-materialize-forks-sinks`\u00a0[\u00b6](#-dc-materialize-forks-sinks)\n\n*Materialize fork and sink operations.*\n\nThis pass analyses a function-like operation and inserts fork and sink\noperations ensuring that all values have exactly one use.\n\n### `-dc-print-dot`\u00a0[\u00b6](#-dc-print-dot)\n\n*Print .dot graph of a DC function.*\n\nThis pass analyses a dc modulen and prints a .dot graph of the\nstructure. If multiple functions are present in the IR, the top level\nfunction will be printed, and called functions will be subgraphs within\nthe main graph.\n\nESI Dialect Passes\u00a0[\u00b6](#esi-dialect-passes)\n-------------------------------------------\n\n### `-esi-appid-hier`\u00a0[\u00b6](#-esi-appid-hier)\n\n*Build an AppID based hierarchy rooted at top module \u2019top\u2019*\n\n#### Options\u00a0[\u00b6](#options-33)\n\n```\n-top : Root module of the instance hierarchy\n```\n\n### `-esi-build-manifest`\u00a0[\u00b6](#-esi-build-manifest)\n\n*Build a manifest of an ESI system*\n\n#### Options\u00a0[\u00b6](#options-34)\n\n```\n-top : Root module of the instance hierarchy\n```\n\n### `-esi-clean-metadata`\u00a0[\u00b6](#-esi-clean-metadata)\n\n*Clean up ESI service metadata*\n\n### `-esi-connect-services`\u00a0[\u00b6](#-esi-connect-services)\n\n*Connect up ESI service requests to service providers*\n\n### `-lower-esi-bundles`\u00a0[\u00b6](#-lower-esi-bundles)\n\n*Lower ESI bundles to channels.*\n\n### `-lower-esi-ports`\u00a0[\u00b6](#-lower-esi-ports)\n\n*Lower ESI input and/or output ports.*\n\n### `-lower-esi-to-hw`\u00a0[\u00b6](#-lower-esi-to-hw)\n\n*Lower ESI to HW where possible and SV elsewhere.*\n\n#### Options\u00a0[\u00b6](#options-35)\n\n```\n-platform : Target this platform\n```\n\n### `-lower-esi-to-physical`\u00a0[\u00b6](#-lower-esi-to-physical)\n\n*Lower ESI abstract Ops to ESI physical ops.*\n\n### `-lower-esi-types`\u00a0[\u00b6](#-lower-esi-types)\n\n*Lower ESI high level types.*\n\n### `-verify-esi-connections`\u00a0[\u00b6](#-verify-esi-connections)\n\n*Verify that channels and bundles are only used once*\n\nFIRRTL Dialect Passes\u00a0[\u00b6](#firrtl-dialect-passes)\n-------------------------------------------------\n\n### `-firrtl-add-seqmem-ports`\u00a0[\u00b6](#-firrtl-add-seqmem-ports)\n\n*Add extra ports to memory modules*\n\nThis pass looks for `AddSeqMemPortAnnotation` annotations and adds extra\nports to memories. It will emit metadata based if the\n`AddSeqMemPortsFileAnnotation` annotation is specified.\n\nThis pass requires that FIRRTL MemOps have been lowered to modules to add\nthe extra ports.\n\n#### Statistics\u00a0[\u00b6](#statistics-12)\n\n```\nnum-added-ports : Number of extra ports added\n```\n\n### `-firrtl-annotate-input-only-modules`\u00a0[\u00b6](#-firrtl-annotate-input-only-modules)\n\n*Annotate input-only modules with InlineAnnotation*\n\nThis pass identifies modules that have only input ports (no output or inout\nports) and annotates them with `firrtl.passes.InlineAnnotation`. These\nmodules don\u2019t produce any hardware outputs.\n\nInlining these modules is necessary because some synthesis tools treat\nmodules without outputs as blackboxes, which can cause synthesis errors.\n\n#### Statistics\u00a0[\u00b6](#statistics-13)\n\n```\nnum-annotated : Number of modules annotated\n```\n\n### `-firrtl-assign-output-dirs`\u00a0[\u00b6](#-firrtl-assign-output-dirs)\n\n*Assign output directories to modules.*\n\nWhile some modules are assigned output directories by the user, many modules\n\u201cdon\u2019t care\u201d what output directory they are placed into. This pass uses the\ninstance graph to assign these modules to the \u201cdeepest\u201d output directory\npossible.\n\n#### Options\u00a0[\u00b6](#options-36)\n\n```\n-output-dir : The default output directory.\n```\n\n### `-firrtl-blackbox-reader`\u00a0[\u00b6](#-firrtl-blackbox-reader)\n\n*Load source files for black boxes into the IR*\n\nThis pass reads the Verilog source files for black boxes and adds them as\n`sv.verbatim.file` operations into the IR. Later passes can then write\nthese files back to disk to ensure that they can be accessed by other tools\ndown the line in a well-known location. Supports inline and path\nannotations for black box source files.\n\nThe supported `firrtl.circuit` annotations are:\n\n* `{class = \"firrtl.transforms.BlackBoxTargetDirAnno\", targetDir = \"...\"}`\n  Overrides the target directory into which black box source files are\n  emitted.\n\nThe supported `firrtl.extmodule` annotations are:\n\n* ```\n  {\n    class = \"firrtl.transforms.BlackBoxInlineAnno\",\n    name = \"myfile.v\",\n    text = \"...\"\n  }\n  ```\n\n  Specifies the black box source code (`text`) inline. Generates a file with\n  the given `name` in the target directory.\n* ```\n  {\n    class = \"firrtl.transforms.BlackBoxPathAnno\",\n    path = \"myfile.v\"\n  }\n  ```\n\n  Specifies the file `path` as source code for the module. Copies the file\n  to the target directory.\n\n#### Options\u00a0[\u00b6](#options-37)\n\n```\n-input-prefix : Prefix for input paths in black box annotations. This should be the directory where the input file was located, to allow for annotations relative to the input file.\n```\n\n### `-firrtl-check-comb-loops`\u00a0[\u00b6](#-firrtl-check-comb-loops)\n\n*Check combinational cycles and emit errors*\n\nThis pass checks combinational cycles in the IR and emit errors.\n\n### `-firrtl-check-layers`\u00a0[\u00b6](#-firrtl-check-layers)\n\n*Check for illegal layers instantiated under layers*\n\nThis pass checks for illegal instantiation of a module with a layer\nunderneath another layer.\n\n### `-firrtl-check-recursive-instantiation`\u00a0[\u00b6](#-firrtl-check-recursive-instantiation)\n\n*Check for illegal recursive instantiation*\n\nThis pass checks for illegal recursive module instantion. Recursive\ninstantiation is when a module instantiates itself, either directly or\nindirectly through other modules it instantiates. Recursive module\ninstantiation is illegal because it would require infinite hardware to\nsynthesize. Recursive class instantiation is illegal as it would create an\ninfinite loop.\n\n### `-firrtl-dedup`\u00a0[\u00b6](#-firrtl-dedup)\n\n*Deduplicate modules which are structurally equivalent*\n\nThis pass detects modules which are structurally equivalent and removes the\nduplicate module by replacing all instances of one with the other.\nStructural equivalence ignores the naming of operations and fields in\nbundles, and any annotations. Deduplicating a module may cause the result\ntype of instances to change if the field names of a bundle type change. To\nhandle this, the pass will update any bulk-connections so that the correct\nfields are legally connected. Deduplicated modules will have their\nannotations merged, which tends to create many non-local annotations.\n\n#### Options\u00a0[\u00b6](#options-38)\n\n```\n-dedup-classes : Deduplicate classes, violating their nominal typing.\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-14)\n\n```\nnum-erased-modules : Number of modules which were erased by deduplication\n```\n\n### `-firrtl-drop-const`\u00a0[\u00b6](#-firrtl-drop-const)\n\n*Drop \u2018const\u2019 modifier from types*\n\nThis pass drops the \u2018const\u2019 modifier from all types and removes all\nconst-cast ops.\n\nThis simplifies downstream passes and folds so that they do not need to\ntake \u2018const\u2019 into account.\n\n### `-firrtl-drop-names`\u00a0[\u00b6](#-firrtl-drop-names)\n\n*Drop interesting names*\n\nThis pass changes names of namable ops to droppable so that we can disable\nfull name preservation. For example,\nbefore:\n\n```\n%a = firrtl.node interesting_name %input\n```\n\nafter:\n\n```\n%a = firrtl.node droppable_name %input\n```\n\n#### Options\u00a0[\u00b6](#options-39)\n\n```\n-preserve-values : specify the values which can be optimized away\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-15)\n\n```\nnum-names-dropped   : Number of names dropped\nnum-names-converted : Number of interesting names made droppable\n```\n\n### `-firrtl-eliminate-wires`\u00a0[\u00b6](#-firrtl-eliminate-wires)\n\n*Eliminate Unneeded Wires*\n\nThis pass eliminates wires for which the write dominates the reads and\nfor which there are no other preservation reasons.\n\n#### Statistics\u00a0[\u00b6](#statistics-16)\n\n```\nnum-erased-wires         : Number of wires erased\nnum-complex-wires        : Number of wires not erased due to complex writes\nnum-not-dominating-wires : Number of wires not erased due to dominance issues\nnum-not-passive-wires    : Number of wires not erased due to type issues\n```\n\n### `-firrtl-emit-metadata`\u00a0[\u00b6](#-firrtl-emit-metadata)\n\n*Emit metadata of the FIRRTL modules*\n\nThis pass handles the emission of several different kinds of metadata.\n\n#### Options\u00a0[\u00b6](#options-40)\n\n```\n-repl-seq-mem      : Lower the seq mem for macro replacement and emit relevant metadata\n-repl-seq-mem-file : File to which emit seq meme metadata\n```\n\n### `-firrtl-expand-whens`\u00a0[\u00b6](#-firrtl-expand-whens)\n\n*Remove all when conditional blocks.*\n\nThis pass will:\n\n1. Resolve last connect semantics.\n2. Remove all when operations.\n\nWhen a wire has multiple connections, only the final connection is used,\nall previous connections are overwritten. When there is a conditional\nconnect, the previous connect is only overwritten when the condition\nholds:\n\n```\nw <= a\nwhen c :\n  w <= b\n\n; Equivalent to:\nw <= mux(c, b, a)\n```\n\nThis pass requires that all connects are expanded.\n\n### `-firrtl-extract-instances`\u00a0[\u00b6](#-firrtl-extract-instances)\n\n*Move annotated instances upwards in the module hierarchy*\n\nThis pass takes instances in the design annotated with one out of a\nparticular set of annotations and pulls them upwards to a location further\nup in the module hierarchy.\n\nThe annotations that control the behaviour of this pass are:\n\n* `MarkDUTAnnotation`\n* `ExtractBlackBoxAnnotation`\n* `ExtractClockGatesFileAnnotation`\n\n### `-firrtl-finalize-ir`\u00a0[\u00b6](#-firrtl-finalize-ir)\n\n*Perform final IR mutations after ExportVerilog*\n\nThis pass finalizes the IR after it has been exported with ExportVerilog,\nand before firtool emits the final IR. This includes mutations like dropping\nverbatim ops that represent sideband files and are not required in the IR.\n\n### `-firrtl-flatten-memory`\u00a0[\u00b6](#-firrtl-flatten-memory)\n\n*Flatten aggregate memory data to a UInt*\n\nThis pass converts the data type of memories into a flat UInt, and inserts\nappropriate bitcasts to access the data.\n\n#### Statistics\u00a0[\u00b6](#statistics-17)\n\n```\nnum-flatten-mems : Number of memories flattened\n```\n\n### `-firrtl-grand-central`\u00a0[\u00b6](#-firrtl-grand-central)\n\n*Remove Grand Central Annotations*\n\nProcesses annotations associated with SiFive\u2019s Grand Central utility.\n\n#### Options\u00a0[\u00b6](#options-41)\n\n```\n-companion-mode : specify the handling of companion modules\n-no-views       : Delete FIRRTL view intrinsics\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-18)\n\n```\nnum-views-created       : Number of top-level SystemVerilog interfaces that were created\nnum-interfaces-created  : Number of SystemVerilog interfaces that were created\nnum-xmrs-created        : Number of SystemVerilog XMRs added\nnum-annotations-removed : Number of annotations removed\n```\n\n### `-firrtl-imconstprop`\u00a0[\u00b6](#-firrtl-imconstprop)\n\n*Intermodule constant propagation and dead code elimination*\n\nUse optimistic constant propagation to delete ports and unreachable IR.\n\n#### Statistics\u00a0[\u00b6](#statistics-19)\n\n```\nnum-folded-op : Number of operations folded\nnum-erased-op : Number of operations erased\n```\n\n### `-firrtl-imdeadcodeelim`\u00a0[\u00b6](#-firrtl-imdeadcodeelim)\n\n*Intermodule dead code elimination*\n\nThis pass performs inter-module liveness analysis and deletes dead code\naggressively. A value is considered as alive if it is connected to a port\nof public modules or a value with a symbol. We first populate alive values\ninto a set, and then propagate the liveness by looking at their dataflow.\n\n#### Statistics\u00a0[\u00b6](#statistics-20)\n\n```\nnum-erased-ops     : Number of operations erased\nnum-erased-modules : Number of modules erased\nnum-removed-ports  : Number of ports erased\n```\n\n### `-firrtl-infer-domains`\u00a0[\u00b6](#-firrtl-infer-domains)\n\n*Infer and type check all firrtl domains*\n\nThis pass does domain inference on a FIRRTL circuit. The end result of this\nis either a corrrctly domain-checked FIRRTL circuit or failure with verbose\nerror messages indicating why the FIRRTL circuit has illegal domain\nconstructs.\n\nE.g., this pass can be used to check for illegal clock-domain-crossings if\nclock domains are specified for signals in the design.\n\n#### Options\u00a0[\u00b6](#options-42)\n\n```\n-mode : infer, check, infer-all.\n```\n\n### `-firrtl-infer-resets`\u00a0[\u00b6](#-firrtl-infer-resets)\n\n*Infer reset synchronicity and add implicit resets*\n\nThis pass infers whether resets are synchronous or asynchronous, and extends\nreset-less registers with a reset based on the following\nannotations:\n\n* `circt.FullResetAnnotation`\n* `circt.ExcludeFromFullResetAnnotation`\n* `sifive.enterprise.firrtl.FullAsyncResetAnnotation` (deprecated)\n* `sifive.enterprise.firrtl.IgnoreFullAsyncResetAnnotation` (deprecated)\n\n### `-firrtl-infer-rw`\u00a0[\u00b6](#-firrtl-infer-rw)\n\n*Infer the read-write memory port*\n\nThis pass merges the read and write ports of a memory, using a simple\nmodule-scoped heuristic. The heuristic checks if the read and write enable\nconditions are mutually exclusive.\nThe heuristic tries to break up the read enable and write enable logic into an\n`AND` expression tree. It then compares the read and write `AND` terms,\nlooking for a situation where the read/write is the complement of the write/read.\n\n#### Statistics\u00a0[\u00b6](#statistics-21)\n\n```\nnum-rw-port-mems-inferred : Number of memories inferred to use RW port\n```\n\n### `-firrtl-infer-widths`\u00a0[\u00b6](#-firrtl-infer-widths)\n\n*Infer the width of types*\n\nThis pass infers the widths of all types throughout a FIRRTL module, and\nemits diagnostics for types that could not be inferred.\n\n### `-firrtl-inject-dut-hier`\u00a0[\u00b6](#-firrtl-inject-dut-hier)\n\n*Add a level of hierarchy outside the DUT*\n\nThis pass takes the DUT (as indicated by the presence of a\nMarkDUTAnnotation) and moves all the contents of it into a new module\ninsided the DUT named by an InjectDUTHierarchyAnnotation. This pass is\nintended to be used in conjunction with passes that pull things out of the\nDUT, e.g., SRAM extraction, to give the extracted modules a new home that is\nstill inside the original DUT.\n\n### `-firrtl-inliner`\u00a0[\u00b6](#-firrtl-inliner)\n\n*Performs inlining, flattening, and dead module elimination*\n\nThis inliner pass will inline any instance of module marked as inline, and\nrecursively inline all instances inside of a module marked with flatten.\nThis pass performs renaming of every entity with a name that is inlined by\nprefixing it with the instance name. This pass also will remove any module\nwhich is not reachable from the top level module.\n\nThe inline and flatten annotation attributes are attached to module\ndefinitions, and they are:\n\n```\n  {class = \"firrtl.passes.InlineAnnotation\"}\n  {class = \"firrtl.transforms.FlattenAnnotation\"}\n```\n\n### `-firrtl-inner-symbol-dce`\u00a0[\u00b6](#-firrtl-inner-symbol-dce)\n\n*Eliminate dead inner symbols*\n\nThis pass deletes all inner symbols which have no uses. This is necessary to\nunblock optimizations and removal of the operations which have these unused\ninner symbols.\n\n#### Statistics\u00a0[\u00b6](#statistics-22)\n\n```\nnum-inner-refs-found  : Number of inner-refs found\nnum-inner-sym-found   : Number of inner symbols found\nnum-inner-sym-removed : Number of inner symbols removed\n```\n\n### `-firrtl-layer-merge`\u00a0[\u00b6](#-firrtl-layer-merge)\n\n*Merge layer blocks*\n\nCombine all layer blocks in a module which reference the same layer\ndefinition.\n\n#### Statistics\u00a0[\u00b6](#statistics-23)\n\n```\nnum-merged : Number of layers merged\n```\n\n### `-firrtl-layer-sink`\u00a0[\u00b6](#-firrtl-layer-sink)\n\n*Sink operations into layer blocks*\n\nThis pass sinks ops into layers, whenever possible, to minimize unused\nhardware in the design.\n\n### `-firrtl-link-circuits`\u00a0[\u00b6](#-firrtl-link-circuits)\n\n*Links multiple circuits into a single one*\n\nThis pass concatenates all circuits into one, iterates through all extmodules\nto find matching public module implementations, replacing them when possible\nand any remaining extmodules are treated as blackboxes.\n\n#### Options\u00a0[\u00b6](#options-43)\n\n```\n-base-circuit : The base circuit name.\n-no-mangle    : Do not perform private symbol mangling.\n```\n\n### `-firrtl-lint`\u00a0[\u00b6](#-firrtl-lint)\n\n*An analysis pass to detect static simulation failures.*\n\nThis pass detects operations that will trivially fail any simulation.\nCurrently it detects assertions whose predicate condition can be statically\ninferred to be false. The pass emits error on such failing ops.\n\n#### Options\u00a0[\u00b6](#options-44)\n\n```\n-lint-static-asserts : enable linting of static assertions\n-lint-xmrs-in-design : enable linting of XMRs that exist in the design\n```\n\n### `-firrtl-lower-annotations`\u00a0[\u00b6](#-firrtl-lower-annotations)\n\n*Lower FIRRTL annotations to usable entities*\n\nLower FIRRTL annotations to usable forms. FIRRTL annotations are a big bag\nof semi-structured, irregular JSON. This pass normalizes all supported\nannotations and annotation paths.\n\n#### Options\u00a0[\u00b6](#options-45)\n\n```\n-disable-annotation-classless : Ignore classless annotations.\n-disable-annotation-unknown   : Ignore unknown annotations.\n-no-ref-type-ports            : Create normal ports, not ref type ports.\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-24)\n\n```\nnum-raw-annos       : Number of raw annotations on circuit\nnum-added-annos     : Number of additional annotations\nnum-annos           : Total number of annotations processed\nnum-unhandled-annos : Number of unhandled annotations\nnum-reused-hierpath : Number of reused HierPathOp's\n```\n\n### `-firrtl-lower-chirrtl`\u00a0[\u00b6](#-firrtl-lower-chirrtl)\n\n*Infer the memory ports of SeqMem and CombMem*\n\nThis pass finds the CHIRRTL behavioral memories and their ports, and\ntransforms them into standard FIRRTL memory operations. For each\n`seqmem` or `combmem`, a new memory is created. For every `memoryport`\noperation using a CHIRRTL memory, a memory port is defined on the\nnew standard memory.\n\nThe direction or kind of the port is inferred from how each of the memory\nports is used in the IR. If a memory port is only written to, it becomes\na `Write` port. If a memory port is only read from, it become a `Read`\nport. If it is used both ways, it becomes a `ReadWrite` port.\n\n`Write`, `ReadWrite` and combinational `Read` ports are disabled by\ndefault, but then enabled when the CHIRRTL memory port is declared.\nSequential `Read` ports have more complicated enable inference:\n\n1. If a wire or register is used as the index of the memory port, then\n   the memory is enabled whenever a non-invalid value is driven to the\n   address.\n2. If a node is used as the index of the memory port, then the memory is\n   enabled at the declaration of the node.\n3. In all other cases, the memory is never enabled.\n\nIn the first two cases, they can easily produce a situation where we try\nto enable the memory before it is even declared. This produces a\ncompilation error.\n\n#### Statistics\u00a0[\u00b6](#statistics-25)\n\n```\nnum-created-mems  : Number of memories created\nnum-lowered-mems  : Number of memories lowered\nnum-portless-mems : Number of memories dropped as having no valid ports\n```\n\n### `-firrtl-lower-classes`\u00a0[\u00b6](#-firrtl-lower-classes)\n\n*Lower FIRRTL classes and objects to OM classes and objects*\n\nThis pass walks all FIRRTL classes and creates OM classes. It also lowers\nFIRRTL objects to OM objects. OM classes are created with parameters\ncorresponding to FIRRTL input properties, and OM class fields corresponding\nto FIRRTL output properties. FIRRTL operations are converted to OM\noperations.\n\n### `-firrtl-lower-domains`\u00a0[\u00b6](#-firrtl-lower-domains)\n\n*Lower domain information to properties*\n\nLower all domain information into FIRRTL properties. This has the effect of\nerasing all domain information.\n\n#### Statistics\u00a0[\u00b6](#statistics-26)\n\n```\nnum-domains : Number of domains lowered\n```\n\n### `-firrtl-lower-dpi`\u00a0[\u00b6](#-firrtl-lower-dpi)\n\n*Lower DPI intrinsic into Sim DPI operations*\n\n### `-firrtl-lower-intmodules`\u00a0[\u00b6](#-firrtl-lower-intmodules)\n\n*Lower instances instances of intrinsic modules to ops.*\n\nThis pass replaces instances of intrinsic modules (intmodule) with\n`firrtl.int.generic` operations, and removes the intmodule\u2019s from\nthe circuit.\n\nUse this before running LowerIntrinsics.\n\n#### Options\u00a0[\u00b6](#options-46)\n\n```\n-fixup-eicg-wrapper : Lower `EICG_wrapper` modules into clock gate intrinsics\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-27)\n\n```\nnum-instances  : Number of intmodules instances lowered\nnum-intmodules : Number of intmodules lowered\n```\n\n### `-firrtl-lower-intrinsics`\u00a0[\u00b6](#-firrtl-lower-intrinsics)\n\n*Lower intrinsics*\n\nThis pass lowers generic intrinsic ops to their implementation or op.\n\n#### Statistics\u00a0[\u00b6](#statistics-28)\n\n```\nnum-converted : Number of intrinsic operations lowered\n```\n\n### `-firrtl-lower-layers`\u00a0[\u00b6](#-firrtl-lower-layers)\n\n*Lower layers and layer blocks to instances*\n\nThis pass lowers FIRRTL layers as defined by their convention. After this\npass, all layer blocks and layers are removed.\n\n#### Options\u00a0[\u00b6](#options-47)\n\n```\n-emit-all-bind-files : Emit bind files for private modules.\n```\n\n### `-firrtl-lower-matches`\u00a0[\u00b6](#-firrtl-lower-matches)\n\n*Remove all matchs conditional blocks*\n\nLowers FIRRTL match statements in to when statements, which can later be\nlowered with ExpandWhens.\n\n### `-firrtl-lower-memory`\u00a0[\u00b6](#-firrtl-lower-memory)\n\n*Lower memories to generated modules*\n\nThis pass lowers FIRRTL memory operations to generated modules.\n\n#### Statistics\u00a0[\u00b6](#statistics-29)\n\n```\nnum-created-mem-modules : Number of modules created\nnum-lowered-mems        : Number of memories lowered\n```\n\n### `-firrtl-lower-open-aggs`\u00a0[\u00b6](#-firrtl-lower-open-aggs)\n\n*Lower \u2018Open\u2019 aggregates by splitting out non-hardware elements*\n\nThis pass lowers aggregates of the more open varieties into their equivalents\nusing only hardware types, by pulling out non-hardware to other locations.\n\n### `-firrtl-lower-signatures`\u00a0[\u00b6](#-firrtl-lower-signatures)\n\n*Lower FIRRTL module signatures*\n\nLower aggregate FIRRTL types in Modules as indicated by the calling\nconvention.\n\n### `-firrtl-lower-types`\u00a0[\u00b6](#-firrtl-lower-types)\n\n*Lower FIRRTL types to ground types*\n\nLower aggregate FIRRTL types to ground types. Memories, ports, wires, etc\nare split apart by elements of aggregate types. The only aggregate types\nwhich exist after this pass are memory ports, though memory data types are\nsplit.\n\nConnect and expansion and canonicalization happen in this pass.\n\n#### Options\u00a0[\u00b6](#options-48)\n\n```\n-preserve-aggregate : Specify aggregate preservation mode\n-preserve-memories  : Specify memory preservation mode\n```\n\n### `-firrtl-lower-xmr`\u00a0[\u00b6](#-firrtl-lower-xmr)\n\n*Lower ref ports to XMR*\n\nThis pass lowers RefType ops and ports to verbatim encoded XMRs.\n\n### `-firrtl-materialize-debug-info`\u00a0[\u00b6](#-firrtl-materialize-debug-info)\n\n*Generate debug ops to track FIRRTL values*\n\nThis pass creates debug ops to track FIRRTL-level ports, nodes, wires,\nregisters, and instances throughout the pipeline. The `DebugInfo` analysis\ncan then be used at a later point in the pipeline to obtain a source\nlanguage view into the lowered IR.\n\n### `-firrtl-mem-to-reg-of-vec`\u00a0[\u00b6](#-firrtl-mem-to-reg-of-vec)\n\n*Convert combinational memories to a vector of registers*\n\nThis pass generates the logic to implement a memory using Registers.\n\n#### Options\u00a0[\u00b6](#options-49)\n\n```\n-repl-seq-mem           : Prepare seq mems for macro replacement\n-ignore-read-enable-mem : ignore the read enable signal, instead of assigning X on read disable\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-30)\n\n```\nnum-converted-mems : Number of memories converted to registers\n```\n\n### `-firrtl-merge-connections`\u00a0[\u00b6](#-firrtl-merge-connections)\n\n*Merge field-level connections into full bundle connections*\n\n#### Options\u00a0[\u00b6](#options-50)\n\n```\n-aggressive-merging : Merge connections even when source values won't be simplified.\n```\n\n### `-firrtl-module-summary`\u00a0[\u00b6](#-firrtl-module-summary)\n\n*Print a summary of modules.*\n\nThe pass produces a summary of modules.\n\n### `-firrtl-passive-wires`\u00a0[\u00b6](#-firrtl-passive-wires)\n\n*Make FIRRTL wires have passive type*\n\nEliminate flips from aggregate types on wires.\n\n### `-firrtl-print-field-source`\u00a0[\u00b6](#-firrtl-print-field-source)\n\n*Print field source information.*\n\n### `-firrtl-print-instance-graph`\u00a0[\u00b6](#-firrtl-print-instance-graph)\n\n*Print a DOT graph of the module hierarchy.*\n\n### `-firrtl-print-nla-table`\u00a0[\u00b6](#-firrtl-print-nla-table)\n\n*Print the NLA Table.*\n\n### `-firrtl-probes-to-signals`\u00a0[\u00b6](#-firrtl-probes-to-signals)\n\n*Convert probes to signals.*\n\nThis pass transforms the design to replace probes with non-probe signals\nthat are explicitly routed through the design instead of remote access.\nThe result will not be ABI-compatible but provide similar behavior without the\nuse of potentially unsynthesizable cross-module references.\n\nThe pass will do a complete conversion or produce an error.\n\nNot all FIRRTL designs with probes can be equivalently represented\nwith non-probes.\n\nRun after LowerOpenAggs, ExpandWhens (so ref.define can always be replaced),\nand any colored probes are removed through specialization.\n\nDue to differences in width and reset inference, it is suggested to run\nthose first as well but not required.\n\nRWProbes and related operations are not supported.\n\n### `-firrtl-randomize-register-init`\u00a0[\u00b6](#-firrtl-randomize-register-init)\n\n*Randomize register initialization.*\n\nThis pass eagerly creates large vectors of randomized bits for initializing\nregisters, and marks each register with attributes indicating which bits to\nread. If the registers survive until LowerToHW, their initialization logic\nwill pick up the correct bits.\n\nThis ensures a stable initialization, so registers should always see the\nsame initial value for the same seed, regardless of optimization levels.\n\n### `-firrtl-register-optimizer`\u00a0[\u00b6](#-firrtl-register-optimizer)\n\n*Optimizer Registers*\n\nThis pass applies classic FIRRTL register optimizations. These\noptimizations are isolated to this pass as they can change the visible\nbehavior of the register, especially before reset.\n\n### `-firrtl-remove-unused-ports`\u00a0[\u00b6](#-firrtl-remove-unused-ports)\n\n*Remove unused ports*\n\nThis pass removes unused ports without annotations or symbols. Implementation\nwise, this pass iterates over the instance graph in a topological order from\nleaves to the top so that we can remove unused ports optimally.\n\n#### Options\u00a0[\u00b6](#options-51)\n\n```\n-ignore-dont-touch : remove unused ports even if they have a symbol or annotation\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-31)\n\n```\nnum-removed-ports : Number of ports erased\n```\n\n### `-firrtl-resolve-paths`\u00a0[\u00b6](#-firrtl-resolve-paths)\n\n*Lowers UnresolvedPathOps to PathOps*\n\nFIRRTL path operations are initially create as unresolved path operations,\nwhich encode their target as a string. This pass parses and resolves those\ntarget strings to actual path operations. Path operations refer to their\ntargets using annotations with a unique identifier.\n\n### `-firrtl-resolve-traces`\u00a0[\u00b6](#-firrtl-resolve-traces)\n\n*Write out TraceAnnotations to an output annotation file*\n\nThis pass implements Chisel\u2019s Trace API. It collects all TraceAnnotations\nthat exist in the circuit, updates them with information about the final\ntarget in a design, and writes these to an output annotation file. This\nexists for Chisel users to build tooling around them that needs to query the\nfinal output name/path of some component in a Chisel circuit.\n\nNote: this pass and API are expected to be eventually replaced via APIs and\nlanguage bindings that enable users to directly query the MLIR.\n\n#### Options\u00a0[\u00b6](#options-52)\n\n```\n-file : Output file for the JSON-serialized Trace Annotations\n```\n\n### `-firrtl-sfc-compat`\u00a0[\u00b6](#-firrtl-sfc-compat)\n\n*Perform SFC Compatibility fixes*\n\n### `-firrtl-specialize-layers`\u00a0[\u00b6](#-firrtl-specialize-layers)\n\n*Specialize a configurable design for a given layer*\n\nThis pass performs specialization of layers, layerblocks, and probe\noperations by permanantly enabling or disabling layers. The layers are\nspecified by attributes on the `firrtl.circuit` operation in the\n`enable_layers` and `disable_layers` attributes which are both lists of\nSymbolRefAttrs. When a layer is specialized, it will be removed from the\ncircuit and all references to it should be cleaned up. If a layer is\ndisabled, all layerblock are referencing that layer will be deleted, and all\nprobe colored by that layer will be removed. When a layer is enabled, all\ncontents of the layer will be inlined in to the outer context, and probes\ncolored by that layer will no longer be colored.\n\n### `-firrtl-specialize-option`\u00a0[\u00b6](#-firrtl-specialize-option)\n\n*Specialize a configurable design for a given option.*\n\nIf the design has option groups, instead of preserving the information\nup to the emitted SystemVerilog, this pass specializes it early on for a\ngiven choice.\n\n#### Options\u00a0[\u00b6](#options-53)\n\n```\n-select-default-for-unspecified-instance-choice : Specialize instance choice to default, if no option selected.\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-32)\n\n```\nnum-instances : Number of instances specialized\n```\n\n### `-firrtl-vb-to-bv`\u00a0[\u00b6](#-firrtl-vb-to-bv)\n\n*Transform vector-of-bundles to bundle-of-vectors*\n\nThis pass converts vectors containing bundles, into bundles containing\nvectors.\n\n### `-firrtl-vectorization`\u00a0[\u00b6](#-firrtl-vectorization)\n\n*Transform firrtl primitive operations into vector operations*\n\nFSM Dialect Passes\u00a0[\u00b6](#fsm-dialect-passes)\n-------------------------------------------\n\n### `-fsm-print-graph`\u00a0[\u00b6](#-fsm-print-graph)\n\n*Print a DOT graph of an FSM\u2019s structure.*\n\nHandshake Dialect Passes\u00a0[\u00b6](#handshake-dialect-passes)\n-------------------------------------------------------\n\n### `-handshake-add-ids`\u00a0[\u00b6](#-handshake-add-ids)\n\n*Add an ID to each operation in a handshake function.*\n\nThis pass adds an ID to each operation in a handshake function. This id can\nbe used in lowerings facilitate mapping lowered IR back to the handshake code\nwhich it originated from. An ID is unique with respect to other operations\nof the same type in the function. The tuple of the operation name and the\noperation ID denotes a unique identifier for the operation within the\n`handshake.func` operation.\n\n### `-handshake-dematerialize-forks-sinks`\u00a0[\u00b6](#-handshake-dematerialize-forks-sinks)\n\n*Dematerialize fork and sink operations.*\n\nThis pass analyses a handshake.func operation and removes all fork and sink\noperations.\n\n### `-handshake-insert-buffers`\u00a0[\u00b6](#-handshake-insert-buffers)\n\n*Insert buffers to break graph cycles*\n\n#### Options\u00a0[\u00b6](#options-54)\n\n```\n-strategy    : Strategy to apply. Possible values are: cycles, allFIFO, all (default)\n-buffer-size : Number of slots in each buffer\n```\n\n### `-handshake-legalize-memrefs`\u00a0[\u00b6](#-handshake-legalize-memrefs)\n\n*Memref legalization and lowering pass.*\n\nLowers various memref operations to a state suitable for passing to the\nCFToHandshake lowering.\n\n### `-handshake-lock-functions`\u00a0[\u00b6](#-handshake-lock-functions)\n\n*Lock each function to only allow single invocations.*\n\nThis pass adds a locking mechanism to each handshake function. This mechanism\nensures that only one control token can be active in a function at each point\nin time.\n\n### `-handshake-lower-extmem-to-hw`\u00a0[\u00b6](#-handshake-lower-extmem-to-hw)\n\n*Lowers handshake.extmem and memref inputs to ports.*\n\nLowers handshake.extmem and memref inputs to a hardware-targeting\nmemory accessing scheme (explicit load- and store ports on the top\nlevel interface).\n\n#### Options\u00a0[\u00b6](#options-55)\n\n```\n-wrap-esi : Create an ESI wrapper for the module. Any extmem will be served by an esi.mem.ram service\n```\n\n### `-handshake-materialize-forks-sinks`\u00a0[\u00b6](#-handshake-materialize-forks-sinks)\n\n*Materialize fork and sink operations.*\n\nThis pass analyses a handshake.func operation and inserts fork and sink\noperations ensuring that all values have exactly one use.\n\n### `-handshake-op-count`\u00a0[\u00b6](#-handshake-op-count)\n\n*Count the number of operations (resources) in a handshake function.*\n\nThis pass analyses a handshake.func operation and prints the number of\noperations (resources) used the function.\n\n### `-handshake-print-dot`\u00a0[\u00b6](#-handshake-print-dot)\n\n*Print .dot graph of a handshake function.*\n\nThis pass analyses a handshake.func operation and prints a .dot graph of the\nstructure. If multiple functions are present in the IR, the top level\nfunction will be printed, and called functions will be subgraphs within\nthe main graph.\n\n### `-handshake-remove-buffers`\u00a0[\u00b6](#-handshake-remove-buffers)\n\n*Remove buffers from handshake functions.*\n\nThis pass analyses a handshake.func operation and removes any buffers from\nthe function.\n\n### `-handshake-split-merges`\u00a0[\u00b6](#-handshake-split-merges)\n\n*Deconstruct >2 input merge operations into 2-input merges*\n\nThis pass deconstructs the (rather complex) semantics of a >2 input merge\nand control merge operation into a series of 2-input merge operations +\nsupporting logic.\n\nHW Dialect Passes\u00a0[\u00b6](#hw-dialect-passes)\n-----------------------------------------\n\n### `-hw-aggregate-to-comb`\u00a0[\u00b6](#-hw-aggregate-to-comb)\n\n*Lower aggregate operations to comb operations*\n\nThis pass lowers aggregate *operations* to comb operations within modules.\nNote that this pass does not lower ports. Ports lowering is handled\nby FlattenIO.\n\nThis pass will change the behavior of out-of-bounds access of arrays,\nspecifically the last element of the array is used as a value for\nout-of-bounds access.\n\n### `-hw-bypass-inner-symbols`\u00a0[\u00b6](#-hw-bypass-inner-symbols)\n\n*Pass through values through inner symbols*\n\nThis pass moves inner symbols from ports to wires, then bypasses wire\noperations with inner symbols by replacing uses with their inputs while\nkeeping the wire to preserve the symbol. This enables optimizations to\ncross symbol boundaries while maintaining symbol references.\n\nWarning: This transformation assumes that values associated with inner\nsymbols are not mutated through inner symbols (e.g. force). This assumption\nmay not hold in simulation, but is safe in synthesis. This pass treats\ninner symbols differently from the optimization-blocking semantics that\nother parts of CIRCT use, so it is opt-in and should only be used when\nthe above assumptions hold.\n\n#### Statistics\u00a0[\u00b6](#statistics-33)\n\n```\nnum-ports-moved : Number of inner symbols moved from ports to wires\n```\n\n### `-hw-convert-bitcasts`\u00a0[\u00b6](#-hw-convert-bitcasts)\n\n*Convert hw.bitcast operations to bit extracts and concats*\n\nThis passes attempts to convert `hw.bitcast` operations on HW aggregates to\nfunctionally identical sequences of explicit aggregate and bit-access\noperations. It currently supports `!hw.array` and `!hw.struct` types.\n\n#### Options\u00a0[\u00b6](#options-56)\n\n```\n-allow-partial-conversion : Ignore bitcasts involving unsupported types\n```\n\n### `-hw-flatten-io`\u00a0[\u00b6](#-hw-flatten-io)\n\n*Flattens hw::Structure typed in- and output ports.*\n\n#### Options\u00a0[\u00b6](#options-57)\n\n```\n-recursive      : Recursively flatten nested structs.\n-flatten-extern : Flatten the extern modules also.\n-join-char      : Use a custom character to construct the flattened names.\n```\n\n### `-hw-flatten-modules`\u00a0[\u00b6](#-hw-flatten-modules)\n\n*Eagerly inline private modules*\n\nThis pass eagerly inlines private HW modules into their instantiation sites.\nThis is necessary for verification purposes, as model checking backends do not\nrequire or support the use of module hierarchy. For simulation, module hierarchies\ndegenerate into a purely cosmetic construct, at which point it is beneficial\nto fully flatten the module hierarchy to simplify further analysis and\noptimization of state transfer arcs.\n\nBy default, all private modules are inlined. The pass supports heuristics to\ncontrol which modules are inlined based on their characteristics.\n\n#### Options\u00a0[\u00b6](#options-58)\n\n```\n-hw-inline-empty      : Inline modules that are empty (only contain hw.output)\n-hw-inline-no-outputs : Inline modules that have no output ports\n-hw-inline-single-use : Inline modules that have only one use\n-hw-inline-small      : Inline modules that are small (fewer than smallThreshold operations)\n-hw-small-threshold   : Maximum number of operations for a module to be considered small\n-hw-inline-with-state : Allow inlining of modules that contain state (seq.firreg operations)\n-hw-inline-public     : Inline public modules as well as private ones\n-hw-inline-all        : Inline all private modules regardless of heuristics (default behavior)\n```\n\n### `-hw-foo-wires`\u00a0[\u00b6](#-hw-foo-wires)\n\n*Change all wires\u2019 name to foo*.\\_\n\nVery basic pass that numbers all of the wires in a given module.\nThe wires\u2019 names are then all converte to foo\\_.\n\n### `-hw-parameterize-constant-ports`\u00a0[\u00b6](#-hw-parameterize-constant-ports)\n\n*Parametize constant ports on private modules*\n\nThis pass converts input ports on private modules into parameters when all\ninstances pass constant values (or parameter values) to those ports.\n\nBy converting constant ports to parameters, synthesis pipelines can\nrecognize these values as compile-time constants through local analysis\nalone, without requiring inter-module analysis. This enables more precise\ntiming information and better optimization of each instance independently,\nsince the constant values are immediately visible at the module interface.\n\n### `-hw-print-instance-graph`\u00a0[\u00b6](#-hw-print-instance-graph)\n\n*Print a DOT graph of the module hierarchy.*\n\n### `-hw-print-module-graph`\u00a0[\u00b6](#-hw-print-module-graph)\n\n*Print a DOT graph of the HWModule\u2019s within a top-level module.*\n\n#### Options\u00a0[\u00b6](#options-59)\n\n```\n-verbose-edges : Print information on SSA edges (types, operand #, ...)\n```\n\n### `-hw-specialize`\u00a0[\u00b6](#-hw-specialize)\n\n*Specializes instances of parametric hw.modules*\n\nAny `hw.instance` operation instantiating a parametric `hw.module` will\ntrigger a specialization procedure which resolves all parametric types and\nvalues within the module based on the set of provided parameters to the\n`hw.instance` operation. This specialized module is created as a new\n`hw.module` and the referring `hw.instance` operation is rewritten to\ninstantiate the newly specialized module.\n\n### `-hw-verify-irn`\u00a0[\u00b6](#-hw-verify-irn)\n\n*Verify InnerRefNamespaceLike operations, if not self-verifying.*\n\nKanagawa Dialect Passes\u00a0[\u00b6](#kanagawa-dialect-passes)\n-----------------------------------------------------\n\n### `-kanagawa-add-operator-library`\u00a0[\u00b6](#-kanagawa-add-operator-library)\n\n*Injects the Kanagawa operator library into the IR*\n\nInjects the Kanagawa operator library into the IR, which contains the\ndefinitions of the Kanagawa operators.\n\n### `-kanagawa-argify-blocks`\u00a0[\u00b6](#-kanagawa-argify-blocks)\n\n*Add arguments to kanagawa blocks*\n\nAnalyses `kanagawa.sblock` operations and converts any SSA value defined outside\nthe `kanagawa.sblock` to a block argument. As a result, `kanagawa.sblock.isolated`\nare produced.\n\n### `-kanagawa-call-prep`\u00a0[\u00b6](#-kanagawa-call-prep)\n\n*Convert kanagawa method calls to use `dc.value`*\n\n### `-kanagawa-clean-selfdrivers`\u00a0[\u00b6](#-kanagawa-clean-selfdrivers)\n\n*Kanagawa clean selfdrivers pass*\n\n* Removes `kanagawa.port.input`s which are driven by operations within the same\n  container.\n* Removes reads of instance ports which are also written to within the same\n  container.\n\n### `-kanagawa-containerize`\u00a0[\u00b6](#-kanagawa-containerize)\n\n*Kanagawa containerization pass*\n\nConvert Kanagawa classes to containers, and outlines containers inside classes.\n\n### `-kanagawa-convert-cf-to-handshake`\u00a0[\u00b6](#-kanagawa-convert-cf-to-handshake)\n\n*Converts an `kanagawa.method` to `kanagawa.method.df`*\n\nConverts an `kanagawa.method` from using `cf` operations and MLIR blocks to\nan `kanagawa.method.df` operation, using the `handshake` dialect to represent\ncontrol flow through the `handshake` fine grained dataflow operations.\n\n### `-kanagawa-convert-containers-to-hw`\u00a0[\u00b6](#-kanagawa-convert-containers-to-hw)\n\n*Kanagawa containers to hw conversion pass*\n\nConverts `kanagawa.container` ops to `hw.module` ops.\n\n### `-kanagawa-convert-handshake-to-dc`\u00a0[\u00b6](#-kanagawa-convert-handshake-to-dc)\n\n*Converts an `kanagawa.method.df` to use DC*\n\nConverts an `kanagawa.method.df` from using `handshake` operations to\n`dc` operations.\n\n### `-kanagawa-convert-methods-to-containers`\u00a0[\u00b6](#-kanagawa-convert-methods-to-containers)\n\n*Converts `kanagawa.method.df` to `kanagawa.container`s*\n\n### `-kanagawa-eliminate-redundant-ops`\u00a0[\u00b6](#-kanagawa-eliminate-redundant-ops)\n\n*Kanagawa eliminate redundant operations pass*\n\nEliminates redundant operations within Kanagawa containers to optimize the IR.\nThis pass analyzes operations within containers and removes unnecessary or\nduplicate operations that do not affect the semantic behavior.\n\nRedundant operations can (read: will) cause issues in other passes. So this\npass needs to be run after any pass which can introduce redundant\noperations.\n\n### `-kanagawa-inline-sblocks`\u00a0[\u00b6](#-kanagawa-inline-sblocks)\n\n*Inlines `kanagawa.sblock` operations as MLIR blocks*\n\nInlines `kanagawa.sblock` operations, by creating MLIR blocks and `cf`\noperations, while adding attributes to the parent operation about\n`sblock`-specific attributes.\n\nThe parent attributes are located under the `kanagawa.blockinfo` identifier as\na dictionary attribute.\nEach entry in the dictionary consists of:\n\n* Key: an ID (numerical) string identifying the block.\n* Value: a dictionary of attributes. As a minimum this will contain a\n  `loc`-keyed attribute specifying the location of the block.\n\n### `-kanagawa-lower-portrefs`\u00a0[\u00b6](#-kanagawa-lower-portrefs)\n\n*Kanagawa portref lowering pass*\n\nLower `kanagawa.portref<portref <T>>` to T (i.e. portref resolution).\n\nWe do this by analyzing how a portref is used\ninside a container, and then creating an in- or output port based on that.\nThat is:\n\n* write to `portref<in portref<in, T>>` becomes `out T`\n  i.e this container wants to write to an input of another container, hence\n  it will produce an output value that will drive that input port.\n* read from `portref<in portref<out, T>>` becomes `in T`\n  i.e. this container wants to read from an output of another container,\n  hence it will have an input port that will be driven by that output port.\n* write to `portref<out portref<out, T>>` becomes `out T`\n  i.e. a port reference inside the module will be driven by a value from\n  the outside.\n* read from `portref<out portref<in, T>>` becomes `in T`\n  i.e. a port reference inside the module will be driven by a value from\n  the outside.\n\nA benefit of having portref lowering separate from portref tunneling is that\nportref lowering can be done on an `kanagawa.container` granularity, allowing\nfor a bit of parallelism in the flow.\n\n### `-kanagawa-prepare-scheduling`\u00a0[\u00b6](#-kanagawa-prepare-scheduling)\n\n*Prepare `kanagawa.sblock` operations for scheduling*\n\nPrepares `kanagawa.sblock` operations for scheduling by:\n\n* creating an `kanagawa.pipleine.header` operation\n* moving operations of an `kanagawa.sblock` into a `pipeline.unscheduled`\n  operation, which is connected to the pipeline header.\n\n### `-kanagawa-reblock`\u00a0[\u00b6](#-kanagawa-reblock)\n\n*Recreates `kanagawa.sblock` operations from a CFG*\n\nRecreates `kanagawa.sblock` operations from a CFG. Any `kanagawa.block.attributes`\noperations at the parent operation will be added to the resulting blocks.\n\nThe IR is expected to be in maximal SSA form prior to this pass, given that\nthe pass will only inspect the terminator operation of a block for any\nvalues that are generated within the block. Maximum SSA form thus ensures\nthat any value defined within the block is never used outside of the block.\n\nIt is expected that `kanagawa.call` operations have been isolated into\ntheir own basic blocks before this pass is run. This implies that all\noperations within a block (except for the terminator operation) can be\nstatically scheduled with each other.\n\ne.g.\n\n```\n^bb_foo(%arg0 : i32, %arg1 : i32):\n  %res = arith.addi %arg0, %arg1 : i32\n  %v = ...\n  cf.br ^bb_bar(%v : i32)\n```\n\nbecomes\n\n```\n^bb_foo(%arg0 : i32, %arg1 : i32):\n  %v_outer = kanagawa.sblock(%a0 : i32 = %arg0, %a1 : i32 = %arg1) -> (i32) {\n    %res = arith.addi %arg0, %arg1 : i32\n    %v = ...\n    kanagawa.sblock.return %v : i32\n  }\n  cf.br ^bb_bar(%v_outer : i32)\n```\n\n### `-kanagawa-tunneling`\u00a0[\u00b6](#-kanagawa-tunneling)\n\n*Kanagawa tunneling pass*\n\nTunnels relative `get_port` ops through the module hierarchy, based on\n`kanagawa.path` ops. The result of this pass is that various new in- and output\nports of `!kanagawa.portref<...>` type are created.\nAfter this pass, `get_port` ops should only exist at the same scope of\ncontainer instantiations.\n\nThe user may provide options for `readSuffix` and `writeSuffix`, respectively,\nwhich is to be used to generate the name of the ports that are tunneled\nthrough the hierarchy, with respect to how the port was requested to be accessed.\nSuffixes must be provided in cases where a port is tunneled for both read and\nwrite accesses, and the suffixes must be different (in this case, the suffixes\nwill be appended to the target port name, and thus de-alias the resulting ports).\n\n#### Options\u00a0[\u00b6](#options-60)\n\n```\n-read-suffix  : Suffix to be used for the port when a port is tunneled for read access\n-write-suffix : Suffix to be used for the port when a port is tunneled for write access\n```\n\nLLHD Dialect Passes\u00a0[\u00b6](#llhd-dialect-passes)\n---------------------------------------------\n\n### `-llhd-combine-drives`\u00a0[\u00b6](#-llhd-combine-drives)\n\n*Combine scalar drives into aggregate drives*\n\nIf individual drives cover all of an aggregate signal\u2019s fields, merge them\ninto a single drive of the whole aggregate value.\n\n### `-llhd-deseq`\u00a0[\u00b6](#-llhd-deseq)\n\n*Convert sequential processes to registers*\n\n### `-llhd-hoist-signals`\u00a0[\u00b6](#-llhd-hoist-signals)\n\n*Hoist probes and promote drives to process results*\n\n### `-llhd-inline-calls`\u00a0[\u00b6](#-llhd-inline-calls)\n\n*Inline all function calls in HW modules*\n\nInlines all `func.call` operations nested within `llhd.combinational`,\n`llhd.process`, and `llhd.final` ops within `hw.module`s. The `func.func`\ndefinitions are left untouched. After the inlining, MLIR\u2019s symbol DCE pass\nmay be used to eliminate the function definitions where possible.\n\nThis pass expects the `llhd-wrap-procedural-ops` pass to have already run.\nOtherwise call ops immediately in the module body, a graph region, cannot be\ninlined at all since the graph region cannot accommodate the function\u2019s\ncontrol flow.\n\n#### Statistics\u00a0[\u00b6](#statistics-34)\n\n```\ncalls-inlined : Number of call ops that were inlined\n```\n\n### `-llhd-lower-processes`\u00a0[\u00b6](#-llhd-lower-processes)\n\n*Convert process ops to combinational ops where possible*\n\n### `-llhd-mem2reg`\u00a0[\u00b6](#-llhd-mem2reg)\n\n*Promotes memory and signal slots into values.*\n\n### `-llhd-remove-control-flow`\u00a0[\u00b6](#-llhd-remove-control-flow)\n\n*Remove acyclic control flow and replace block args with muxes*\n\nRemove the control flow in `llhd.combinational` operations by merging all\nblocks into the entry block and replacing block arguments with multiplexers.\nThis requires the control flow to be acyclic, for example by unrolling all\nloops beforehand. Additionally, since this moves operations from\nconditionally executed blocks into the unconditionally executed entry block,\nall operations must be side-effect free.\n\n### `-llhd-sig2reg`\u00a0[\u00b6](#-llhd-sig2reg)\n\n*Promote LLHD signals to SSA values*\n\n### `-llhd-unroll-loops`\u00a0[\u00b6](#-llhd-unroll-loops)\n\n*Unroll control flow loops with static bounds*\n\nUnroll loops in `llhd.combinational` operations by replicating the loop body\nand replacing induction variables with constants. The loop bounds must be\nknown at compile time.\n\n### `-llhd-wrap-procedural-ops`\u00a0[\u00b6](#-llhd-wrap-procedural-ops)\n\n*Wrap procedural ops in modules to make them inlinable*\n\nOperations such as `func.call` or `scf.if` may appear in an `hw.module` body\ndirectly. They cannot be inlined into the module though, since the inlined\nfunction or result of converting the SCF ops to the CF dialect may create\ncontrol-flow operations with multiple blocks. This pass wraps such\noperations in `llhd.combinational` ops to give them an SSACFG region to\ninline into.\n\n#### Statistics\u00a0[\u00b6](#statistics-35)\n\n```\nops-wrapped : Number of procedural ops wrapped\n```\n\nMSFT Dialect Passes\u00a0[\u00b6](#msft-dialect-passes)\n---------------------------------------------\n\n### `-msft-export-tcl`\u00a0[\u00b6](#-msft-export-tcl)\n\n*Create tcl ops*\n\n#### Options\u00a0[\u00b6](#options-61)\n\n```\n-tops     : List of top modules to export Tcl for\n-tcl-file : File to output Tcl into\n```\n\n### `-msft-lower-constructs`\u00a0[\u00b6](#-msft-lower-constructs)\n\n*Lower high-level constructs*\n\n### `-msft-lower-instances`\u00a0[\u00b6](#-msft-lower-instances)\n\n*Lower dynamic instances*\n\nOM Dialect Passes\u00a0[\u00b6](#om-dialect-passes)\n-----------------------------------------\n\n### `-om-freeze-paths`\u00a0[\u00b6](#-om-freeze-paths)\n\n*Hard code all path information*\n\nReplaces paths to hardware with hard-coded string paths. This pass should\nonly run once the hierarchy will no longer change, and the final names for\nobjects have been decided.\n\n### `-om-link-modules`\u00a0[\u00b6](#-om-link-modules)\n\n*Link separated OM modules into a single module*\n\nFlatten nested modules and resolve external classes.\n\n### `-om-verify-object-fields`\u00a0[\u00b6](#-om-verify-object-fields)\n\n*Verify fields of ObjectOp are valid*\n\nVerify object fields are valid.\n\n### `-strip-om`\u00a0[\u00b6](#-strip-om)\n\n*Remove OM information*\n\nRemoves all OM operations from the IR. Useful as a prepass in pipelines that\nhave to discard OM.\n\nPipeline Dialect Passes\u00a0[\u00b6](#pipeline-dialect-passes)\n-----------------------------------------------------\n\n### `-pipeline-explicit-regs`\u00a0[\u00b6](#-pipeline-explicit-regs)\n\n*Makes stage registers explicit.*\n\nMakes all stage-crossing def-use chains into explicit registers.\n\n### `-pipeline-schedule-linear`\u00a0[\u00b6](#-pipeline-schedule-linear)\n\n*Schedules `pipeline.unscheduled` operations.*\n\nSchedules `pipeline.unscheduled` operations based on operator latencies.\n\nSeq Dialect Passes\u00a0[\u00b6](#seq-dialect-passes)\n-------------------------------------------\n\n### `-externalize-clock-gate`\u00a0[\u00b6](#-externalize-clock-gate)\n\n*Convert seq.clock\\_gate ops into hw.module.extern instances*\n\n#### Options\u00a0[\u00b6](#options-62)\n\n```\n-name          : Name of the external clock gate module\n-input         : Name of the clock input\n-output        : Name of the gated clock output\n-enable        : Name of the enable input\n-test-enable   : Name of the optional test enable input\n-instance-name : Name of the generated instances\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-36)\n\n```\nnum-clock-gates-converted : Number of clock gates converted to external module instances\n```\n\n### `-hw-memory-sim`\u00a0[\u00b6](#-hw-memory-sim)\n\n*Implement FIRRTMMem memories nodes with simulation model*\n\nThis pass replaces generated module nodes of type FIRRTLMem with a model\nsuitable for simulation.\n\n#### Options\u00a0[\u00b6](#options-63)\n\n```\n-disable-mem-randomization                                : Disable emission of memory randomization code\n-disable-reg-randomization                                : Disable emission of register randomization code\n-repl-seq-mem                                             : Prepare seq mems for macro replacement\n-read-enable-mode                                         : specify the behaviour of the read enable signal\n-add-mux-pragmas                                          : Add mux pragmas to memory reads\n-add-vivado-ram-address-conflict-synthesis-bug-workaround : Add a vivado attribute to specify a ram style of an array register\n```\n\n### `-lower-seq-fifo`\u00a0[\u00b6](#-lower-seq-fifo)\n\n*Lower seq.fifo ops*\n\n### `-lower-seq-hlmem`\u00a0[\u00b6](#-lower-seq-hlmem)\n\n*Lowers seq.hlmem operations.*\n\n### `-lower-seq-shiftreg`\u00a0[\u00b6](#-lower-seq-shiftreg)\n\n*Lower seq.shiftreg ops*\n\nDefault pass for lowering shift register operations. This will lower\ninto a chain of `seq.compreg.ce` operations.\nNote that this is *not* guaranteed to be a performant implementation,\nbut instead a default, fallback lowering path which is guaranteed to\nprovide a semantically valid path to verilog emissions.\nUsers are expected to provide a custom lowering pass to maps `seq.shiftreg`\noperations to target-specific primitives.\n\n### `-seq-reg-of-vec-to-mem`\u00a0[\u00b6](#-seq-reg-of-vec-to-mem)\n\n*Convert register arrays to FIRRTL memories*\n\nThis pass identifies register arrays that follow memory access patterns\nand converts them to seq.firmem operations. It looks for patterns where:\n\n1. A register array is updated via array\\_inject operations\n2. The array is read via array\\_get operations\n3. Updates are controlled by enable signals through mux operations\n4. Read and write operations use the same clock\n\nSSP Dialect Passes\u00a0[\u00b6](#ssp-dialect-passes)\n-------------------------------------------\n\n### `-ssp-print`\u00a0[\u00b6](#-ssp-print)\n\n*Prints all SSP instances as DOT graphs.*\n\n### `-ssp-roundtrip`\u00a0[\u00b6](#-ssp-roundtrip)\n\n*Roundtrips all SSP instances via the scheduling infrastructure*\n\n#### Options\u00a0[\u00b6](#options-64)\n\n```\n-check  : Check the problem's input constraints.\n-verify : Verify the problem's solution constraints.\n```\n\n### `-ssp-schedule`\u00a0[\u00b6](#-ssp-schedule)\n\n*Schedules all SSP instances.*\n\n#### Options\u00a0[\u00b6](#options-65)\n\n```\n-scheduler : Scheduling algorithm to use.\n-options   : Scheduler-specific options.\n```\n\nSV Dialect Passes\u00a0[\u00b6](#sv-dialect-passes)\n-----------------------------------------\n\n### `-hw-cleanup`\u00a0[\u00b6](#-hw-cleanup)\n\n*Cleanup transformations for operations in hw.module bodies*\n\nThis pass merges sv.alwaysff operations with the same condition, sv.ifdef\nnodes with the same condition, and perform other cleanups for the IR.\nThis is a good thing to run early in the HW/SV pass pipeline to expose\nopportunities for other simpler passes (like canonicalize).\n\n#### Options\u00a0[\u00b6](#options-66)\n\n```\n-merge-always-blocks : Allow always and always_ff blocks to be merged\n```\n\n### `-hw-eliminate-inout-ports`\u00a0[\u00b6](#-hw-eliminate-inout-ports)\n\n*Raises usages of inout ports into explicit input and output ports*\n\nThis pass raises usages of inout ports into explicit in- and output ports.\nThis is done by analyzing the usage of the inout ports and creating new\ninput and output ports at the using module, and subsequently moving the\ninout read- and writes to the instantiation site.\n\n#### Options\u00a0[\u00b6](#options-67)\n\n```\n-read-suffix  : Suffix to be used for the port when the inout port has readers\n-write-suffix : Suffix to be used for the port when the inout port has writers\n```\n\n### `-hw-export-module-hierarchy`\u00a0[\u00b6](#-hw-export-module-hierarchy)\n\n*Export module and instance hierarchy information*\n\nThis pass exports the module and instance hierarchy tree for each module\nwith the firrtl.moduleHierarchyFile attribute. These are lowered to\nsv.verbatim ops with the output\\_file attribute.\n\n### `-hw-generator-callout`\u00a0[\u00b6](#-hw-generator-callout)\n\n*Lower Generator Schema to external module*\n\nThis pass calls an external program for all the hw.module.generated nodes,\nfollowing the description in the hw.generator.schema node.\n\n#### Options\u00a0[\u00b6](#options-68)\n\n```\n-schema-name                    : Name of the schema to process\n-generator-executable           : Generator program executable with optional full path\n-generator-executable-arguments : Generator program arguments separated by ;\n```\n\n### `-hw-legalize-modules`\u00a0[\u00b6](#-hw-legalize-modules)\n\n*Eliminate features marked unsupported in LoweringOptions*\n\nThis pass lowers away features in the SV/Comb/HW dialects that are\nunsupported by some tools, e.g. multidimensional arrays. This pass is\nrun relatively late in the pipeline in preparation for emission. Any\npasses run after this must be aware they cannot introduce new invalid\nconstructs.\n\n### `-hw-stub-external-modules`\u00a0[\u00b6](#-hw-stub-external-modules)\n\n*Transform external hw modules to empty hw modules*\n\nThis pass creates empty module bodies for external modules. This is\nuseful for linting to eliminate missing file errors.\n\n### `-prettify-verilog`\u00a0[\u00b6](#-prettify-verilog)\n\n*Transformations to improve quality of ExportVerilog output*\n\nThis pass contains elective transformations that improve the quality of\nSystemVerilog generated by the ExportVerilog library. This pass is not\ncompulsory: things that are required for ExportVerilog to be correct\nshould be included as part of the ExportVerilog pass itself to make sure\nit is self contained.\n\n### `-sv-extract-test-code`\u00a0[\u00b6](#-sv-extract-test-code)\n\n*Extract simulation only constructs to modules and bind*\n\nThis pass extracts cover, assume, assert operations to a module, along with\nany ops feeding them only, to modules which are instantiated with a bind\nstatement.\n\n#### Options\u00a0[\u00b6](#options-69)\n\n```\n-disable-instance-extraction : Disable extracting instances only that feed test code\n-disable-register-extraction : Disable extracting registers only that feed test code\n-disable-module-inlining     : Disable inlining modules that only feed test code\n```\n\n#### Statistics\u00a0[\u00b6](#statistics-37)\n\n```\nnum-ops-extracted : Number of ops extracted\nnum-ops-erased    : Number of ops erased\n```\n\n### `-sv-trace-iverilog`\u00a0[\u00b6](#-sv-trace-iverilog)\n\n*Add tracing to an iverilog simulated module*\n\nThis pass adds the necessary instrumentation to a HWModule to trigger\ntracing in an iverilog simulation.\n\n#### Options\u00a0[\u00b6](#options-70)\n\n```\n-top-only : If true, will only add tracing to the top-level module.\n-module   : Module to trace. If not provided, will trace all modules\n-dir-name : Directory to emit into\n```\n\nSynth Dialect Passes\u00a0[\u00b6](#synth-dialect-passes)\n-----------------------------------------------\n\n### `-synth-abc-runner`\u00a0[\u00b6](#-synth-abc-runner)\n\n*Run ABC on AIGER files*\n\nThis pass runs ABC on AIGER files. It is a wrapper around AIGERRunner that\nuses ABC as the external solver. It runs the following ABC commands:\n\n* `read <inputFile>`: Read the AIGER file\n* for each command in `abcCommands`, run `-q <command>`\n* `write <outputFile>`: Write the AIGER file\n\n#### Options\u00a0[\u00b6](#options-71)\n\n```\n-continue-on-failure : Don't fail even if the AIGER exporter, external solver, or AIGER importer fail\n-abc-path            : Path to the ABC executable\n-abc-commands        :\n```\n\n### `-synth-aiger-runner`\u00a0[\u00b6](#-synth-aiger-runner)\n\n*Run external solver on AIGER files*\n\nThis pass runs an external solver on AIGER files. It exports the current\nmodule to AIGER format, runs the external solver, and imports the result\nback into the module.\n\n#### Options\u00a0[\u00b6](#options-72)\n\n```\n-continue-on-failure : Don't fail even if the AIGER exporter, external solver, or AIGER importer fail\n-aiger-path          : Path to the AIGER file\n-solver-path         : Path to the external solver\n-solver-args         :\n```\n\n### `-synth-generic-lut-mapper`\u00a0[\u00b6](#-synth-generic-lut-mapper)\n\n*LUT mapping using generic K-input LUTs*\n\nThis pass performs technology mapping using generic K-input lookup tables\n(LUTs). It converts combinational logic networks into implementations\nusing K-input LUTs (comb.truth\\_table) with unit area cost and delay.\n\n#### Options\u00a0[\u00b6](#options-73)\n\n```\n-max-cuts-per-root : Maximum number of cuts to maintain per node\n-strategy          : Optimization strategy (area vs. timing)\n-test              : Attach timing to IR for testing\n-max-lut-size      : Maximum number of inputs per LUT\n```\n\n### `-synth-lower-variadic`\u00a0[\u00b6](#-synth-lower-variadic)\n\n*Lower variadic operations to binary operations*\n\nThis pass lowers variadic operations to binary operations using a\ndelay-aware algorithm. For commutative operations, it builds a balanced\ntree by combining values with the earliest arrival times first to minimize\nthe critical path.\n\n#### Options\u00a0[\u00b6](#options-74)\n\n```\n-op-names     : Specify operation names to lower (empty means all)\n-timing-aware : Lower operators with timing information\n```\n\n### `-synth-lower-word-to-bits`\u00a0[\u00b6](#-synth-lower-word-to-bits)\n\n*Lower multi-bit AndInverter to single-bit ones*\n\n#### Statistics\u00a0[\u00b6](#statistics-38)\n\n```\nnum-lowered-bits      : Number of total bits lowered including constant\nnum-lowered-constants : Number of total constant bits lowered\nnum-lowered-ops       : Number of total operations lowered\n```\n\n### `-synth-maximum-and-cover`\u00a0[\u00b6](#-synth-maximum-and-cover)\n\n*Maximum And Cover for And-Inverter*\n\nThis pass performs maximum AND-cover optimization by collapsing single-fanout\nand-inverter ops into their users\n\n### `-synth-print-longest-path-analysis`\u00a0[\u00b6](#-synth-print-longest-path-analysis)\n\n*Print longest path analysis results with detailed timing statistics*\n\nThis pass performs longest path analysis on AIG circuits and outputs detailed\ntiming information including:\n\n* Delay distribution statistics showing timing levels and path counts\n* Critical path details for the top N end points\n* Path history with intermediate debug points for detailed analysis\n\nThe analysis considers each AIG and-inverter operation to have unit delay and\ncomputes maximum delays through combinational paths across module hierarchies.\n\n#### Options\u00a0[\u00b6](#options-75)\n\n```\n-output-file        : Output file for analysis results (use '-' for stdout)\n-test               : Emit longest paths as diagnostic remarks for testing\n-show-top-k-percent : The size of the longest paths to show.\n-emit-json          : Output analysis results in JSON format\n-top-module-name    : Name of the top module to analyze (empty for automatic inference from instance graph)\n```\n\n### `-synth-sop-balancing`\u00a0[\u00b6](#-synth-sop-balancing)\n\n*SOP (Sum-of-Products) balancing for delay optimization*\n\nThis pass optimizes delay by restructuring the logic network using balanced\nsum-of-products expressions. It enumerates cuts, derives their SOP\nrepresentation, and selects the best cut based on delay and area.\n\nThe algorithm is based on \u201cDelay Optimization Using SOP Balancing\u201d by\nMishchenko et al. (ICCAD 2011).\n\n#### Options\u00a0[\u00b6](#options-76)\n\n```\n-max-cuts-per-root  : Maximum number of cuts to maintain per node\n-strategy           : Optimization strategy (area vs. timing)\n-test               : Attach timing to IR for testing\n-max-cut-input-size : Maximum number of inputs per cut\n```\n\n### `-synth-structural-hash`\u00a0[\u00b6](#-synth-structural-hash)\n\n*Structural hashing (CSE) for Synth operations*\n\nThis pass performs aggressive structural hashing-based CSE for Synth dialect\noperations (AIG/MIG), domain-specific to AIG/MIG operations to enable operand\nreordering based on structural properties and inversion flag consideration\nfor canonicalization.\n\n### `-synth-tech-mapper`\u00a0[\u00b6](#-synth-tech-mapper)\n\n*Technology mapping using cut rewriting*\n\nThis pass performs technology mapping by converting logic network\n(AIG etc) representations into technology-specific gate implementations.\nIt uses cut-based rewriting with priority cuts and NPN canonical forms for\nefficient pattern matching.\n\nThe pass serves dual purposes: providing practical technology mapping\ncapabilities and acting as a test vehicle for the cut rewriting framework,\nsince testing cut enumeration and pattern matching algorithms directly\nwould otherwise be difficult without a concrete application.\n\nSupports both area and timing optimization strategies.\n\n#### Options\u00a0[\u00b6](#options-77)\n\n```\n-max-cuts-per-root : Maximum number of cuts to maintain per node\n-strategy          : Optimization strategy (area vs. timing)\n-test              : Attach timing to IR for testing\n```\n\n### `-synth-test-priority-cuts`\u00a0[\u00b6](#-synth-test-priority-cuts)\n\n*Test priority cuts for synthesis*\n\n#### Options\u00a0[\u00b6](#options-78)\n\n```\n-max-cuts-per-root  : Maximum number of cuts to maintain per node\n-max-cut-input-size : Maximum number of cut inputs to consider\n```\n\nSystemC Dialect Passes\u00a0[\u00b6](#systemc-dialect-passes)\n---------------------------------------------------\n\n### `-systemc-lower-instance-interop`\u00a0[\u00b6](#-systemc-lower-instance-interop)\n\n*Lower all SystemC instance interop operations.*\n\nLEC (logical equivalence checking) Passes\u00a0[\u00b6](#lec-logical-equivalence-checking-passes)\n---------------------------------------------------------------------------------------\n\n### `-construct-lec`\u00a0[\u00b6](#-construct-lec)\n\n*Lower CIRCTs core dialects to a LEC problem statement*\n\nTakes two `hw.module` operations and lowers them to a `verif.lec` operation\ninside a `func.func` matching the name of the first module.\n\nThis pass can also (optionally) insert a \u2018main\u2019 function that calls the\nfunction with the `verif.lec` and adheres to the typical main function\nsignature. This is useful when compiling to a standalone binary rather than\nusing the JIT compiler.\n\nThis pass also inserts a few LLVM dialect operation to print the result of\nthe `verif.lec` using the `printf` function of the standard library.\n\n#### Options\u00a0[\u00b6](#options-79)\n\n```\n-first-module  : Name of the first of the two modules to compare.\n-second-module : Name of the second of the two modules to compare.\n-insert-mode   : Select what additional code to add.\n```\n\nBMC (bounded model checking) Passes\u00a0[\u00b6](#bmc-bounded-model-checking-passes)\n---------------------------------------------------------------------------\n\n### `-externalize-registers`\u00a0[\u00b6](#-externalize-registers)\n\n*Removes registers and adds corresponding input and output ports*\n\n### `-lower-to-bmc`\u00a0[\u00b6](#-lower-to-bmc)\n\n*Lower CIRCTs core dialects to a BMC problem statement*\n\n#### Options\u00a0[\u00b6](#options-80)\n\n```\n-top-module           : Name of the top module to verify.\n-bound                : Cycle bound.\n-ignore-asserts-until : Specifies an initial window of cycles where assertions should be ignored (starting from 0).\n-insert-main          : Whether a main function should be inserted for AOT compilation.\n-rising-clocks-only   : Only consider the circuit and property on rising clock edges.\n```\n\n [Prev - HLS in CIRCT](https://circt.llvm.org/docs/HLS/ \"HLS in CIRCT\")\n[Next - Python CIRCT Design Entry (PyCDE)](https://circt.llvm.org/docs/PyCDE/ \"Python CIRCT Design Entry (PyCDE)\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/PyCDE/index.md"
  },
  {
    "role": "user",
    "content": "Python CIRCT Design Entry (PyCDE) - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nPython CIRCT Design Entry (PyCDE)\n=================================\n\nPyCDE is a python API for hardware related activities. It was intended to make\nCIRCT functionality easy to expose to Python developers. PyCDE, therefore,\nmostly maps down to CIRCT operations through \u201ca bit\u201d of syntactic sugar. The\nvast majority of the work is done by CIRCT.\n\nInstallation\n------------\n\nBecause PyCDE is rapidly evolving, we recommend always using the latest\npre-release. New packages are posted nightly if there have been updates (and so\nlong as the build and CI are working).\n\n```\npip install pycde --pre\n```\n\nor\n[compile it yourself](/docs/PyCDE/compiling/) (not recommended).\n\nHello world!\n------------\n\nThe following example demonstrates a simple module that ors two integers:\n\n```\nfrom pycde import Input, Output, Module, System\nfrom pycde import generator\nfrom pycde.types import Bits\n\nclass OrInts(Module):\n    a = Input(Bits(32))\n    b = Input(Bits(32))\n    c = Output(Bits(32))\n\n    @generator\n    def construct(self):\n        self.c = self.a | self.b\n\n\nsystem = System([OrInts], name=\"ExampleSystem\", output_directory=\"exsys\")\nsystem.compile()\n```\n\nPython CIRCT Design Entry (PyCDE) Docs\n--------------------------------------\n\n* [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n* [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n\n [Prev - Passes](https://circt.llvm.org/docs/Passes/ \"Passes\")\n[Next - Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/ \"Compiling CIRCT and PyCDE\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/PyCDE/compiling/index.md"
  },
  {
    "role": "user",
    "content": "Compiling CIRCT and PyCDE - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nCompiling CIRCT and PyCDE\n=========================\n\nPyCDE is compiled as a component of CIRCT which pulls in the LLVM/MLIR project\nas a submodule. As such, compiling it is complex and takes some time. If you\u2019re\nnot a CIRCT or PyCDE developer,\n[use pip](https://pypi.org/project/pycde/).\n\nCloning the repo\u00a0[\u00b6](#cloning-the-repo)\n---------------------------------------\n\nIf you havent already, you need to clone the CIRCT repo. Unless you already\nhave contributor permissions to the LLVM project, the easiest way to develop\n(with the ability to create and push branches) is to fork the repo in your\nGitHub account. You can then clone your fork. The clone command should look\nlike this:\n\n```\ngit clone git@github.com:<your_github_username>/circt.git <optional_repo_name>\n```\n\nIf you don\u2019t envision needing that ability, you can clone the main repo\nfollowing the directions in step 2 of the\n[GettingStarted](GettingStarted.md) page.\n\nAfter cloning, navigate to your repo root (circt is the default) and use the\nfollowing to pull down LLVM:\n\n```\ngit submodule update --init\n```\n\nPyCDE Installation\u00a0[\u00b6](#pycde-installation)\n-------------------------------------------\n\n### Installing and Building with Wheels\u00a0[\u00b6](#installing-and-building-with-wheels)\n\nIf you are using a fork, you\u2019ll need the git tags since the package versioning step requires them:\n\n```\ngit remote add upstream git@github.com:llvm/circt.git\ngit fetch upstream --tags\n```\n\nThe simplest way to compile PyCDE for local use is to install it with the `pip install` command:\n\n```\n$ cd circt\n$ pip install frontends/PyCDE --use-feature=in-tree-build\n```\n\nIf you just want to build the wheel, use the `pip wheel` command:\n\n```\n$ cd circt\n$ pip wheel frontends/PyCDE --use-feature=in-tree-build\n```\n\nThis will create a `pycde-<version>-<python version>-<platform>.whl` file in the root of the repo.\n\n### Manual Compilation\u00a0[\u00b6](#manual-compilation)\n\nFollow these steps to setup your repository for installing PyCDE via CMake.\nEnsure that your repo has the proper Python requirements by running the\nfollowing from your CIRCT repo root:\n\n```\npython -m pip install -r frontends/PyCDE/python/requirements.txt\n```\n\nAlthough not scrictly needed for PyCDE develoment, scripts for some tools you\nmight want to install are located in utils/\n(Verilator, OR-Tools):\n\n```\nutils/get-verilator.sh\nutils/get-or-tools.sh\n```\n\nInstall PyCDE with CMake. PyCDE requires cmake version >= 3.21:\n\n```\nmkdir build\ncd build\ncmake \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DLLVM_ENABLE_PROJECTS=mlir \\\n    -DLLVM_ENABLE_ASSERTIONS=ON \\\n    -DLLVM_EXTERNAL_PROJECTS=circt \\\n    -DLLVM_EXTERNAL_CIRCT_SOURCE_DIR=.. \\\n    -DMLIR_ENABLE_BINDINGS_PYTHON=ON \\\n    -DCIRCT_BINDINGS_PYTHON_ENABLED=ON \\\n    -DCIRCT_ENABLE_FRONTENDS=PyCDE\n    -G Ninja ../llvm/llvm\n```\n\nAlternatively, you can pass the source and build paths to the CMake command and\nbuild in the specified folder:\n\n```\ncmake \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DLLVM_ENABLE_PROJECTS=mlir \\\n    -DLLVM_ENABLE_ASSERTIONS=ON \\\n    -DLLVM_EXTERNAL_PROJECTS=circt \\\n    -DMLIR_ENABLE_BINDINGS_PYTHON=ON \\\n    -DCIRCT_BINDINGS_PYTHON_ENABLED=ON \\\n    -DCIRCT_ENABLE_FRONTENDS=PyCDE \\\n    -G Ninja \\\n    -DLLVM_EXTERNAL_CIRCT_SOURCE_DIR=<your_circt_repo_root_path> \\\n    -B<path_to_desired_build_dir> \\\n    <your_circt_repo_root_path>/llvm/llvm\n```\n\nAfterwards, use the following commands to ensure that CIRCT and PyCDE are built\nand the tests pass:\n\n```\nninja -C <path_to_your_circt_build> check-circt\nninja -C <path_to_your_circt_build> check-pycde\nninja -C <path_to_your_circt_build> check-pycde-integration\n```\n\nIf you want to use PyCDE after compiling it, you must add the core CIRCT\nbindings and PyCDE to your PYTHONPATH. This is quite helpful if you are hacking\non PyCDE as you don\u2019t have to run an install after each Python file change since\nNinja uses links in the build dir rather than copying the files as it does\nduring install.\n\n```\nexport PYTHONPATH=\"<full_path_to_your_circt_build>/tools/circt/python_packages/pycde\"\n```\n\nIf you are installing PyCDE through `ninja install`, the libraries and Python modules will be installed into the correct location automatically.\n\n [Prev - Python CIRCT Design Entry (PyCDE)](https://circt.llvm.org/docs/PyCDE/ \"Python CIRCT Design Entry (PyCDE)\")\n[Next - PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/ \"PyCDE Basics\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)-](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/PyCDE/basics/index.md"
  },
  {
    "role": "user",
    "content": "PyCDE Basics - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nPyCDE Basics\n============\n\nYou know what\u2019s more difficult than forcing yourself to write documentation?\nMaintaining it! We apologize for the inevitable inaccuracies.\n\nModules, Generators, and Systems\u00a0[\u00b6](#modules-generators-and-systems)\n---------------------------------------------------------------------\n\n```\nfrom pycde import Input, Output, Module, System\nfrom pycde import generator\nfrom pycde.types import Bits\n\nclass OrInts(Module):\n    a = Input(Bits(32))\n    b = Input(Bits(32))\n    c = Output(Bits(32))\n\n    @generator\n    def construct(self):\n        self.c = self.a | self.b\n\n\nsystem = System([OrInts], name=\"ExampleSystem\", output_directory=\"exsys\")\nsystem.compile()\n```\n\nHardware modules extend `pycde.Module`. They define any number of typed inputs\nand outputs by setting class members.\n\nThe `pycde.generator` decorator is used to denote the module construction code.\nIt is called once per module at `compile` time. Unlike standard python, the body\nof the generator does not have access to instance members through `self` \u2013 just\nports. All of the output ports **must** be set.\n\nIn order to compile a hardware system, use `System` constructing it with the\nclass or list of classes which are the top modules. Other modules instantiated\nin the generators get generated and emitted automatically and recursively (i.e.\nonly the root of the hierarchy needs to be given). `name` defaults to the top\nmodule name. `output_directory` defaults to `name`. The `compile` method outputs\na \u201cbuild package\u201d containing the generated system into `output_directory`.\n\nInstantiating Modules\u00a0[\u00b6](#instantiating-modules)\n-------------------------------------------------\n\nModules can be instantiated in other modules. The following example defines a module that instantiates the `AddInts` module defined above.\n\n```\nclass Top(Module):\n    a = Input(Bits(32))\n    b = Input(Bits(32))\n    c = Output(Bits(32))\n\n    @generator\n    def construct(self):\n        or_ints = OrInts(a=self.a, b=self.b)\n        self.c = or_ints.c\n\n\nsystem = System([Top], name=\"ExampleSystem\")\nsystem.compile()\n```\n\nThe constructor of a `Module` expects named keyword arguments for each input\nport. These keyword arguments can be any PyCDE Signal. The above example uses\nmodule inputs. Instances of `Module`s support named access to output port values\nlike `add_insts.c`. These output port values are PyCDE Signals, and can be use\nto further connect modules or instantiate CIRCT dialect operations.\n\nTypes & Signals\u00a0[\u00b6](#types--signals)\n------------------------------------\n\nSince CIRCT primarily targets hardware not software, it defines its own types.\nPyCDE exposes them through the `pycde.types.Type` class hierarchy. PyCDE\nsignals represent values on the target device. Signals have a particular `Type`\n(which is distinct from the signal objects\u2019 Python `type`) stored in their\n`type` instance member. `Type`s are heretofor referred to interchangeably as\n\u201cPyCDE type\u201d, \u201cCIRCT type\u201d, or \u201cType\u201d.\n\nAll signals extend the `pycde.signals.Signal` class, specialized by their Type.\nThe various specializations often include operator overrides to perform common\noperations, as demonstrated in the hello world example\u2019s `|` bitwise or.\n\nNote that the CIRCT type conveys information not just about the data type but\ncan also specify the signaling mechanism. In other words, a signal does not\nnecessarily imply standard wires (though it usually does).\n\n\\*\\* For CIRCT/MLIR developers: \u201csignals\u201d map 1:1 to MLIR Values.\n\n### Constants and Python object conversion\u00a0[\u00b6](#constants-and-python-object-conversion)\n\nSome Python objects (e.g. int, dict, list) can be converted to constants in\nhardware. PyCDE tries its best to make this automatic, but it sometimes needs to\nknow the Type. For instance, we don\u2019t know the desired bitwidth of an int. In\nsome cases we default to the required number of bits to represent a number, but\nsometimes that fails.\n\nIn those cases, you must manually specify the Type. So `Bits(16)(i)` would\ncreate a 16-bit constant of `i`.\n\n### Scalars\u00a0[\u00b6](#scalars)\n\n`Bits(width)` models a bitvector. Allows indexing, slicing, bitwise operations, etc. No math operations.\n\n`UInt(width)`, `SInt(width)` math.\n\n### Arrays\u00a0[\u00b6](#arrays)\n\n`Bits(32) * 10` creates an array of 32-bits of length 10.\n\n`Bits(32) * 10 * 12` creates an array of arrays.\n\n### Structs\u00a0[\u00b6](#structs)\n\n```\nfrom pycde import Input, Output, generator, System, Module\nfrom pycde.types import Bits\nfrom pycde.signals import Struct, BitsSignal\n\nclass ExStruct(Struct):\n  a: Bits(4)\n  b: Bits(32)\n\n  def get_b_xor(self, x: int) -> BitsSignal:\n    return self.b ^ Bits(32)(x)\n\n\nclass StructExample(Module):\n  inp1 = Input(ExStruct)\n  out1 = Output(Bits(32))\n  out2 = Output(Bits(4))\n  out3 = Output(ExStruct)\n\n  @generator\n  def build(self):\n    self.out1 = self.inp1.get_b_xor(5432)\n    self.out2 = self.inp1.a\n    self.out3 = ExStruct(a=self.inp1.a, b=42)\n```\n\n### NumPy features\u00a0[\u00b6](#numpy-features)\n\nPyCDE supports a subset of numpy array transformations (see `pycde/ndarray.py`)\nthat can be used to do complex reshaping and transformation of multidimensional\narrays.\n\nThe numpy functionality is provided by the `NDArray` class, which creates a view\non top of existing SSA values. Users may choose to perform transformations\ndirectly on `ListSignal`s:\n\n```\nclass M1(Module):\n  in1 = Input(dim(Bits(32), 4, 8))\n  out = Output(dim(Bits(32), 2, 16))\n\n  @generator\n  def build(self):\n    self.out = self.in1.transpose((1, 0)).reshape((16, 2))\n    # Under the hood, this resolves to\n    # Matrix(from_value=\n    #    Matrix(from_value=ports.in1).transpose((1,0)).to_circt())\n    #  .reshape(16, 2).to_circt()\n```\n\nor manually manage a `NDArray` object.\n\n```\nclass M1(Module):\n  in1 = Input(dim(Bits(32), 4, 8))\n  out = Output(dim(Bits(32), 2, 16))\n\n  @generator\n  def build(self):\n    m = NDArray(from_value=self.in1).transpose((1, 0)).reshape((16, 2))\n    self.out = m.to_circt()\n```\n\nManually managing the NDArray object allows for postponing materialization\n(`to_circt()`) until all transformations have been applied. In short, this\nallows us to do as many transformations as possible in software, before emitting\nIR. Note however, that this might reduce debugability of the generated hardware\ndue to the lack of `sv.wire`s in between each matrix transformation.\n\nFor further usage examples, see `PyCDE/test/test_ndarray.py`, and inspect\n`ListSignal` in `pycde/signals.py` for the full list of implemented numpy\nfunctions.\n\nExternal Modules\u00a0[\u00b6](#external-modules)\n---------------------------------------\n\nExternal modules are how PyCDE and CIRCT support interacting with existing\nSystem Verilog or Verilog modules. They must be declared and the ports must\nmatch the externally defined implementation in SystemVerilog or other language.\nWe have no way of checking that they do indeed match so it\u2019ll be up to the EDA\nsynthesizer (and they generally do a poor job reporting mismatches).\n\nIn PyCDE, an external module is any module without a generator.\n\n```\nclass MulInts(Module):\n    module_name = \"MyMultiplier\"\n    a = Input(Bits(32))\n    b = Input(Bits(32))\n    c = Output(Bits(32))\n```\n\nThe `MyMultiplier` module is declared in the default output file, `ExampleSystem/ExampleSystem.sv`.\n\nParameterized modules\u00a0[\u00b6](#parameterized-modules)\n-------------------------------------------------\n\n```\nfrom pycde import modparams\n\n@modparams\ndef AddInts(width: int):\n\n  class AddInts(Module):\n    a = Input(UInt(width))\n    b = Input(UInt(width))\n    c = Output(UInt(width + 1))\n\n    @generator\n    def build(self):\n      self.c = self.a + self.b\n\n  return AddInts\n\n\nclass Top(Module):\n  a = Input(UInt(32))\n  b = Input(UInt(32))\n  c = Output(UInt(33))\n\n  @generator\n  def construct(self):\n    add_ints_m = AddInts(32)\n    add_ints = add_ints_m(a=self.a, b=self.b)\n    self.c = add_ints.c\n```\n\nIn order to \u201cparameterize\u201d a module, simply return one from a function. Said\nfunction must be decorated with `modparams` to inform PyCDE that the returned\nmodule is a parameterized one. The `modparams` decorator does several things\nincluding: (1) memoizing the parameterization function, and (2) automatically\nderive a module name which includes the parameter values (for module name\nuniqueness).\n\nPyCDE does not produce parameterized SystemVerilog modules! The specialization\nhappens with Python code, which is far more powerful than SystemVerilog\nparameterization constructs.\n\nExternal parameterized modules\u00a0[\u00b6](#external-parameterized-modules)\n-------------------------------------------------------------------\n\nJust like internally defined parameterized modules, leave off the generator and\nPyCDE will output SystemVerilog instantations with the module parameters. The\nparameter types are best effort based on the first instantiation encountered.\n\n```\nfrom pycde import modparams, Module\n\n@modparams\ndef AddInts(width: int):\n\n  class AddInts(Module):\n    a = Input(UInt(width))\n    b = Input(UInt(width))\n    c = Output(UInt(width + 1))\n\n  return AddInts\n\n\nclass Top(Module):\n  a = Input(UInt(32))\n  b = Input(UInt(32))\n  c = Output(UInt(33))\n\n  @generator\n  def construct(self):\n    add_ints_m = AddInts(32)\n    add_ints = add_ints_m(a=self.a, b=self.b)\n    self.c = add_ints.c\n```\n\nFor the instantiation produces:\n\n```\n  AddInts #(\n    .width(64'd32)\n  ) AddInts (\n    .a (a),\n    .b (b),\n    .c (c)\n  );\n```\n\nUsing CIRCT dialects directly (instead of with PyCDE syntactic sugar)\u00a0[\u00b6](#using-circt-dialects-directly-instead-of-with-pycde-syntactic-sugar)\n-----------------------------------------------------------------------------------------------------------------------------------------------\n\nGenerally speaking, don\u2019t.\n\nOne can directly instantiate CIRCT operations through\n`pycde.dialects.<dialect_name>`. The CIRCT operations contained therein provide\nthin wrappers around the CIRCT operations to adapt them to\n[PyCDE\nSignals](#signals) by overriding each operation\u2019s constructor. This\nauto-wrapper, however, does not always \u201cjust work\u201d depending on the complexity\nof the operation it is attemption to wrap. So don\u2019t use it unless you know what\nyou\u2019re doing. User beware. Warranty voided. Caveat emptor. etc.\n\n [Prev - Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/ \"Compiling CIRCT and PyCDE\")\n[Next - Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/ \"Static scheduling infrastructure\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)-](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/Scheduling/index.md"
  },
  {
    "role": "user",
    "content": "Static scheduling infrastructure - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nStatic scheduling infrastructure\n================================\n\nScheduling is a common concern in hardware design, for example in high-level\nsynthesis flows targeting an FSM+Datapath execution model (\u201cstatic HLS\u201d). This\ndocument gives an overview of, and provides rationale for, the infrastructure in\nthe `circt::scheduling` namespace. At its core, it defines an **extensible\nproblem model** that acts as an interface between **clients** (i.e. passes that\nhave a need to schedule a graph-like IR) and reusable **algorithm**\nimplementations.\n\nThis infrastructure aims to provide:\n\n* a library of ready-to-use problem definitions and schedulers for clients to\n  hook into.\n* an API to make algorithm implementations comparable and reusable.\n* a mechanism to extend problem definitions to model additional concerns and\n  constraints.\n\nGetting started\u00a0[\u00b6](#getting-started)\n-------------------------------------\n\nLet\u2019s walk through a simple example. Assume we want to *schedule* the\ncomputation in the entry block of a function such as `@foo(...)` in the listing\nbelow. This means we want to assign integer *start times* to each of the\n*operations* in this untimed IR.\n\n```\nfunc @foo(%a1 : i32, %a2 : i32, %a3 : i32, %a4 : i32) -> i32 {\n  %0 = arith.addi %a1, %a2 : i32\n  %1 = arith.addi %0, %a3 : i32\n  %2:3 = \"more.results\"(%0, %1) : (i32, i32) -> (i32, i32, i32)\n  %3 = arith.addi %a4, %2#1 : i32\n  %4 = arith.addi %2#0, %2#2 : i32\n  %5 = arith.addi %3, %3 : i32\n  %6 = \"more.operands\"(%3, %4, %5) : (i32, i32, i32) -> i32\n  return %6 : i32\n}\n```\n\nOur only constraint is that an operation can start *after* its operands have\nbeen computed. The operations in our source IR are unaware of time, so we need\nto associate them with a suitable *operator type*. Operator types are an\nabstraction of the target architecture onto which we want to schedule the source\nIR. Here, the only *property* we need to model is their *latency*. Let\u2019s assume\nthat additions take 1 time step, the operations in the dummy `more.` dialect\ntake 3 time steps. As the return operation just passes control back to the\ncaller, we assume a latency of 0 time steps for it.\n\n### Boilerplate\u00a0[\u00b6](#boilerplate)\n\nThe scheduling infrastructure currently has three toplevel header files.\n\n```\n//...\n#include \"circt/Scheduling/Problems.h\"\n#include \"circt/Scheduling/Algorithms.h\"\n#include \"circt/Scheduling/Utilities.h\"\n//...\nusing namespace circt::scheduling;\n```\n\n### Constructing a problem instance\u00a0[\u00b6](#constructing-a-problem-instance)\n\nOur stated goal requires solving an acyclic scheduling problem without resource\nconstraints, represented by the `Problem` class in the scheduling\ninfrastructure. We need to construct an *instance* of the problem, which serves\nas a container for the problem *components* as well as their properties. The\nMLIR operation passed as an argument to the `get(...)` method is used to emit\ndiagnostics.\n\n```\nauto prob = Problem::get(func);\n```\n\nThen, we set up the operator types with the latencies as discussed in the\nintroduction. Operator types are identified by string handles.\n\n```\nauto retOpr = prob.getOrInsertOperatorType(\"return\");\nprob.setLatency(retOpr, 0);\nauto addOpr = prob.getOrInsertOperatorType(\"add\");\nprob.setLatency(addOpr, 1);\nauto mcOpr = prob.getOrInsertOperatorType(\"multicycle\");\nprob.setLatency(mcOpr, 3);\n```\n\nNext, we register all operations that we want to consider in the problem\ninstance, and link them to one of the operator types.\n\n```\nauto &block = func.getBlocks().front();\nfor (auto &op : block) {\n  prob.insertOperation(&op);\n  if (isa<func::ReturnOp>(op))\n    prob.setLinkedOperatorType(&op, retOpr);\n  else if (isa<arith::AddIOp>(op))\n    prob.setLinkedOperatorType(&op, addOpr);\n  else\n    prob.setLinkedOperatorType(&op, mcOpr);\n}\n```\n\nNote that we do not have to tell the instance about the *dependences* between\nthe operations in this simple example because the problem model automatically\nincludes the SSA def-use-edges maintained by MLIR. However, we often have to\nconsider additional dependences that are not represented by value flow, such as\nmemory dependences. For these situations, so-called\n[auxiliary](#components)\ndependences between operations are inserted explicitly into the problem:\n`prob.insertDependence(srcOp, destOp)`.\n\n### Scheduling\u00a0[\u00b6](#scheduling)\n\nBefore we attempt to schedule, we invoke the `check()` method, which ensures\nthat the constructed instance is complete and valid. For example, the check\nwould capture if we had forgot to set an operator type\u2019s latency. We dump the\ninstance to visualize the dependence graph.\n\n```\nauto checkRes = prob.check();\nassert(succeeded(checkRes));\ndumpAsDOT(prob, \"sched-problem.dot\");\n```\n\n![Dump of example instance](https://circt.llvm.org/includes/img/sched-instance.svg)\n\nWe use a simple list scheduler, available via the `Algorithms.h` header, to\ncompute a solution for the instance.\n\n```\nauto schedRes = scheduleASAP(prob);\nassert(succeeded(schedRes));\n```\n\n### Working with the solution\u00a0[\u00b6](#working-with-the-solution)\n\nThe solution is now stored in the instance, and we invoke the problem\u2019s\n`verify()` method to ensure that the computed start times adhere to the\nprecedence constraint we stated earlier, i.e. operations start after their\noperands have computed their results. We can also convince ourselves of that by\ndumping the instance and inspecting the solution.\n\n```\nauto verifRes = prob.verify();\nassert(succeeded(verifRes));\ndumpAsDOT(prob, \"sched-solution.dot\");\n```\n\n![Dump of example instance, including solution](https://circt.llvm.org/includes/img/sched-solution.svg)\n\nTo inspect the solution programmatically, we can query the instance in the\nfollowing way. Note that by convention, all getters in the problem classes\nreturn `Optional<T>` values, but as we have already verified that the start\ntimes for registered operations are set, we can directly dereference the values.\n\n```\nfor (auto &op : prob.getOperations())\n  llvm::dbgs() << *prob.getStartTime(&op) << \"\\n\";\n```\n\nAnd that\u2019s it! For a more practical example, have a look at the\n[`AffineToPipeline`](https://github.com/llvm/circt/blob/main/lib/Conversion/AffineToPipeline/AffineToPipeline.cpp)\npass.\n\nExtensible problem model\u00a0[\u00b6](#extensible-problem-model)\n-------------------------------------------------------\n\n### Theory and terminology\u00a0[\u00b6](#theory-and-terminology)\n\nScheduling problems come in many flavors and variants in the context of hardware\ndesign. In order to make the scheduling infrastructure as modular and flexible\nas CIRCT itself, it is build on the following idea of an *extensible problem\nmodel*:\n\nAn *instance* is comprised of *components* called *operations*, *dependences*\nand *operator types*. Operations and dependences form a graph structure and\ncorrespond to the source IR to be scheduled. Operator types encode the\ncharacteristics of the target IR. The components as well as the instance can be\nannotated with *properties*. Properties are either *input* or *solution*\nproperties, based on whether they are supplied by the client, or computed by the\nalgorithm. The values of these properties are subject to the *input constraints*\nand *solution constraints*, which are a first-class concern in the model and are\nintended to be strictly enforced before respectively after scheduling.\n\nConcrete problem definitions derived from this model share the same\nrepresentation of the components, but differ in their sets of properties (and\npotentially distinction of input and solution properties) and input and solution\nconstraints. Hence, we tie together properties and constraints to model a\nspecific scheduling problem. Extending one (or more!) parent problems means\ninheriting or adding properties, and redefining the constraints (as these don\u2019t\nalways compose automatically).\n\nA key benefit of this approach is that these problem definitions provide a\nreliable contract between the clients and algorithms, making it clear which\ninformation needs to be provided, and what kind of solution is to be expected.\nClients can therefore choose a problem definition that fits their needs, and\nalgorithms can *opt-in* to accepting a specific subset of problems, which they\ncan solve efficiently. Extensibility is ensured because new problem definitions\ncan be added to the infrastructure (or inside a specific lowering flow, or even\nout-of-tree) without adapting any existing users.\n\n### Implementation\u00a0[\u00b6](#implementation)\n\nSee\n[Problems.h](https://github.com/llvm/circt/blob/main/include/circt/Scheduling/Problems.h) /\n[Problems.cpp](https://github.com/llvm/circt/blob/main/lib/Scheduling/Problems.cpp).\n\n#### Problem definitions\u00a0[\u00b6](#problem-definitions)\n\nThe `Problem` class is currently the base of the problem hierarchy. Several\nextended problems are\n[currently defined](#available-problem-definitions) via\nvirtual multiple inheritance. Upon construction, a `containingOp` is passed to\ninstances. This MLIR operation is currently only used to emit diagnostics, and\nhas no semantic meaning beyond that.\n\n#### Components\u00a0[\u00b6](#components)\n\nThe infrastructure uses the following representation of the problem components.\n\nOperations are just `mlir::Operation *`s.\n\nWe distinguish two kinds of dependences, *def-use* and *auxiliary*. Def-use\ndependences are part of the SSA graph maintained by MLIR, and can distinguish\nspecific result and operand numbers. As we expect any relevant graph-like input\nIR to use this MLIR facility, instances automatically consider these edges\nbetween registered operations. Auxiliary dependences, in contrast, only specify\na source and destination operation, and have to be explicitly added to the\ninstance by the client, e.g. for control or memory dependences. The\n`detail::Dependence` class abstracts the differences between both kinds, in\norder to offer a uniform API to iterate over dependences and query their\nproperties.\n\nLastly, operator types are identified by `mlir::StringAttr`s, in order to give\nclients maximum flexibility in modeling their operator library. This may change\nin the future, when a CIRCT-wide concept to model physical properties of\nhardware emerges.\n\n#### Properties\u00a0[\u00b6](#properties)\n\nProperties can involve arbitrary data types, as long as these can be stored in\nmaps. Problem classes offer public getter and setter methods to access a given\ncomponents properties. Getters return optional values, in order to indicate if a\nproperty is unset. For example, the signature of the method the queries the\ncomputed start time is `Optional<unsigned> getStartTime(Operation *op)`.\n\n#### Constraints\u00a0[\u00b6](#constraints)\n\nClients call the virtual `Problem::check()` method to test any input\nconstraints, and `Problem::verify()` to test the solution constraints. Problem\nclasses are expected to override them as needed. There are no further\nrestrictions of how these methods are implemented, but it is recommended to\nintroduce helper methods that test a specific aspect and can be reused in\nextended problems. In addition, it makes sense to check/verify the properties in\nan order that avoids redundant tests for the presence of a particular property\nas well as redundant iteration over the problem components.\n\nAvailable problem definitions\u00a0[\u00b6](#available-problem-definitions)\n-----------------------------------------------------------------\n\n*See the linked Doxygen docs for more details.*\n\n* [Problem](https://circt.llvm.org/doxygen/classcirct_1_1scheduling_1_1Problem.html):\n  A basic, acyclic problem at the root of the problem hierarchy. Operations are\n  linked to operator types, which have integer latencies. The solution comprises\n  integer start times adhering to the precedence constraints implied by the\n  dependences.\n* [CyclicProblem](https://circt.llvm.org/doxygen/classcirct_1_1scheduling_1_1CyclicProblem.html):\n  Cyclic extension of `Problem`. Its solution solution can be used to construct\n  a pipelined datapath with a fixed, integer initiation interval, in which the\n  execution of multiple iterations/samples/etc. may overlap. Operator types are\n  assumed to be fully pipelined.\n* [SharedOperatorsProblem](https://circt.llvm.org/doxygen/classcirct_1_1scheduling_1_1SharedOperatorsProblem.html):\n  A resource-constrained scheduling problem that corresponds to multiplexing\n  multiple operations onto a pre-allocated number of fully pipelined operator\n  instances.\n* [ModuloProblem](https://circt.llvm.org/doxygen/classcirct_1_1scheduling_1_1ModuloProblem.html):\n  Models an HLS classic: Pipeline scheduling with limited resources.\n* [ChainingProblem](https://circt.llvm.org/doxygen/classcirct_1_1scheduling_1_1ChainingProblem.html):\n  Extends `Problem` to consider the accumulation of physical propagation delays\n  on combinational paths along SSA dependences.\n* [ChainingCyclicProblem](https://circt.llvm.org/doxygen/classcirct_1_1scheduling_1_1ChainingCyclicProblem.html):\n  Extends `ChainingProblem` and `CyclicProblem` to consider the accumulation\n  of physical propagation delays on combinational paths along SSA dependences\n  on a cyclic scheduling problem. Note that the problem does not model\n  propagation delays along inter-iteration dependences. These are commonly\n  represented as auxiliary dependences, which are already excluded in the\n  parent ChainingProblem. In addition, the ChainingCyclicProblem explicitly\n  prohibits the use of def-use dependences with a non-zero distance.\n\nNB: The classes listed above each model a *trait*-like aspect of scheduling.\nThese can be used as-is, but are also intended for mixing and matching, even\nthough we currently do not provide definitions for all possible combinations in\norder not to pollute the infrastructure. For example, the `ChainingProblem` may\nbe of limited use standalone, but can serve as a parent class for a future\nchaining-enabled modulo scheduling problem.\n\nAvailable schedulers\u00a0[\u00b6](#available-schedulers)\n-----------------------------------------------\n\n* ASAP list scheduler\n  (\n  [`ASAPScheduler.cpp`](https://github.com/llvm/circt/blob/main/lib/Scheduling/ASAPScheduler.cpp)):\n  Solves the basic `Problem` with a worklist algorithm. This is mostly a\n  problem-API demo from the viewpoint of an algorithm implementation.\n* Linear programming-based schedulers\n  (\n  [`SimplexSchedulers.cpp`](https://github.com/llvm/circt/blob/main/lib/Scheduling/SimplexSchedulers.cpp)):\n  Solves `Problem`, `CyclicProblem` and `ChainingProblem` optimally, and\n  `SharedOperatorsProblem` / `ModuloProblem` with simple (not state-of-the-art!)\n  heuristics. This family of schedulers shares a tailored implementation of the\n  simplex algorithm, as proposed by de Dinechin. See the sources for more\n  details and literature references.\n* Integer linear programming-based scheduler\n  (\n  [`LPSchedulers.cpp`](https://github.com/llvm/circt/blob/main/lib/Scheduling/LPSchedulers.cpp)):\n  Demo implementation for using an ILP solver via the OR-Tools integration.\n\nUtilities\u00a0[\u00b6](#utilities)\n-------------------------\n\nSee\n[`Utilities.h`](https://github.com/llvm/circt/blob/main/include/circt/Scheduling/Utilities.h):\n\n* Topological graph traversal\n* DFA to compute combinational path delays\n* DOT dump\n\nAdding a new problem\u00a0[\u00b6](#adding-a-new-problem)\n-----------------------------------------------\n\n*See e.g.\n[#2233](https://github.com/llvm/circt/pull/2233), which added the\n`ChainingProblem`.*\n\n* Decide where to add it. Guideline: If it is trait-like and similar to the\n  existing problem mentioned above, add it to `Problems.h`. If the model is\n  specific to your use-case, it is best to start out in locally in your\n  dialect/pass.\n* Declare the new problem class and inherit *virtually* from the relevant\n  superclasses (at least `Problem`).\n* Define additional properties (private), and the corresponding public\n  getters/setters. Getters return `Optional<T>` values, to indicate an unset\n  state.\n  + Note that dependence properties are somewhat expensive to store, making it\n    desirable that clients and algorithms expect and handle the unset state.\n    This should be clearly documented. Example: `distance` property in\n    `CyclicProblem`.\n* Redefine the `getProperties(*)` methods to get dumping support. These should\n  consider any properties the new class adds, plus properties defined in the\n  superclass(es).\n* Redefine `check()` (input constraints) and `verify()` (solution constraints).\n  If possible, follow the\n  [design used in the existing problem classes](#constraints).\n\n### Testing\u00a0[\u00b6](#testing)\n\nPlease extend the\n[SSP](https://circt.llvm.org/docs/Dialects/SSP/) dialect to\nenable testing of the new problem definition.\n\n* If the problem defines any new properties, add them to\n  [`SSPAttributes.td`](https://github.com/llvm/circt/blob/main/include/circt/Dialect/SSP/SSPAttributes.td).\n* Instantiate the\n  [`Default<ProblemT>`](https://github.com/llvm/circt/blob/main/include/circt/Dialect/SSP/Utilities.h#L457-L459)\n  template for the new problem.\n* Handle the problem class in the\n  [`-ssp-roundtrip`](https://github.com/llvm/circt/blob/main/lib/Dialect/SSP/Transforms/Roundtrip.cpp)\n  pass.\n* Write a couple of \u201cpositive\u201d testcases, as well as at least one error test for\n  each input/solution constraint, as validated by `check()` / `verify()`. See\n  the\n  [existing test cases](https://github.com/llvm/circt/tree/main/test/Scheduling)\n  for inspiration.\n\nAdding a new scheduler\u00a0[\u00b6](#adding-a-new-scheduler)\n---------------------------------------------------\n\n*See e.g.\n[#2650](https://github.com/llvm/circt/pull/2650), which added a\nscheduler for the `CyclicProblem`.*\n\n* Schedulers should opt-in to specific problems by providing entry points for\n  the problem subclasses they support. Example:\n\n  ```\n  LogicalResult awesomeScheduler(Problem &prob);\n  LogicalResult awesomeScheduler(CyclicProblem &prob);\n  ```\n* Schedulers can expect that the input invariants were enforced by a\n  `check()`-call in the client, and must compute a solution that complies with\n  the solution constraints when the client calls the problem\u2019s `verify()`\n  method.\n* Schedulers can live anywhere. If a new algorithm is not entirely\n  dialect/pass-specific and supports problems defined in `Problems.h`, it should\n  offer entry points in `Algorithms.h`.\n* Objectives are not part of the problem signature. Therefore, if an algorithm\n  supports optimizing for different objectives, clients should be able to select\n  one via the entry point(s).\n\n### Testing\u00a0[\u00b6](#testing-1)\n\n* To enable testing, add the new scheduler to the\n  [`-ssp-schedule`](https://github.com/llvm/circt/blob/main/lib/Dialect/SSP/Transforms/Schedule.cpp)\n  pass, and invoke it from the test cases for the supported problems\n  (\n  [example](https://github.com/llvm/circt/blob/main/test/Scheduling/problems.mlir#L2-L4)).\n* If the algorithm may fail in certain situations (e.g., \u201clinear program is\n  infeasible\u201d), add suitable error tests as well.\n\n [Prev - PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/ \"PyCDE Basics\")\n[Next - Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/ \"Symbol and Inner Symbol Rationale\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/RationaleSymbols/index.md"
  },
  {
    "role": "user",
    "content": "Symbol and Inner Symbol Rationale - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nSymbol and Inner Symbol Rationale\n=================================\n\nThis document describes various design points of the major CIRCT dialects\nrelating to the use of symbols and the introduction of inner symbols and\nrelated types. This follows in the spirit of other\n[MLIR Rationale docs](https://mlir.llvm.org/docs/Rationale/).\n\nIntroduction\u00a0[\u00b6](#introduction)\n-------------------------------\n\nVerilog and FIRRTL have, from a software compiler perspective, an unusual\nnumber of nameable entities which can be referred to non-locally. These entities\nhave deep nesting in the code structures. The requirements of dealing with\nthese entities and references entails more complexity than provided by MLIR\u2019s\nsymbols and symbol tables. Several CIRCT dialects, therefore, share a common\nsupplemental mechanism called \u201cInner Symbols\u201d to manage these requirements.  \nInner Symbols necessarily deviate from MLIR nested symbol tables to enable\nrepresentation of the behavior of Verilog and FIRRTL.\n\nUse of MLIR symbols\u00a0[\u00b6](#use-of-mlir-symbols)\n---------------------------------------------\n\nMLIR symbols are directly used for items in the global scope. This primarily\nconsists of `hw` or `firrtl` modules, though other entities, such as `sv`\ninterfaces and bind statements and `firrtl` non-local anchors, also share this\nspace. Modules and instances of them are well suited to MLIR symbols. They\nare analogous in scoping and structure to functions and call instructions. The\ntop-level `builtin.module` or `firrtl.circuit` operations define a symbol table, and all\nmodules contained define symbols, with instances referring by symbol to their\ninstantiated module.\n\nInner Symbol\u00a0[\u00b6](#inner-symbol)\n-------------------------------\n\nWithin a `firrtl` or `hw` module, many entities may exist which can be referenced\noutside the module. Operations and ports (and memory ports), need to define\nsymbol-like data to allow forming non-SSA linkage between disparate elements.  \nTo accomplish this, an attribute named `inner_sym` is attached, providing a\nscoped symbol-like name to the element. An operation with an `inner_sym`\nresides in arbitrarily-nested regions of a region that defines an\n`InnerSymbolTable` and a `Symbol` . `InnerSymbolTable` operations must reside\nwithin an `InnerRefNamespace`. The `inner_sym` attribute must be an `InnerSymAttr`\nwhich defines the inner symbols attached to the operation and its fields.\nOperations containing an inner symbol must implement the `InnerSymbol` interface.\n\nInner Symbols are different from normal symbols due to MLIR symbol table\nresolution rules. Specifically, normal symbols are resolved by first going up\nto the closest parent symbol table and resolving down from there (recursing\nback down for nested symbol paths). In FIRRTL and HW, modules define a symbol in a\n`firrtl.circuit` or `builtin.module` symbol table. For instances to be able to resolve the\nmodules they instantiate, the symbol use in an instance must resolve in the\ntop-level symbol table. If a module were a symbol table, instances resolving a\nsymbol would start from their own module, never seeing other modules (since\nresolution would start in the parent module of the instance and be unable to go\nto the global scope). The second problem arises from nesting. Symbol\ndefining operations must be immediate children of a symbol table. FIRRTL and HW/SV\noperations which define an `inner_sym` are grandchildren, at least, of a symbol\ntable and may be much further nested. Lastly, ports need to define `inner_sym`,\nsomething not allowed by normal symbols.\n\nInner Symbol Reference Attribute\u00a0[\u00b6](#inner-symbol-reference-attribute)\n-----------------------------------------------------------------------\n\nAn attribute `InnerRefAttr` is provided to encapsulate references to inner\nsymbols. This attribute stores the parent symbol and the inner symbol. This\nprovides a uniform type for storing and manipulating references to inner\nsymbols. An `InnerRefAttr` resolves in an `InnerRefNamespace`.\n\nOperations using `InnerRefAttr` should implement the `verifyInnerRefs` method\nof `InnerRefUserOpInterface` to verify these references efficiently.\n\nTraits and Classes\u00a0[\u00b6](#traits-and-classes)\n-------------------------------------------\n\n### InnerSymbolTable\u00a0[\u00b6](#innersymboltable)\n\nSimilar to MLIR\u2019s `SymbolTable`, `InnerSymbolTable` is both a trait and a class.\n\n#### Trait\u00a0[\u00b6](#trait)\n\nThe trait is used by Operations to define a new scope for inner symbols\ncontained within. These operations must have the `Symbol` trait and be\nimmediate children of an `InnerRefNamespace`. Operations must use the\n`InnerSymbol` interface to provide a symbol, regardless of presence of\nattributes.\n\n#### Class\u00a0[\u00b6](#class)\n\nThe class is used either manually constructed or as an analysis to track and\nresolve inner symbols within an operation with the trait.\n\nThe class is also used in verification.\n\n### InnerSymbolTableCollection\u00a0[\u00b6](#innersymboltablecollection)\n\nThis class is used to construct the inner symbol tables\nfor all `InnerSymbolTable`s (e.g., a Module) within an `InnerRefNamespace`\n(e.g., a circuit), either on-demand or eagerly in parallel.\n\nUse this to efficiently gather information about inner symbols.\n\n### InnerRefNamespace\u00a0[\u00b6](#innerrefnamespace)\n\nThis is also both a class and a trait.\n\n#### Class\u00a0[\u00b6](#class-1)\n\nCombines `InnerSymbolTableCollection` with a `SymbolTable` for resolution of\n`InnerRefAttr`s, primarily used during verification as argument to the\n`verifyInnerRefs` hook which operations may use for more efficient checking of\n`InnerRefAttr`s.\n\n#### Trait\u00a0[\u00b6](#trait-1)\n\nThe `InnerRefNamespace` trait is used by Operations to define a new scope for\nInnerRef\u2019s. Operations with this trait must also be a `SymbolTable`.\nPresently the only user is `CircuitOp`.\n\nCost\u00a0[\u00b6](#cost)\n---------------\n\nInner symbols are more costly than normal symbols, precisely from the\nrelaxation of MLIR symbol constraints. Since nested regions are allowed,\nfinding all operations defining an `inner_sym` requires a recursive IR scan.  \nVerification is likewise trickier, partly due the significant increase in\nnon-local references.\n\nFor this reason, verification is driven as a trait verifier on\n`InnerRefNamespace` which constructs and verifies `InnerSymbolTable`s in\nparallel, and uses these to conduct a per-`InnerSymbolTable` parallelized walk\nto verify references by calling the `verifyInnerRefs` hook on\n`InnerRefUserOpInterface` operations.\n\nCommon Use\u00a0[\u00b6](#common-use)\n---------------------------\n\nThe most common use for `InnerRefAttr`s are to build paths through the instantiation\ngraph to use a subset of the instances of an entity in some way. This may\nbe reading values via SystemVerilog\u2019s cross-module references (XMRs),\nspecifying SV bind constraints,\nspecifying placement constraints, or representing non-local attributes (FIRRTL).\n\nThe common element for building paths of instances through the instantiation\ngraph is with a `NameRefArrayAttr` attribute. This is used, for example, by\n`hw.GlobalRefOp` and `firrtl.hierpath`.\n\n [Prev - Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/ \"Static scheduling infrastructure\")\n[Next - Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/ \"Using the Python Bindings\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  },
  {
    "role": "user",
    "content": "circt.llvm.org/docs/PythonBindings/index.md"
  },
  {
    "role": "user",
    "content": "Using the Python Bindings - CIRCT\n\nCIRCT\n=====\n\nCircuit IR Compilers and Tools\n\n* Community\n  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)\n  + [Chat](https://discord.gg/xS7Z362)\n* [Source](https://github.com/llvm/circt/tree/main/)\n  + [Doxygen](/doxygen/)\n  + [GitHub](https://github.com/llvm/circt/tree/main/)\n\nUsing the Python Bindings\n=========================\n\nIf you are mainly interested in using CIRCT from Python scripts, you need to compile both LLVM/MLIR and CIRCT with Python bindings enabled. Furthermore, you must use a unified build, where LLVM/MLIR and CIRCT are compiled together in one step.\n\nCIRCT also includes an experimental, opinionated frontend for CIRCT\u2019s Python bindings, called\n[PyCDE](/docs/PyCDE/).\n\nInstalling and Building with Wheels\u00a0[\u00b6](#installing-and-building-with-wheels)\n-----------------------------------------------------------------------------\n\nCIRCT provides a `setup.py` script that take care of configuring and building LLVM/MLIR, CIRCT, and CIRCT\u2019s Python bindings. You can install the CIRCT Python bindings with the `pip install` command:\n\n```\n$ cd circt\n$ pip install lib/Bindings/Python\n```\n\nIf you just want to build the wheel, use the `pip wheel` command:\n\n```\n$ cd circt\n$ pip wheel lib/Bindings/Python\n```\n\nThis will create a `circt_core-<version>-<python version>-<platform>.whl` file in the root of the repo.\n\nThere are some environment variables you can set to control the script. These should be prefixed to the above command(s), or `export`ed in your shell.\n\nTo specify an existing CMake build directory, you can set `CIRCT_CMAKE_BUILD_DIR`:\n\n```\nexport CIRCT_CMAKE_BUILD_DIR=/path/to/your/build/dir\n```\n\nTo specify an alternate LLVM directory, you can set `CIRCT_LLVM_DIR`:\n\n```\nexport CIRCT_LLVM_DIR=/path/to/your/llvm\n```\n\nFinally, you can set other environment variables to control CMake. By default, the script uses the same settings as\n[Manual Compilation](#manual-compilation) below. It is recommended to use Ninja and CCache, which can be accomplished with:\n\n```\nexport CMAKE_GENERATOR=Ninja CMAKE_C_COMPILER_LAUNCHER=ccache CMAKE_CXX_COMPILER_LAUNCHER=ccache\n```\n\nAll other\n[CMake environment variables](https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html) can also be used.\n\nManual Compilation\u00a0[\u00b6](#manual-compilation)\n-------------------------------------------\n\nTo manually compile LLVM/MLIR, CIRCT, and CIRCT\u2019s Python bindings, you can use a single CMake invocation like this:\n\n```\n$ cd circt\n$ mkdir build\n$ cd build\n$ cmake -G Ninja ../llvm/llvm \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DLLVM_ENABLE_PROJECTS=mlir \\\n    -DLLVM_ENABLE_ASSERTIONS=ON \\\n    -DLLVM_EXTERNAL_PROJECTS=circt \\\n    -DLLVM_EXTERNAL_CIRCT_SOURCE_DIR=.. \\\n    -DMLIR_ENABLE_BINDINGS_PYTHON=ON \\\n    -DCIRCT_BINDINGS_PYTHON_ENABLED=ON\n```\n\nAfterwards, use `ninja check-circt-integration` to ensure that the bindings work. (This will now additionally spin up a couple of Python scripts to test that they are accessible.)\n\n### Without Installation\u00a0[\u00b6](#without-installation)\n\nIf you want to try the bindings fresh from the compiler without installation, you need to ensure Python can find the generated modules:\n\n```\nexport PYTHONPATH=\"$PWD/llvm/build/tools/circt/python_packages/circt_core\"\n```\n\n### With Installation\u00a0[\u00b6](#with-installation)\n\nIf you are installing CIRCT through `ninja install` anyway, the libraries and Python modules will be installed into the correct location automatically.\n\nTrying things out\u00a0[\u00b6](#trying-things-out)\n-----------------------------------------\n\nNow you are able to use the CIRCT dialects and infrastructure from a Python interpreter and script:\n\n```\n# silicon.py\nimport circt\nfrom circt.ir import Context, InsertionPoint, IntegerType, Location, Module\nfrom circt.dialects import hw, comb\n\nwith Context() as ctx, Location.unknown():\n  circt.register_dialects(ctx)\n  i42 = IntegerType.get_signless(42)\n  m = Module.create()\n  with InsertionPoint(m.body):\n\n    def magic(module):\n      xor = comb.XorOp.create(module.a, module.b)\n      return {\"c\": xor}\n\n    hw.HWModuleOp(name=\"magic\",\n                  input_ports=[(\"a\", i42), (\"b\", i42)],\n                  output_ports=[(\"c\", i42)],\n                  body_builder=magic)\n  print(m)\n```\n\nRunning this script through `python3 silicon.py` should print the following MLIR:\n\n```\nmodule {\n  hw.module @magic(in %a: i42, in %b: i42, out c: i42) {\n    %0 = comb.xor %a, %b : i42\n    hw.output %0 : i42\n  }\n}\n```\n\n [Prev - Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/ \"Symbol and Inner Symbol Rationale\")\n[Next - Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/ \"Verilog and SystemVerilog Generation\") \n\nPowered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).\n\n* [Home](https://circt.llvm.org/)\n* [Talks and Related Publications](https://circt.llvm.org/talks/)\n* [Getting Started](https://circt.llvm.org/getting_started/)\n* [Code Documentation-](https://circt.llvm.org/docs/)\n  + [Tools+](https://circt.llvm.org/docs/Tools/)\n    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)\n    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)\n    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)\n  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)\n  + [Dialects+](https://circt.llvm.org/docs/Dialects/)\n\n    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)\n    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)\n    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)\n    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)\n      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)\n    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)\n      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)\n    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)\n      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)\n    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)\n      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)\n    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)\n      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)\n      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)\n      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)\n      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)\n      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)\n    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)\n      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)\n      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)\n      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)\n    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)\n      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)\n    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)\n      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)\n    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)\n      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)\n    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)\n      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)\n    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)\n      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)\n    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)\n      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)\n    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)\n    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)\n      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)\n    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)\n      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)\n    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)\n    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)\n      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)\n    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)\n      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)\n    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)\n      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)\n    - ['synth' Dialect+](https://circt.llvm.org/docs/Dialects/Synth/)\n      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)\n      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)\n    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)\n      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)\n    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)\n    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)\n      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)\n    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)\n    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)\n    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)\n    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)\n    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)\n    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)\n    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)\n  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)\n  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)\n  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)\n  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)\n  + [Passes](https://circt.llvm.org/docs/Passes/)\n  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)\n    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)\n    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)\n  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)\n  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)\n  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)\n  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)"
  }
]
