Synth Longest Path Analysis - CIRCT

CIRCT
=====

Circuit IR Compilers and Tools

* Community
  + [Forums](https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40)
  + [Chat](https://discord.gg/xS7Z362)
* [Source](https://github.com/llvm/circt/tree/main/)
  + [Doxygen](/doxygen/)
  + [GitHub](https://github.com/llvm/circt/tree/main/)

Synth Longest Path Analysis
===========================

This document describes the longest path analysis for the Synth dialect, which calculates the maximum delay through combinational paths in a circuit where Synth primitive operations are considered to have a unit delay.

* [Overview](#overview)
* [Design](#design)
* [Implementation Details](#implementation-details)
  + [Data Structures](#data-structures)
  + [Algorithm](#algorithm)
* [Usage](#usage)
  + [Analysis Interface](#analysis-interface)

Overview [¶](#overview)
-----------------------

The longest path analysis is a static analysis that computes the maximum delay from inputs to outputs in a circuit. It is particularly useful for:

1. Identifying critical paths in a design
2. Estimating circuit performance
3. Guiding optimization passes to focus on high-delay paths

The analysis treats each primitive logic operation as having a unit delay (1), and calculates the maximum delay through all possible paths in the circuit.

Design [¶](#design)
-------------------

The longest path analysis is by nature very expensive analysis:

* Dataflow must be tracked in a bit-sensitive manner
* The analysis must handle module instances and hierarchies
* The dataflow graph can be very large, especially for multi core designs with deep hierarchies and wide datapaths
* The analysis must provide debuggable information if requested.

To make the analysis tractable, we use several techniques:

* Redundant Path Elimination: If a path is closed under specific hierarchical context, it’s not necessary to propagate it its parents.
* Graph Parallelism: The analysis is designed to be executed in parallel across the instance graph. Each module is analyzed independently, and the results are combined across the hierarchy.
* Early pruning of paths: Paths that are known to be not part of the longest paths are pruned early.

Implementation Details [¶](#implementation-details)
---------------------------------------------------

### Data Structures [¶](#data-structures)

The analysis uses several key data structures:

* **Object**: Represents a specific bit of a value at a specific instance path
* **OpenPath**: Represents an open path from a fan-in with an associated delay
* **DataflowPath**: Represents a complete path from a fanout to a fanin
* **DebugPoint**: Provides debug information for a point in the path

### Algorithm [¶](#algorithm)

The analysis works by:

1. Traverse instance graph in post-order
2. Walk operations, and start tracing from fanOuts (FFs and module outputs)
3. Following combinational paths through logic operations
4. Computing the maximum delay to each point in the circuit
5. Recording the paths with their associated delays
6. 1-5 are parallelly executed across all modules in the design

For each operation, the analysis:

* Computes the delay as the maximum of input delays plus the operation’s delay
* Records the path information including the source, sink, and intermediate points
* Handles multi-bit values by analyzing each bit position separately

Usage [¶](#usage)
-----------------

### Analysis Interface [¶](#analysis-interface)

The `LongestPathAnalysis` class provides the following key methods:

#### Core Query Methods [¶](#core-query-methods)

* `getResults(Value, size_t, SmallVectorImpl<DataflowPath>&)`: Gets all paths to the given value and bit position.
* `getAverageMaxDelay(Value)`: Returns the average of maximum delays across all bits of a value
* `isAnalysisAvailable(StringAttr)`: Checks if analysis is available for a module

#### Path Query Methods [¶](#path-query-methods)

* `getInternalPaths(StringAttr, SmallVectorImpl<DataflowPath>&, bool elaboratePaths = false)`: Gets all closed paths (register-to-register) in a module
* `getOpenPathsFromInputPortsToInternal(StringAttr, SmallVectorImpl<DataflowPath>&)`: Gets open paths from module input ports to internal sequential elements
* `getOpenPathsFromInternalToOutputPorts(StringAttr, SmallVectorImpl<DataflowPath>&)`: Gets open paths from internal sequential elements to module output ports
* `getAllPaths(StringAttr, SmallVectorImpl<DataflowPath>&, bool elaboratePaths = false)`: Convenience method that combines all path types

#### Hierarchical Path Support [¶](#hierarchical-path-support)

The analysis now supports hierarchical path elaboration through the `elaboratePaths` parameter. When enabled, paths include full hierarchical instance information across module boundaries, providing complete visibility into timing paths in hierarchical designs.

 [Prev - 'synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/ "'synth' Dialect")
[Next - 'systemc' Dialect](https://circt.llvm.org/docs/Dialects/SystemC/ "'systemc' Dialect") 

Powered by [Hugo](https://gohugo.io). Theme by [TechDoc](https://themes.gohugo.io/hugo-theme-techdoc/). Designed by [Thingsym](https://github.com/thingsym/hugo-theme-techdoc).

* [Home](https://circt.llvm.org/)
* [Talks and Related Publications](https://circt.llvm.org/talks/)
* [Getting Started](https://circt.llvm.org/getting_started/)
* [Code Documentation-](https://circt.llvm.org/docs/)
  + [Tools+](https://circt.llvm.org/docs/Tools/)
    - [circt-synth](https://circt.llvm.org/docs/Tools/circt-synth/)
    - [circt-verilog](https://circt.llvm.org/docs/Tools/circt-verilog/)
    - [handshake-runner](https://circt.llvm.org/docs/Tools/handshake-runner/)
  + [CIRCT Charter](https://circt.llvm.org/docs/Charter/)
  + [Dialects-](https://circt.llvm.org/docs/Dialects/)

    - ['arc' Dialect](https://circt.llvm.org/docs/Dialects/Arc/)
    - ['calyx' Dialect](https://circt.llvm.org/docs/Dialects/Calyx/)
    - ['chirrtl' Dialect](https://circt.llvm.org/docs/Dialects/CHIRRTL/)
    - ['comb' Dialect+](https://circt.llvm.org/docs/Dialects/Comb/)
      * [`comb` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/)
    - ['datapath' Dialect+](https://circt.llvm.org/docs/Dialects/Datapath/)
      * ['datapath' Dialect Rationale](https://circt.llvm.org/docs/Dialects/Datapath/RationaleDatapath/)
    - ['dc' Dialect+](https://circt.llvm.org/docs/Dialects/DC/)
      * [DC Dialect Rationale](https://circt.llvm.org/docs/Dialects/DC/RationaleDC/)
    - ['emit' Dialect+](https://circt.llvm.org/docs/Dialects/Emit/)
      * [Emission (Emit) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/)
    - ['esi' Dialect+](https://circt.llvm.org/docs/Dialects/ESI/)
      * [ESI data types and communication types](https://circt.llvm.org/docs/Dialects/ESI/types/)
      * [ESI Global Services](https://circt.llvm.org/docs/Dialects/ESI/services/)
      * [ESI Software APIs](https://circt.llvm.org/docs/Dialects/ESI/software_api/)
      * [Miscellaneous Notes](https://circt.llvm.org/docs/Dialects/ESI/notes/)
      * [The Elastic Silicon Interconnect dialect](https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/)
    - ['firrtl' Dialect+](https://circt.llvm.org/docs/Dialects/FIRRTL/)
      * [FIRRTL Annotations](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/)
      * [FIRRTL Dialect Rationale](https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/)
      * [Intrinsics](https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/)
    - ['fsm' Dialect+](https://circt.llvm.org/docs/Dialects/FSM/)
      * [FSM Dialect Rationale](https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/)
    - ['handshake' Dialect+](https://circt.llvm.org/docs/Dialects/Handshake/)
      * [Handshake Dialect Rationale](https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/)
    - ['hw' Dialect+](https://circt.llvm.org/docs/Dialects/HW/)
      * [HW Dialect Rationale](https://circt.llvm.org/docs/Dialects/HW/RationaleHW/)
    - ['hwarith' Dialect+](https://circt.llvm.org/docs/Dialects/HWArith/)
      * [HW Arith Dialect Rationale](https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/)
    - ['kanagawa' Dialect+](https://circt.llvm.org/docs/Dialects/Kanagawa/)
      * [`kanagawa` Dialect Rationale](https://circt.llvm.org/docs/Dialects/Kanagawa/RationaleKanagawa/)
    - ['loopschedule' Dialect+](https://circt.llvm.org/docs/Dialects/LoopSchedule/)
      * [LoopSchedule Dialect Rationale](https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/)
    - ['msft' Dialect](https://circt.llvm.org/docs/Dialects/MSFT/)
    - ['om' Dialect+](https://circt.llvm.org/docs/Dialects/OM/)
      * [Object Model Dialect Rationale](https://circt.llvm.org/docs/Dialects/OM/RationaleOM/)
    - ['pipeline' Dialect+](https://circt.llvm.org/docs/Dialects/Pipeline/)
      * [Pipeline Dialect Rationale](https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/)
    - ['rtgtest' Dialect](https://circt.llvm.org/docs/Dialects/RTGTest/)
    - ['seq' Dialect+](https://circt.llvm.org/docs/Dialects/Seq/)
      * [Seq(uential) Dialect Rationale](https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/)
    - ['ssp' Dialect+](https://circt.llvm.org/docs/Dialects/SSP/)
      * [SSP Dialect Rationale](https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/)
    - ['sv' Dialect+](https://circt.llvm.org/docs/Dialects/SV/)
      * [SV Dialect Rationale](https://circt.llvm.org/docs/Dialects/SV/RationaleSV/)
    - ['synth' Dialect-](https://circt.llvm.org/docs/Dialects/Synth/)
      * ['synth' Dialect](https://circt.llvm.org/docs/Dialects/Synth/RationaleSynth/)
      * [Synth Longest Path Analysis](https://circt.llvm.org/docs/Dialects/Synth/LongestPathAnalysis/)
    - ['systemc' Dialect+](https://circt.llvm.org/docs/Dialects/SystemC/)
      * [SystemC Dialect Rationale](https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/)
    - [Debug Dialect](https://circt.llvm.org/docs/Dialects/Debug/)
    - [Interop Dialect+](https://circt.llvm.org/docs/Dialects/Interop/)
      * [Interoperability Dialect Rationale](https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/)
    - [LLHD Dialect](https://circt.llvm.org/docs/Dialects/LLHD/)
    - [LTL Dialect](https://circt.llvm.org/docs/Dialects/LTL/)
    - [Moore Dialect](https://circt.llvm.org/docs/Dialects/Moore/)
    - [Random Test Generation (RTG) Rationale](https://circt.llvm.org/docs/Dialects/RTG/)
    - [Simulation Dialect](https://circt.llvm.org/docs/Dialects/Sim/)
    - [SMT Dialect](https://circt.llvm.org/docs/Dialects/SMT/)
    - [Verif Dialect](https://circt.llvm.org/docs/Dialects/Verif/)
  + [EDA Tool Workarounds](https://circt.llvm.org/docs/ToolsWorkarounds/)
  + [Formal Verification Tooling](https://circt.llvm.org/docs/FormalVerification/)
  + [Getting Started with the CIRCT Project](https://circt.llvm.org/docs/GettingStarted/)
  + [HLS in CIRCT](https://circt.llvm.org/docs/HLS/)
  + [Passes](https://circt.llvm.org/docs/Passes/)
  + [Python CIRCT Design Entry (PyCDE)+](https://circt.llvm.org/docs/PyCDE/)
    - [Compiling CIRCT and PyCDE](https://circt.llvm.org/docs/PyCDE/compiling/)
    - [PyCDE Basics](https://circt.llvm.org/docs/PyCDE/basics/)
  + [Static scheduling infrastructure](https://circt.llvm.org/docs/Scheduling/)
  + [Symbol and Inner Symbol Rationale](https://circt.llvm.org/docs/RationaleSymbols/)
  + [Using the Python Bindings](https://circt.llvm.org/docs/PythonBindings/)
  + [Verilog and SystemVerilog Generation](https://circt.llvm.org/docs/VerilogGeneration/)